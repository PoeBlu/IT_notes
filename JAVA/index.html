<html>
<head>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[xxsmall], #zoomDiv > * > *[xxsmall], #zoomDiv > * > * > *[xxsmall]{ font-size:1rem; }
#zoomDiv > *[xsmall] , #zoomDiv > * > *[xsmall] , #zoomDiv > * > * > *[xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]   {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE
<tr {>
  <td topic >
     topic
  </td>
  <td summa >
     <ul>
     <li></li>
     <li></li>
     <li></li>
     </ul>
  </td>
  <td col1  >
     <pre xxsmall>
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td topic >topic</td>
  <td summa ></td>
  <td col1  ></td>
  <td col2  ></td>
</tr>
<tr {>
  <td topic >JavaDoc</td>
  <td summa >
    <pre xxsmall>
-----------------------+-------------------------------------+-------------------------+-------
Tag& Parameter         | Usage                               | Applies to              | Since
-----------------------+-------------------------------------+-------------------------+-------
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |
-----------------------+-------------------------------------+-------------------------+-------
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |
                       | Max one per Class or Interface.     |                         |
-----------------------+-------------------------------------+-------------------------+-------
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |
                       | has first existed.                  | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
@seereference          | Provides a link to other element    | Class, Interface, Enum, |  
                       | of documentation.                   | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
@paramname descrip     | Describes a method parameter.       | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@return description    | Describes the return value.         | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |  
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | <code>{@literal}</code>.            | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
    <pre>
  </td>
  <td col1>
    <pre xxsmall>
/**
 * Short one line description.
 * <p>
 * Longer description. If there were any, it would be
 * here.
 * <p>
 * And even more explanations to follow in consecutive
 * paragraphs separated by HTML paragraph breaks.
 *
 * @author John Bla
 * @param  variable Description text text text.
 * @return Description text text text.
 */
public int methodName (...) {
    // method body with a return statement
}
    </pre>
</td>
  <td col2></td>
</tr }>

<tr {>
  <td topic ><span TODO>Date &amp; Time</span></td>
  <td summa >
     <pre TODO xxsmall> 
     - package java.time.* (java 1.8+)
       All the classes are immutable and thread-safe
     - Parsing DateTime
     </pre>
     <hr/> 
     <h3>Java Up to 1.8 Compatibility:</h3>
     <p xxsmall>
     Prior to the Java SE 8 release, the Java date and time mechanism was provided by the  java.util.Date, java.util.Calendar, and java.util.TimeZone classes, as well as their subclasses, such as java.util.GregorianCalendar.<br/><br/>
      
     These classes had several drawbacks, including:<br/>
     -   The Calendar class was not type safe.<br/>
     -   Because the classes were mutable, they could not be used in multithreaded applications.<br/>
     -   Bugs in application code were common due to the unusual numbering of months and the lack of type safety.<br/>
<br/>
      Added to the JDK 8 release are several methods that allow conversion between java.util and java.time objects:<br/>
     -   Calendar.toInstant() converts the Calendar object to an Instant.<br/>
     -   GregorianCalendar.toZonedDateTime() converts a GregorianCalendar instance to a ZonedDateTime.<br/>
     -   GregorianCalendar.from(ZonedDateTime) creates a GregorianCalendar object using the default locale from a ZonedDateTime instance.<br/>
     -   Date.from(Instant) creates a Date object from an Instant.<br/>
     -   Date.toInstant() converts a Date object to an Instant.<br/>
     -   TimeZone.toZoneId() converts a TimeZone object to a ZoneId.<br/>
     </p>
     <hr/> 
     <h3>Java 9 <a href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>REF</a></h3>
     <p xxsmall TODO>

A number of parsing and formatting changes have been incorporated in Java 9 to bring the functionality closer to Unicode Locale Data Markup Language (LDML). These changes have been supervised by Stephen Colebourne, creator of the popular date-time library JodaTime, precursor of the new java.time component in Java 8. Abiding by the Unicode standard will provide better interoperability with other non-Java systems.<br/>
LDML is the language used by the Unicode Common Locale Data Repository (CLDR), a project of the Unicode Consortium to gather and store locale data from different parts of the world, enabling application developers to better adapt their programs to different cultures. Among other things, LDML deals with dates, times, and timezones, and more particularly with date formatting and parsing. The following is an extract of new features coming in Java 9 that bring java.time closer to the LDML specification:<br/>
    JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as specified in LDML, indicates a “Modified Julian day”; this is different from a normal Julian day in the sense that a) it depends on local time, rather than GMT, and b) it demarcates days at midnight, as opposed to noon.<br/>
    JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML formats to indicate “generic non-location format”, e.g. “Pacific Time”, as opposed to the “generic location format” with specifies a city, like “Los Angeles Time”.<br/>
    JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the total number of milliseconds elapsed in the day, with variable width, but currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it will fail to parse any value that is further than 99 milliseconds in the day. ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds within the second, and nanoseconds within the day, respectively.<br/>
    JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit day-of-year value: similar to the previous problem, but with ‘D’ representing days within a year. If one specifies “DD” as a pattern, it will fail to parse “123” as the 123th day of the year.<br/>
As previously mentioned, a better alignment with the LDML will ease interoperability across systems, since there are multiple technologies that have adopted the LDML to some degree. Microsoft .NET uses LDML for general interexchange of locale data, and there are packages available for Node.js and Ruby, just to mention a few.<br/>
     </p>
     <hr/> 
  </td>
  <td col1  >
    java.time. Package
    <pre xxsmall>
                   Description
----------------------------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and time using a time-zone.
----------------------------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
----------------------------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
----------------------------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system, such as 2007-12-03.
----------------------------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30.
----------------------------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system, such as 10:15:30.
----------------------------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
----------------------------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 2007-12-03T10:15:30+01:00.
----------------------------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 10:15:30+01:00.
----------------------------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.
----------------------------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
----------------------------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12.
----------------------------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30+01:00 Europe/Paris.
----------------------------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
----------------------------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
----------------------------------------------------------------------------------------------------


Enum               Description
----------------------------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
----------------------------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
----------------------------------------------------------------------------------------------------


Exception          Description
----------------------------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.
    </pre>
    java.text.MessageFormat:
    <pre xxsmall>
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale()) 
  
time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())
    </pre>
  </td>
  <td col2  >
  </td>
</tr }>


<tr {>
  <td topic >
     ANNOTATIONS
  </td>
  <td summa >
    <ul>
    <li>
    Annotation types are a form of interface:
<pre xxsmall>
DECLARATION(interface is preceded by the @ sign)| USAGE
  @interface ClassPreamble {                    |   @ClassPreamble (
     String   author        ()              ;   |      author         = "John Doe"      ,
     String   date          ()              ;   |      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;   |      currentRev     = 6               ,
     String   lastModified  () default "N/A";   |      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";   |      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;   |      reviewers      = {"Alice", "Bob"}
  }                                             |   )
                                                | public class Generation3List extends Generation2List {
                                                |     // ...
                                                | }
</pre> 
    </li>
    <li>
      Annotations can be applied to declarations of: classes, fields, methods, other program elements. 
      When used on a declaration, each annotation often appears, *by convention*, on its own line.<br/>
      As of the Java SE 8 release, annotations can also be applied to the use of types. A few examples of where
      types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses
    <pre xxsmall>I
Ex. Class instance creation expression:      new @Interned MyObject();
----------------------------------------------------------------------
Ex. Type cast:                            |  myString = (@NonNull String) str;
------------------------------------------+---------------------------
Ex. implements clause:                    |  class UnmodifiableList<T> implements
                                          |        @Readonly List<@Readonly T> { ... }
------------------------------------------+---------------------------
Ex. thrown exception declaration:         |  void monitorTemperature() throws 
                                          |        @Critical TemperatureException { ... }
------------------------------------------+---------------------------
    </pre>I
    </li>
    <li>
Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, 
annotate the @ClassPreamble DECLARATION wih @Documented annotation like:
    <pre xsmall>
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
   ...
} 
    </pre>I
    </li>
    <li>
        predefined annotation types defined in java.lang:
        @Deprecated   @Override   @SuppressWarnings
    <pre xsmall>
Ex: @SuppressWarnings(value = "unchecked")
    void myMethod() { ... }
    @SuppressWarnings({"unchecked", "deprecation"})
    void myMethod() { ... }
    </pre>
    </li>
    <li>@SafeVarargs (Java ?+) when applied to a method or constructor, asserts that the code does not perform potentially 
    unsafe operations on its varargs parameter. Unchecked warnings relating to varargs usage are suppressed.
    </li>
    <li>JAVA 8+ <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>Ref</a>
    <table xxsmall>
    <tr>
    <td>@NonNull</td>
    <td>compiler can determine cases where a code path might receive a null value, 
        without ever having to debug a NullPointerException. The compiler just print a warning, but it continues to compile!!!</td>
    </tr>
    <tr>
    <td>@ReadOnly </td>
    <td>compiler will flag any attempt to change the object. This is similar to Collections.unmodifiableList, 
    but more general and verified at compile time.</td>
    </tr>
    <tr>
    <td>@Regex</td>
    <td>Provides compile-time verification that a String intended to be used as a regular expression is a properly formatted 
    regular expression.</td>
    </tr>
    <tr>
    <td>@(Un)Tainted</td>
    <td>Identity types of data that should not be used together, such as remote user input being used in 
    system commands, or sensitive information in log streams</td>
    </tr>
    <tr>
    <td>@m</td>
    <td>Units of measure ensures that numbers used for measuring objects are used and compared correctly, or have undergone the
    proper unit conversion.</td>
    </tr>
    <tr>
    <td>@FunctionalInterface</td>
    <td>indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Spec.</td>
    </tr>
    </table> 
    Ex:
      <pre xxsmall>
Annotation                                         Meaning
@NonNull List<String>                              A non-null list of Strings.
List<@NonNull String>                              A list of non-null Strings.
@Regex String validation = "(Java|JDK) [7,8]"      Check at compile time that this String is a valid regular expression.
private String getInput(String parameterName){     The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval = 
      @Tainted request.getParameter(parameterName);
  return retval;
}
        
private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
  ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

  Process process = processBuilder.start();
}
    
         </pre>
    </li>


    </ul>
  </td>
  <td col1  >
    <ul>
    <li> META-ANNOTATIONS: Annotations that apply to other annotations.<br/>
         There are several meta-annotation types defined in java.lang.annotation.<br/>
         @Retention: specifies how the marked annotation is stored:
         <pre xxsmall>
RetentionPolicy.SOURCE: annotation is retained only in source level and is ignored by the compiler.
RetentionPolicy.CLASS: annotation is retained by compiler, but ignored by the (JVM)
RetentionPolicy.RUNTIME: annotation is retained by the JVM, can be used@RunTime 
        </pre>
        @Documented: indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.)<br/>
        @Target meta-annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to.
         <pre xxsmall>
ElementType.ANNOTATION_TYPE can be applied to an annotation type.
ElementType.CONSTRUCTOR can be applied to a constructor.
ElementType.FIELD can be applied to a field or property.
ElementType.LOCAL_VARIABLE can be applied to a local variable.
ElementType.METHOD can be applied to a method-level annotation.
ElementType.PACKAGE can be applied to a package declaration.
ElementType.PARAMETER can be applied to the parameters of a method.
ElementType.TYPE can be applied to any element of a class.
         </pre>
        @Inherited meta-annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class' superclass is queried for the annotation type. This annotation applies only to class declarations.<br/>
        @Repeatable annotation (Java 8+), indicates that the marked annotation can be applied more than once to the same declaration or type use.
Ref: http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
         <pre xxsmall>
Ex:
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
         </pre>
    </li>
    </ul>
  </td>
  <td col2  >
  </td>
</tr }>
<tr {>
  <td topic >
     NIO
  </td>
  <td summa >
     <ul>
     <li>java.nio.ByteBuffer <a href='http://tutorials.jenkov.com/java-nio/buffers.html'>REF</a>
Using a Buffer to read and write data typically follows this little 4-step process:
     <ol>
       <li>1. Write data into the Buffer</li>
       <li>2. Call buffer.flip()</li>
       <li>3. Read data out of the Buffer</li>
       <li>4. Call buffer.clear() or buffer.compact()</li>
     </ol>
     <pre xsmall>
channel data -> Buffer:               |  buffer -> channel:
  int bytesRead = inChannel.read(buf);|   int bytesWritten = inChannel.write(buf);
  var -> Buffer:                      | Buffer -> var:
    buf.put(127);                     |   byte aByte = buf.get();    
     </pre>
     <pre xsmall>
rewind (): The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer. 
clear  (): reset and prepare for writing.
compact(): pseudo-reset, but leave non-read data at the start of the buffer.
mark   (): mark <- inverser -> reset
reset  (): mark <- inverser -> reset
equals () & compareTo()
     </pre>
     </li>
     <li>
     </li>
     </ul>
  </td>
  <td col1 >
     <pre xxsmall>
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;

public class main {
  public static void main(String[] args) {
    //  STEP 0: PREPARE THE BUFFER
    ByteBuffer buf = ByteBuffer.allocate(48); // <- Capacity: 48 bytes
    buf.order(ByteOrder.BIG_ENDIAN);
    buf.clear();   //  Clears this buffer before writing to it (channel-read/put-operations) to fill the buffer.
                   // The position is set to zero, the limit to the capacity, and the mark discarded.
    boolean fromChannel = false; // Write from channel or programatically (put*)

    //  STEP 1: WRITE TO THE BUFFER
    if (fromChannel) {
        RandomAccessFile aFile = null;
                              try {
        // STEP 1.1: PREPARE THE SOURCE THAT WRITES TO THE BUFFER
        aFile = new RandomAccessFile("data/nio-data.txt", "rw");
        FileChannel inChannel = aFile.getChannel();
        
        // STEP 1.2: WRITE TO THE BUFFER (READ THE INPUT CHANNEL)
        int bytesRead = inChannel.read(buf); //read into buffer.
        while (bytesRead != -1) {
            buf.flip();  //make buffer ready for read
            while(buf.hasRemaining()){ System.out.print((char) buf.get()); } // read 1 byte at a time  
            buf.clear(); //make buffer ready for writing
            bytesRead = inChannel.read(buf);
        }
                              } catch(Exception e){
        // ...
                              } finally {
        if (aFile != null) { aFile.close(); aFile = null};
                              }
    } else  /* Use "put*" */{
        short short0 =      23; buf.putShort(short0);
        char char0   =     'a'; buf.putChar (char0 );
        int int0     = 1231313; buf.putInt  (int0  );
    }

    //  STEP 2: PREPARE BUFFER FOR READING.
    buf.flip();
    
    //  STEP 3: READ THE BUFFER
    //   (Alt. read the buffer writing to a Channel: int bytesWritten = inChannel.write(buf);)
    char     char1 = buf.getChar  (); long     long1 = buf.getLong  ();
    short   short1 = buf.getShort (); float   float1 = buf.getFloat ();
    int       int1 = buf.getInt   (); double double1 = buf.getDouble();
  }
}
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >JSON</td>
  <td summa >
      <a href='https://www.infoq.com/news/2017/03/json-processing-public-review'>REF:JSON processing public review</a>
      <p>Public review of JSR 374: Java API for JSON Processing (JSON-P) version 1.1 is now open. 
This version is expected to be included in the release of J2EE 8 and keeps JSON-P current with JSON IETF standards. It includes support for:
      <ul>
      <li>JSON Pointer</li>
      <li>JSON Patch</li>
      <li>JSON Merge Patch</li>
      <li>Query and transformation operations</li>
      <li>Java 8 streams and lambdas</li>
      </ul>
     </p>

JSON-P was introduced in 2013 with the release of J2EE 7, as an alternative to Gson and Jackson. It was designed to parse, generate, 
and query standard JSON documents.

JSR-367: Java API for JSON Binding (JSON-B), will also be included in the release of J2EE 8.    -----
  </td>
  <td col1  >
    tags: [JSON Parsing, HTTP GET/POST, TLS, Basic Authorization]
    <pre xxsmall>
package com.mycomp.project1;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.json.JSONObject;

import java.security.cert.X509Certificate;
import java.util.Date;

import java.util.Scanner;

public class TestAPI<JSONArray> {
    static String userpass = "operator1:ecllqy";
    private static SSLSocketFactory sslSocketFactory = null;

    private JSONObject sendPost(String url, String post_body, String token) throws Exception 
    {
        URL obj = new URL(url);
        String basicAuth = "Basic " +
            javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

        HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

        setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

        con.setRequestMethod("POST"); //add request header
        con.setRequestProperty("Content-Type", "application/json");
        con.setRequestProperty("Cache-Control", "no-cache");
        if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
        } else               { con.setRequestProperty("Authorization", "Bearer "+token);
        }
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(post_body);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();

        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        StringBuffer response = new StringBuffer();
        String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
        in.close();
        return new JSONObject(response.toString()); //String myJSONStr
    }


    /********************************************************************************/
    /**
     * Overrides the SSL TrustManager and HostnameVerifier to allow
     * all certs and hostnames.
     * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
     * environment.
     *
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     */
    protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
        // Create the socket factory.
        // Reusing the same socket factory allows sockets to be
        // reused, supporting persistent connections.
        if( null == sslSocketFactory) {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
            sslSocketFactory = sc.getSocketFactory();
        }

        connection.setSSLSocketFactory(sslSocketFactory);

        // Since we may be using a cert with a different name, we need to ignore
        // the hostname as well.
        connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
    }

    private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {}
            public void checkServerTrusted(X509Certificate[] certs, String authType) {}
        }
    };

    private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
}
    </pre>
    
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >Exceptions</td>
  <td summa >
     <ul>
     <li>(compiler) checked vs unchecked (Error, RuntimeException and their subclasses).</li>
     <li>Checked: All except Error, RuntimeException and their subclasses</li>
     <li>Error: Exceptional conditions external to the application.</li>
     <pre>
|java.lang.Object
|   java.lang.Throwable
|       java.lang.Exception
|           java.lang.RuntimeException (non-checked)
|           java.lang.*Exception       (checked -A)
|       java.lang.Error                (non-checked)
     </pre>
    
     <li>The Throwable class is the superclass of all errors and exceptions in the Java language.  Only objects that are instances of this class (or one of its subclasses) are thrown by the JVM or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.</li>
     <li>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.</li>
    </ul>
  </td>
  <td col1  >
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >
     Concurrent
  </td>
  <td summa >
     <ul>
     <li TODO>java.util.concurrent</li>
     <li>In the Java language, each object may be used as a monitor. Methods requiring mutual exclusion must be explicitly marked with the synchronized keyword. Blocks of code may also be marked by synchronized.<br/>
Rather than having explicit condition variables, each monitor (i.e. object) is equipped with a single wait queue in addition to its entrance queue. All waiting is done on this single wait queue and all notify and notifyAll operations apply to this queue.</li>
     <pre>
             enter         
               |           
 +---+-------- | --+       
 |  notified   v   |       
 | ----->          |       
 |                 |       
 | O |         O   |       
 | O |         O   |       
 | O +--------   --+--+    
 | O |                |    
 |   |                |    
 |  <-- wait   O      |    
 |   |      (Running  |    
 +---+       thread)  |    
     |                |    
     |                |    
     |     leave      |    
     |        |       |    
     +------- | ------+    
              v            
     </pre>

     <li>
     <a href='https://github.com/google/guava/wiki/ListenableFutureExplained'>REF: ListenableFuture Explained</a><br/>
      Concurrency is a hard problem, but it is significantly simplified by working with powerful and simple abstractions. To simplify matters, Guava extends the Future interface of the JDK with ListenableFuture.<br/>
      <i>"""We strongly advise that you always use ListenableFuture instead of Future in all of your code, because:<br/>
    Most Futures methods require it.<br/>
    It's easier than changing to ListenableFuture later.<br/>
    Providers of utility methods won't need to provide Future and ListenableFuture variants of their methods.<br/>
       """</i>
     </li>
     </ul>
  </td>
  <td col1  >
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >Async code</td>
  <td summa >
     <ul>
     <li>
     <pre>
 +------------+ |               [[Executor]]
 |[[Runnable]]| |                   ^
 |------------| |                   |
 |+run()      | |           [[ExecutorService]]
 +------------+ |                   ^
       ^        |        +----------+--------------+
       |        |        |                         |
 +------------+ | AbstractExecutorService  [[ScheduledExecutorService]]
 |   Thread   | |        ^                         ^
 |------------| | ThreadPoolExecutor               |
 |+run()      | |        ^                         |
 |+start()    | | ScheduledThreadPoolExecutor -----+
 |+sleep()    | |
 |....        | |
 |------------| |
 +------------+ |
     </pre>
     </li>
     <li>
     ExecutorService(Thread Pool): managed collection of threads available to execute tasks.<br/>
     To use a thread pool, you can use an implementation of the interface ExecutorService, such as ThreadPoolExecutor or ScheduledThreadPoolExecutor. However, more convenient factory methods are provided in the Executors class as follows:<br/>
     Using thread pool:
     <ol>
       <li>Write worker thread class implementing <<Runnable>> run()</li>
       <li>STEP 2: Create ExecutorService using:
         <pre>
Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int numThreads)
Executors.newCachedThreadPool(): <-- unbounded pool, with automatic reclamation
Executors.newSingleThreadScheduledExecutor()
Executors.newScheduledThreadPool(int size)
         </pre>
       </li>
       <li>Use executor(Service)Instance.execute(/*Runnable */workerThreadInstance) to add a Runnable task to thread pool. Executes task at some time in the future in a new thread, in a thread pool, or in the calling thread, depending on the implementation of Executor</li>
     </ol>
     <pre>
 [[java.util.concurrent.ExecutorService]]
 + public     void      shutdown(); // Initiates orderly shutdown of pool
 + public <T> Future<T> submit(Callable<T> task); // schedule callable task for execution
     </pre>
     </li>
     <li><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'>CompletableFuture (Java 8+)</a><br/>
       A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.<br/>
       When two or more threads attempt to complete, completeExceptionally, or cancel a CompletableFuture, only one of them succeeds.<br/>
     </li>
     <li>
     <pre>
[[ java.util.concurrent.Callable&lt;V> ]]
   +public V call()  (vs run() in Runnable)
   similar to a Runnable, but allows to return a result/Exception to the thread triggering the Callable
   returns a result of type &lt;V>, or throws an exception if unable to do so.
  
[[ Future&lt;V> ]] 
   +V get()           // blocks waiting for result
   +V get(long timeout, TimeUnit unit)
   +boolean cancel(boolean mayInterruptIfRunning)
   +boolean isCancelled()
   +boolean isDone()  // return true if this task completed
     </pre>
     </li>
     </ul>
  </td>
  <td col1  >
     <pre xsmall>
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {

   public static void main(String[] args) {
      ExecutorService pool = Executors.newFixedThreadPool(10);
      MyWorker[] workers = new MyWorker[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) pool.execute(new MyWorker(i+1));
      pool.shutdown();
   }
}
     </pre>

     <pre xsmall>
import java.util.concurrent.Callable;
import java.util.concurrent.*;

public class CallableThreadPoolTest {

    public class MyCallableWorkerThread implements Callable&lt;String> {
       MyCallableWorkerThread(int workerNumber) { ... }
       public String call() { 
          Thread.sleep((int)(Math.random() * 1000));
          return "worker " + workerNumber;
       }
    }

   public static void main(String[] args) {
      int numWorkers = 10;
      ExecutorService pool = Executors.newCachedThreadPool();
      MyCallableWorkerThread workers[] = new MyCallableWorkerThread[numWorkers];
      Future                 futures[] = new Future                [numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new MyCallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
                                 try {
            System.out.println(futures[i].get() + " ended");
                                 } catch (InterruptedException ex) {
            ex.printStackTrace();
                                 } catch (ExecutionException ex) {
            ex.printStackTrace();
                                 }
      }
   }
}
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>


<tr {>
  <td topic >[QA] Checker framework</td>
  <td summa >
     <ul>
     <li>
     <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>REF: Oracle Java 8 new Type Annotations</a>
Java SE 8 allows type annotations anywhere that a type is used. Previously, annotations were only allowed on definitions. 
The Checker Framework provides a few Type Annotations that could benefit both library and application developers, such as:
<pre>
@NonNull: compiler can determine cases where a code path might receive a null.

@ReadOnly: compiler will flag any attempt to change the object.

@Regex – compile-time verification that a String intended to be used 
    as a regular expression is a properly formatted regular expression.

@Tainted and @Untainted: Identity types of data that should not be used
    together, such as remote user input being used in system commands, 
    or sensitive information in log streams.

@m – Units of measure ensures that numbers used for measuring objects 
    are used and compared correctly, or have undergone the proper unit
    conversion.

</pre>
     </li>
     <li TODO >installation process:<br/>
    Download the Checker Framework distribution: https://checkerframework.org/checker-framework-2.1.8.zip. <br/>
    Configure your IDE, build system, or command shell to include the Checker Framework on the classpath. Choose the appropriate section of Chapter 30 for javac (Section 30.1), Ant (Section 30.2), Maven (Section 30.3), Gradle (Section 30.4), IntelliJ IDEA (Section 30.6), Eclipse (Section 30.7), or tIDE (Section 30.8).<br/>
Option 1: Add directory .../checker-framework-2.1.8/checker/bin to your path, before any other directory that contains a javac executable.<li>
     <li>The Nullness Checker supports several annotations that specify method behavior. <br/>
       These are declaration annotations, not type annotations:<br/>
       they apply to the method itself rather than to some particular type.<br/>
       @RequiresNonNull (precondition): annotated method expects the specified variables to be non-null when the method is invoked.<br/>
       @EnsuresNonNull (postcondition): the given expressions are non-null after the method returns;<br/>
       @EnsuresNonNullIf: if annotated method returns true|false, then the given expressions are non-null.<br/>
<li>
     <li>The Lock Checker prevents certain concurrency errors by enforcing a locking discipline. A locking discipline indicates which locks must be held when a given operation occurs. You express the locking discipline by declaring a variable’s type to have the qualifier @GuardedBy("lockexpr"). This indicates that the variable’s value may be dereferenced only if the given lock is held.<li>
     <li>@GuardedBy(exprSet): If a variable x has type @GuardedBy("expr"), then a thread may dereference the value referred to by x only when the thread holds the lock that expr currently evaluates to. It can list multiple expressions, as in @GuardedBy({"expr1", "expr2"}), in which case the dereference is permitted only if the thread holds all the locks.<li>
     <li>Method pre-conditions and post-conditions<br/>
@Holding(String[] locks): All the given lock expressions are held at the method call site.<br/>
@EnsuresLockHeld(String[] locks): The given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that acquires a lock such as ReentrantLock.lock().<br/>
@EnsuresLockHeldIf(String[] locks, boolean result): If the annotated method returns the given boolean value (true or false), the given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that conditionally acquires a lock. See Section 6.4.4 for examples.<li>
     <li>Side effect specifications<br/>
@LockingFree: The method does not acquire or release locks, directly or indirectly. The method is not synchronized, it contains no synchronized blocks, it contains no calls to lock or unlock methods, and it contains no calls to methods that are not themselves @LockingFree. <br/>
    Since @SideEffectFree implies @LockingFree, if both are applicable then you only need to write @SideEffectFree.<br/>
@ReleasesNoLocks: The method maintains a strictly nondecreasing lock hold count on the current thread for any locks that were held prior to the method call. The method might acquire locks but then release them, or might acquire locks but not release them (in which case it should also be annotated with @EnsuresLockHeld or @EnsuresLockHeldIf).<br/>
    This is the default for methods being type-checked that have no @LockingFree, @MayReleaseLocks, @SideEffectFree, or @Pure annotation.<br/>
<li>
     <li>The Format String Checker prevents use of incorrect format strings in format methods such as System.out.printf and String.format. Ej:
     <pre xxsmall>
void printFloatAndInt(@Format({FLOAT, INT}) String fs) {
        System.out.printf(fs, 3.1415, 42);
    }
     </pre>
<li>
     <li>Here are the examples of errors that the I18n Format Checker detects at compile time
     <pre xxsmall>
// Warning: the second argument is missing.
MessageFormat.format("{0} {1}", 3.1415);
// String argument cannot be formatted as Time type.
MessageFormat.format("{0, time}", "my string");
// Invalid format string: unknown format type: thyme.
MessageFormat.format("{0, thyme}", new Date());
// Invalid format string: missing the right brace.
MessageFormat.format("{0", new Date());
// Invalid format string: the argument index is not an integer.
MessageFormat.format("{0.2, time}", new Date());
// Invalid format string: "#.#.#" subformat is invalid.
MessageFormat.format("{0, number, #.#.#}", 3.1415);<li>
     </pre>
     <li>The Property File Checker ensures that a property file or resource bundle (both of which act like maps from keys to values) is only accessed with valid keys. Accesses without a valid key either return null or a default value, which can lead to a NullPointerException or hard-to-trace behavior. The Property File Checker (Section 12.1) ensures that the used keys are found in the corresponding property file or resource bundle.<li>
     <li>One of the most prevalent GUI-related bugs is invalid UI update or invalid thread access: accessing the UI directly from a background thread.

Most GUI frameworks (including Android, AWT, Swing, and SWT) create a single distinguished thread — the UI event thread — that handles all GUI events and updates. To keep the interface responsive, any expensive computation should be offloaded to background threads (also called worker threads). If a background thread accesses a UI element such as a JPanel (by calling a JPanel method or reading/writing a field of JPanel), the GUI framework raises an exception that terminates the program. To fix the bug, the background thread should send a request to the UI thread to perform the access on its behalf.

It is difficult for a programmer to remember which methods may be called on which thread(s). The GUI Effect Checker solves this problem. The programmer annotates each method to indicate whether:

    It accesses no UI elements (and may run on any thread); such a method is said to have the “safe effect”.
    It may access UI elements (and must run on the UI thread); such a method is said to have the “UI effect”. 
<li>
     <li>The following kind of (physical) UNIT annotations are defined:
     <pre xsmall>
@Acceleration @Angle @Area @Current @Length @Luminance @Mass
@Speed @Substance @Temperature @Time

For each kind of unit, the corresponding SI unit of measurement is defined:

For @Acceleration: Meter Per Second Square @mPERs2
For @Angle: Radians @radians, and the derived unit Degrees @degrees
For @Area: the derived units square millimeters @mm2, square meters @m2, and square kilometers @km2
For @Current: Ampere @A
For @Length: Meters @m and the derived units millimeters @mm and kilometers @km
For @Luminance: Candela @cd
For @Mass: kilograms @kg and the derived unit grams @g
For @Speed: meters per second @mPERs and kilometers per hour @kmPERh
For @Substance: Mole @mol
For @Temperature: Kelvin @K and the derived unit Celsius @C
For @Time: seconds @s and the derived units minutes @min and hours @h 
     </pre>
<li>
     <li>The Signedness Checker guarantees that signed and unsigned values are not mixed together in a computation. In addition, it prohibits meaningless operations, such as division on an unsigned value.
@Unsigned  @Signed
<li>
     <li>A type alias or typedef is a type that shares the same representation as another type but is conceptually distinct from it. For example, some strings in your program may be street addresses; others may be passwords; and so on. You wish to indicate, for each string, which one it is, and to avoid mixing up the different types of strings. Likewise, you could distinguish integers that are offsets from those that are absolute values.<li>
     <li>SPARTA is a security toolset aimed at preventing malware from appearing in an app store. SPARTA provides an information-flow type-checker that is customized to Android but can also be applied to other domains. The SPARTA toolset is available from https://checkerframework.org/sparta/. The paper “Collaborative verification of information flow for a high-assurance app store” appeared in CCS 2014.<li>
     </ul>
  </td>
  <td col1  >
     <pre>
@NonNull List<String>

List<@NonNull String> 

@Regex String validation = "(Java|JDK) [7,8]"

private String getInput(String parameterName){
 final String retval = @Tainted request.getParameter(parameterName);
 return retval;
} 

private void runCommand(@Untainted String… commands){
 // the previously tainted String must be validated before being passed in here.
 ProcessBuilder processBuilder = new ProcessBuilder(command);
 Process process = processBuilder.start();
}
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>


<tr {>
  <td topic >[QA] Eclipse Static Code Analasys</td>
  <td summa >
     <pre xxsmall>
Eclipse -> Properties -> Java -> Compiler -> Errors/Warnings -> Null analysis:
  Null pointer access
  Potential null pointer access
  Redundant null check:
    x Include 'assert' in null analysis
    x Enable annotation-based null analysis
      Violation of null specification
      Conflict between null annotations an null inference
      Unchecked conversion from non-annotated type to @NonNull type
      Problems detected by pessimistic analysis fro free type variables
      Unsafe "@Nonnull" interpretation of the free type variable from library
      Redundant null anotation:
      "@NonNull" parametere not annotated in overriding method
      Missing "@NonNullByDefault" annotation on package
      x Use default annotations for null specifications (configure)
      x Inherit null annotations
      x Enable syntatic null analisys for fields
  x Treat above errors like fatal compile erros (make compiled code not executable) 
     </pre>
  </td>
  <td col1  >
  </td>
  <td col2  >
  </td>
</tr }>



<tr {>
  <td topic >Java Cryptographic API (JCA)</td>
  <td summa >
     <ul>
     <li></li>
     <li></li>
     <li></li>
     </ul>
  </td>
  <td col1  >
     <pre xxsmall>
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>

</table>
</body>

<!--
-------------------------------------------------
TODO:
JAVA MIND-MAP:
https://zeroturnaround.com/wp-content/uploads/2014/06/jtnt-mindmap.png
-------------------------------------------------
-  Weak reference:
- http://picodotdev.github.io/blog-bitix/ , http://elblogdepicodev.blogspot.com.es/
- java.util.concurrent.Future
- Annotations
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw
-------------------------------------------------
List of (Active) Java JVM: https://en.wikipedia.org/wiki/List_of_Java_virtual_machines
 Light weight alternatives to standard Oracle JVM, ...
-------------------------------------------------
http://teavm.org/
"https://en.wikipedia.org/wiki/Java_virtual_machine#Compilation_to_JavaScript

""Main JVM bytecode to JavaScript compilers are TeaVM,[20] the compiler contained in Dragome Web SDK,[21] Bck2Brwsr,[22] and j2js-compiler.[23]"""
-------------------------------------------------
FAQ About Java generics
-------------------------------------------------
OpenJDK at Mercurial:
http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share
-------------------------------------------------
TODO: Google Guice
http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers
""" Although Spring provides many benefits, it was created in a pre-Java-5 world. The Guice framework takes DI to the next level, leveraging the full power of Java typing, especially annotations and generics"""
-------------------------------------------------
{
Java programming language provides multiple mechanisms for communicating between threads:
- The most basic of these methods is synchronization, which is implemented using monitors.
  Each object in Java is associated with a monitor, which a thread can lock or unlock.
 Only one thread at a time may hold a lock on a monitor. Any other threads attempting to
 lock that monitor are blocked until they can obtain a lock on that monitor. A thread t
 may lock a particular monitor multiple times; each unlock reverses the effect of one
 lock operation.
The synchronized statement (§14.19) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 A synchronized method (§8.4.3.6) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.
 Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.
Every object, in addition to having an associated monitor, has an associated wait-set. A wait-set is a set of threads.
 When an object is first created, its wait set is empty. Elementary actions that add threads to and remove threads from wait sets are atomic. Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll.

Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
  - A notify action being performed on m in which t is selected for removal from the wait set.
  - A notifyAll action being performed on m. 
  - An interrupt action being performed on t. 
  - If this is a timed wait, an internal action removing t from m's wait set that occurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse since the beginning of this wait action. 
  - An internal action by the implementation. Implementations are permitted, although not encouraged, to perform "spurious wake-ups",
    that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
  
 Notification actions occur upon invocation of methods notify and notifyAll.

Memory that can be shared between threads is called shared memory or heap memory. All instance fields, static fields, and array elements are stored in heap memory. In this chapter, we use the term variable to refer to both fields and array elements. Local variables (Â§14.4), formal method parameters (Â§8.4.1), and exception handler parameters (Â§14.20) are never shared between threads and are unaffected by the memory model.
}
-------------------------------------------------
addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation style APIs — as popularized by CompletableFuture and ReactiveX, that allow declarative composition of asynchronous logic. At the programming model level Java 8 enabled Spring WebFlux to offer functional web endpoints alongside with annotated controllers.


The term "reactive" refers to programming models that are built around reacting to change — network component reacting to I/O events, UI controller reacting to mouse events, etc. In that sense non-blocking is reactive because instead of being blocked we are now in the mode of reacting to notifications as operations complete or data becomes available.

Spring Reactive Streams is a small spec, also adopted in Java 9, that defines the interaction between asynchronous components with back pressure. For example a data repository — acting as Publisher, can produce data that an HTTP server — acting as Subscriber, can then write to the response. The main purpose of Reactive Streams is to allow the subscriber to control how fast or how slow the publisher will produce data.
   
Reactive Streams plays an important role for interoperability. It is of interest to libraries and infrastructure components but less useful as an application API because it is too low level. What applications need is a higher level and richer, functional API to compose async logic — similar to the Java 8 Stream API but not only for collections. This is the role that reactive libraries play.
-------------------------------------------------
Java Value Types proposal:
https://www.infoq.com/news/2017/11/ValueTypesNov10
--------------------------------
JAVA Enhancements proposals:
http://openjdk.java.net/jeps/0
-------------------------------
REF: http://www.baeldung.com/java-completablefuture
  |In asynchronous computation, actions are represented as callbacks, handling errors might occur at any step.
  |
  |Java 5+: Future: Represent an asynchronous computation
  |Java 8+: CompletableFuture : Extends Future with methods to combine and handle errors
  |                            Extends the CompletionStage interface
  |                              - Contract for an asynchronous computation step that
  |                                can be combined with other steps.
  |                            About 50 different methods for composing, combining, executing async computation
  |
  |
  |Using CompletableFuture as a Simple Future (no-arg constructor) 
  |
  |In the example below we have a method that creates a CompletableFuture instance, then spins off some computation in another thread and returns the Future immediately.
  |
  |  1  public Future<String> calculateAsync() throws InterruptedException {
  |  2      Future<String> result = new CompletableFuture<>();
  |  3     
  |  4      Executors.newCachedThreadPool().submit(() -> {
  |  5          Thread.sleep(500);
  |  6          completableFuture.complete("Hello");
  |  7          return null;
  |  8      });
  |  9   
  |  10     return completableFuture;
  |  11 }
  |  Line 2: Alternatively when the result of computation is known:
  |          Future<String> result = CompletableFuture.
  |             completedFuture("Hello");
  |  
  |  Line 6: Alternatively completableFuture.cancel(false);
  |  Line 5: any other mechanism can be used to compute 
  |    
  |
  |  1 Future<String> completableFuture = calculateAsync();
  |  2  
  |  3 // ... 
  |  4  
  |  5 String result = completableFuture.get();
  |  6 assertEquals("Hello", result);
  |
  |Line 5: get() blocks until .complete("...") is called in other thread
  |Line 5: get()can raise 
  |           ExecutionException: error during computation
  |           InterruptedException: thread executing method interrupted
  |
  |4. CompletableFuture with Encapsulated Computation Logic (runAsync -<<Runnable>>-, supplyAsync -<<Supplier>>-)
  |
  |<<Supplier>>: generic functional interface with single method (zero arguments, returns value)
  |
  |  1 CompletableFuture<String> future
  |  2   = CompletableFuture.supplyAsync(/*supplier lambda*/ () -> "Hello")
  |  3 .thenApply(/* "processor" lambda */ s -> s + " World") /* returns CompletableFuture */;
  |  4 .thenAccept(/*consumer lambda */ 
  |  5    s -> System.out.println("Computation returned: " + s));
  |    Line 4: Alternatively (ignrore result)
  |    .thenRun(/*Runnable lambda*/ () -> System.out.println("Computation finished."));
  |
  |5. Combining Futures (monadic design pattern in functional languages)
  |
  |  1 CompletableFuture<String> completableFuture 
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCompose(
  |  4           s -> CompletableFuture.supplyAsync(() -> s + " World"));
  |  4  
  |  5 assertEquals("Hello World", completableFuture.get());
  |    
  |6. Execute two independent Futures and do something with their results
  |
  |  1 CompletableFuture future  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCombine(CompletableFuture.supplyAsync(
  |  4       () -> " World"), (s1, s2) -> s1 + s2));
  |  5  
  |  6 assertEquals("Hello World", future.get());
  |    
  |(Simpler case - nothing to do with resulting value-)
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3   .thenAcceptBoth(CompletableFuture.supplyAsync(
  |  4      () -> " World"), (s1, s2) -> log(s1 + s2));
  |    
  |7. Running Multiple Futures in Parallel:  wait for all to execute and process combined results
  |
  |  1  CompletableFuture<String> future1  
  |  2    = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  CompletableFuture<String> future2  
  |  4    = CompletableFuture.supplyAsync(() -> "Beautiful");
  |  5  CompletableFuture<String> future3  
  |  6    = CompletableFuture.supplyAsync(() -> "World");
  |  7   
  |  8  CompletableFuture<Void> combinedFuture 
  |  9    = CompletableFuture.allOf(future1, future2, future3);
  |  10  
  |  11 // ...
  |  12  
  |  13 combinedFuture.get();
  |  14  
  |  15 String combined = Stream.of(future1, future2, future3)
  |  16   .map(CompletableFuture::join)
  |  17   .collect(Collectors.joining(" "));
  |  18 assertEquals("Hello Beautiful World", combined);
  |
  |    Line 16: join() is similar to get, but throws unchecked exception if the Future does not complete normally.
  |
  |8. Handling Errors
  |
  |   Instead of catching an exception in a syntactic block, the CompletableFuture class allows you to handle it in a special handle method. This method receives two parameters: a result of a computation (if it finished successfully) and the exception thrown (if some computation step did not complete normally).
  |
  |
  |
  |Capture async exception:
  |           
  |  1  CompletableFuture<String> completableFuture  
  |  2    =  CompletableFuture.supplyAsync(() -> {
  |  3        ... if(errorDetected) 
  |  4               throw new RuntimeException("Computation error!");
  |  6        return "Hello ";
  |  7    })}).handle((s, t) -> s != null ? s : "Hello, Stranger!");
  |  8   
  |  9  assertEquals("Hello, Stranger!", completableFuture.get());
  |Alt: 
  |  1  completableFuture.completeExceptionally(
  |  2    new RuntimeException("Calculation failed!"));
  |  3  ...  
  |  4  completableFuture.get(); // ExecutionException
  |                                                                            
  |9. Async Methods
  | - The methods without the Async postfix run next execution stage using a calling thread.
  |
  | - The Async method without the Executor argument runs a step using the common fork/join pool implementation of Executor 
  |   that is accessed with the ForkJoinPool.commonPool() method.
  |
  | - The Async method with an Executor argument runs a step using the passed Executor.
  |
  | Ex.: process result of computation with a Function instance
  |  1 CompletableFuture<String> completableFuture  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  
  |  4 CompletableFuture<String> future = completableFuture
  |  5   .thenApplyAsync(s -> s + " World");
  |  6  
  |  7 assertEquals("Hello World", future.get());
  |
  |    Line 5: under the hood the application of a function is wrapped into a ForkJoinTask instance 
  |    (for more information on the fork/join framework, see the article ?Guide to the Fork/Join Framework in Java?).
  |    This allows to parallelize your computation even more and use system resources more efficiently.

--------------
QA: 
  - Static analysis tool for Java / C/C++ / Objective C
       http://fbinfer.com/ 

  - FindBugs:

  - Junit:
    https://www.infoq.com/news/2018/01/VSCodeJunit

  - 
-->

</html>
