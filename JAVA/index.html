<html>
<head>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[ xxsmall], #zoomDiv > * > *[ xxsmall], #zoomDiv > * > * > *[ xxsmall]{ font-size:1rem; }
#zoomDiv > *[  xsmall], #zoomDiv > * > *[  xsmall], #zoomDiv > * > * > *[  xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]   {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE
<tr {>
  <td topic >
     topic
  </td>
  <td summa >
     <ul>
     <li></li>
     <li></li>
     <li></li>
     </ul>
  </td>
  <td col1  >
     <pre xxsmall>
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td topic >topic</td>
  <td summa ></td>
  <td col1  ></td>
  <td col2  ></td>
</tr>
<tr {>
  <td topic >JavaDoc</td>
  <td summa >
    <pre xxsmall>
-----------------------+-------------------------------------+-------------------------+-------
Tag& Parameter         | Usage                               | Applies to              | Since
-----------------------+-------------------------------------+-------------------------+-------
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |
-----------------------+-------------------------------------+-------------------------+-------
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |
                       | Max one per Class or Interface.     |                         |
-----------------------+-------------------------------------+-------------------------+-------
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |
                       | has first existed.                  | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
@seereference          | Provides a link to other element    | Class, Interface, Enum, |  
                       | of documentation.                   | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
@paramname descrip     | Describes a method parameter.       | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@return description    | Describes the return value.         | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |  
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | <code>{@literal}</code>.            | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
    <pre>
  </td>
  <td col1>
    <pre xxsmall>
/**
 * Short one line description.
 * <p>
 * Longer description. If there were any, it would be
 * here.
 * <p>
 * And even more explanations to follow in consecutive
 * paragraphs separated by HTML paragraph breaks.
 *
 * @author John Bla
 * @param  variable Description text text text.
 * @return Description text text text.
 */
public int methodName (...) {
    // method body with a return statement
}
    </pre>
</td>
  <td col2></td>
</tr }>

<tr {>
  <td topic ><span TODO>Date &amp; Time</span></td>
  <td summa >
     <pre TODO xxsmall> 
     - package java.time.* (java 1.8+)
       All the classes are immutable and thread-safe
     - Parsing DateTime
     </pre>
     <hr/> 
     <h3>Java Up to 1.8 Compatibility:</h3>
     <p xxsmall>
     Prior to the Java SE 8 release, the Java date and time mechanism was provided by the  java.util.Date, java.util.Calendar, and java.util.TimeZone classes, as well as their subclasses, such as java.util.GregorianCalendar.<br/><br/>
      
     These classes had several drawbacks, including:<br/>
     -   The Calendar class was not type safe.<br/>
     -   Because the classes were mutable, they could not be used in multithreaded applications.<br/>
     -   Bugs in application code were common due to the unusual numbering of months and the lack of type safety.<br/>
<br/>
      Added to the JDK 8 release are several methods that allow conversion between java.util and java.time objects:<br/>
     -   Calendar.toInstant() converts the Calendar object to an Instant.<br/>
     -   GregorianCalendar.toZonedDateTime() converts a GregorianCalendar instance to a ZonedDateTime.<br/>
     -   GregorianCalendar.from(ZonedDateTime) creates a GregorianCalendar object using the default locale from a ZonedDateTime instance.<br/>
     -   Date.from(Instant) creates a Date object from an Instant.<br/>
     -   Date.toInstant() converts a Date object to an Instant.<br/>
     -   TimeZone.toZoneId() converts a TimeZone object to a ZoneId.<br/>
     </p>
     <hr/> 
     <h3>Java 9 <a href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>REF</a></h3>
     <p xxsmall TODO>

A number of parsing and formatting changes have been incorporated in Java 9 to bring the functionality closer to Unicode Locale Data Markup Language (LDML). These changes have been supervised by Stephen Colebourne, creator of the popular date-time library JodaTime, precursor of the new java.time component in Java 8. Abiding by the Unicode standard will provide better interoperability with other non-Java systems.<br/>
LDML is the language used by the Unicode Common Locale Data Repository (CLDR), a project of the Unicode Consortium to gather and store locale data from different parts of the world, enabling application developers to better adapt their programs to different cultures. Among other things, LDML deals with dates, times, and timezones, and more particularly with date formatting and parsing. The following is an extract of new features coming in Java 9 that bring java.time closer to the LDML specification:<br/>
    JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as specified in LDML, indicates a “Modified Julian day”; this is different from a normal Julian day in the sense that a) it depends on local time, rather than GMT, and b) it demarcates days at midnight, as opposed to noon.<br/>
    JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML formats to indicate “generic non-location format”, e.g. “Pacific Time”, as opposed to the “generic location format” with specifies a city, like “Los Angeles Time”.<br/>
    JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the total number of milliseconds elapsed in the day, with variable width, but currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it will fail to parse any value that is further than 99 milliseconds in the day. ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds within the second, and nanoseconds within the day, respectively.<br/>
    JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit day-of-year value: similar to the previous problem, but with ‘D’ representing days within a year. If one specifies “DD” as a pattern, it will fail to parse “123” as the 123th day of the year.<br/>
As previously mentioned, a better alignment with the LDML will ease interoperability across systems, since there are multiple technologies that have adopted the LDML to some degree. Microsoft .NET uses LDML for general interexchange of locale data, and there are packages available for Node.js and Ruby, just to mention a few.<br/>
     </p>
     <hr/> 
  </td>
  <td col1  >
    java.time. Package
    <pre xxsmall>
                   Description
----------------------------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and time using a time-zone.
----------------------------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
----------------------------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
----------------------------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system, such as 2007-12-03.
----------------------------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30.
----------------------------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system, such as 10:15:30.
----------------------------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
----------------------------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 2007-12-03T10:15:30+01:00.
----------------------------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 10:15:30+01:00.
----------------------------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.
----------------------------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
----------------------------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12.
----------------------------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30+01:00 Europe/Paris.
----------------------------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
----------------------------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
----------------------------------------------------------------------------------------------------


Enum               Description
----------------------------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
----------------------------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
----------------------------------------------------------------------------------------------------


Exception          Description
----------------------------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.
    </pre>
    java.text.MessageFormat:
    <pre xxsmall>
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale()) 
  
time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())
    </pre>
  </td>
  <td col2  >
  </td>
</tr }>


<tr {>
  <td topic >
     ANNOTATIONS
  </td>
  <td summa >
    <ul>
    <li>
    Annotation types are a form of interface:
<pre xxsmall>
DECLARATION(interface is preceded by the @ sign)| USAGE
  @interface ClassPreamble {                    |   @ClassPreamble (
     String   author        ()              ;   |      author         = "John Doe"      ,
     String   date          ()              ;   |      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;   |      currentRev     = 6               ,
     String   lastModified  () default "N/A";   |      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";   |      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;   |      reviewers      = {"Alice", "Bob"}
  }                                             |   )
                                                | public class Generation3List extends Generation2List {
                                                |     // ...
                                                | }
</pre> 
    </li>
    <li>
      Annotations can be applied to declarations of: classes, fields, methods, other program elements. 
      When used on a declaration, each annotation often appears, *by convention*, on its own line.<br/>
      As of the Java SE 8 release, annotations can also be applied to the use of types. A few examples of where
      types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses
    <pre xxsmall>I
Ex. Class instance creation expression:      new @Interned MyObject();
----------------------------------------------------------------------
Ex. Type cast:                            |  myString = (@NonNull String) str;
------------------------------------------+---------------------------
Ex. implements clause:                    |  class UnmodifiableList<T> implements
                                          |        @Readonly List<@Readonly T> { ... }
------------------------------------------+---------------------------
Ex. thrown exception declaration:         |  void monitorTemperature() throws 
                                          |        @Critical TemperatureException { ... }
------------------------------------------+---------------------------
    </pre>I
    </li>
    <li>
Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, 
annotate the @ClassPreamble DECLARATION wih @Documented annotation like:
    <pre xsmall>
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
   ...
} 
    </pre>I
    </li>
    <li>
        predefined annotation types defined in java.lang:
        @Deprecated   @Override   @SuppressWarnings
    <pre xsmall>
Ex: @SuppressWarnings(value = "unchecked")
    void myMethod() { ... }
    @SuppressWarnings({"unchecked", "deprecation"})
    void myMethod() { ... }
    </pre>
    </li>
    <li>@SafeVarargs (Java ?+) when applied to a method or constructor, asserts that the code does not perform potentially 
    unsafe operations on its varargs parameter. Unchecked warnings relating to varargs usage are suppressed.
    </li>
    <li>JAVA 8+ <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>Ref</a>
    <table xxsmall>
    <tr>
    <td>@NonNull</td>
    <td>compiler can determine cases where a code path might receive a null value, 
        without ever having to debug a NullPointerException. The compiler just print a warning, but it continues to compile!!!</td>
    </tr>
    <tr>
    <td>@ReadOnly </td>
    <td>compiler will flag any attempt to change the object. This is similar to Collections.unmodifiableList, 
    but more general and verified at compile time.</td>
    </tr>
    <tr>
    <td>@Regex</td>
    <td>Provides compile-time verification that a String intended to be used as a regular expression is a properly formatted 
    regular expression.</td>
    </tr>
    <tr>
    <td>@(Un)Tainted</td>
    <td>Identity types of data that should not be used together, such as remote user input being used in 
    system commands, or sensitive information in log streams</td>
    </tr>
    <tr>
    <td>@m</td>
    <td>Units of measure ensures that numbers used for measuring objects are used and compared correctly, or have undergone the
    proper unit conversion.</td>
    </tr>
    <tr>
    <td>@FunctionalInterface</td>
    <td>indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Spec.</td>
    </tr>
    </table> 
    Ex:
      <pre xxsmall>
Annotation                                         Meaning
@NonNull List<String>                              A non-null list of Strings.
List<@NonNull String>                              A list of non-null Strings.
@Regex String validation = "(Java|JDK) [7,8]"      Check at compile time that this String is a valid regular expression.
private String getInput(String parameterName){     The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval = 
      @Tainted request.getParameter(parameterName);
  return retval;
}
        
private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
  ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

  Process process = processBuilder.start();
}
    
         </pre>
    </li>


    </ul>
  </td>
  <td col1  >
    <ul>
    <li> META-ANNOTATIONS: Annotations that apply to other annotations.<br/>
         There are several meta-annotation types defined in java.lang.annotation.<br/>
         @Retention: specifies how the marked annotation is stored:
         <pre xxsmall>
RetentionPolicy.SOURCE: annotation is retained only in source level and is ignored by the compiler.
RetentionPolicy.CLASS: annotation is retained by compiler, but ignored by the (JVM)
RetentionPolicy.RUNTIME: annotation is retained by the JVM, can be used@RunTime 
        </pre>
        @Documented: indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.)<br/>
        @Target meta-annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to.
         <pre xxsmall>
ElementType.ANNOTATION_TYPE can be applied to an annotation type.
ElementType.CONSTRUCTOR can be applied to a constructor.
ElementType.FIELD can be applied to a field or property.
ElementType.LOCAL_VARIABLE can be applied to a local variable.
ElementType.METHOD can be applied to a method-level annotation.
ElementType.PACKAGE can be applied to a package declaration.
ElementType.PARAMETER can be applied to the parameters of a method.
ElementType.TYPE can be applied to any element of a class.
         </pre>
        @Inherited meta-annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class' superclass is queried for the annotation type. This annotation applies only to class declarations.<br/>
        @Repeatable annotation (Java 8+), indicates that the marked annotation can be applied more than once to the same declaration or type use.
Ref: http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
         <pre xxsmall>
Ex:
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
         </pre>
    </li>
    </ul>
  </td>
  <td col2  >
  </td>
</tr }>
<tr {>
  <td topic >
     NIO
  </td>
  <td summa >
     <ul>
     <li>java.nio.ByteBuffer <a href='http://tutorials.jenkov.com/java-nio/buffers.html'>REF</a>
Using a Buffer to read and write data typically follows this little 4-step process:
     <ol>
       <li>1. Write data into the Buffer</li>
       <li>2. Call buffer.flip()</li>
       <li>3. Read data out of the Buffer</li>
       <li>4. Call buffer.clear() or buffer.compact()</li>
     </ol>
     <pre xsmall>
channel data -> Buffer:               |  buffer -> channel:
  int bytesRead = inChannel.read(buf);|   int bytesWritten = inChannel.write(buf);
  var -> Buffer:                      | Buffer -> var:
    buf.put(127);                     |   byte aByte = buf.get();    
     </pre>
     <pre xsmall>
rewind (): The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer. 
clear  (): reset and prepare for writing.
compact(): pseudo-reset, but leave non-read data at the start of the buffer.
mark   (): mark <- inverser -> reset
reset  (): mark <- inverser -> reset
equals () & compareTo()
     </pre>
     </li>
     <li>
     </li>
     </ul>
  </td>
  <td col1 >
     <pre xxsmall>
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;

public class main {
  public static void main(String[] args) {
    //  STEP 0: PREPARE THE BUFFER
    ByteBuffer buf = ByteBuffer.allocate(48); // <- Capacity: 48 bytes
    buf.order(ByteOrder.BIG_ENDIAN);
    buf.clear();   //  Clears this buffer before writing to it (channel-read/put-operations) to fill the buffer.
                   // The position is set to zero, the limit to the capacity, and the mark discarded.
    boolean fromChannel = false; // Write from channel or programatically (put*)

    //  STEP 1: WRITE TO THE BUFFER
    if (fromChannel) {
        RandomAccessFile aFile = null;
                              try {
        // STEP 1.1: PREPARE THE SOURCE THAT WRITES TO THE BUFFER
        aFile = new RandomAccessFile("data/nio-data.txt", "rw");
        FileChannel inChannel = aFile.getChannel();
        
        // STEP 1.2: WRITE TO THE BUFFER (READ THE INPUT CHANNEL)
        int bytesRead = inChannel.read(buf); //read into buffer.
        while (bytesRead != -1) {
            buf.flip();  //make buffer ready for read
            while(buf.hasRemaining()){ System.out.print((char) buf.get()); } // read 1 byte at a time  
            buf.clear(); //make buffer ready for writing
            bytesRead = inChannel.read(buf);
        }
                              } catch(Exception e){
        // ...
                              } finally {
        if (aFile != null) { aFile.close(); aFile = null};
                              }
    } else  /* Use "put*" */{
        short short0 =      23; buf.putShort(short0);
        char char0   =     'a'; buf.putChar (char0 );
        int int0     = 1231313; buf.putInt  (int0  );
    }

    //  STEP 2: PREPARE BUFFER FOR READING.
    buf.flip();
    
    //  STEP 3: READ THE BUFFER
    //   (Alt. read the buffer writing to a Channel: int bytesWritten = inChannel.write(buf);)
    char     char1 = buf.getChar  (); long     long1 = buf.getLong  ();
    short   short1 = buf.getShort (); float   float1 = buf.getFloat ();
    int       int1 = buf.getInt   (); double double1 = buf.getDouble();
  }
}
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >JSON</td>
  <td summa >
      <a href='https://www.infoq.com/news/2017/03/json-processing-public-review'>REF:JSON processing public review</a>
      <p>Public review of JSR 374: Java API for JSON Processing (JSON-P) version 1.1 is now open. 
This version is expected to be included in the release of J2EE 8 and keeps JSON-P current with JSON IETF standards. It includes support for:
      <ul>
      <li>JSON Pointer</li>
      <li>JSON Patch</li>
      <li>JSON Merge Patch</li>
      <li>Query and transformation operations</li>
      <li>Java 8 streams and lambdas</li>
      </ul>
     </p>

JSON-P was introduced in 2013 with the release of J2EE 7, as an alternative to Gson and Jackson. It was designed to parse, generate, 
and query standard JSON documents.

JSR-367: Java API for JSON Binding (JSON-B), will also be included in the release of J2EE 8.    -----
  </td>
  <td col1  >
    tags: [JSON Parsing, HTTP GET/POST, TLS, Basic Authorization]
    <pre xxsmall>
package com.mycomp.project1;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.json.JSONObject;

import java.security.cert.X509Certificate;
import java.util.Date;

import java.util.Scanner;

public class TestAPI<JSONArray> {
    static String userpass = "operator1:ecllqy";
    private static SSLSocketFactory sslSocketFactory = null;

    private JSONObject sendPost(String url, String post_body, String token) throws Exception 
    {
        URL obj = new URL(url);
        String basicAuth = "Basic " +
            javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

        HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

        setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

        con.setRequestMethod("POST"); //add request header
        con.setRequestProperty("Content-Type", "application/json");
        con.setRequestProperty("Cache-Control", "no-cache");
        if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
        } else               { con.setRequestProperty("Authorization", "Bearer "+token);
        }
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(post_body);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();

        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        StringBuffer response = new StringBuffer();
        String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
        in.close();
        return new JSONObject(response.toString()); //String myJSONStr
    }


    /********************************************************************************/
    /**
     * Overrides the SSL TrustManager and HostnameVerifier to allow
     * all certs and hostnames.
     * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
     * environment.
     *
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     */
    protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
        // Create the socket factory.
        // Reusing the same socket factory allows sockets to be
        // reused, supporting persistent connections.
        if( null == sslSocketFactory) {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
            sslSocketFactory = sc.getSocketFactory();
        }

        connection.setSSLSocketFactory(sslSocketFactory);

        // Since we may be using a cert with a different name, we need to ignore
        // the hostname as well.
        connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
    }

    private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {}
            public void checkServerTrusted(X509Certificate[] certs, String authType) {}
        }
    };

    private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
}
    </pre>
    
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >Exceptions</td>
  <td summa >
     <ul>
     <li>(compiler) checked vs unchecked (Error, RuntimeException and their subclasses).</li>
     <li>Checked: All except Error, RuntimeException and their subclasses</li>
     <li>Error: Exceptional conditions external to the application.</li>
     <pre>
|java.lang.Object
|   java.lang.Throwable
|       java.lang.Exception
|           java.lang.RuntimeException (non-checked)
|           java.lang.*Exception       (checked -A)
|       java.lang.Error                (non-checked)
     </pre>
    
     <li>The Throwable class is the superclass of all errors and exceptions in the Java language.  Only objects that are instances of this class (or one of its subclasses) are thrown by the JVM or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.</li>
     <li>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.</li>
    </ul>
  </td>
  <td col1  >
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >
     Cocurrent
  </td>
  <td summa >
     <ul>
     <li TODO>java.util.concurrent</li>
     <li>In the Java language, each object may be used as a monitor. Methods requiring mutual exclusion must be explicitly marked with the synchronized keyword. Blocks of code may also be marked by synchronized.<br/>
Rather than having explicit condition variables, each monitor (i.e. object) is equipped with a single wait queue in addition to its entrance queue. All waiting is done on this single wait queue and all notify and notifyAll operations apply to this queue.</li>
     <pre>
             enter         
               |           
 +---+-------- | --+       
 |  notified   v   |       
 | ----->          |       
 |                 |       
 | O |         O   |       
 | O |         O   |       
 | O +--------   --+--+    
 | O |                |    
 |   |                |    
 |  <-- wait   O      |    
 |   |      (Running  |    
 +---+       thread)  |    
     |                |    
     |                |    
     |     leave      |    
     |        |       |    
     +------- | ------+    
              v            
     </pre>

     <li>
     <a href='https://github.com/google/guava/wiki/ListenableFutureExplained'>REF: ListenableFuture Explained</a><br/>
      Concurrency is a hard problem, but it is significantly simplified by working with powerful and simple abstractions. To simplify matters, Guava extends the Future interface of the JDK with ListenableFuture.<br/>
      <i>"""We strongly advise that you always use ListenableFuture instead of Future in all of your code, because:<br/>
    Most Futures methods require it.<br/>
    It's easier than changing to ListenableFuture later.<br/>
    Providers of utility methods won't need to provide Future and ListenableFuture variants of their methods.<br/>
       """</i>
     </li>
     </ul>
  </td>
  <td col1  >
  </td>
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >Async code</td>
  <td summa >
     <ul>
     <li>
     <pre>
 +------------+ |               [[Executor]]
 |[[Runnable]]| |                   ^
 |------------| |                   |
 |+run()      | |           [[ExecutorService]]
 +------------+ |                   ^
       ^        |        +----------+--------------+
       |        |        |                         |
 +------------+ | AbstractExecutorService  [[ScheduledExecutorService]]
 |   Thread   | |        ^                         ^
 |------------| | ThreadPoolExecutor               |
 |+run()      | |        ^                         |
 |+start()    | | ScheduledThreadPoolExecutor -----+
 |+sleep()    | |
 |....        | |
 |------------| |
 +------------+ |
     </pre>
     </li>
     <li>
     ExecutorService(Thread Pool): managed collection of threads available to execute tasks.<br/>
     To use a thread pool, you can use an implementation of the interface ExecutorService, such as ThreadPoolExecutor or ScheduledThreadPoolExecutor. However, more convenient factory methods are provided in the Executors class as follows:<br/>
     Using thread pool:
     <ol>
       <li>Write worker thread class implementing <<Runnable>> run()</li>
       <li>STEP 2: Create ExecutorService using:
         <pre>
Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int numThreads)
Executors.newCachedThreadPool(): <-- unbounded pool, with automatic reclamation
Executors.newSingleThreadScheduledExecutor()
Executors.newScheduledThreadPool(int size)
         </pre>
       </li>
       <li>Use executor(Service)Instance.execute(/*Runnable */workerThreadInstance) to add a Runnable task to thread pool. Executes task at some time in the future in a new thread, in a thread pool, or in the calling thread, depending on the implementation of Executor</li>
     </ol>
     <pre>
 [[java.util.concurrent.ExecutorService]]
 + public     void      shutdown(); // Initiates orderly shutdown of pool
 + public <T> Future<T> submit(Callable<T> task); // schedule callable task for execution
     </pre>
     </li>
     <li><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'>CompletableFuture (Java 8+)</a><br/>
       A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.<br/>
       When two or more threads attempt to complete, completeExceptionally, or cancel a CompletableFuture, only one of them succeeds.<br/>
     </li>
     <li>
     <pre>
[[ java.util.concurrent.Callable&lt;V> ]]
   +public V call()  (vs run() in Runnable)
   similar to a Runnable, but allows to return a result/Exception to the thread triggering the Callable
   returns a result of type &lt;V>, or throws an exception if unable to do so.
  
[[ Future&lt;V> ]] 
   +V get()           // blocks waiting for result
   +V get(long timeout, TimeUnit unit)
   +boolean cancel(boolean mayInterruptIfRunning)
   +boolean isCancelled()
   +boolean isDone()  // return true if this task completed
     </pre>
     </li>
     </ul>
  </td>
  <td col1  >
     <pre xsmall>
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {

   public static void main(String[] args) {
      ExecutorService pool = Executors.newFixedThreadPool(10);
      MyWorker[] workers = new MyWorker[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) pool.execute(new MyWorker(i+1));
      pool.shutdown();
   }
}
     </pre>

     <pre xsmall>
import java.util.concurrent.Callable;
import java.util.concurrent.*;

public class CallableThreadPoolTest {

    public class MyCallableWorkerThread implements Callable&lt;String> {
       MyCallableWorkerThread(int workerNumber) { ... }
       public String call() { 
          Thread.sleep((int)(Math.random() * 1000));
          return "worker " + workerNumber;
       }
    }

   public static void main(String[] args) {
      int numWorkers = 10;
      ExecutorService pool = Executors.newCachedThreadPool();
      MyCallableWorkerThread workers[] = new MyCallableWorkerThread[numWorkers];
      Future                 futures[] = new Future                [numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new MyCallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
                                 try {
            System.out.println(futures[i].get() + " ended");
                                 } catch (InterruptedException ex) {
            ex.printStackTrace();
                                 } catch (ExecutionException ex) {
            ex.printStackTrace();
                                 }
      }
   }
}
     </pre>
  </td>
  <td col2  >
  </td>
</tr }>

</table>
</body>

</html>
