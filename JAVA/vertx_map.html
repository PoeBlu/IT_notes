<html>
<head>
   <meta charset="UTF-8">
   <title>VertX map (alpha)<!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table>
<tr {>
  <td summa > 
     Vert.X
     <ul xxxsmall zoom > 
     <li><a href='https://github.com/vert-x3/vertx-guide-for-java-devs'>Vert.X guide for java devs</a> </li> 
     <li><a href='https://github.com/vert-x3/vertx-maven-starter'>VertX maven starter</a> </li> 
     <li><a href='https://github.com/vert-x3/vertx-examples'>Examples</a> for amqp-bridge, grpc, core, docker, gradle*/maven*, ignite, jca, jdbc,
          kafka, kotlin, mail, metrics, mqtt, openshift3, reactjs-server-side-rendering, redis, resteasy, rx, service-discovery, service-proxy, shell, spring, sync, unit, web/web-client ...</a> </li> 
     <li><a href='https://github.com/vert-x3/vertx-examples/tree/master/web-examples/src/main/java/io/vertx/example/web'>Web server examples</a></li> 
       (angular*, auth, authjdbc, authorisation, blockinghandler,
       chat, cookie, cors, custom_authorisation, form,
       helloworld, http2, 
       <a href='https://github.com/vert-x3/vertx-examples/blob/master/web-examples/src/main/java/io/vertx/example/web/jdbc/Server.java'>jdbc</a>, jwt, mongo, react, realtime, rest,
       sessions, staticsite, templating, upload, vertxbus)
     <li><a href=''></a> </li> 
     </ul> 
  </td>
  <td summa >
  verticle
  <ul xxxsmall zoom >
    <li>reusable event processing unit (of development)</li>
    <li>verticle 1 &lt;-> event-loop 1 &lt;-> 1 Thread </li>
    <li>Can be passed some configuration like credentials, network address,... and
        can be deployed several times</li>
    <li>A verticle processes incoming events over an thread-event-loop,
        where events can be anything like receiving network buffers, 
        timing events, or messages sent by other verticles</li>
    <li>thread blocking operations shall not be performed on the event loop thread</li>
    <li>Base class: io.vertx.core.AbstractVerticle. Provides:<br/>
      - life-cycle start and stop methods to override with sync and async (future) variants <br/>
      - 'vertx' protected field pointing to the Vert.x environment where the verticle is deployed<br/>
      - accessors to some configuration object allowing to pass external configuration<br/>
    </li>
   </ul>
   VertX summary
<pre xxxsmall zoom >
import io.vertx.core.AbstractVerticle;
public class MainVerticle extends AbstractVerticle {
  @Override
  public void start(Future<Void> startFuture) throws Exception {
    startFuture.complete();
  }
}
  </pre>
  </td>
  <td >
  Event Bus
  <ul xxxsmall zoom >
    <li>main tool for different verticles to communicate through asynchronous message passing
<pre {>
     HTTP server verticle        event-bus         DDBB client verticle
            |                     |                    |              
            +--- user 1234 ? -->  |                    |              
            |                     +--- user 1234 ? --> |              
            |                     |                    +-- ....->              
            |                     |                    |&lt;- ....              
            |                     | <- user 1234 ? ----+              
            |&lt;-- user 1234   ---  |                    |
</pre }>
    </li>
    <li>Message destinations are free-form strings. </li>
    <li>communication patterns supported:<br/>
      - point-to-point messaging
      - request-response messaging
      - publish / subscribe for broadcasting messages
    </li>
    <li>It can be accessed through a simple TCP protocol for 3rd party apps
        or exposed over general-purpose messaging bridges (AMQP, Stomp,...)</li>
    </ul>
  </td>
  <td TODO >Testing asyncrhonous ops</td>
  <td summa >
    [AAA] Securing and controlling access HTTPS
    user authentication for web browser sessions and JWT tokens for third-party client applications</td>
  <td TODO >
     RxJava Integration
  <!-- Refactoring some code to use reactive programming with the
        popular RxJava library and its Vert.x integration -->
  </td>
</tr }>
</table>

<table>
<tr {>
  <td topic >Client-Side</td>
  <td summa >
   Client-side programming of a single-page application with AngularJS</td>
  <td >SockJS<br/>
  <span xsmall zoom TODO >
    Event-bus bridge allowing web apps to seamlessly communicate over the
    event bus from JavaScript running in the browser by receiving and publishing
    messsages just like any verticle would do
  </span>
  </td>
</tr }>
</table>

<!--
 TODO:
 Cookbook recipe:
    Vertx vertx = Vertx.vertx();
    HttpServer server = vertx.createHttpServer();
    server.requestHandler(req -> {
      req.response().end("Hello world");
    });
    server.listen(8080);
 ------------------------------------

"""
There are many features and modules that we havenâ€™t covered in this guide, such as:
  - Clustering using Hazelcast, Infinispan, Apache Ignite or Apache Zookeeper,
  - How the code looks like with other supported languages,
  - Exposing and consuming over HTTP/2, possibly (but not necessarily) with gRPC
  - Using NoSQL databases such as MongoDB or Redis,
  - Sending emails over SMTP,
  - Messaging with AMQP, Stomp, Kafka, MQTT or RabbitMQ,
  - Using OAuth2 authentication from custom and popular providers,
  - Vert.x sync for writing blocking-style code that is later turned into fibers non-blocking code at runtime,
  - Publishing and discovering micro-services from registries, for instance when deploying on cloud environments like OpenShift,
  - Exposing metrics and health checks.
"""


-->

</body>
</html>


