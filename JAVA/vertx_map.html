<html>
<head>
   <meta charset="UTF-8">
   <title>VertX map (alpha)<!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>
<pre zoom > 
<span xsmall>Summary</span>
- <a href='https://github.com/vert-x3/vertx-guide-for-java-devs'>Vert.X guide for java devs</a> 
- <a href='https://github.com/vert-x3/vertx-maven-starter'>VertX maven starter</a>  
- <a href='https://github.com/vert-x3/vertx-examples'>Examples</a> for amqp-bridge, grpc, core, docker, gradle*/maven*, ignite, jca, jdbc,
       kafka, kotlin, mail, metrics, mqtt, openshift3, reactjs-server-side-rendering, redis, resteasy, rx, service-discovery, service-proxy, shell, spring, sync, unit, web/web-client ...</a>  
- <a href='https://github.com/vert-x3/vertx-examples/tree/master/web-examples/src/main/java/io/vertx/example/web'>Web server examples</a> 
    (angular*, auth, authjdbc, authorisation, blockinghandler,
    chat, cookie, cors, custom_authorisation, form,
    helloworld, http2, 
    <a href='https://github.com/vert-x3/vertx-examples/blob/master/web-examples/src/main/java/io/vertx/example/web/jdbc/Server.java'>jdbc</a>, jwt, mongo, react, realtime, rest,
    sessions, staticsite, templating, upload, vertxbus)
</pre>
<pre zoom >
<span xsmall>verticle</span>
 
- reusable event processing unit (of development)
- verticle 1 ←→ event-loop 1 ←→ 1 Thread 
- Can be passed some configuration like credentials, network address,... and
        can be deployed several times
- A verticle processes incoming events over an thread-event-loop,
        where events can be anything like receiving network buffers, 
        timing events, or messages sent by other verticles
- thread blocking operations shall not be performed on the event loop thread
- Base class: io.vertx.core.AbstractVerticle. Provides:
      - life-cycle start and stop methods to override with sync and async (future) variants 
      - 'vertx' protected field pointing to the Vert.x environment where the verticle is deployed
      - accessors to some configuration object allowing to pass external configuration
    
import io.vertx.core.AbstractVerticle;
public class MainVerticle extends AbstractVerticle {
  @Override
  public void start(Future<Void> startFuture) throws Exception {
    startFuture.complete();
  }
}
</pre>
<pre zoom>
<span xsmall>Event Bus</span>
- main tool for different verticles to communicate through 
  asynchronous message passing
HTTP server       event─bus           DDBB client
 verticle                              verticle
│                    │                    │              
├─── user 1234 ? ──→ │                    │              
│                    ├─── user 1234 ? ──→ │              
│                    │                    ├── ....─→              
│                    │                    │←─ ....              
│                    │ ←─ user 1234 ? ────┤              
│←── user 1234   ─── │                    │

    
- Message destinations are free-form strings. 
- communication patterns supported:
      - point-to-point messaging
      - request-response messaging
      - publish / subscribe for broadcasting messages
    
- It can be accessed through a simple TCP protocol for 3rd party apps
        or exposed over general-purpose messaging bridges (AMQP, Stomp,...)
</pre>

<pre zoom labels="" TODO>
<span xsmall>Testing asyncrhonous ops</span>
</pre>

<pre zoom labels="" TODO>
<span xsmall></span>
[AAA] Securing and controlling access HTTPS
user authentication for web browser sessions and JWT tokens for third-party client applications
</pre>

<pre zoom labels="" TODO>
<span xsmall>RxJava Integration</span>
  <!-- Refactoring some code to use reactive programming with the
        popular RxJava library and its Vert.x integration -->
</pre>
</tr }>



<div groupv>
<pre title>
Client-Side
</pre>
<pre zoom labels="" TODO>
<span xsmall>SockJS</span>
- SockJS:
  - Event-bus bridge allowing web apps to seamlessly communicate over
  - event bus from JavaScript running in the browser by receiving and publishing
  - messsages just like any verticle would do
</pre>
</tr }>
</table>

<!--
 TODO:
 Cookbook recipe:
    Vertx vertx = Vertx.vertx();
    HttpServer server = vertx.createHttpServer();
    server.requestHandler(req -> {
      req.response().end("Hello world");
    });
    server.listen(8080);
 ------------------------------------

"""
There are many features and modules that we haven’t covered in this guide, such as:
  - Clustering using Hazelcast, Infinispan, Apache Ignite or Apache Zookeeper,
  - How the code looks like with other supported languages,
  - Exposing and consuming over HTTP/2, possibly (but not necessarily) with gRPC
  - Using NoSQL databases such as MongoDB or Redis,
  - Sending emails over SMTP,
  - Messaging with AMQP, Stomp, Kafka, MQTT or RabbitMQ,
  - Using OAuth2 authentication from custom and popular providers,
  - Vert.x sync for writing blocking-style code that is later turned into fibers non-blocking code at runtime,
  - Publishing and discovering micro-services from registries, for instance when deploying on cloud environments like OpenShift,
  - Exposing metrics and health checks.
"""


-->

</body>
</html>
