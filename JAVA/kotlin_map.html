<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Kotlin map(v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<br/>
<table style='width:100%'{>
<tbody>
<tr {>
<td>
  External Links:
  <ul xxxsmall zoom >
  <li><a href="https://kotlinlang.org/docs/reference/">Reference@Kotlinlang.org</a></li>
  <li><a href="https://kotlinlang.org/docs/resources.html">More resources</li>
  <li><a href="https://try.kotlinlang.org/#">On-line IDE</a></li>
  </ul>

  Everything is an expresion
<pre xxsmall zoom { >
// "if" are expresions and the last 
// expression is the value of the "if"-block:
val max = if (a > b) {
    print("a Wins "); a 
} else {
    print("b Wins "); b 
}
</pre }>
  Immutable values and inferred types
<pre xxsmall zoom { >
// Immediate inmutable assignment
val a: Int  = 1

// Inferred Int type (var mutable)
var count  = 5;
    count += 1;
</pre } >

  Python like import-as
<pre xxsmall zoom { >
import bar.Bar as bBar
</pre } >

  Check types at runtime ('is')
<pre xxsmall zoom { >
fun getStringLenght(obj: Any) {
  if (obj  is String) {...} 
  if (obj !is String) {...}
}
</pre } >

  Equality
<pre xxsmall zoom {>
   val a = Class(param1, param2)
   val b = Class(param1, param2)
   a === b // returns false
   a == b  // returns true
</pre }>

   <code orange>Require/assert/check</code>
<pre xxxsmall zoom {>
fun neverEmpty(str: String) {
  require(str.length > 0,
    { "String should not be empty" })
  println(str)
}
</pre }>
<br/>
  <b orange>Type alias</b>
  <ul xxxsmall zoom>
  <li>Rename type with alias.  The alias is simply replaced by the compiler. 
    This means that new types are not created or allocated, so we suffer no performance penalty. <br/>
    typealias do <b>NOT</b> increase type safety.</li>
  <li>
<pre {>
typealias Cache = HashMap<String, Boolean>
typealias Address = String
typealias FamilyName = String
</pre }>
  </li>
  </ul>
  <hr/>
  <b orange>Avoiding nulls</b>
  <a href="https://kotlinlang.org/docs/reference/null-safety.html">docs/ref</a><br/>
  <ul xxxsmall zoom>
  <li>nullables must be declared explicetelly</li>
  <li>
<pre>
val nullableBob : String? = "abc"
nullableInstance<b>?</b>.department<b>?</b>.head<b>?</b>.name 
^_______________^___________^_____^
Returns null if nullableInstance,
 department or head is null

val listWithNulls: List<String?> = listOf("A", null)
for (item in listWithNulls) {
<b>/* "?.let" skips expression
 * block execution for nulls */</b>
  item<b>?.let</b> { println(it) }
}

<b>Filtering Nulls at list initialization
(Fix-fast)</b>
val intList: List<Int> =
  listOf(1, 2, null, 4)
  <b>.filterNotNull()</b>

<b>
/* Assigning nullable to non-nullable
 * requires if (..!=null) ... else ...*/</b>
val l: Int = <b>if (b != null)</b> b.length else -1
<b>or Elvis operator ?:</b>
val l = b?.length ?: -1

<b>Abort/throw NullPointerE. if null present</b>
  val name = node.getName()!!

<b>SmartCast</b>
fun getName(): String? = ...
val name = getName()
if (name != null) {
  // here compiler knows name is not null
  println(name.length)
}
</pre>
  </li>
  </ul>
</td>  
<td>
  <b>utility functions</b><br/>
  (standard functions, no import required)<br/>
  <code orange>Apply</code><br/>
  helping funct. to init. objects:
<pre xxsmall zoom {>
// applies lambda to object and returns same object
val task = Runnable { println("Running") }
Thread(task)<b>.apply</b> {  setDaemon(true) }.start()
</pre }>

  <code orange>'with'</code> to avoid repeated typing:
<pre xxsmall zoom {>
  class Turtle {
      turn(degrees: Double)
      forward(pixels: Double)
      ...
  }
  val myTurtle = Turtle()
  with(myTurtle) {
    penDown() ;
    for(i in 1..4) { 
      forward(100.0) ; turn(90.0) 
    }
  }
</pre }>
  <code orange>Run</code> extension function.

  <ul xxxsmall zoom>
  <li>A closure is passed to run, which has the instance 
    as the receiver. The return value of the closure is used as the return value of run itself:
<pre>
val outputPath = Paths.get("/user/home").run {
  val path = resolve("output")
  path.toFile().createNewFile()
  path
}
</pre>
  </li>
  </ul>

  <code orange>Lazy</code>
  <ul xxxsmall zoom>
  <li>wraps an expensive function call to be invoked when first required:
<pre>
// expensive operation
fun readStringFromDatabase(): String = ... 
val lazyString = lazy { readStringFromDatabase() }
</pre>
  </li>
  </ul>


  <code orange>Use</code> (Java try-catch-with-resources)
<pre xxxsmall zoom {>
val stream = Files.newInputStream(
    Paths.get("/some/file.txt"))
stream.buffered().
  reader()<b>.use</b> {
  reader -> 
    println(reader.readText()) 
}
</pre }>

  <code orange>Repeat</code>: Avoid "for" for simple operations:
<pre xxxsmall zoom{>
repeat(10, { println("Hello") })
</pre }>
<!-- TODO:
   Let
-->
  <b orange>Sequences</b> (Java Streams)<br/>
  Sequences are collections of unknown size
<pre xxxsmall zoom { >
val charSequence: Sequence<Char> =
  charArrayOf('a','b','c').asSequence()  //a,b,
val s1 : String  = charSequence.joinToString(",")
</pre>

  <b orange>Sequence generator</b>
<pre xxsmall zoom { >
// NOTE: compared to collections, sequences
//     <b orange>do NOT intermediate waste memory</b>
var count = 10
val sequence = 
  generateSequence {
    (count--).takeIf { it &gt; 0 } 
}
</pre>
Run over/iterate collection/array/sequence
<pre xxsmall zoom { >
   sequence.forEach { it*it }
</pre }>
</td>  
  
<td>  
  <b orange>Basic Types</b>
<pre xxsmall zoom { >
Long/Int/Short/Byte(64,32,16,8)
Boolean 
Chars
  val c: Char = '\uFF00' //  'a', '\b'
Strings
Arrays

<b>explicit Chart to Int conversion</b>
if (c in '0'..'9')  // alt: '0'..'9'.contains(c)
  c.toInt() - '0'.toInt() 
else
  throw RuntimeException("...")

  <b orange>bitwise operations</b>
val x = (1 shl 2) and 0x00FF
// (u)shl/(u)shr) bits:(un)signed shift left/righ
// and/or/xor bits 
// inv()               :bitwise inversion

  <b orange>special optimized arrays</b>
// (Byte|Short|Int|...)Array
</pre }>
    <code orange>when(extended switch-case)</code>

<pre xxsmall zoom {>
fun describe(obj: Any = 1) :
    String = when(obj) {
  1            -&gt; "One" 
  "Hello"      -&gt; "Greeting" 
  is Long      -&gt; "Long"
  in 32...128  -&gt; "Is ASCII"
  !is String   -&gt; "Not a string"
  "dog" in obj -&gt; "Animal list"
  else         -&gt; "Unknown"
}
</pre }>
  <code orange>try/catch as expresion</code> returning values
<pre xxsmall zoom {>
  val result = 
    try { count() } 
    catch (e: ArithmeticException) {
      throw RuntimeException(e) 
    }
</pre }>

  <b orange>Ranges</b>: Interval with start and end value. Any comparable type can be used.
<pre xxsmall zoom {>
val aToZ = "a"<b>..</b>"z" // "c" in aToZ == true
val countingDown = 100.downTo(0)
val ten20 = 10.rangeTo(20).step(2)
</pre }>
</td>  
<td>
  <b orange>String template</b>
<pre xxsmall zoom { >
val a  = 23
val s1 = "Hello World <b>$a</b>!"
println(s1)
</pre } >

  <b orange>String Expresions</b>
<pre xxsmall zoom  { >
"col1: <b>${</b>s1.replace("A", "B")<b>}</b> $d"
</pre } >

  <b orange>Multiline string with margin</b>
<pre xxsmall zoom { >
  val myMultiLineString = """
<b>    |</b> for (c in "foo")
<b>    |</b>     print(c)
<b>    |</b> Dolar is writen as ${'$'}
  """.<b>trimMargin()</b> // remove leading spaces.
  print(myMultiLineString)
</pre }>
  <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/">Regex</a>s<br/>
<pre xxxsmall zoom>
// Matching and finding the groups in Kotlin:

val pattern = <b>Regex</b>("[a-zA-Z]+([0-9]+)[a-zA-Z]+([0-9]+)[a-zA-Z]+")
val inputString = "ABcDEFG12345DiFKGLSG938SDsFSd"

val matchGroups = pattern.matchEntire(inputString)?.groupValues
while (matchGroups.find()) println(matchGroups.group())
</pre>
</td>
<td>
  <b orange>Collection Handling<br/>Array initialization</b>
<pre xxsmall zoom { >
val array1 : Array<String> = <b>arrayOf</b>("asdf","ADF")
val emptyStringArray = arrayOf<String>()
val intArray = arrayOf(1,2,3)
val doubleList : List<Double>= arrayListOf(84.88, 100.25, 999.99)
var nonNulls: List<String> = listOfNotNull<String>{null, "a",...}
val map1 = mapOf("a" to 1, "b" to 2)
val intSet: Set<Int> = setOf(1, 2, 1,..)    
val hashSet: java.util.HashSet<Book> = 
    hashSetOf(Book(...), Book(...)
val longSet: MutableSet<Long> = mutableSetOf( 1, 2, 3)

val readWriteList: MutableList<String> =  mutableListOf(...)
val readOnlyView : List<String> = readWriteList

<b>Lambda initializer for arrays</b>
val squaredArray: Array = 
    Array(5, <b>{ idx -> (idx * idx).toString() }</b>)

<b>"Walk" over collection</b>
for (<b>item in</b> myArrayOrList)
  println("item is ${item}")

<b>"Walk" over list index</b>
for (<b>idx  in intList.indices</b>)
  println("$idx is ${intList[idx]}")

<b>Initialize a map</b>
(HashTable/Dictionary)
val map1 = mapOf("a" to 1, "b" to 2)
val map2 = mapOf(Pair("a", 1), Pair("b", 2))
println(map1) // Prints [1, 2]

<b>"spread" array</b>
val    a = asList(1, 2, 3)
val list = asList(-1, 1, <b>*a</b> /*spread*/, 4)  

<b>Filtering a list</b>
val positives = list<b>.filter</b> { x -&gt; x &gt; 0 }
// even shorter: (using default "it")
val positives = list.filter { it &gt; 0 }
</pre } >
</td>  


</tr }>
</table>
<table>
<tr {>
<td>
  <b orange>Interfaces</b>
<pre xxsmall zoom {>
interface MyInterface {
    val prop1: Int 
    val prop2: String
        <b>get() = "foo"</b> // default accessor
    fun bar(): Int
    // default implementation
    fun foo() { print(prop)  } 
    fun foo() { }
}

class Child : MyInterface {
  override val prop: Int = 29
}
</pre }>

  <b orange>Single abstract method Interface pattern</b>
  <ul xxxsmall zoom>
  <li>
  (An interface with a single method: Runnable, Callable, Closeable, Comparator, ...).<br/>
  Kotlin has support for converting a function literal directly
  into a SAM. If the conversion is unambiguous, you can simply pass the function literal
  where a SAM is expected:
<pre xxsmall zoom { >
val threadPool = Executors.newFixedThreadPool(4)
threadPool.submit {
  <b>println("...")</b> 
}
// The kotlin compiler will convert this code to:
threadPool.submit(<b>object : Runnable {
  override fun run() {
    println("I don't have a lot of work to do")
  }
}</b>)
</pre }>
  </li>
  </ul>
</td>  
<td>
  <b xbig blue>Functions</b><a href="https://kotlinlang.org/docs/reference/functions.html">(ref)</a>
<pre xxxsmall zoom { >
data class Coordinate(val x: Int, val y: Int)

fun getPoint
   (a: Int, b: Int <b>= 1 /*def.val*/</b>, <b>vararg</b> names: String) : Coordinate {   
  return Coordinate(a+b,a-b)
}                                
// "shortcut"
fun getPoint(a: Int, b: Int = 1) <b>= Coordinate(a+b,a-b)</b>
// ussage, split vl
val (x, y) = getPoint(1,2)
// Using named parameters
val (x, y) = getPoint(a = 1, b = 2)

<b>Generic Functions</b>
// &lt;T&gt; is specified before the fun. name
fun <T> singletonList(item: T): 
  List<T> {
    // ...
}
</a>
<b>Tail recursive</b>
// <b>Compiler optimises out the recursion!!!</b>
// - function must call itself as last operation)
// - doesn't work  within try/catch.
// - only supported in JVM (currently)
tailrec 
fun findFixPoint(x: Double = 1.0): Double
  = if (x == Math.cos(x)) x 
    else findFixPoint(Math.cos(x))

<a orange href="https://kotlinlang.org/docs/reference/inline-functions.html">Inline functions</a>
inline 
  fun lock(param1: Class1, ...) :
  ReturnClass {
}
</pre } >

<b>(Class)Extension Functions</b>
<pre xxxsmall zoom { >
fun <b orange>String.</b>spaceToCamelCase()
    String { ... }
(String. == Applies only to String objects)
Ussage:
"to camelcase".spaceToCamelCase()
23424.spaceToCammelCase() // Compiler error
</pre } >

<b>Functions receivers</b>
<pre xxxsmall zoom { >
/* 
 * Very similar to extension functions but applies to func. literals.
 * that is, to variables representing functions.
 */
// Definition:
val countChars: <b orange>String.</b>() -&gt; Unit = { println("Counted chars: ${length}") }
// Ussage:
val txt = "ASDF"
countChars(<b orange>txt</b>)
</pre }>

<b>Infix Member Functions</b>
<pre xxxsmall zoom { >
class Account {
  var balance = 0.0
  <b>infix</b> fun add(amount:Double): Unit {
     this.balance = balance + amount
  }
}
accountInstance add 100.00

<b>Operator Overloading</b>
Allowed for 
class     |
Operation | Function name
a + b     | plus()
a – b     | minus()
A * b     | times()
A / b     | div()
A &amp; b     | mod()
a..b      | rangeTo()
+a        | unaryPlus()
-a        | unaryMinus()
!a        | not()
[p1,p2,..]| operator fun get(param1, param2,...)
&lt; &lt;=      | compareTo
&gt; &gt;=      |
-------------------------
()        | operator func invoke():
</pre }>

<pre TODO hidden {>
// <- instance 'space':'space' => type <-> supertype
interface Foo<out T : Any> : Bar {
// <- instance: => instance <-> type
    fun foo(a: Int): T 
}
</pre }>
  <b orange>High Order Functs</b></a>
<pre xxxsmall zoom {>
<b>Function receiving a function</b>
fun foo(name: String, <b>paramFunc: (String) -> String</b>): Unit {
  val applied = paramFunc(name)
  println(applied)
}
foo("hello", <b>paramFunc = { it.reversed() }</b>)


<b>Function returning a function</b>
fun bar() :
   <b>(String) -> String = { str -> str.reversed() }</b>

<b>Closures</b>
fun students(nameToMatch: String): List<Student> {
  return loadStudents().filter <b>{
    // closure has access to parent stack
    it.lastName == nameToMatch
  }</b>
}

<b>Currying functions</b><br/>
<span TODO>TODO</span>

<b>Memoization (Avoid repeated long-running calculus)</b>
fun Function1<b>.memoized()</b>: (String) -> MyClass {
  val map = ConcurrentHashMap<String, MyClass>()
  return {
    a -> map.getOrPut(a) {
      this.invoke(a)
    }
  }
}
</pre }>
</td>

<td>
  <b orange>Classes<a href="https://kotlinlang.org/docs/reference/classes.html">(REF)</a></b><br/>
  <code orange>"Any"</code> (common superclass in Kotlin) is <b>NOT</b> java.lang.Object; 
  it does not have any members other than equals(), hashCode() and toString().
  <hr/>
  <b orange>Composition over inheritance</b>
  <ul xxxsmall zoom>
  <li>sometimes called delegation, where delegation is actually the dessign pattern 
      and composition the standard/easiest way to implement it.</li>
  <li>REF1:"Efective Java"</li>
  <li>REF2:<a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin doc ref</a><li/>
  <li>Note: foreign keys in SQL is the best well known form of composition:
<pre xxsmall zoom { >
employee      person     client
--------      -------    ------
id      ←─┐┌─→ id   ←─┐  id
roll      ││   name   └─ fk_person
fk_person ─┘   ...    ┌─ fk_saleManager
...       └───────────┘   ...
</pre } >
   </li>
   </ul>
   <b orange>Composition</b>
<pre xxxsmall zoom {>                
interface IPerson { fun print() ... }

class Person(val name: String, val familyName1: ...) : IPerson {
  override fun print() { print(x) }
}

class Employee(b: IPerson) : IPerson <b orange>by</b> b

fun main(args: Array&lt;String&gt;) {
    val pacoMA = Person(
             surname:"Paco", name1: "Martinez", ... )
    val employee = Employee(
                     <b>person: <b>pacoMA</b>,
                     roll: manager,
                     ... )
    employee<b orange>.print()</b> /* == myClass.base.print() */
}
</pre>
  <b orange>Inheritance (discouraged)</b>
<pre xxxsmall zoom>
class Derived(p: Int) <b orange>:</b> Base(p)

class Container(
  id     : Int, 
  size   : Int,
  childs : Containers
) : SuperClass(id, name),
  Iface1, Iface2, Iface3 {
  var person_id = id
  <b orange>// custom accesor</b>
  val isEmpty: Boolean 
      <b orange>get() = this.size == 0 
             || (var sum = 0; for (c in childs) sum+=c.size) == 0  </b>
  val stringRepr : String
      <b>get() = this.toString()</b>
      <b>set(value) = _setFromString(value)</b>
  // ...

  <b>companion object</b> Factory : FactoryTemplate<MyClass> { // <- object name ('Factory') can be ommited
    override fun create(): Container = Container(...)
  }
  }
  val instance = MyClass.create()
}
</pre>

<b orange>Singletons Syntax</b>

<pre xxxsmall zoom>
<b orange>object</b> Resource {
  val name = "Name"
}
</pre } >

<pre { >
<!--  TODO:(0)
class Customer public @Inject constructor(name: String = "") { ... }

/* The 'constructor' keyword is optional if not annotations or visibility
 modifiers are used */
class Customer constructor(name: String) { // primary constructor
    init { // 'init' marks an initializer block
        logger.info("Customer initialized with value ${name}")
    }
}
class Customer {
  constructor(parent: Person) { // Secondary constructor
    parent.children.add(this)
  }
}
-->
</pre } >
</td>
<td>
   <b orange>Compaq class declaration</b>
<pre xxsmall zoom { >
// use val or var:
class Person(
  val firstName: String,
  val lastName: String,
  var age: Int) {
  ...
}
</pre }>

  <b orange>data class (DTO)</b>
<pre xxsmall zoom { >
<span comment>automatically generates:
- getters (and setters for vars),
- equals(), hashCode(), toString(), copy()
- component1(),… for all properties 
</span>
<b orange>data</b> class Customer(
  val name  : String,  // val: inmutable
  val email : String, // val: inmutable
  var refNum: Int )    // var:   mutable 
<span gray> /* optional class member functions */ 
{
  override fun toString() : String {
    return "(${refNum} : ${name} &lt;${email}&gt;)"
  }
}</span>
</pre } >

  <b orange>Sealed Classes</b> <a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Ref</a> </br>
  <ul xxxsmall zoom>
  <li>represent restricted class hierarchies or "sort of" enum extensions,
    with subclasses being able to have multiple instances</li>
  <li>(sealed class/subclasses must be declared in the same file)
<pre { >
Declaration:
<b>sealed</b> class Expr
data class Const(val number: Double)      <b>: Expr()</b>
data class Sum(val e1: Expr, val e2: Expr)<b>: Expr()</b>
object /*singleton*/ NotANumber <b>: Expr()</b>

Ussage:
fun eval(expr: <b>Expr</b>): Double =
  when(expr) {
  is <b>Const</b>      -&gt; expr.number
  is <b>Sum</b>        -&gt; eval(expr.e1) + eval(expr.e2)
     <b>NotANumber</b> -&gt; Double.NaN
}
</pre } >
</td>
<td>
  <b orange>DSL</b>
  <a xxsmall href="https://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/">REF</a>,
<a xxsmall href="https://kotlinlang.org/docs/reference/type-safe-builders.html">REF 2</a> <br/>
  Examples
  <ul xxxsmall zoom>
  <li><a href="https://github.com/Kotlin/kotlinx.html">Kotlin DSL for HTML</a></li>
  <li><a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts">Programatically generate layouts</a></li>
  <li><a href="https://ktor.io/features/routing.html#routing-tree">Defining (Web server) routing trees</a></li>


  </ul>
  Syntactic sugar
  <ul xxxsmall zoom>
  <li>Allow to conver code like:
<pre>
Collection.sort(<b>list</b>);
int index = Collection.binarySearch(<b>list</b>,x);
</pre>
    into 
<pre>
<b>list</b>.sort();
int index = <b>list</b>.binarySearch(x);
</pre>
  providing IDE autocompletion by just writing an object instance. (No need to be aware of Collection object)
  </li>
  <li>All that needed is code like:
<pre>
// Restrict fun &lt;T : Comparable&lt;T>> </b>sort() to List elements 
// i.e., only to elements compatibles with <b orange>Collections.sort(...)</b>

fun &lt;T : Comparable&lt;T>> <b>List&lt;T>.</b>sort() {
   Collections.sort(this)
}
</pre>
  </li>
  <li>Infix functions allows to convert
<pre>
<b orange>hasPrivilege</b>(<b brown>it</b>, WRITE) 
</pre>
   into
<pre>
/* human friendly "subject" + verb + "predicate" */
<b brown>it</b> <b orange>hasPrivilege</b> WRITE  
</pre>
  </li>
  <li>Code like
<pre>
lock(myLock, <b orange>{...}</b>)
</pre>
    can be written like (last <b orange>funct.literal</b> can be put outside the parenthesis):
<pre>
lock(myLock) , <b orange>{...}</b>
</pre>
  </li>
  <li>Another convention: If a function with only one parameter is expected,
    the parameter declaration may be omitted, and the default name "it" will be used. 
    Code like 
<pre>
filter {<span style="text-decoration:line-through">it =></span> it.foo()}
</pre>
    can be "shortcuted" to:
<pre>
filter {it.foo()}
</pre>
  </li>
  </ul>

  Legitimate Kotlin code (HTML DSL):
<pre xxxsmall zoom>
import com.example.html.* // see declarations below

fun result(args: Array<String>) =
  html /* 1 */ {
    /*<b blue>this. HTML instance</b>*/ head {
        title {+"XML encoding with Kotlin"}
    }
    /*<b blue>this. HTML instance</b>*/ body {
      h1 {+"XML encoding with Kotlin"}
      p  {+"this format can be used as an alternative markup to XML"}

      // an element with attributes and text content
      a(href = "http://kotlinlang.org") {+"Kotlin"}

      // mixed content
      p {
        +"This is some"
        b {+"mixed"}
        +"text. For more see the"
        a(href = "http://kotlinlang.org") {+"Kotlin"}
        +"project"
      }
      p {+"some text"}

      // content generated by
      p {
        for (arg in args)
          +arg
      }
    }
  }

/* 1 call to html function defined as: */
fun html(<b orange>init</b>: HTML.() -> Unit): HTML {
    val <b blue>htmlInstance = HTML()</b> // init reciever 
    htmlInstance.<b orange>init</b>()
    return htmlInstance
}

protected fun &lt;T : Element> initTag(<b green>tagInstance</b>: T, <b orange>init</b>: T.() -> Unit): T {
    <b green>tagInstance</b>.<b orange>init</b>()
    /*<b blue>this. parent Tag instance</b>*/.add(<b green>tagInstance</b>)
    return <b green>tagInstance</b>
}

fun head(<b orange>init</b>: Head.() -> Unit)  = initTag(Head(), <b orange>init</b>)
fun body(<b orange>init</b>: Body.() -> Unit)  = initTag(Body(), <b orange>init</b>)

operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
</pre>
</td>
</tr }>
</table>
</body>
<!--
***** The open annotation on a class is the opposite of Java's final:
 it allows others to inherit from this class. By default, all classes
 in Kotlin are final, which corresponds to Effective Java, Item 17:
  Design and document for inheritance or else prohibit it. ****
open class Base          {           open fun v() {} } // if not open => final
class Derived() : Base() { final override fun v() {} } // by default override is also open


======================================================
Object expressions and declarations
generalization of anonymous inner classes:
Ej1:
  window.addMouseListener( object : MouseListenerBaseClase(baseClassConstructorParam1,...) 
    { // object is an instance of an anonymous class inheriting from base listener class
      override fun onMouseClicked(e: MouseEvent) { ... }
      ...
    })
Ej 2:
  interface B {...}
  val ab: A = object : A(1), B { override ...  }
----------- Object singletons --------------------------
Object singletons or object declaration, always has a name following the object keyword. Just
like a variable declaration, an object declaration is not an expression, and cannot be used
on the right hand side of an assignment statement.
  object DataProviderManager {
      fun registerDataProvider(provider: DataProvider) {
          // ...
      }
  
      val allDataProviders: Collection<DataProvider>
          get() = // ...
  }
  DataProviderManager.registerDataProvider(...)
===== Delegation =====
A class "Derived" can inherit from an interface <IBase> and delegate all of its public methods
to a specified object:
Ex:
   interface IBase { fun print() }

   class BaseImpl(val x: Int) : IBase { override fun print() { print(x) } }

   // b will be stored internally in objects of Derived and the compiler will
   // generate all the methods of IBase that forward to b
   class Derived(b: IBase) : IBase by b 

   fun main (args: Array<String>) {
      val b = BaseImpl(10)
      Derived(b).print() // prints 10
   }
</pre } >

-->

<!--
  Multiplatform Native Development In Kotlin
https://blog.kotlin-academy.com/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec


https://www.infoworld.com/article/3224868/java/what-is-kotlin-the-java-alternative-explained.html#tk.ifw-infsb

https://www.infoworld.com/article/3236419/development-tools/kotlin-frameworks-a-survey-of-jvm-development-tools.html#tk.ifw-infsb

-->

<!--
TODO: Lazy property:
  val p: String by lazy { // compute the string }

__________________________
TODO: If you need to write a function that can be called without having a class instance
but needs access to the internals of a class (for example, a factory method), you
can write it as a member of an object declaration
(https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.
Even more specifically, if you declare a companion object 
(https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) 
inside your class, you'll be able to call its members with the same syntax as calling
static methods in Java/C#, using only the class name as a qualifier.
____________________________
Use Kotlin with npm, webpack and react:
  https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/
____________________________
<span xbig>// Checking ranges:</span>
<pre { >
if (x in 1...y+1) { println("OK") } 

for (x in 1..10       step 2) { print(x) }
for (x in 10 downTo 0 step 2) { print(x) }
for (idx          in array.indices)     { println(array[idx])       }
for ((idx, value) in array.withIndex()) { println("$idx -> $value") }
for ((key, value) in map              ) { println("$key -> $value") }
fruits.filter { it.startsWith("a") }.sortedBy { it }.
    map { it.toUpperCase() }.forEeach( println(it) )

val arrayOfMinusOnes: Array = IntArray(20).apply{fill(-1)} // 
</pre } >

____________________________
<pre { >
fun foo() {
  // Alt 1. lambda function
  ints.forEach lit@ {
    // returns from foo
    if (it == 0) return
    // returns from lambda lit@
    if (it == 1) return@lit
    // returns from lambda lit@ (implicit label)
    if (it == 2) return@forEach
    print(it)
  }
  // Alt 2. anonymous function
  ints.forEach( func(value: Int) {
    // local returns from  anonymous funct
    if (it == 0) return
    print(value)
  }
}
_______________________
mainLoop@ for (i in 1..100) { // <- any expresion can be marked with a  label ("identifier"@)
  for (j in 1..100) {
    if (j == 55) break@loop // jumps right after the loop marked with label
  }
}
</pre }>


-->
<!--
<ul>
<li><a href="http://kotlinlang.org/api/latest/kotlin.test/index.html">kotlin.test</a>, included out of the box in Kotlin 1.2, lets you write your test once and run it under both the JVM and JS;</li>
<li><a href="https://github.com/kotlin/kotlinx.html">kotlinx.html</a> supports <strong>isomorphic rendering</strong> – using the same code to render HTML in the backend and in the frontend;</li>
<li><a href="https://github.com/kotlin/kotlinx.serialization">kotlinx.serialization</a> allows you to easily marshal Kotlin objects between different tiers of your application, using JSON or ProtoBuf as serialization formats.</li>
</ul>

What's new in Koltin 1.2:
http://kotlinlang.org/docs/reference/whatsnew12.html

____________________
Warnings as errors

The compiler now provides an option to treat all warnings as errors. Use -Werror on the command line, or the following Gradle snippet:

compileKotlin {
    kotlinOptions.allWarningsAsErrors = true
}
__________________________
https://kotlinlang.org/docs/reference/native-overview.html

https://github.com/JetBrains/kotlin-native/blob/master/samples/tensorflow/src/main/kotlin/HelloTensorflow.kt


__________________________

Koltin Coroutines:
  https://kotlinlang.org/docs/reference/coroutines.html
Many asynchronous mechanisms available in other languages can be implemented as libraries using Kotlin coroutines. This includes async/await from C# and ECMAScript, channels and select from Go, and generators/yield from C# and Python. See the description below for libraries providing such constructs.

vs Java Fibers: (fast threads for java)
  - http://docs.paralleluniverse.co/quasar/


Design documents and examples for coroutines in Kotlin
  https://github.com/Kotlin/kotlin-coroutines
__________________
https://kotlin.es/2015/11/kotlin-koans-repositorio-de-ejercicios-oficiales/#
<p>###Introduction [13/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#hello-world" target="_blank" rel="noopener">Hello World!</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#java-to-kotlin-conversion" target="_blank" rel="noopener">Java to Kotlin conversion</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#named-arguments" target="_blank" rel="noopener">Named arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#default-arguments" target="_blank" rel="noopener">Default arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lambdas" target="_blank" rel="noopener">Lambdas</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#strings" target="_blank" rel="noopener">Strings</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#data-classes" target="_blank" rel="noopener">Data classes</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#nullable-types" target="_blank" rel="noopener">Nullable types</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#smart-casts" target="_blank" rel="noopener">Smart casts</a> &lt;? Nivel 1</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-functions" target="_blank" rel="noopener">Extension functions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#object-expressions" target="_blank" rel="noopener">Object expressions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sam-conversions" target="_blank" rel="noopener">SAM conversions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extensions-on-collections" target="_blank" rel="noopener">Extensions on collections</a></li>
</ul>
<p>###Collections [25/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#introduction" target="_blank" rel="noopener">Introduction</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#filter-map" target="_blank" rel="noopener">Filter map</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#all,any,count,firstornull" target="_blank" rel="noopener">All, Any, Count, FirstOrNull</a> &lt;? Nivel 2</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#flatmap" target="_blank" rel="noopener">FlatMap</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#maxmin" target="_blank" rel="noopener">Max min</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sort" target="_blank" rel="noopener">Sort</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sum" target="_blank" rel="noopener">Sum</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#group-by" target="_blank" rel="noopener">Group by</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#partition" target="_blank" rel="noopener">Partition</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#fold" target="_blank" rel="noopener">Fold</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#compoundtasks" target="_blank" rel="noopener">Compound tasks</a> &lt;? Nivel 3</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#getusedtonewstyle" target="_blank" rel="noopener">Get used to new style</a></li>
</ul>
<p>###Conventions [32/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#comparison" target="_blank" rel="noopener">Comparison</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#in-range" target="_blank" rel="noopener">In range</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#range-to" target="_blank" rel="noopener">Range to</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#for-loop" target="_blank" rel="noopener">For loop</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#operators-overloading" target="_blank" rel="noopener">Operators overloading</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#multi-assignment" target="_blank" rel="noopener">Multi assignment</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#invoke" target="_blank" rel="noopener">Invoke</a> &lt;? Nivel 4</li>
</ul>
<p>###Properties [36/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#properties" target="_blank" rel="noopener">Properties</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lazy-property" target="_blank" rel="noopener">Lazy property</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delgates-examples" target="_blank" rel="noopener">Delegates examples</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delegates-how-it-works" target="_blank" rel="noopener">Delegates how it works</a></li>
</ul>
<p>###Builders [41/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-function-literals" target="_blank" rel="noopener">Extension function literals</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#string-and-map-builders" target="_blank" rel="noopener">String and map builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#the-function-with" target="_blank" rel="noopener">The function with</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#html-builders" target="_blank" rel="noopener">Html builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#builders-how-it-works" target="_blank" rel="noopener">Builders how it works</a>
______________
https://gist.github.com/dodyg/5823184
______________
https://www.infoq.com/news/2018/03/jetbrains-releases-kotlin-1.2.30

JetBrains recently released version 1.2.30 of their popular programming language, Kotlin, as a bug fix and tooling update that comes about a month-and-a-half after the release of version 1.2.20. New features include:

    New function, suspend, for coroutines.
    Support for Gradle's build cache tool.
    IDE support for the new Kotlin style guide.
    New inspections, performance improvements, and bug fixes in the IntelliJ plug-in.
    Support for TestNG in kotlin.test.

All new features and enhancements are supported in IntelliJ IDEA versions 2017.1 through 2017.3 and 2018.1 EAP, along with Android Studio 3.0. We highlight some of these enhancements here.

Multiplatform Projects
Kotlin Multiplatform Projects, introduced in November 2017 with the release of version 1.2, can compile the same codebase to multiple target platforms which, at this time, are the JVM and JavaScript.

As described on the website:
  A multiplatform project allows you to build multiple tiers of your application:
backend, frontend and Android app from the same codebase.
  Such a project contains both common modules, which contain platform-independent code,
as well as platform-specific modules, which contain code for a specific platform
(JVM or JS) and can use platform-specific libraries. To call platform-specific code
from a common module, you can specify expected declarations for
which all platform-specific modules need to provide actual implementations.
______________________
https://dzone.com/articles/kotlin-dsl-from-theory-to-practice
____________________
Scripting enhancements for Kotlin
    https://github.com/holgerbrandl/kscript
________________________
https://kotlinlang.org/docs/reference/kapt.html
    Annotation Processing with Kotlin

    Annotation processors (see JSR 269) are supported in Kotlin with the kapt compiler plugin.
    Being short, you can use libraries such as Dagger or Data Binding in your Kotlin projects.
__________________________
org.jetbrains.kotlin artifacts at Maven Central:
   https://search.maven.org/#search%7Cga%7C3%7Corg.jetbrains.kotlin
_________________________
https://kotlinlang.org/docs/reference/reflection.html
-->
</html>
