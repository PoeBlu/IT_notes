<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Kotlin map(v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<br/>
<table style='width:100%'{>
<tbody>
<tr {>
<td>
  External Links:
  <ul xxxsmall zoom >
  <li><a href="https://kotlinlang.org/docs/reference/">Reference@Kotlinlang.org</a></li>
  <li><a href="https://kotlinlang.org/docs/resources.html">More resources</li>
  <li><a href="https://try.kotlinlang.org/#">On-line IDE</a></li>
  <li><a href="https://blog.kotlin-academy.com/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec">Multiplatform Native Development In Kotlin</a></li>
  <li><a href="https://www.infoworld.com/article/3236419/development-tools/kotlin-frameworks-a-survey-of-jvm-development-tools.html#tk.ifw-infsb">Kotlin Frameworks survey</a></li>
  <li><a href="https://search.maven.org/#search%7Cga%7C3%7Corg.jetbrains.kotlin">org.jetbrains.kotlin artifacts at Maven Central</a></li>
  <li><a href="https://kotlinlang.org/docs/reference/kapt.html">Annotation Processing with Kotlin</a>:
    Annotation processors (see JSR 269) are supported in Kotlin with the kapt 
    compiler plugin. Being short, you can use libraries such as Dagger or Data 
    Binding in your Kotlin projects.</li>
  <li><a href="https://github.com/Kotlin/kotlin-koans/tree/master/src">Kotlin Koans Excercises (Basic, Collections, conventions, properties, builders, generics)</a></li>
<!--
  <li><a href="XXX">XXX</a></li>
--> 
  </ul>

  Everything is an expresion
<pre xxsmall zoom { >
// "if" are expresions and the last 
// expression is the value of the "if"-block:
val max = if (a &bt; b) {
    print("a Wins "); a 
} else {
    print("b Wins "); b 
}
</pre }>
  Immutable values and inferred types
<pre xxsmall zoom { >
// Immediate inmutable assignment
val a: Int  = 1

// Inferred Int type (var mutable)
var count  = 5;
    count += 1;
</pre } >

  Python like import-as
<pre xxsmall zoom { >
import bar.Bar as bBar
</pre } >

  Check types at runtime ('is')
<pre xxsmall zoom { >
fun getStringLenght(obj: Any) {
  if (obj  is String) {...} 
  if (obj !is String) {...}
}
</pre } >

  Equality
<pre xxsmall zoom {>
   val a = Class(param1, param2)
   val b = Class(param1, param2)
   a === b // returns false
   a == b  // returns true
</pre }>
</td>  
<td colsep></td>  
<td>
  <b>utility functions</b><br/>
  (standard functions, no import required)<br/>
  <code orange>Apply</code><br/>
  helping funct. to init. objects:
<pre xxsmall zoom {>
// applies lambda to object and 
// returns same object
val task = Runnable { println("Running") }
Thread(task)<b>.apply</b> {
  setDaemon(true) }.start()
</pre }>

  <code orange>'with'</code> to avoid repeated typing:
<pre xxsmall zoom {>
  class Turtle {
      turn(degrees: Double)
      forward(pixels: Double)
      ...
  }
  val myTurtle = Turtle()
  with(myTurtle) {
    penDown() ;
    for(i in 1..4) { 
      forward(100.0) ; turn(90.0) 
    }
  }
</pre }>
  <code orange>Run</code> extension function.

  <ul xxxsmall zoom>
  <li>A closure is passed to run, which has the instance 
    as the receiver. The return value of the closure is used as the return value of run itself:
<pre>
val outputPath = Paths.get("/user/home").run {
  val path = resolve("output")
  path.toFile().createNewFile()
  path
}
</pre>
  </li>
  </ul>
</td>
<td>
  <code orange>Lazy</code>
  <ul xxxsmall zoom>
  <li>wraps an expensive function call to be invoked when first required:
<pre>
// expensive operation
fun readStringFromDatabase(): String = ... 
val lazyString = lazy { readStringFromDatabase() }
</pre>
  </li>
  </ul>


  <code orange>Use</code> (Java try-catch-with-resources)
<pre xxxsmall zoom {>
val stream = Files.newInputStream(
    Paths.get("/some/file.txt"))
stream.buffered().
  reader()<b>.use</b> {
  reader -> 
    println(reader.readText()) 
}
</pre }>
  <code orange>Repeat</code>: Avoid "for" for simple operations:
<pre xxxsmall zoom{>
repeat(10, { println("Hello") })
</pre }>
<!-- TODO:
   Let
-->
  <b orange>Sequences</b> (Java Streams)<br/>
  Sequences are collections of unknown size
<pre xxxsmall zoom { >
val charSequence: Sequence<Char> =
  charArrayOf('a','b','c').asSequence()  //a,b,
val s1 : String  = charSequence.joinToString(",")
</pre>

  <b orange>Sequence generator</b>
<pre xxsmall zoom { >
// NOTE: compared to collections, sequences
//     <b orange>do NOT intermediate waste memory</b>
var count = 10
val sequence = 
  generateSequence {
    (count--).takeIf { it &gt; 0 } 
}
</pre>
   <code orange>Require/assert/check</code>
<pre xxxsmall zoom {>
fun neverEmpty(str: String) {
  require(str.length > 0,
    { "String should not be empty" })
  println(str)
}
</pre }>

</td>  
<td colsep></td>  
<td>  
  <b orange>Basic Types</b>
<pre xxsmall zoom { >
Long/Int/Short/Byte(64,32,16,8)
Boolean 
Chars
  val c: Char = '\uFF00' //  'a', '\b'
Strings
Arrays

<b>explicit Chart to Int conversion</b>
// alt: '0'..'9'.contains(c)
if (c in '0'..'9')  
  c.toInt() - '0'.toInt() 
else
  throw RuntimeException("...")

  <b orange>bitwise operations</b>
val x = (1 shl 2) and 0x00FF
// (u)shl/(u)shr) bits:
//     (un)signed shift left/righ
// and/or/xor bits 
// inv()               :bitwise inversion

  <b orange>special optimized arrays</b>
// (Byte|Short|Int|...)Array
</pre }>
  <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/">Regex</a>s<br/>
<pre xxxsmall zoom>
// Matching and finding the groups in Kotlin:

val pattern = <b>Regex</b>("[a-zA-Z]+([0-9]+)[a-zA-Z]+([0-9]+)[a-zA-Z]+")
val inputString = "ABcDEFG12345DiFKGLSG938SDsFSd"

val matchGroups = pattern.matchEntire(inputString)?.groupValues
while (matchGroups.find()) println(matchGroups.group())
</pre>
  <hr/>
  <b orange>Avoiding nulls</b>
  <a href="https://kotlinlang.org/docs/reference/null-safety.html">docs/ref</a><br/>
  <ul xxxsmall zoom>
  <li>nullables must be declared explicetelly</li>
  <li>
<pre>
val nullableBob : String? = "abc"
nullableInstance<b>?</b>.department<b>?</b>.head<b>?</b>.name 
^_______________^___________^_____^
Returns null if nullableInstance,
 department or head is null

val listWithNulls: List<String?> = listOf("A", null)
for (item in listWithNulls) {
<b>/* "?.let" skips expression
 * block execution for nulls */</b>
  item<b>?.let</b> { println(it) }
}

<b>Filtering Nulls at list initialization
(Fix-fast)</b>
val intList: List<Int> =
  listOf(1, 2, null, 4)
  <b>.filterNotNull()</b>

<b>
/* Assigning nullable to non-nullable
 * requires if (..!=null) ... else ...*/</b>
val l: Int = <b>if (b != null)</b> b.length else -1
<b>or Elvis operator ?:</b>
val l = b?.length ?: -1

<b>Abort/throw NullPointerE. if null present</b>
  val name = node.getName()!!

<b>SmartCast</b>
fun getName(): String? = ...
val name = getName()
if (name != null) {
  // here compiler knows name is not null
  println(name.length)
}
</pre>
  </li>
  </ul>
  <b orange>Type alias</b>
  <ul xxxsmall zoom>
  <li>Rename type with alias.  The alias is simply replaced by the compiler. 
    This means that new types are not created or allocated, so we suffer no performance penalty. <br/>
    typealias do <b>NOT</b> increase type safety.</li>
  <li>
<pre {>
typealias Cache = HashMap<String, Boolean>
typealias Address = String
typealias FamilyName = String
</pre }>
  </li>
  </ul>


</td>
<td>
    <code orange>when(extended switch-case)</code>

<pre xxsmall zoom {>
fun describe(obj: Any = 1) :
    String = when(obj) {
  1            -&gt; "One" 
  "Hello"      -&gt; "Greeting" 
  is Long      -&gt; "Long"
  in 32...128  -&gt; "Is ASCII"
  !is String   -&gt; "Not a string"
  "dog" in obj -&gt; "Animal list"
  else         -&gt; "Unknown"
}
</pre }>
  <code orange>try/catch as expresion</code> returning values
<pre xxsmall zoom {>
  val result = 
    try { count() } 
    catch (e: ArithmeticException) {
      throw RuntimeException(e) 
    }
</pre }>

  <b orange>Ranges</b>: Interval with start and end value. Any comparable type can be used.
<pre xxsmall zoom {>
val aToZ = "a"<b>..</b>"z" // "c" in aToZ == true
val countingDown = 100.downTo(0)
val ten20 = 10.rangeTo(20).step(2)
</pre }>
</td>  
</tr>
</table>
<table>
<tr>
<td>
  <b orange>String template</b>
<pre xxsmall zoom { >
val a  = 23
val s1 = "Hello World <b>$a</b>!"
println(s1)
</pre } >

  <b orange>String Expresions</b>
<pre xxsmall zoom  { >
"col1: <b>${</b>s1.replace("A", "B")<b>}</b> $d"
</pre } >

  <b orange>Multiline string with margin</b>
<pre xxsmall zoom { >
  val myMultiLineString = """
<b>    |</b> for (c in "foo")
<b>    |</b>     print(c)
<b>    |</b> Dolar is writen as ${'$'}
  """.<b>trimMargin()</b> // remove leading spaces.
  print(myMultiLineString)
</pre }>
</td>
<td colsep></td>
<td>
  <b orange>Init. array,map,list,...</b>
<pre xxsmall zoom { >
val array1 : Array<String> = <b>arrayOf</b>("asdf","ADF")
val emptyStringArray = arrayOf<String>()
val intArray = arrayOf(1,2,3)
val doubleList : List<Double>= arrayListOf(84.88, ...)
var nonNulls: List<String> = 
                  listOfNotNull<String>{null, "a",...}
val map1 = mapOf("a" to 1, "b" to 2)
val map2 = mapOf(Pair("a", 1), Pair("b", 2))
println(map1) // Prints [1, 2]

val intSet: Set<Int> = setOf(1, 2, 1,..)    
val hashSet: java.util.HashSet<Book> = 
    hashSetOf(Book(...), Book(...)
val longSet: MutableSet<Long> = mutableSetOf( 1, 2, 3)

val readWriteList: MutableList<String> =
                      mutableListOf(...)
val readOnlyView : List<String> = readWriteList

// array-lambda-init
val squaredArray: Array = 
    Array(5, <b>{ idx -> (idx * idx).toString() }</b>)
</pre>
</td>
<td>
  <b orange>Walk-over/iterate</b>
<pre xxsmall zoom>
// iterate through elements
// Alt 1:
sequence.<b>forEach</b> { it*it }

// Alt 2:
for (<b>item in</b> myArrayOrList) println("${item}")

// "walk" by index 
for (<b>idx  in intList.indices</b>)
  println("$idx is ${intList[idx]}")
</pre>
  <b orange>spread array</b>
<pre xxsmall zoom >
val    a = asList(1, 2, 3)
val list = asList(-1, 1, <b>*a</b> /*spread*/, 4)  
</pre>
  <b orange>Filtering a list</b>
<pre xxsmall zoom >
val positives = list<b>.filter</b> { x -&gt; x &gt; 0 }
// even shorter: (using default "it")
val positives = list.filter { it &gt; 0 }
</pre } >
</td>  
<td colsep></td>
<td>
  <b orange>Interfaces</b>
<pre xxsmall zoom {>
interface MyInterface {
    val prop1: Int 
    val prop2: String
        <b>get() = "foo"</b> // default accessor
    fun bar(): Int
    // default implementation
    fun foo() { print(prop)  } 
    fun foo() { }
}

class Child : MyInterface {
  override val prop: Int = 29
}
</pre }>
  <b orange>Single method Iface pattern</b>
  <ul xxxsmall zoom>
  <li>
  (An interface with a single method: Runnable, Callable, Closeable, Comparator, ...).<br/>
  Kotlin has support for converting a function literal directly
  into a SAM. If the conversion is unambiguous, you can simply pass the function literal
  where a SAM is expected:
<pre xxsmall zoom { >
val threadPool = Executors.newFixedThreadPool(4)
threadPool.submit {
  <b>println("...")</b> 
}
// The kotlin compiler will convert this code to:
threadPool.submit(<b>object : Runnable {
  override fun run() {
    println("I don't have a lot of work to do")
  }
}</b>)
</pre }>
  </li>
  </ul>
</td>

</tr }>
</table>
<table>
<tr {>
<td>
  <b xbig blue>Functions</b><a href="https://kotlinlang.org/docs/reference/functions.html">(ref)</a>
<pre xxxsmall zoom { >
data class Coordinate(val x: Int, val y: Int)

fun getPoint
   (a: Int, b: Int <b>= 1 /*def.val*/</b>, <b>vararg</b> names: String) : Coordinate {   
  return Coordinate(a+b,a-b)
}                                
// "shortcut"
fun getPoint(a: Int, b: Int = 1) <b>= Coordinate(a+b,a-b)</b>
// ussage, split vl
val (x, y) = getPoint(1,2)
// Using named parameters
val (x, y) = getPoint(a = 1, b = 2)

<b>Generic Functions</b>
// &lt;T&gt; is specified before the fun. name
fun <T> singletonList(item: T): 
  List<T> {
    // ...
}
</a>
<b>Tail recursive</b>
// <b>Compiler optimises out the recursion!!!</b>
// - function must call itself as last operation)
// - doesn't work  within try/catch.
// - only supported in JVM (currently)
tailrec 
fun findFixPoint(x: Double = 1.0): Double
  = if (x == Math.cos(x)) x 
    else findFixPoint(Math.cos(x))

<a orange href="https://kotlinlang.org/docs/reference/inline-functions.html">Inline functions</a>
inline 
  fun lock(param1: Class1, ...) :
  ReturnClass {
}
</pre } >

<b>(Class)Extension Functions</b>
<pre xxxsmall zoom { >
fun <b orange>String.</b>spaceToCamelCase()
    String { ... }
(String. == Applies only to String objects)
Ussage:
"to camelcase".spaceToCamelCase()
23424.spaceToCammelCase() // Compiler error
</pre } >

<b>Functions receivers</b>
<pre xxxsmall zoom { >
/* 
 * Very similar to extension functions but applies to func. literals.
 * that is, to variables representing functions.
 */
// Definition:
val countChars: <b orange>String.</b>() -&gt; Unit = { println("Counted chars: ${length}") }
// Ussage:
val txt = "ASDF"
countChars(<b orange>txt</b>)
</pre }>

<b>Infix Member Functions</b>
<pre xxxsmall zoom { >
class Account {
  var balance = 0.0
  <b>infix</b> fun add(amount:Double): Unit {
     this.balance = balance + amount
  }
}
accountInstance add 100.00

<b>Operator Overloading</b>
Allowed for 
class     |
Operation | Function name
a + b     | plus()
a – b     | minus()
A * b     | times()
A / b     | div()
A &amp; b     | mod()
a..b      | rangeTo()
+a        | unaryPlus()
-a        | unaryMinus()
!a        | not()
[p1,p2,..]| operator fun get(param1, param2,...)
&lt; &lt;=      | compareTo
&gt; &gt;=      |
-------------------------
()        | operator func invoke():
</pre }>

<pre TODO hidden {>
// <- instance 'space':'space' => type <-> supertype
interface Foo<out T : Any> : Bar {
// <- instance: => instance <-> type
    fun foo(a: Int): T 
}
</pre }>
  <b orange>High Order Functs</b></a>
<pre xxxsmall zoom {>
<b>Function receiving a function</b>
fun foo(name: String, <b>paramFunc: (String) -> String</b>): Unit {
  val applied = paramFunc(name)
  println(applied)
}
foo("hello", <b>paramFunc = { it.reversed() }</b>)


<b>Function returning a function</b>
fun bar() :
   <b>(String) -> String = { str -> str.reversed() }</b>

<b>Closures</b>
fun students(nameToMatch: String): List<Student> {
  return loadStudents().filter <b>{
    // closure has access to parent stack
    it.lastName == nameToMatch
  }</b>
}

<b>Currying functions</b><br/>
<span TODO>TODO</span>

<b>Memoization (Avoid repeated long-running calculus)</b>
fun Function1<b>.memoized()</b>: (String) -> MyClass {
  val map = ConcurrentHashMap<String, MyClass>()
  return {
    a -> map.getOrPut(a) {
      this.invoke(a)
    }
  }
}
</pre }>
</td>
<td colsep></td>
<td>
  <b orange>Classes<a href="https://kotlinlang.org/docs/reference/classes.html">(REF)</a></b><br/>
  <ul xxxsmall zoom>
  <li><code orange>"Any"</code> (common superclass in Kotlin) is <b>NOT</b> java.lang.Object; 
  it does not have any members other than equals(), hashCode() and toString().
</li>
  <li>By default classses are final. Use <code>open class ...</code> to make non-final</li>
  </ul>
  <b orange>Composition over inheritance</b>
  <ul xxxsmall zoom>
  <li>sometimes called delegation, where delegation is actually the dessign pattern 
      and composition the standard/easiest way to implement it.</li>
  <li>REF1:"Efective Java"</li>
  <li>REF2:<a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin doc ref</a><li/>
  <li>Note: foreign keys in SQL is the best well known form of composition:
<pre xxsmall zoom { >
employee      person     client
--------      -------    ------
id      ←─┐┌─→ id   ←─┐  id
roll      ││   name   └─ fk_person
fk_person ─┘   ...    ┌─ fk_saleManager
...       └───────────┘   ...
</pre } >
   </li>
   </ul>
   <b orange>Composition</b>
<pre xxxsmall zoom {>                
interface IPerson { fun print() ... }

class Person(val name: String, val familyName1: ...) : IPerson {
  override fun print() { print(x) }
}

class Employee(b: IPerson) : IPerson <b orange>by</b> b

fun main(args: Array&lt;String&gt;) {
    val pacoMA = Person(
             surname:"Paco", name1: "Martinez", ... )
    val employee = Employee(
                     <b>person: <b>pacoMA</b>,
                     roll: manager,
                     ... )
    employee<b orange>.print()</b> /* == myClass.base.print() */
}
</pre>
  <b orange>Inheritance (discouraged)</b>
<pre xxxsmall zoom>
class Derived(p: Int) <b orange>:</b> Base(p)

class Container(
  id     : Int, 
  size   : Int,
  childs : Containers
) : SuperClass(id, name),
  Iface1, Iface2, Iface3 {
  var person_id = id
  <b orange>// custom accesor</b>
  val isEmpty: Boolean 
      <b orange>get() = this.size == 0 
             || (var sum = 0; for (c in childs) sum+=c.size) == 0  </b>
  val stringRepr : String
      <b>get() = this.toString()</b>
      <b>set(value) = _setFromString(value)</b>
  // ...

  <b>companion object</b> Factory : FactoryTemplate<MyClass> { // <- object name ('Factory') can be ommited
    override fun create(): Container = Container(...)
  }
  }
  val instance = MyClass.create()
}
</pre>
</td>
<td>
  <b orange>Singletons Syntax</b>
<pre xxxsmall zoom>
<b orange>object</b> Resource {
  val name = "Name"
  fun method1(...) {
          // ...
  }
}
Resource.method1(...)
</pre } >
   <b orange>Compaq class declaration</b>
<pre xxxsmall zoom { >
// use val or var:       | <b orange>constructor</b> keyword optional if no 
class Person(            | annotations and default visibility  applies
  val firstName: String, | class Customer 
  val lastName: String,  |   public @Inject <b orange>constructor</b>(
  var age: Int) {        |     val name: String = "") 
  ...                    | { 
}                        |     ...
                         |     init { // 'init' marks an initializer block
                         |         logger.info("initialized with ${name}")
                         |     }
                         |     /* (Secondary) */
                         |     constructor(parent: Person) {
                         |       parent.children.add(this)
                         |   }
                         | }
</pre }>

  <b xorange>data class (DTO)</b>
<pre xxxsmall zoom { >
<span comment>automatically generates:
- getters (and setters for vars),
- equals(), hashCode(), toString(), copy()
- component1(),… for all properties 
</span>
<b orange>data</b> class Customer(
  val name  : String,  // val: inmutable
  val email : String, // val: inmutable
  var refNum: Int )    // var:   mutable 
<span gray> /* optional class member functions */ 
{
  override fun toString() : String {
    return "(${refNum} : ${name} &lt;${email}&gt;)"
  }
}</span>
</pre } >

  <b orange>Sealed Classes</b> <a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Ref</a> </br>
  <ul xxxsmall zoom>
  <li>represent restricted class hierarchies or "sort of" enum extensions,
    with subclasses being able to have multiple instances</li>
  <li>(sealed class/subclasses must be declared in the same file)
<pre>
Declaration:
<b>sealed</b> class Expr
data class Const(val number: Double)      <b>: Expr()</b>
data class Sum(val e1: Expr, val e2: Expr)<b>: Expr()</b>
object /*singleton*/ NotANumber <b>: Expr()</b>

Ussage:
fun eval(expr: <b>Expr</b>): Double =
  when(expr) {
  is <b>Const</b>      -&gt; expr.number
  is <b>Sum</b>        -&gt; eval(expr.e1) + eval(expr.e2)
     <b>NotANumber</b> -&gt; Double.NaN
}
</pre>
  </li>
  </ul>
  Inner class
<pre xxxsmall zoom>
Object expressions are a generalization of anonymous inner classes:
// Ex1:
window.addMouseListener( 
  <b orange>object : ListenerBase</b>(
    baseClassConstructorParam1,
    ...) {
      override fun onMouseClicked(e: MouseEvent) { ... }
    })
// Ex2:
interface B {...}
val ab: A = object : A(1), B { override ...  }
</td>
<td colsep></td>
<td>
  <b orange>DSL</b>
  <a xxsmall href="https://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/">REF</a>,
<a xxsmall href="https://kotlinlang.org/docs/reference/type-safe-builders.html">REF 2</a> <br/>
  Examples
  <ul xxxsmall zoom>
  <li><a href="https://github.com/Kotlin/kotlinx.html">Kotlin DSL for HTML</a></li>
  <li><a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts">Programatically generate layouts</a></li>
  <li><a href="https://ktor.io/features/routing.html#routing-tree">Defining (Web server) routing trees</a></li>


  </ul>
  Syntactic sugar
  <ul xxxsmall zoom>
  <li>Allow to conver code like:
<pre>
Collection.sort(<b>list</b>);
int index = Collection.binarySearch(<b>list</b>,x);
</pre>
    into 
<pre>
<b>list</b>.sort();
int index = <b>list</b>.binarySearch(x);
</pre>
  providing IDE autocompletion by just writing an object instance. (No need to be aware of Collection object)
  </li>
  <li>All that needed is code like:
<pre>
// Restrict fun &lt;T : Comparable&lt;T>> </b>sort() to List elements 
// i.e., only to elements compatibles with <b orange>Collections.sort(...)</b>

fun &lt;T : Comparable&lt;T>> <b>List&lt;T>.</b>sort() {
   Collections.sort(this)
}
</pre>
  </li>
  <li>Infix functions allows to convert
<pre>
<b orange>hasPrivilege</b>(<b brown>it</b>, WRITE) 
</pre>
   into
<pre>
/* human friendly "subject" + verb + "predicate" */
<b brown>it</b> <b orange>hasPrivilege</b> WRITE  
</pre>
  </li>
  <li>Code like
<pre>
lock(myLock, <b orange>{...}</b>)
</pre>
    can be written like (last <b orange>funct.literal</b> can be put outside the parenthesis):
<pre>
lock(myLock) , <b orange>{...}</b>
</pre>
  </li>
  <li>Another convention: If a function with only one parameter is expected,
    the parameter declaration may be omitted, and the default name "it" will be used. 
    Code like 
<pre>
filter {<span style="text-decoration:line-through">it =></span> it.foo()}
</pre>
    can be "shortcuted" to:
<pre>
filter {it.foo()}
</pre>
  </li>
  </ul>
</td>
<td>
  Legitimate Kotlin code (HTML DSL):
<pre xxxsmall zoom>
import com.example.html.* // see declarations below

fun result(args: Array<String>) =
  html /* 1 */ {
    /*<b blue>this. HTML instance</b>*/ head {
        title {+"XML encoding with Kotlin"}
    }
    /*<b blue>this. HTML instance</b>*/ body {
      h1 {+"XML encoding with Kotlin"}
      p  {+"this format can be used as an alternative markup to XML"}

      // an element with attributes and text content
      a(href = "http://kotlinlang.org") {+"Kotlin"}

      // mixed content
      p {
        +"This is some"
        b {+"mixed"}
        +"text. For more see the"
        a(href = "http://kotlinlang.org") {+"Kotlin"}
        +"project"
      }
      p {+"some text"}

      // content generated by
      p {
        for (arg in args)
          +arg
      }
    }
  }

/* 1 call to html function defined as: */
fun html(<b orange>init</b>: HTML.() -> Unit): HTML {
    val <b blue>htmlInstance = HTML()</b> // init reciever 
    htmlInstance.<b orange>init</b>()
    return htmlInstance
}

protected fun &lt;T : Element> initTag(<b green>tagInstance</b>: T, <b orange>init</b>: T.() -> Unit): T {
    <b green>tagInstance</b>.<b orange>init</b>()
    /*<b blue>this. parent Tag instance</b>*/.add(<b green>tagInstance</b>)
    return <b green>tagInstance</b>
}

fun head(<b orange>init</b>: Head.() -> Unit)  = initTag(Head(), <b orange>init</b>)
fun body(<b orange>init</b>: Body.() -> Unit)  = initTag(Body(), <b orange>init</b>)

operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
</pre>
</td>
</tr }>
</table>

<table>
<tr }>

<td>
  <a href="https://kotlinlang.org/docs/reference/coroutines.html">Coroutines(v.1.1+ experimental) </a>

  <ul xxxsmall zoom>
  <li>See also <a href="https://github.com/Kotlin/kotlin-coroutines">Design documents and examples for coroutines in Kotlin</a>, <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions">More info</a></li>
  <li>Basically, coroutines are computations that can be suspended without blocking a thread.<br/>
      Suspension can be controlled by a user library to a large extent deciding what happens upon suspension
      and optimize/log/intercept according to our needs.</li>
  <li>Compared to threads, coroutines can not be suspended at random instructions, but rather only at defined 
      suspension points, which are calls to specially marked functions
<pre>
// <b orange>suspend</b> marks the function as a suspension point
// can ONLY be called from coroutines and other suspending functions

<b orange>suspend</b> funs doSomething(foo: Foo): Bar {
    ...
}
</pre>
  </li>
  <li>To start a coroutine, there must be at least one suspending function,
    and it is usually a suspending lambda. Ex:
<pre>
// Ex.simplified async() function (from kotlinx.coroutines library):
fun <T> async(<b blue>block</b>:      suspend () -&gt; T)
//      ^                 +----------------+                  
//      +async() is a     lambda suspendable funct
//      regular function 

Ussage:
async {
    doSomething(foo)
    ...
}
</pre>
  </li>
  <li>Continuing with the analogy, await() can be a suspending function
     that suspends a coroutine until some computation is done and returns its 
     result:
</pre>
async {
    ...
    val result = computation.await()
    ...
}
</pre>
  </li>
  <li>Async blocking calls are expressed sequentially with coroutines, and the underlying 
   library will take care of any complexity (wrap relevant parts into callbacks, subscribing
   to relevant events, scheduling execution on different threads (or even different machines!)
  <li>Can be used to implement async mechanisms like async/await in C#/ECMAScript, channels/select in Go,
    and generators/yield in C#/Python</li>
  <li>Note that suspending functions await() and doSomething() cannot be called from function
literals that are not inlined into a suspending function body and from regular function like main():
<pre>
fun main(args: Array<String>) {
    doSomething() // ERROR: Suspending function called from a non-coroutine context 
    
    async { 
        ...
        computations.<b blue>forEach { 
            // `forEach` is an inline function, the lambda is inlined
            it.await() // OK
        }</b>
            
        <b red>thread {
            // `thread` is not an inline function, so the lambda is not inlined
            doSomething() // ERROR
        }</b>
    }
}
</pre>
  </li>
  <li>@RestrictsSuspension to prevent users from adding new ways of suspending a coroutine
<pre>
@RestrictsSuspension
public abstract class SequenceBuilder<in T> {
    ...
}
</pre>
     When a receiver class or interface R is annotated with it, all suspending extensions
   are required to delegate to either members of R or other extensions to it. 
   Since extensions can't delegate to each other indefinitely (the program would
   not terminate), this guarantees that all suspensions happen through calling 
   members of R that the author of the library can fully control.
  </li>
  </ul>

  Coroutines' inner workings
  <ul xxxsmall zoom>
  <li>Coroutines are completely implemented through a compilation technique 
    <b>(no support from the VM or OS side is required)</b>, and suspension
    works through code transformation. Briefly, every suspending function
    is transformed to a state machine where states correspond to suspending
    calls. Right before a suspension, the next state is stored in a field of
    a compiler-generated class along with relevant local variables, etc. 
    Upon resumption of that coroutine, local variables are restored and the 
    state machine proceeds from the state right after suspension.
  </li>
  <li>A suspended coroutine can be stored and passed around as an object 
    that keeps its suspended state and locals. The type of such objects is
    Continuation, and the overall code transformation described here corresponds to 
    the classical Continuation-passing style. Consequently, suspending functions
    take an extra parameter of type Continuation under the hood.</li>
  </ul>

 
  <code>buildSequence()(v.1.2.41+)</code>
  <ul xxxsmall zoom>
  <li>Implement generators, cheap way to build a lazy/on-demand sequence:
<pre>
// See also buildIterator(). Similarly to buildSequence() but returns a lazy iterator
val fibonacciSeq = buildSequence {
    var a = 0
    var b = 1
    yield(1)
    while (true) {
        yield(a + b)
        val tmp = a + b
        a = b
        b = tmp
    }
}

// Ex ussage:
fibonacciSeq.take(8).toList() // == [1, 1, 2, 3, 5, 8, 13, 21]
</pre>
  </li>
  <li>To yield a collection (or sequence) of values at once use yieldAll():
<pre>
val lazySeq = buildSequence {
    yield(0)
    yieldAll(1..10) 
}
</pre>
  </li>
  </ul>

  <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md"><code>kotlinx.coroutines</code></a>
  <ul xxxsmall zoom>
  <li>This mostly consists of core primitives and interfaces that all coroutine-based
    libraries are likely to use covering
    <ul>
    <li>Platform-agnostic asynchronous programming with kotlinx-coroutines-core,
      including Go-like channels that support select and other convenient
      primitives</li>
    <li>APIs based on CompletableFuture from JDK 8: kotlinx-coroutines-jdk8</li>
    <li>Non-blocking IO (NIO) based on APIs from JDK 7 and higher: kotlinx-coroutines-nio</li>
    <li>Support for Swing (kotlinx-coroutines-swing) and JavaFx (kotlinx-coroutines-javafx)</li>
    <li>Support for RxJava: kotlinx-coroutines-rx</li>
    </ul>
  </li>
  </ul>
</td>
<td>
  Ex. Micro-shell:
<pre xxxsmall zoom>
//  reads, tokenise and execute command

// https://discuss.kotlinlang.org/t/k2jvmcompiler/3629
private val REGEX_WHITESPACE_SEPARATED_TOKENS = Regex("[ \t]+")

// returns all tokens delimited by whitespace
private fun <b orange>parseLine</b>(shellInput : String) : List<String> =
    shellInput.split(REGEX_WHITESPACE_SEPARATED_TOKENS).filter { !it.isEmpty()}

private fun _command01(args : List<String>) = /* ... */ "OK"
private fun _command02(args : List<String>) = /* ... */ "OK"

private val USSAGE = """USSAGE EXAMPLES: ...""".trimMargin()

fun main(args: Array<String>) {
    <b orange>while (true) { // MAIN LOOP</b>
        print("~ ") // print shell prompt
        val lineTokens = parseLine(readLine() ?: continue)
        if (lineTokens.size == 0) continue
        val action = lineTokens[0]
        if ( action == "quit") break
        val args : List<String> = if (lineTokens.size == 0) listOf() else
            lineTokens.subList(1,lineTokens.size)

        val ouput : String = if (false) ""
            else if (action == "command01" &amp;&amp; args.size&gt;=1) _command01(args)
            else if (action == "command02" &amp;&amp; args.size&gt;=1) _command02(args)
            else USSAGE
        System.err.println(ouput)
    <b orange>}</b></b>
}
</pre>
  <a href="https://github.com/holgerbrandl/kscript">kscript</a>(Kotlin as script lang)
  , See also <a href="https://holgerbrandl.github.io/kscript_kotlinconf_2017/kscript_kotlinconf.html#1">Presentation@KotlinConf2017</a>
  <ul xxxsmall zoom>
  <li>Compiled script caching (using md5 checksums)</li>
  <li>Dependency declarations using gradle-style resource locators and automatic dependency resolution with maven</li>
  <li>More options to provide scripts including interpreter mode, reading from stdin, local files or URLs</li>
  <li>Embedded configuration for Kotlin runtime options</li>
  <li>Support library to ease the writing of Kotlin scriptlets</li>
  <li>Deploy scripts as stand-alone binaries</li>
  </ul>

</td>
</tr }>
</table>
</body>
<!--
TODO_start
TODO: Lazy property:
  val p: String by lazy { // compute the string }

__________________________
TODO: If you need to write a function that can be called without having a class instance
but needs access to the internals of a class (for example, a factory method), you
can write it as a member of an object declaration
(https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.
Even more specifically, if you declare a companion object 
(https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) 
inside your class, you'll be able to call its members with the same syntax as calling
static methods in Java/C#, using only the class name as a qualifier.
____________________________
Use Kotlin with npm, webpack and react:
  https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/
____________________________
<span xbig>// Checking ranges:</span>
<pre { >
if (x in 1...y+1) { println("OK") } 

for (x in 1..10       step 2) { print(x) }
for (x in 10 downTo 0 step 2) { print(x) }
for (idx          in array.indices)     { println(array[idx])       }
for ((idx, value) in array.withIndex()) { println("$idx -> $value") }
for ((key, value) in map              ) { println("$key -> $value") }
fruits.filter { it.startsWith("a") }.sortedBy { it }.
    map { it.toUpperCase() }.forEeach( println(it) )

val arrayOfMinusOnes: Array = IntArray(20).apply{fill(-1)} // 
</pre } >

____________________________
<pre { >
fun foo() {
  // Alt 1. lambda function
  ints.forEach lit@ {
    // returns from foo
    if (it == 0) return
    // returns from lambda lit@
    if (it == 1) return@lit
    // returns from lambda lit@ (implicit label)
    if (it == 2) return@forEach
    print(it)
  }
  // Alt 2. anonymous function
  ints.forEach( func(value: Int) {
    // local returns from  anonymous funct
    if (it == 0) return
    print(value)
  }
}
_______________________
mainLoop@ for (i in 1..100) { // <- any expresion can be marked with a  label ("identifier"@)
  for (j in 1..100) {
    if (j == 55) break@loop // jumps right after the loop marked with label
  }
}
</pre }>


-->
<!--
<ul>
<li><a href="http://kotlinlang.org/api/latest/kotlin.test/index.html">kotlin.test</a>, included out of the box in Kotlin 1.2, lets you write your test once and run it under both the JVM and JS;</li>
<li><a href="https://github.com/kotlin/kotlinx.html">kotlinx.html</a> supports <strong>isomorphic rendering</strong> – using the same code to render HTML in the backend and in the frontend;</li>
<li><a href="https://github.com/kotlin/kotlinx.serialization">kotlinx.serialization</a> allows you to easily marshal Kotlin objects between different tiers of your application, using JSON or ProtoBuf as serialization formats.</li>
</ul>

What's new in Koltin 1.2:
http://kotlinlang.org/docs/reference/whatsnew12.html

____________________
Warnings as errors

The compiler now provides an option to treat all warnings as errors. Use -Werror on the command line, or the following Gradle snippet:

compileKotlin {
    kotlinOptions.allWarningsAsErrors = true
}
__________________________
https://kotlinlang.org/docs/reference/native-overview.html

https://github.com/JetBrains/kotlin-native/blob/master/samples/tensorflow/src/main/kotlin/HelloTensorflow.kt


__________________
https://kotlin.es/2015/11/kotlin-koans-repositorio-de-ejercicios-oficiales/#
<p>###Introduction [13/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#hello-world" target="_blank" rel="noopener">Hello World!</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#java-to-kotlin-conversion" target="_blank" rel="noopener">Java to Kotlin conversion</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#named-arguments" target="_blank" rel="noopener">Named arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#default-arguments" target="_blank" rel="noopener">Default arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lambdas" target="_blank" rel="noopener">Lambdas</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#strings" target="_blank" rel="noopener">Strings</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#data-classes" target="_blank" rel="noopener">Data classes</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#nullable-types" target="_blank" rel="noopener">Nullable types</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#smart-casts" target="_blank" rel="noopener">Smart casts</a> &lt;? Nivel 1</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-functions" target="_blank" rel="noopener">Extension functions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#object-expressions" target="_blank" rel="noopener">Object expressions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sam-conversions" target="_blank" rel="noopener">SAM conversions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extensions-on-collections" target="_blank" rel="noopener">Extensions on collections</a></li>
</ul>
<p>###Collections [25/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#introduction" target="_blank" rel="noopener">Introduction</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#filter-map" target="_blank" rel="noopener">Filter map</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#all,any,count,firstornull" target="_blank" rel="noopener">All, Any, Count, FirstOrNull</a> &lt;? Nivel 2</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#flatmap" target="_blank" rel="noopener">FlatMap</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#maxmin" target="_blank" rel="noopener">Max min</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sort" target="_blank" rel="noopener">Sort</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sum" target="_blank" rel="noopener">Sum</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#group-by" target="_blank" rel="noopener">Group by</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#partition" target="_blank" rel="noopener">Partition</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#fold" target="_blank" rel="noopener">Fold</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#compoundtasks" target="_blank" rel="noopener">Compound tasks</a> &lt;? Nivel 3</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#getusedtonewstyle" target="_blank" rel="noopener">Get used to new style</a></li>
</ul>
<p>###Conventions [32/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#comparison" target="_blank" rel="noopener">Comparison</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#in-range" target="_blank" rel="noopener">In range</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#range-to" target="_blank" rel="noopener">Range to</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#for-loop" target="_blank" rel="noopener">For loop</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#operators-overloading" target="_blank" rel="noopener">Operators overloading</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#multi-assignment" target="_blank" rel="noopener">Multi assignment</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#invoke" target="_blank" rel="noopener">Invoke</a> &lt;? Nivel 4</li>
</ul>
<p>###Properties [36/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#properties" target="_blank" rel="noopener">Properties</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lazy-property" target="_blank" rel="noopener">Lazy property</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delgates-examples" target="_blank" rel="noopener">Delegates examples</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delegates-how-it-works" target="_blank" rel="noopener">Delegates how it works</a></li>
</ul>
<p>###Builders [41/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-function-literals" target="_blank" rel="noopener">Extension function literals</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#string-and-map-builders" target="_blank" rel="noopener">String and map builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#the-function-with" target="_blank" rel="noopener">The function with</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#html-builders" target="_blank" rel="noopener">Html builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#builders-how-it-works" target="_blank" rel="noopener">Builders how it works</a>
-->
</html>
