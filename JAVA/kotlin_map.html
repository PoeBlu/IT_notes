<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Koltin map</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->
<br/>
<table style='width:100%'{>
<tbody>
<tr {>
  <td col1 ></td> <td col2 ></td> <td col3 ></td> <td col4 ></td>
  <td col5 ></td> <td col6 ></td> <td col7 ></td> <td col8 ></td>
  <td col9 ></td> <td col10></td> <td col11></td> <td col12></td>
</tr }>

<tr {>
  <td col1 colspan=1 >
    External Links:
    <ul xxxsmall zoom >
      <li><a href="https://kotlinlang.org/docs/reference/">Reference@Kotlinlang.org</a></li>
      <li><a href="https://kotlinlang.org/docs/resources.html">More resources</li>
      <li><a href="https://try.kotlinlang.org/#">On-line IDE</a></li>
    </ul>
<br/>
    <span xbig>Everything is an expresion</span>
<pre xxsmall zoom { >
// "if" are expresions and the last 
// expression is the value of the "if"-block:
val max = if (a > b) {
    print("a Wins "); a 
} else {
    print("b Wins "); b 
}
</pre }>
    <span xbig>Immutable values and inferred types</span>
<pre xxsmall zoom { >
// Immediate inmutable assignment
val a: Int  = 1

// Inferred Int type (var mutable)
var count  = 5;
    count += 1;
</pre } >

    <span xbig>Python like import-as</span>
<pre xxsmall zoom { >
import bar.Bar as bBar
</pre } >

<span xbig>Check types at runtime ('is')</span>

<pre xxsmall zoom { >
fun getStringLenght(obj: Any) {
  if (obj  is String) {...} 
  if (obj !is String) {...}
}
</pre } >



    <span xbig>Equality</span><br/>
<pre xxsmall zoom {>
   val a = Class(param1, param2)
   val b = Class(param1, param2)
   a === b // returns false
   a == b  // returns true
</pre }>


  </td>  
  <td col1 colspan=2 >
<span xxbig>utility functions</span><br/>
(standard functions, no import required)<br/>
<span xbig>Apply</span><br/>
helping function to initialize objects:
<pre xxsmall zoom {>
// applies lambda to object and returns same object
val task = Runnable { println("Running") }
Thread(task)<b>.apply</b> {  setDaemon(true) }.start()
</pre }>

<span xbig>'with' to avoid repeated typing:</span><br/>
<pre xxsmall zoom {>
  class Turtle {
      turn(degrees: Double)
      forward(pixels: Double)
      ...
  }
  val myTurtle = Turtle()
  with(myTurtle) {
    penDown() ;
    for(i in 1..4) { 
      forward(100.0) ; turn(90.0) 
    }
  }
</pre }>
<span xbig>Run</span><br/>
extension function. A closure is passed to run, which has the instance 
as the receiver. The return value of the closure is used as the return value of run itself:
<pre xxsmall zoom {>
val outputPath = Paths.get("/user/home").run {
  val path = resolve("output")
  path.toFile().createNewFile()
  path
}
</pre }>

<span xbig>Lazy</span><br/>
wraps an expensive function call to be invoked when first required:
<pre xxxsmall zoom {>
// expensive operation
fun readStringFromDatabase(): String = ... 
val lazyString = lazy { readStringFromDatabase() }
</pre }>

<span xbig>Use</span><br/>
(Java try-catch-with-resources)
<pre xxxsmall zoom {>
val stream = Files.newInputStream(
    Paths.get("/some/file.txt"))
stream.buffered().
  reader()<b>.use</b> {
  reader -> 
    println(reader.readText()) 
}
</pre }>

<span xbig>Repeat</span><br/>
Avoid "for" for simple operations:
<pre {>
repeat(10, { println("Hello") })
</pre }>
<!-- TODO:
<span xxbig>Let</span>
-->
  </td>  
  <td col2 colspan=3 >

<span xbig>Require/assert/check</span><br/>
<pre xxxsmall zoom {>
fun neverEmpty(str: String) {
  require(str.length > 0,
    { "String should not be empty" })
  println(str)
}
</pre }>
<br/>
    <span xbig>Type alias</span><br/>
Rename type with alias.  The alias is simply replaced by the compiler. 
This means that new types are not created or allocated, so we suffer no performance penalty. <br/>
typealias do <b>NOT</b> increase type safety. 
<pre xxsmall zoom {>
typealias Cache = HashMap<String, Boolean>
typealias Address = String
typealias FamilyName = String
</pre }>
      <span xxbig>Avoiding nulls</span><br/> 
      <a href="https://kotlinlang.org/docs/reference/null-safety.html">docs/ref</a><br/>
    <span xbig>nullables must be declared explicetelly</span>
<pre xxxsmall zoom { >
val nullableBob : String? = "abc"
nullableInstance<b>?</b>.department<b>?</b>.head<b>?</b>.name 
^_______________^___________^_____^
<span xbig>Returns null if nullableInstance,
 department or head is null
</span>

val listWithNulls: List<String?> = listOf("A", null)
for (item in listWithNulls) {
<b>/* "?.let" skips expression
 * block execution for nulls */</b>
  item<b>?.let</b> { println(it) }
}

<b>Filtering Nulls at list initialization
(Fix-fast)</b>
val intList: List<Int> =
  listOf(1, 2, null, 4)
  <b>.filterNotNull()</b>

<span xbig>
/* Assigning nullable to non-nullable
 * requires if (..!=null) ... else ...*/</span>
val l: Int = <b>if (b != null)</b> b.length else -1
<span xbig>or Elvis operator ?:</span>
val l = b?.length ?: -1

<span xbig>Abort/throw NullPointerE. if null present</span>
  val name = node.getName()!!


<span xbig>SmartCast</span>
fun getName(): String? = ...
val name = getName()
if (name != null) {
  // here compiler knows name is not null
  println(name.length)
}
      
  </td>  

  <td colspan=2>  
    <span xbig>Basic Types</span>
<pre xxsmall zoom { >
Long/Int/Short/Byte(64,32,16,8)
Boolean 
Chars
  val c: Char = '\uFF00' //  'a', '\b'
Strings
Arrays

<b>explicit Chart to Int conversion</b>
if (c in '0'..'9')  // alt: '0'..'9'.contains(c)
  c.toInt() - '0'.toInt() 
else
  throw RuntimeException("...")

<span xbig>bitwise operations</span>
val x = (1 shl 2) and 0x00FF
// (u)shl/(u)shr) bits:(un)signed shift left/righ
// and/or/xor bits 
// inv()               :bitwise inversion

<span xbig>special optimized arrays</span>
// (Byte|Short|Int|...)Array
</pre }>
    <span xbig>"When"</span>
<pre xxsmall zoom {>
fun describe(obj: Any = 1) :
    String = when(obj) {
  1            -> "One" 
  "Hello"      -> "Greeting" 
  is Long      -> "Long"
  in 32...128  -> "Is ASCII"
  !is String   -> "Not a string"
  "dog" in obj -> "Animal list"
  else         -> "Unknown"
}
</pre }>
<br/>
    <span xbig>try/catch as expresion</span><br/>
     try/catch block returns values:(return value)
<pre xxsmall zoom {>
  val result = 
    try { count() } 
    catch (e: ArithmeticException) {
      throw RuntimeException(e) 
    }
</pre }>
<br/>
    <span xbig>Ranges</span><br/>
   Interval with start and end value. Any comparable type can be used.
<pre xxsmall zoom {>
val aToZ = "a"<b>..</b>"z" // "c" in aToZ == true
val countingDown = 100.downTo(0)
val ten20 = 10.rangeTo(20).step(2)
</pre }>
  </td>  

  <td col3 colspan=2 >
</pre } >
    <span xbig>String template</span>
<pre xxsmall zoom { >
  val a  = 23
  val s1 = "Hello World <b>$a</b>!"
  println(s1)
</pre } >
<br/>
    <span xbig>String Expresions</span>
<pre xxsmall zoom  { >
  val s2 = "<b>${</b>s1.replace("Hello", "Goodbye")<b>}</b> $d"
</pre } >
    <span xbig>Multiline string with margin</span>
<pre xxsmall zoom { >
  val myMultiLineString = """
<b>    |</b> for (c in "foo")
<b>    |</b>     print(c)
<b>    |</b> Dolar is writen as ${'$'}
  """.<b>trimMargin()</b> // remove leading spaces.
  print(myMultiLineString)
</pre }>
<br/><br/>
    <span xxbig>Collection Handling</span><br/>
<pre xxsmall zoom { >
val intArray = arrayOf(1,2,3)
val doubleList : List<Double>= arrayListOf(84.88, 100.25, 999.99)
var nonNulls: List<String> = listOfNotNull<String>{null, "a",...}
val map1 = mapOf("a" to 1, "b" to 2)
val intSet: Set<Int> = setOf(1, 2, 1,..)    
val hashSet: java.util.HashSet<Book> = 
    hashSetOf(Book(...), Book(...)
val longSet: MutableSet<Long> = mutableSetOf( 1, 2, 3)

val readWriteList: MutableList<String> =  mutableListOf(...)
val readOnlyView : List<String> = readWriteList


<span xbig>Lambda initializer for arrays</span>
val squaredArray: Array = 
    Array(5, <b>{ idx -> (idx * idx).toString() }</b>)

<span xbig>"Walk" over collection</span>
for (<b>item in</b> myArrayOrList)
  println("item is ${item}")

<span xbig>"Walk" over list index</span>
for (<b>idx  in intList.indices</b>)
  println("$idx is ${intList[idx]}")

<span xbig>Initialize a map<br/>
(HashTable/Dictionary)</span>
val map1 = mapOf("a" to 1, "b" to 2)
val map2 = mapOf(Pair("a", 1), Pair("b", 2))
println(map1) // Prints [1, 2]

<span xbig>"spread" array</span>
val    a = asList(1, 2, 3)
val list = asList(-1, 1, <b>*a</b> /*spread*/, 4)  

<span xbig>Filtering a list</span>
val positives = list<b>.filter</b> { x -&gt; x &gt; 0 }
// even shorter: (using default "it")
val positives = list.filter { it &gt; 0 }
</pre } >
  </td>  
  <td col2 colspan=2 >
    <span xxbig>Sequences</span><br/>
    (Java Streams)<br/>
    <br/>
    Sequences are collections of unknown size
<pre xxsmall zoom { >
val charSequence: Sequence<Char> =
  charArrayOf('a','b','c').asSequence()  //a,b,
val s1 : String  = charSequence.joinToString(",")
</pre>

    <span xbig >Sequence generator</span>
<pre xxsmall zoom { >
var count = 10
val sequence = 
  generateSequence {
    (count--).takeIf { it > 0 } 
}
// println(sequence.toList())
// sequence.forEach { it*it }
</pre }>
  </td>  

</tr }>
</table>
<table>
<tr {>
  <td col1 ></td> <td col2 ></td> <td col3 ></td> <td col4 ></td>
  <td col5 ></td> <td col6 ></td> <td col7 ></td> <td col8 ></td>
  <td col9 ></td> <td col10></td> <td col11></td> <td col12></td>
</tr }>

<tr {>
  <td col1 colspan=2>


    <span xxbig>Interfaces</span>
<pre xxsmall zoom {>
interface MyInterface {
    val prop1: Int 
    val prop2: String
        <b>get() = "foo"</b> // default accessor
    fun bar(): Int
    // default implementation
    fun foo() { print(prop)  } 
    fun foo() { }
}

class Child : MyInterface {
  override val prop: Int = 29
}
</pre }>

    <span xbig>Single abstract method Interface pattern</span><br/>
(An interface with a single method: Runnable, Callable, Closeable, Comparator, ...).<br/>
Kotlin has support for converting a function literal directly
into a SAM. If the conversion is unambiguous, you can simply pass the function literal
where a SAM is expected:
<pre xxsmall zoom { >
val threadPool = Executors.newFixedThreadPool(4)
threadPool.submit *1 {
  <b>println("...")</b> 
}
// The kotlin compiler will convert this code to:
threadPool.submit(<b>object : Runnable {
  override fun run() {
    println("I don't have a lot of work to do")
  }
}</b>)
</pre }>
  </td>  
  <td col2 colspan=1>
    <span xxbig>Functions</span><a href="https://kotlinlang.org/docs/reference/functions.html">(ref)</a>
<pre xxxsmall zoom { >
data class Coordinate(val x: Int, val y: Int)

fun getPoint
   (a: Int, b: Int <b>= 1 /*def.val*/</b>, <b>vararg</b> names: String) : Coordinate {   
  return Coordinate(a+b,a-b)
}                                
// "shortcut"
fun getPoint(a: Int, b: Int = 1) <b>= Coordinate(a+b,a-b)</b>
// ussage, split vl
val (x, y) = getPoint(1,2)
// Using named parameters
val (x, y) = getPoint(a = 1, b = 2)

<span xbig>Generic Functions</span>
// &lt;T&gt; is specified before the fun. name
fun <T> singletonList(item: T): 
  List<T> {
    // ...
}
</a>
<span xbig>Tail recursive</span>
// <b>Compiler optimises out the recursion!!!</b>
// - function must call itself as last operation)
// - doesn't work  within try/catch.
// - only supported in JVM (currently)
tailrec 
fun findFixPoint(x: Double = 1.0): Double
  = if (x == Math.cos(x)) x 
    else findFixPoint(Math.cos(x))

<a xbig href="https://kotlinlang.org/docs/reference/inline-functions.html">Inline functions</a>
inline 
  fun lock(param1: Class1, ...) :
  ReturnClass {
}
</pre } >

<span xbig>(Class)Extension Functions</span>
<pre xxxsmall zoom { >
fun <span xbig><b orange>String.</b></span>spaceToCamelCase()
    String { ... }
(String. == Applies only to String objects)
Ussage:
"to camelcase".spaceToCamelCase()
23424.spaceToCammelCase() // Compiler error
</pre } >

<span xbig>Functions receivers</span>
<pre xxxsmall zoom { >
/* 
 * Very similar to extension functions but applies to func. literals.
 * that is, to variables representing functions.
 */
// Definition:
val countChars: <b orange>String.</b>() -> Unit = { println("Counted chars: ${length}") }
// Ussage:
val txt = "ASDF"
countChars(<b orange>txt</b>)
</pre }>

<span xbig>Infix Member Functions</span>
<pre xxxsmall zoom { >
class Account {
  var balance = 0.0
  <b>infix</b> fun add(amount:Double): Unit {
     this.balance = balance + amount
  }
}
accountInstance add 100.00

<span xbig>Operator Overloading</span>
Allowed for 
class     |
Operation | Function name
a + b     | plus()
a – b     | minus()
A * b     | times()
A / b     | div()
A & b     | mod()
a..b      | rangeTo()
+a        | unaryPlus()
-a        | unaryMinus()
!a        | not()
[p1,p2,..]| operator fun get(param1, param2,...)
&lt; &lt;=      | compareTo
&gt; &gt;=      |
-------------------------
()        | operator func invoke():
</pre }>

<pre TODO hidden {>
// <- instance 'space':'space' => type <-> supertype
interface Foo<out T : Any> : Bar {
// <- instance: => instance <-> type
    fun foo(a: Int): T 
}
</pre }>
  </td>  
  <td col2 colspan=1>
    <span xbig>High Order Functs</span></a>
    <br/>
<pre xxsmall zoom {>
<b>Function receiving a function</b>
fun foo(name: String, <b>paramFunc: (String) -> String</b>): Unit {
  val applied = paramFunc(name)
  println(applied)
}
foo("hello", <b>paramFunc = { it.reversed() }</b>)


<b>Function returning a function</b>
fun bar() :
   <b>(String) -> String = { str -> str.reversed() }</b>

<b>Closures</b>
fun students(nameToMatch: String): List<Student> {
  return loadStudents().filter <b>{
    // closure has access to parent stack
    it.lastName == nameToMatch
  }</b>
}

<b>Currying functions</b><br/>
<span TODO>TODO</span>

<b>Memoization (Avoid repeated long-running calculus)</b>
fun Function1<b>.memoized()</b>: (String) -> MyClass {
  val map = ConcurrentHashMap<String, MyClass>()
  return {
    a -> map.getOrPut(a) {
      this.invoke(a)
    }
  }
}
</pre }>


  </td>
<td col3 colspan=3>
<span xxbig>Classes<a href="https://kotlinlang.org/docs/reference/classes.html">(REF)</a></span><br/>

<span xbig><code>"Any"</code> (common superclass in Kotlin) is <b>NOT</b> java.lang.Object;</span><br/>
it does not have any members other than equals(), hashCode() and toString().

<span xxxbig>Composition over inheritance</span></br>
sometimes called delegation, where delegation is actually the dessign pattern and composition the standard/easiest way to implement it.<br/>
REF1:"Efective Java"<br/>
REF2:<a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin doc ref</a><br/>
Note: foreign keys in SQL is the best well known form of composition:
<pre xxsmall zoom { >
employee      person     client
--------      -------    ------
id      ←─┐┌─→ id   ←─┐  id
roll      ││   name   └─ fk_person
fk_person ─┘   ...    ┌─ fk_saleManager
...       └───────────┘   ...
</pre } >
<br/>
<span xxbig>Composition</span>
<pre xxxsmall zoom {>                
interface IPerson { fun print() ... }

class Person(val name: String, val familyName1: ...) : IPerson {
  override fun print() { print(x) }
}

class Employee(b: IPerson) : IPerson <b xxbig>by</b> b

fun main(args: Array&lt;String&gt;) {
    val pacoMA = Person(
             surname:"Paco", name1: "Martinez", ... )
    val employee = Employee(
                     <b>person: <b>pacoMA</b>,
                     roll: manager,
                     ... )
    employee<b xxbig>.print()</b> /* == myClass.base.print() */
}

<span xbig>Inheritance (discouraged)</span>
class Derived(p: Int) <b>:</b> Base(p)

class Container(
  id     : Int, 
  size   : Int,
  childs : Containers
) : SuperClass(id, name),
  Iface1, Iface2, Iface3 {
  var person_id = id
  <span xbig>// custom accesor</span>
  val isEmpty: Boolean 
      <b>get() = this.size == 0 
             || (var sum = 0; for (c in childs) sum+=c.size) == 0  </b>
  val stringRepr : String
      <b>get() = this.toString()</b>
      <b>set(value) = _setFromString(value)</b>
  // ...

  <b>companion object</b> Factory : FactoryTemplate<MyClass> { // <- object name ('Factory') can be ommited
    override fun create(): Container = Container(...)
  }
  }
  val instance = MyClass.create()

}
<span xxbig>Singletons</span>
<span xbig><b>object</b></span> Resource {
  val name = "Name"
}
</pre } >

<pre { >
<!--  TODO:(0)
class Customer public @Inject constructor(name: String = "") { ... }

/* The 'constructor' keyword is optional if not annotations or visibility
 modifiers are used */
class Customer constructor(name: String) { // primary constructor
    init { // 'init' marks an initializer block
        logger.info("Customer initialized with value ${name}")
    }
}
class Customer {
  constructor(parent: Person) { // Secondary constructor
    parent.children.add(this)
  }
}
-->
</pre } >
  </td>
  <td col3 colspan=3>
<span xbig>Compaq class declaration</span>
<pre xxsmall zoom { >
// use val or var:
class Person(
  val firstName: String,
  val lastName: String,
  var age: Int) {
  ...
}
</pre }>
<br/>
<span xxbig>data class (DTO)</span>
<pre xxsmall zoom { >
<span comment>automatically generates:
- getters (and setters for vars),
- equals(), hashCode(), toString(), copy()
- component1(),… for all properties 
</span>
<span xbig><b>data</b></span> class Customer(
  val name  : String,  // val: inmutable
  val email : String, // val: inmutable
  var refNum: Int )    // var:   mutable
</pre } >

<span xbig>Sealed Classes </span> <a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Ref</a> </br>
represent restricted class hierarchies or "sort of" enum extensions,
with subclasses being able to have multiple instances<br/>

(sealed class/subclasses must be declared in the same file)
<pre xxsmall zoom { >
Declaration:
<b>sealed</b> class Expr
data class Const(val number: Double)      <b>: Expr()</b>
data class Sum(val e1: Expr, val e2: Expr)<b>: Expr()</b>
object /*singleton*/ NotANumber <b>: Expr()</b>

Ussage:
fun eval(expr: <b>Expr</b>): Double =
  when(expr) {
  is <b>Const</b>      -> expr.number
  is <b>Sum</b>        -> eval(expr.e1) + eval(expr.e2)
     <b>NotANumber</b> -> Double.NaN
}
</pre } >
  </td>
  <td colspan=2>
    <span xbig>DSL</span>
    <ul>
      <li>Uses function receivers to introduce methods that can be used 
        in function literals, but restricting to the appropriate "section".
      </li>
      <li>
      </li>
    </ul>
For example, let's introduce some matchers that only work on collections, and allow several
of them to be applied at the same time. The idea is to allow syntax like the following:
    listOfNames should {
      contain("george")
      contain("harry")
      notContain("francois")
      haveSizeLessThan(4)
    }

    class CollectionMatchers<T>(val collection: Collection<T>) {
      fun contain(rhs: T): Unit {
        if (!collection.contains(rhs))
          throw RuntimeException("Collection did not contain $rhs")
      }

      fun notContain(rhs: T): Unit {
        if (collection.contains(rhs))
          throw RuntimeException("Collection should not contain $rhs")
      }

      fun haveSizeLessThan(size: Int): Unit {
        if (collection.size >= size)
          throw RuntimeException("Collection should have size less  than $size")
      }

      infix fun <T> Collection<T>.should(fn: CollectionMatchers<T>.() -> Unit) {
        val matchers = CollectionMatchers(this)
        matchers.fn()
      }

    }


Kotlin also ease the creation of an internal DSLs, or fluent interface.
It does that with lambdas and the help of some syntactic sugar.
 Like the fact that the last argument of a function, if it is a lambda,
 can also be put outside of the parentheses.

 This is useful to reduce the need for complex string interpolations. 
For instance, this example uses a library to create HTML.

createHTML().table {
    for (language in languages) {
       tr {
           td { +language.name }
           td { +language.popularity }
       }
    }
}
  </td>
</tr }>
</table>
</body>
<!--
***** The open annotation on a class is the opposite of Java's final:
 it allows others to inherit from this class. By default, all classes
 in Kotlin are final, which corresponds to Effective Java, Item 17:
  Design and document for inheritance or else prohibit it. ****
open class Base          {           open fun v() {} } // if not open => final
class Derived() : Base() { final override fun v() {} } // by default override is also open


======================================================
Object expressions and declarations
generalization of anonymous inner classes:
Ej1:
  window.addMouseListener( object : MouseListenerBaseClase(baseClassConstructorParam1,...) 
    { // object is an instance of an anonymous class inheriting from base listener class
      override fun onMouseClicked(e: MouseEvent) { ... }
      ...
    })
Ej 2:
  interface B {...}
  val ab: A = object : A(1), B { override ...  }
----------- Object singletons --------------------------
Object singletons or object declaration, always has a name following the object keyword. Just
like a variable declaration, an object declaration is not an expression, and cannot be used
on the right hand side of an assignment statement.
  object DataProviderManager {
      fun registerDataProvider(provider: DataProvider) {
          // ...
      }
  
      val allDataProviders: Collection<DataProvider>
          get() = // ...
  }
  DataProviderManager.registerDataProvider(...)
===== Delegation =====
A class "Derived" can inherit from an interface <IBase> and delegate all of its public methods
to a specified object:
Ex:
   interface IBase { fun print() }

   class BaseImpl(val x: Int) : IBase { override fun print() { print(x) } }

   // b will be stored internally in objects of Derived and the compiler will
   // generate all the methods of IBase that forward to b
   class Derived(b: IBase) : IBase by b 

   fun main (args: Array<String>) {
      val b = BaseImpl(10)
      Derived(b).print() // prints 10
   }


</pre } >















-->

<!--
  Multiplatform Native Development In Kotlin
https://blog.kotlin-academy.com/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec


https://www.infoworld.com/article/3224868/java/what-is-kotlin-the-java-alternative-explained.html#tk.ifw-infsb

https://www.infoworld.com/article/3236419/development-tools/kotlin-frameworks-a-survey-of-jvm-development-tools.html#tk.ifw-infsb

-->

<!--
TODO: Lazy property:
  val p: String by lazy { // compute the string }

__________________________

__________________________
TODO: If you need to write a function that can be called without having a class instance
but needs access to the internals of a class (for example, a factory method), you
can write it as a member of an object declaration
(https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.
Even more specifically, if you declare a companion object 
(https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) 
inside your class, you'll be able to call its members with the same syntax as calling
static methods in Java/C#, using only the class name as a qualifier.
____________________________
Use Kotlin with npm, webpack and react:
  https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/
____________________________
<span xbig>// Checking ranges:</span>
<pre { >
if (x in 1...y+1) { println("OK") } 

for (x in 1..10       step 2) { print(x) }
for (x in 10 downTo 0 step 2) { print(x) }
for (idx          in array.indices)     { println(array[idx])       }
for ((idx, value) in array.withIndex()) { println("$idx -> $value") }
for ((key, value) in map              ) { println("$key -> $value") }
fruits.filter { it.startsWith("a") }.sortedBy { it }.
    map { it.toUpperCase() }.forEeach( println(it) )

val arrayOfMinusOnes: Array = IntArray(20).apply{fill(-1)} // 
</pre } >

____________________________
<pre { >
fun foo() {
  // Alt 1. lambda function
  ints.forEach lit@ {
    // returns from foo
    if (it == 0) return
    // returns from lambda lit@
    if (it == 1) return@lit
    // returns from lambda lit@ (implicit label)
    if (it == 2) return@forEach
    print(it)
  }
  // Alt 2. anonymous function
  ints.forEach( func(value: Int) {
    // local returns from  anonymous funct
    if (it == 0) return
    print(value)
  }
}
_______________________
mainLoop@ for (i in 1..100) { // <- any expresion can be marked with a  label ("identifier"@)
  for (j in 1..100) {
    if (j == 55) break@loop // jumps right after the loop marked with label
  }
}
</pre }>


-->
<!--
<ul>
<li><a href="http://kotlinlang.org/api/latest/kotlin.test/index.html">kotlin.test</a>, included out of the box in Kotlin 1.2, lets you write your test once and run it under both the JVM and JS;</li>
<li><a href="https://github.com/kotlin/kotlinx.html">kotlinx.html</a> supports <strong>isomorphic rendering</strong> – using the same code to render HTML in the backend and in the frontend;</li>
<li><a href="https://github.com/kotlin/kotlinx.serialization">kotlinx.serialization</a> allows you to easily marshal Kotlin objects between different tiers of your application, using JSON or ProtoBuf as serialization formats.</li>
</ul>

What's new in Koltin 1.2:
http://kotlinlang.org/docs/reference/whatsnew12.html

____________________
Warnings as errors

The compiler now provides an option to treat all warnings as errors. Use -Werror on the command line, or the following Gradle snippet:

compileKotlin {
    kotlinOptions.allWarningsAsErrors = true
}
__________________________
https://kotlinlang.org/docs/reference/native-overview.html

https://github.com/JetBrains/kotlin-native/blob/master/samples/tensorflow/src/main/kotlin/HelloTensorflow.kt

_____________________________________

__________________________

Koltin Coroutines:
  https://kotlinlang.org/docs/reference/coroutines.html
Many asynchronous mechanisms available in other languages can be implemented as libraries using Kotlin coroutines. This includes async/await from C# and ECMAScript, channels and select from Go, and generators/yield from C# and Python. See the description below for libraries providing such constructs.

vs Java Fibers: (fast threads for java)
  - http://docs.paralleluniverse.co/quasar/


Design documents and examples for coroutines in Kotlin
  https://github.com/Kotlin/kotlin-coroutines
__________________
https://kotlin.es/2015/11/kotlin-koans-repositorio-de-ejercicios-oficiales/#
<p>###Introduction [13/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#hello-world" target="_blank" rel="noopener">Hello World!</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#java-to-kotlin-conversion" target="_blank" rel="noopener">Java to Kotlin conversion</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#named-arguments" target="_blank" rel="noopener">Named arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#default-arguments" target="_blank" rel="noopener">Default arguments</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lambdas" target="_blank" rel="noopener">Lambdas</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#strings" target="_blank" rel="noopener">Strings</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#data-classes" target="_blank" rel="noopener">Data classes</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#nullable-types" target="_blank" rel="noopener">Nullable types</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#smart-casts" target="_blank" rel="noopener">Smart casts</a> &lt;? Nivel 1</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-functions" target="_blank" rel="noopener">Extension functions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#object-expressions" target="_blank" rel="noopener">Object expressions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sam-conversions" target="_blank" rel="noopener">SAM conversions</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extensions-on-collections" target="_blank" rel="noopener">Extensions on collections</a></li>
</ul>
<p>###Collections [25/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#introduction" target="_blank" rel="noopener">Introduction</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#filter-map" target="_blank" rel="noopener">Filter map</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#all,any,count,firstornull" target="_blank" rel="noopener">All, Any, Count, FirstOrNull</a> &lt;? Nivel 2</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#flatmap" target="_blank" rel="noopener">FlatMap</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#maxmin" target="_blank" rel="noopener">Max min</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sort" target="_blank" rel="noopener">Sort</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#sum" target="_blank" rel="noopener">Sum</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#group-by" target="_blank" rel="noopener">Group by</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#partition" target="_blank" rel="noopener">Partition</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#fold" target="_blank" rel="noopener">Fold</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#compoundtasks" target="_blank" rel="noopener">Compound tasks</a> &lt;? Nivel 3</li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#getusedtonewstyle" target="_blank" rel="noopener">Get used to new style</a></li>
</ul>
<p>###Conventions [32/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#comparison" target="_blank" rel="noopener">Comparison</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#in-range" target="_blank" rel="noopener">In range</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#range-to" target="_blank" rel="noopener">Range to</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#for-loop" target="_blank" rel="noopener">For loop</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#operators-overloading" target="_blank" rel="noopener">Operators overloading</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#multi-assignment" target="_blank" rel="noopener">Multi assignment</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#invoke" target="_blank" rel="noopener">Invoke</a> &lt;? Nivel 4</li>
</ul>
<p>###Properties [36/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#properties" target="_blank" rel="noopener">Properties</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#lazy-property" target="_blank" rel="noopener">Lazy property</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delgates-examples" target="_blank" rel="noopener">Delegates examples</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#delegates-how-it-works" target="_blank" rel="noopener">Delegates how it works</a></li>
</ul>
<p>###Builders [41/42] Koans</p>
<ul>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#extension-function-literals" target="_blank" rel="noopener">Extension function literals</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#string-and-map-builders" target="_blank" rel="noopener">String and map builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#the-function-with" target="_blank" rel="noopener">The function with</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#html-builders" target="_blank" rel="noopener">Html builders</a></li>
<li><a href="https://github.com/vicboma1/Kotlin-Koans#builders-how-it-works" target="_blank" rel="noopener">Builders how it works</a>


______________
https://gist.github.com/dodyg/5823184
______________
https://www.infoq.com/news/2018/03/jetbrains-releases-kotlin-1.2.30

JetBrains recently released version 1.2.30 of their popular programming language, Kotlin, as a bug fix and tooling update that comes about a month-and-a-half after the release of version 1.2.20. New features include:

    New function, suspend, for coroutines.
    Support for Gradle's build cache tool.
    IDE support for the new Kotlin style guide.
    New inspections, performance improvements, and bug fixes in the IntelliJ plug-in.
    Support for TestNG in kotlin.test.

All new features and enhancements are supported in IntelliJ IDEA versions 2017.1 through 2017.3 and 2018.1 EAP, along with Android Studio 3.0. We highlight some of these enhancements here.

Multiplatform Projects
Kotlin Multiplatform Projects, introduced in November 2017 with the release of version 1.2, can compile the same codebase to multiple target platforms which, at this time, are the JVM and JavaScript.

As described on the website:
  A multiplatform project allows you to build multiple tiers of your application:
backend, frontend and Android app from the same codebase.
  Such a project contains both common modules, which contain platform-independent code,
as well as platform-specific modules, which contain code for a specific platform
(JVM or JS) and can use platform-specific libraries. To call platform-specific code
from a common module, you can specify expected declarations for
which all platform-specific modules need to provide actual implementations.
______________________
"Using function receivers in a DSL"
Function receivers can be used in a powerful way when writing DSLs. They allow us to
introduce methods that can be used in function literals, but their use is restricted to the
appropriate "section".
For example, let's introduce some matchers that only work on collections, and allow several
of them to be applied at the same time. The idea is to allow syntax like the following:
    listOfNames should {
      contain("george")
      contain("harry")
      notContain("francois")
      haveSizeLessThan(4)
    }

    class CollectionMatchers<T>(val collection: Collection<T>) {
      fun contain(rhs: T): Unit {
        if (!collection.contains(rhs))
          throw RuntimeException("Collection did not contain $rhs")
      }

      fun notContain(rhs: T): Unit {
        if (collection.contains(rhs))
          throw RuntimeException("Collection should not contain $rhs")
      }

      fun haveSizeLessThan(size: Int): Unit {
        if (collection.size >= size)
          throw RuntimeException("Collection should have size less  than $size")
      }

      infix fun <T> Collection<T>.should(fn: CollectionMatchers<T>.() -> Unit) {
        val matchers = CollectionMatchers(this)
        matchers.fn()
      }

    }


Kotlin also ease the creation of an internal DSLs, or fluent interface.
It does that with lambdas and the help of some syntactic sugar.
 Like the fact that the last argument of a function, if it is a lambda,
 can also be put outside of the parentheses.

 This is useful to reduce the need for complex string interpolations. 
For instance, this example uses a library to create HTML.

createHTML().table {
    for (language in languages) {
       tr {
           td { +language.name }
           td { +language.popularity }
       }
    }
}
-->
</html>
