<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Spring map <!-- ignore --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>
<div groupv>
<pre zoom>
<span xsmall>External Links</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/]
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/overview.html#spring-introduction']
@[https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework]
</pre>

<span title>Building Blocks</span>  
<pre zoom>
<span xsmall>IoC container</span>
https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#spring-core
- also known as dependency injection (DI)
- objects define their dependencies through input arguments 
  (in constructor, factories or setters) vs objects controlling 
  building and instantiation themself. 
- The container then injects those input dependencies when it creates the bean.
Base packages:
  org.springframework.beans
  org.springframework.context

˂˂org.springframework.context.BeanFactory˃˃
- provides advanced configuration mechanism
  for "any" type of object.

˂˂org.springframework.context.*ApplicationContext*˃˃
(extends BeanFactory with "Enterprise Features")
- represents the IoC container 
- easier integration with Spring's AOP features
- message resource handling (for use in i18n)
- event publication
- application-layer specific contexts such as 
  - WebApplicationContext

Supplied implementations:
- ClassPathXmlApplicationContext
- FileSystemApplicationContext
 *ApplicationContext*context = 
     new ClassPathXmlApplicationContext ( // Alt 1:
      "services.xml", "daos.xml");
      ^^^^^^^^^^^^^^^^^^^^^^^^^^
  // new GenericGroovyApplicationContext( // Alt 2:
  //  "services.groovy", "daos.groovy");
  // new ...                              // Alt Others:

  MyBeanClass myBean = context*.getBean*("idBeanDef", MyBeanClass.class);
                               ^^^^^^^^ 
                         Ideally an app will never use this method
                         Everything will be "transparent"
 
- Annotation-based configuration(Spring 2.5+)

- Java-based configuration: (Spring 3.0+ by
  moving features from JavaConfig to the Spring core)

- NO explicit user code is required to
  instantiate one or more instances of a Spring IoC container
</pre>

<pre zoom>
<span xsmall>Beans</span>
- backbone objects of the running app.
- Spring IoC container control beans instantiation,
  assembly and (life) management
- Beans and their relationships are reflected
  in configuration metadata

Within the container itself, these bean definitions
are represented as:
*BeanDefinition object*
 class                     https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-class 
 
 name                      https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-beanname 
 
 scope                     https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-scopes 
 
 constructor arguments     https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators 
 
 properties                https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators
 
 autowiring mode           https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-autowire
 
 lazy-initialization mode  https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-lazy-init 
 
 initialization method     https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean 
 
 destruction method        https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean


</pre>

<pre zoom>
<span xsmall>Autowiring</span>

- advantages:
  - reduce the need to specify properties or constructor arguments.
    (bean templates also help in this sense)
  - update a configuration as the app objects evolve.

Autowiring modes Mode      Explanation
no               (Default) No autowiring.
Bean references must be defined via a ref element.
recommended for large deployments

byName:  Ex. if a beans contains a 'master' property (setMaster(...)),
         Spring will looks for a bean definition named 'master'

byType:  works if exactly one bean of the property type exists in the container.
         of fatal exception is thrown.

         arrays and typed-collections wiring will work too.
         All autowire candidates within the container 
         will be added to the collection
         strongly-typed Maps will work if expected key type is String.
          - Maps keys will contain the bean names
          - Maps values will consist of all bean instances that matchs the expected type

constructor: Analogous to byType, but applies to constructor arguments.

</pre>

<pre zoom>
<span xsmall>Method injection</span>
- Suppose singleton A needs to use non-singleton (prototype) bean B
  on each method invocation on A.
- IoC container only creates the singleton A once, and thus only gets
  one opportunity to set the properties.
- By defaul IoC container will NOT provide bean A with a new instance
  of B every time than needed.

Solution A: (Discouraged, makes our design tied to Spring internals)
- Make bean A implement  ˂˂ApplicationContextAware˃˃.
  Make getBean("B") call to the container ask for 
  (a typically new) bean B instance.

Solution B:
- Method Injection
  Lookup method injection is the ability of the IoC container to override
  methods on container managed beans, to return the lookup result for
  another named bean in the container.
- Implemented in Spring Framework by using bytecode generation from the
  CGLIB library to generate dynamically a subclass that overrides the method.
  (class and method cannot be final)
- A further key limitation is that lookup methods won't work with
  factory methods and in particular not with @Bean methods in configuration
  classes, since the container is not in charge of creating the instance
  in that case and therefore cannot create a runtime-generated subclass 
  on the fly.
</pre>

<pre zoom>
<span TODO xsmall>Annotation Config</span>
See the @Configuration, @Bean, @Import and @DependsOn annotations
</pre>

<pre TODO zoom>
<span xsmall>Programatic Config</span>
</pre>

<pre zoom>
<span xsmall>Registrering</span>
<span xsmall>external</span>
<span xsmall>objects</span>
(external  to the container, not recomended)
// returns DefaultListableBeanFactory impl
BeanFactory bFactImpl = 
    "AppCntextInstance".getBeanFactory() 
bFactImpl.registerSingleton(..)
bFactImpl.registerBeanDefinition(..)
</pre>

<pre zoom>
<span xsmall>Scope</span>
<span xsmall>Description</span>
- singleton
  - (Default) Scopes a single bean definition 
    to a single object instance per Spring IoC
    container.
- prototype
  - Scopes a single bean definition to any 
     number of object instances.

- Within the context of a web-aware Spring ApplicationContext
  we also have:
  -*request:*Scopes a single bean definition to the lifecycle
             of a single HTTP request
  -*session:*single bean definition to the lifecycle of
             an HTTP Session. 
  -*application*: Single bean definition for the lifecycle of
             a ServletContext. 
  -*websocket*: Scopes a single bean definition to the
             lifecycle of a WebSocket.
</pre>

<pre zoom>
<span xsmall>Nullability</span>
- the following annotations (org.springframework.lang package)
  declare the nullability of APIs and fields:
  - @NonNull force  parameter, return value or field to be NON-null
  @[https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNull.html]
  - @NonNull allows parameter, return value or field to be     null
  @[https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/Nullable.html]
  -*@NonNullApi package level annotation*
   *declares non-null as the default behavior for parameters and return values*
  @[https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html]
  -*@NonNullFields package level annotation*
   *declares non-null as the default behavior for fields*
  @[https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html]
</pre>

<pre zoom>
<span xsmall>Configuration</span>
- Spring sets properties and resolves dependencies 
  as late as possible, when the bean is actually
  created.
- To avoid "fail-late" error ApplicationContext 
  implementations by default pre-instantiate 
  singleton beans
  (can be disabled with bean lazy-init="true"
   attribute -discouraged-)
- ˂idref˃ is prefered to property with value
  attribute (fails-faster)
- bean *depends-on* attribute can force initialization
  (and destruction) order
- autowire: None, byName, byType, constructor

<span xsmall>xml config</span>
<span xsmall>example</span>

xml config inport:

NOTE:  Other namespaces appart of beans are also
       provided such as "context" and "util" 
       for extra config. options

˂?xml version="1.0" encoding="UTF-8"?˃
˂beans xmlns="http://www...schema/beans"
  ˂xmlns:xsi= "http://www.w3.org/2001/XMLSchema-instance"
  ˂xsi:schemaLocation="http://.../schema/beans
     http://..../schema/beans/spring-beans.xsd"˃

 ˂!-- *including (importing) other xml --˃
 ˂import resource="/resources/messaging.xml"/˃
 ˂import resource="/resources/persistence.xml"/˃
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
                   relative to current xml.
                     → "/resources/..." is 'down' current xml path
 ˂import resource="custom.xml"/˃
 ˂import resource="file:/config/custom.xml"/˃
                   ^^^^^^^^^^^^^^^^^^^^^^^^
                   Absolute system dependent file (discouraged)
 ˂import resource="classpath:/config/otherResources.xml"/˃
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   Absolute classpath (discouraged) 
 ˂import resource="file:${JVM_RUNTIME_ENV_VAR}/....xml"/˃
                        ^^^^^^^^^^^^^^^^^^^^^^
                        Use JVM ENV.VARs (*DevOps friendly*)

                   


  ˂bean B*id*="idFactoryInst" class="..."˃˂/bean˃ ˂-- Using factory --˃
               ^^^^^^^^^^^^^  
               convention:
               initial lower-case + camelCase
              (With auto-scanned beans, spring will
               take the className and convert 
               first letter to lower-case.
               - java.beans.Introspector.decapitalize -)

  ˂--*Using Constructor*--˃
  ˂bean B*id*="idBeanDefinition1" 
          class="my.full.qualified.ClassName1"
          depends-on="beanId1,beanId2,..."
          ^^^^^^^^^^
        - Sometimes dependencies between beans are in-direct and 'ref' to
          another bean is not enough. For example an static initializer in
          a class needs to be triggered. In this case 
          'depends-on' will explicitly force dependent-on beans to be 
          initialized in order.
        - In the case of singleton beans only, it can also
          indicate a destroy time dependency (shutdown order)




   *˂constructor-arG*g*ref*="bar"/˃
   *˂constructor-arG*g*ref*="baz"/˃
   *˂constructor-arg*  type="int" index="0" value="23" /˃
   *˂constructor-arg*  type="int" index="1" value="10" /˃
                                  ^^^^^^^^^ 
                        The index resolves the ambiguity a constructor 
                        with two arguments of the same type.
                        Name can also be used to disambiguate like :
                        ˂constructor-arg name="years" value="23"/˃
                        ˂constructor-arg name="ultimateAnswer" value="10"/˃
  ˂/bean˃
 
  USING SETTERS:
  - discouraged in favour of constructor based , since favour "safer" code.
  - Can be useful if there are circular dependencies between two
    beans at initialization time.

  ˂bean B*id*="idBeanDefinition2" name="alias1;alias2" class="my.full.qualified.ClassName2"˃
                                  ^^^^^^^^^^^^^^^^^^^^
                                  allows for alias to the id
                                  Most probably alias are used in
                                  multi-module projects like:
                          ˂alias name="dataSource"            alias="subsystemA-dataSource"/˃
                          ˂alias name="subsystemB-dataSource" alias="subsystemB-dataSource"/˃
    ˂constructor-arg G*ref*="bar"/˃
    ˂constructor-arg G*ref*="baz"/˃

    ˂!-- TODO 
        Bean behavioral configuration elements, stating how bean should behave 
        (scope, lifecycle callbacks, ...).
    --˃

    STATIC FACTORY METHOD
    ˂property name="myInnerBean"˃ 
      ˂bean B*id*="idMyBuildBean" 
            class="my.full.qualified.Factory" 
       *factory-method*="createInstance"/˃
       ^^^^^^^^^^^^^^^^
    ˂/property˃

    USING INSTANCE B*FACTORY METHOD* FOR G*ANOTHER BEAN*
    (No class is specified in this case, resolved from type 
     returned by *B*gactory-method*)
    ˂bean          id="clientService"                      
       G*factory-bean="serviceLocator"*
       B*factory-method="createClientServiceInstance"*/˃
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    The serviceLocatos Class would be similar to
    public class DefaultServiceLocator {
      public ClientService B*createClientServiceInstance()* { ... }
             ^^^^^^^^^^^^^
             built bean class type
      public AccountService  createAccountServiceInstance() { ... }
    }

    ˂-- non-static factory method --˃
    ˂property name="myInnerBean2"˃
      ˂bean factory-bean="idFactoryInst" factory-method="createInstance"˃
        ˂constructor-arg G*ref*="factoryArg1Ref"/˃
      ˂/bean˃

      ˂!-- java.util.Properties --˃
      ˂property name="myConfProps"˃
        ˂value˃
          prop1=val1
          prop2=val2
        ˂/value˃
      ˂/property˃
    ˂/property˃

    ˂!-- Spring Expresion Language --˃
    ˂property name="randomNumber" value="#{ T(java.lang.Math).random() }" /˃

    ˂-- non static factory method --˃
    ˂property name="accountDao" G*ref*="idAccountDaoBeanDef"/˃
    ˂property name="itemDao" G*ref*="idItemDaoBeanDef"/˃
  ˂/bean˃
  ˂alias name="DataSource" alias="subsystemA-DS"/˃
  ...
˂/beans˃
<span xsmall>Programatic</span>
<span xsmall>Configuration</span>
<span xsmall>(Annotations)</span>
package ...;

public class ExampleBean {
  @Autowired
  private MyClass2 beanTwo;

  @ConstructorProperties({"years", "ultimateAnswer"})
  public ExampleBean(int years, String ultimateAnswer) 
  {
      ...
  }

  @Autowired
  @Required
  public void setBeanOne(AnotherBean beanOne) {
      ...
  }
}
</pre>

<pre zoom>
<span xsmall>*Collections*</span>

(˂list/˃, ˂set/˃, ˂map/˃, ˂props/˃)

˂bean id="moreComplexObject" class="example.ComplexObject"˃
  ˂property name="adminEmails"˃ ←*will call setAdminEmails(Properties ...)*
    ˂props˃
      ˂prop key="administrator"˃administrator@example.org˂/prop˃
      ˂prop key="support"      ˃support@example.org˂/prop˃
      ...
    ˂/props˃
  ˂/property˃
  ˂property name="someList"˃   ←*will call setSomeList(List ...) *
    ˂list˃
      ˂ref bean="myDataSource0" /˃
      ˂ref bean="myDataSource1" /˃
      ...
    ˂/list˃
  ˂/property˃
  ˂property name="someMap"˃    ←*will call setSomeMap(Map ...) *
    ˂map˃
┌──→  ˂entry key="key1"  value    ="just some string"/˃
│     ˂entry key="a ref" value-ref="myDataSource"/˃
│   ˂/map˃
│ ˂/property˃
│ ˂property name="someSet"˃    ←*will call setSomeSet(Map ...) *
│   ˂set˃
├──→  ˂value˃string 01˂/value˃
│     ˂value˃string 02˂/value˃
│     ...
│     ˂ref bean="myDataSource" /˃
│   ˂/set˃
│ ˂/property˃
│ ^^^^^^^^^^^^^^^^^^^^^^^^ 
└─The value of a map key or value, or a set value,
  bean | ref | idref | list | set | map | props | value | null
˂/bean˃

*Collection merging*
- The Spring container also supports merging of collections.
- In parent-child like relationships for 
  ˂list/˃, ˂map/˃, ˂set/˃ or ˂props/˃
Ex:
   ˂beans˃
     ˂bean id="parentBean" 
       B*abstract="true"* class="example.ComplexObject"˃
       ˂property name="adminEmails"˃
         ˂props˃
           ˂prop key="administrator"˃administrator@example.com˂/prop˃
           ˂prop key="support"˃support@example.com˂/prop˃
         ˂/props˃
       ˂/property˃
     ˂/bean˃
     ˂bean id="child" B*parent="parentBean"*˃
       ˂property name="adminEmails"˃
         ˂!-- the merge is specified on the child collection definition --˃
┌─────→  ˂props B*merge="true"*˃
│          ˂prop key="sales"˃sales@example.com˂/prop˃
│          ˂prop key="support"˃support@example.co.uk˂/prop˃
│        ˂/props˃
│      ˂/property˃
│    ˂/bean˃
│  ˂beans˃
│  
└─ adminEmails Properties will contain result of the merging of the child's
   adminEmails collection with the parent's adminEmails collection.
 
  In the list case the *order criterium* is that
  of parent's values preceding all of the child list's values.

</pre>

<pre zoom>
<span xsmall>Null,</span>
<span xsmall>empty string</span>
<span xsmall>values</span>
- empty arguments for properties,... convert to "" empty String.
- ˂null/˃ element handles null values. Ex
  ˂property name="email"˃
    ˂null/˃
  ˂/property˃
</pre>

<pre zoom>
<span xsmall>Groovy DSL</span>
Ex: config.groovy
(XML bean definition can be included through "importBeans" directive)
beans {
  dataSource(BasicDataSource) {
    driverClassName = "org.hsqldb.jdbcDriver"
    url = "jdbc:hsqldb:mem:grailsDB"
    username = "sa"
    password = ""
    settings = [mynew:"setting"]
  }
  sessionFactory(SessionFactory) {
    dataSource = dataSource
  }
  myService(MyService) {
    nestedBean = { AnotherBean bean -˃
      dataSource = dataSource
    }
  }
}
</pre>
</div>


<div groupv>
<span title>Reactive WebFlux</span>  
<pre zoom>
<span xsmall>Reactive</span>
<span xsmall>Stack</span>
<span xsmall>(Spring 5.0+)</span>
<span xsmall>Reactive Web</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux]
- Note: Servlet 3.1+ API for non-blocking I/O leads away from
  the rest of the Servlet API where contracts are synchronous 
  (Filter, Servlet) or blocking (getParameter, getPart).
- fully non-blocking, handling concurrency with a small number of threads
- supports Reactive Streams non-blocking back pressure:
  In synch/imperative code, blocking calls serve as a natural form
  of back pressure that forces the caller to wait.
  In non-blocking code it becomes important to control the rate 
   of events so that a fast producer does not overwhelm its destination.
  Spring Reactive Streams is a small spec, also adopted in Java 9,
  that defines the interaction between asynchronous components 
  with back pressure. Ex: a data repository (Publisher),
  produces data that an HTTP server (Subscriber), can then "forward"
  to the response. Main purpose of Reactive Streams is to allow
  the subscriber to control how fast or how slow the publisher
  will produce data.
  If a publisher can’t slow down then it has to decide whether
  to buffer, drop, or fail.
- As a general rule WebFlux APIs accept a plain Publisher as input,
  adapt it to Reactor types internally, use those, and then return
  either Flux or Mono as output.
- runs on Netty, Undertow, Servlet 3.1+ containers
- TODO: WebClient
- TODO: WebTestClient
- TODO: WebSocket
- The spring-web module contains the reactive building block:  
  HTTP abstractions, Reactive Streams server adapters, reactive codecs, 
  and a core Web API.
- public spring-web APIs Server support is organized in two layers:
  - HttpHandler and server adapters : the most basic, common API for HTTP 
    request handling with Reactive Streams back pressure running on different 
    servers.
  - WebHandler API : slightly higher level but still general purpose server 
    web API with exception handlers (WebExceptionHandler), filters (WebFilter), 
    and a target handler (WebHandler)
    All components work on ServerWebExchange — a container for the HTTP 
    request and response that also adds request attributes, session attributes, 
    access to form data, multipart data, and more.
- Codecs: The spring-web module provides 
  HttpMessageReader(DecoderHttpMessageReader) and 
  HttpMessageWriter(EncoderHttpMessageWriter) for encoding and decoding the
  HTTP request and response body with Reactive Streams.
  Basic Encoder and Decoder implementations exist in spring-core but 
  spring-web adds more for JSON, XML, and other formats.
</pre>

<pre zoom>
<span xsmall>DispatcherHandler</span>
- central controller
- discovers delegate components from Spring configuration
  If declared with the bean name "webHandler" it is in turn
  discovered by WebHttpHandlerBuilder which puts together a 
  request processing chain as described in WebHandler API
- typical WebFlux application Spring configuration:
  - DispatcherHandler named "webHandler"
  - WebFilters
  - WebExceptionHandlers
  - DispatcherHandler special beans
  - Others
- The configuration is given to WebHttpHandlerBuilder to 
  build the processing chain:
 (The resulting HttpHandler is ready for use with a server adapter)
  ApplicationContext context = ...
  HttpHandler handler = WebHttpHandlerBuilder.
      applicationContext(context);
- "special beans":  Spring-managed instances implementing one of the contracts listed:

  Bean type            | Explanation
  ---------------------+------------------------------------
  HandlerMapping       | Map a request to a handler.
                       | mapping is based on some criteria
                       | the details of which vary by 
                       | HandlerMapping implementation 
                       | (annotated controllers, 
                       | simple URL pattern mappings,...)
  ---------------------+------------------------------------
  HandlerAdapter       | Helps the DispatcherHandler to
                       | invoke a handler mapped to a 
                       | request regardless of how the
                       | handler is actually invoked. 
                       | For example invoking an annotated
                       | controller requires resolving
                       | various annotations. The main
                       | purpose of a HandlerAdapter
                       | is to shield the DispatcherHandler
                       | from such details.
  ---------------------+------------------------------------
  HandlerResultHandler | Process the HandlerResult returned
                       | from a HandlerAdapter

- request flow:
  for map in HandlerMapping_list:
    //  (continue is map doesn't match request)
    handler = first handler in map matching request
    HandlerResult res = handler()
    HandlerResultHandler(res)

  Rules  
  1) Each HandlerMapping is asked to find a
     matching handler and the first match is used
  2) If a handler is found, it is executed through
     an appropriate HandlerAdapter which exposes 
     the return value from the execution as
     HandlerResult.
  3) The HandlerResult is given to an appropriate
     HandlerResultHandler to complete processing 
     by writing to the response directly or using
     a view to render.
</pre>

<pre zoom>
<span xsmall>Processing</span>
<span xsmall>Chain</span>
- The processing chain can be put together with WebHttpHandlerBuilder which builds an
HttpHandler that in turn can be run with a server adapter.
To use the builder either add components individually or point to an ApplicationContext
to have the following detected:<p>

 ┌──────────────────────────────────────────────────────────────────────────────────────────
 │Bean name             │Bean type            │Count│ Description
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │webHandler            │WebHandler           │1    │ Target handler after filters
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │"any"                 │WebFilter            │0..N │ Filters
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │"any"                 │WebExceptionHandler  │0..N │ Exception handlers after filter chain
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │webSessionManager     │WebSessionManager    │0..1 │ Custom session manager
 │                      │                     │     │ DefaultWebSessionManager by default
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │serverCodecConfigurer │ServerCodecConfigurer│0..1 │ Custom form and multipart data decoders
 │                      │                     │     │ ServerCodecConfigurer.create() by default
 ├──────────────────────┼─────────────────────┼─────┼───────────────────────────────────────
 │localeContextResolver │LocaleContextResolver│0..1 │ Custom resolver for LocaleContext;
 │                      │                     │     │ AcceptHeaderLocaleContextResolver by default
 └──────────────────────┴─────────────────────┴─────┴───────────────────────────────────────
</pre>

<pre zoom>
<span xsmall>Required</span>
<span xsmall>dependencies</span>
Server name     │  Group id              │ Artifact name      │  Code snippet
────────────────┼────────────────────────┼────────────────────┼────────────────
Reactor Netty   │ io.projectreactor.ipc  │ reactor-netty      │ HttpHandler handler = ...
                │                        │                    │ ReactorHttpHandlerAdapter adapter = 
                │                        │                    │     new ReactorHttpHandlerAdapter(handler);
                │                        │                    │ HttpServer.create(host, port).
                │                        │                    │     newHandler(adapter).block();
────────────────┼────────────────────────┼────────────────────┼────────────────
Undertow        │ io.undertow            │ undertow-core      │ HttpHandler handler = ...
                │                        │                    │ UndertowHttpHandlerAdapter adapter =
                │                        │                    │      new UndertowHttpHandlerAdapter(handler);
                │                        │                    │ Undertow server = Undertow.builder().
                │                        │                    │      addHttpListener(port, host).
                │                        │                    │      setHandler(adapter).build();
                │                        │                    │ server.start();
────────────────┼────────────────────────┼────────────────────┼────────────────
Tomcat          │ org.apache.tomcat.embe │ omcat-embed-core   │ HttpHandler handler = ...
                │                        │                    │ Servlet servlet = new 
                │                        │                    │     TomcatHttpHandlerAdapter(handler);
                │                        │                    │ 
                │                        │                    │ Tomcat server = new Tomcat();
                │                        │                    │ File base = new File(
                │                        │                    │    System.getProperty("java.io.tmpdir"));
                │                        │                    │ Context rootContext = server.
                │                        │                    │    addContext("", base.getAbsolutePath());
                │                        │                    │ Tomcat.addServlet(rootContext, "main", servlet);
                │                        │                    │ rootContext.addServletMappingDecoded("/", "main");
                │                        │                    │ server.setHost(host);
                │                        │                    │ server.setPort(port);
                │                        │                    │ server.start();
────────────────┼────────────────────────┼────────────────────┼────────────────
Jetty           │ org.eclipse.jetty      │ etty-server        │ HttpHandler handler = ...
                │                        │ etty-servlet       │ Servlet servlet = 
                │                        │                    │     new JettyHttpHandlerAdapter(handler);
                │                        │                    │ 
                │                        │                    │ Server server = new Server();
                │                        │                    │ ServletContextHandler contextHandler =
                │                        │                    │     new ServletContextHandler(server, "");
                │                        │                    │ contextHandler.addServlet(
                │                        │                    │     new ServletHolder(servlet), "/");
                │                        │                    │ contextHandler.start();
                │                        │                    │ 
                │                        │                    │ ServerConnector connector =
                │                        │                    │     new ServerConnector(server);
                │                        │                    │ connector.setHost(host);
                │                        │                    │ connector.setPort(port);
                │                        │                    │ server.addConnector(connector);
                │                        │                    │ server.start();
────────────────┴────────────────────────┴────────────────────┴────────────────

</pre>

<span title>Annotated Controllers</span>
    
<pre TODO zoom>
<span xsmall>DATA-ACCESS</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/data-access.html]
</pre>

<pre TODO zoom>
<span xsmall>TESTING</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/testing.html]
</pre>

<pre TODO zoom>
<span xsmall>INTEGRATION</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/integration.html]
</pre>
</div>

<div groupv>
<span title>Un-ordered</span>

<pre TODO zoom>
<span xsmall>scan config</span>
<span xsmall>auto-detection</span>
<span xsmall></span>
</pre>

<pre TODO zoom>
<span xsmall>MVC</span>
@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc]
</pre>

<pre TODO zoom>
<span xsmall>Eclipse IDE</span>
Spring Tool Suite Eclipse-powered development environment
</pre>

<pre zoom>
<span xsmall>@Required</span>
- @Required on a setter method can be used to make the property
   a required dependency.
</pre>

<pre TODO zoom>
<span xsmall>GraalVM integration</span>
<span xsmall>Spring</span>
<span xsmall>Issues</span>
UUID: 6374869e-4921-497d-9d43-75fb6ae1c9c9
REF:
@[https://github.com/spring-projects/spring-framework/wiki/GraalVM-native-image-support]
Working toward GraalVM native image support without requiring additional 
configuration or workaround is one of the themes of upcoming Spring Framework 
5.3. The main missing piece for considering GraalVM as a suitable deployment 
target for Spring applications is providing custom GraalVM Feature 
implementation at Spring Framework level to automatically register classes 
used in the dependency mechanism or Spring factories, see the related issue #
22968 for more details.
</pre>

<pre zoom TODO>
<span xsmall>Spring 5 Security</span>
</pre>



<pre TODO zoom>
<span xsmall>Spring vs Guice</span>
@[https://www.baeldung.com/guice-spring-dependency-injection]
</pre>

</div>
</body>
</html>
<!--
  //@[https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#resources]

--˃
