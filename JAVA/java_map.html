<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>JAVA map(v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table>
<tr {>
<td>
  Ext.Links
  <ul xsmall zoom > 
  <li> <a href="https://docs.oracle.com/javase/8/docs/api/index.html">API</a></li>
  <li> <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share">OpenJDK@Mercurial</a></li>
  <li> <a href="https://zeroturnaround.com/wp-content/uploads/2014/06/jtnt-mindmap.png">JAVA MIND-MAP</a></li>
  <li> <a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">(Active) Java JVM List</a> </li>
  <li> <a href="https://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-improve_code_quality.htm&cp=1_3_9">Eclipe Tools for [QA]</a> </li>
  </ul> 
  <b xsmall>JavaDoc</b>
<pre xxxsmall zoom {>
-----------------------+-------------------------------------+-------------------------+-------   Example
Tag& Parameter         | Usage                               | Applies to              | Since    /**
-----------------------+-------------------------------------+-------------------------+-------    * Short one line description.
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * Longer description. ... 
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |           * ...here.
                       | Max one per Class or Interface.     |                         |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * And even more explanations to follow 
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |           * in consecutive paragraphs
                       | has first existed.                  | Field, Method           |           *
-----------------------+-------------------------------------+-------------------------+-------    * @author John Bla
@seereference          | Provides a link to other element    | Class, Interface, Enum, |           * @param  variable Description ....
                       | of documentation.                   | Field, Method           |           * @return Description ....
-----------------------+-------------------------------------+-------------------------+-------    */
@paramname descrip     | Describes a method parameter.       | Method                  |          public int methodName (...) {
-----------------------+-------------------------------------+-------------------------+-------       // method body with a return statement
@return description    | Describes the return value.         | Method                  |          }
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |  
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | <code>{@literal}</code>.            | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
</pre }>
</td>
<td colsep> </td>
<td>
  <code><b orange>java.time</b>.*(1.8+)</code>
  <span xxsmall>("deprecates" java.util.(Date|Calendar|TimeZome)</span>
  <ul xxxsmall zoom >
  <li>All the classes are immutable and thread-safe</li>
  </ul>
  <span orange>Parsing DateTime Ex:</span>
<pre xxxsmall zoom { >
import java.time.Instant;
// Build from "now", current time
Instant timestamp = Instant.now(); 
        timestamp.plus(Duration.ofSeconds(10)).
// Build from ZonedDateTime "20170630010203.100Z",
Instant.from(ZonedDateTime.of(2017, 6, 30, 1, 2, 3, (int) TimeUnit.MILLISECONDS.toNanos(100), ZoneId.of("Z"))) 
// ZoneId: ZoneId.of("-02:00"), ZoneId.of("Z"), ZoneId.of("Asia/Tokyo")
// Build from ZonedDateTime String
Instant.from(ZonedDateTime.parse(sExpiresAt)) 
// Ej: 
timestamp.toString() // Produces something like similar to 2013-05-30T23:38:23.085Z
</pre } >
  <spam xsmall>Up to 1.8 compatibility:</span>
  <ul xxxsmall zoom >
  <li>Prior to the Java SE 8 release, the Java date and time mechanism was provided 
    by the  java.util.Date, java.util.Calendar, and java.util.TimeZone classes, as 
    well as their subclasses, such as java.util.GregorianCalendar.
  </li>
  <li>These classes had several drawbacks, including:<br/>
  - The Calendar class was not type safe.<br/>
  - classes were mutable, could NOT be used in multithreaded applications.<br/>
  - Bugs in application code were common due to the unusual numbering of 
    months and the lack of type safety.
  </li>
  <li>JDK 8+ add conversion methods between java.util and java.time:<br/>
  - Calendar.toInstant() converts the Calendar object to an Instant.
  - GregorianCalendar.toZonedDateTime() converts a GregorianCalendar instance 
    to a ZonedDateTime.<br/>
  - GregorianCalendar.from(ZonedDateTime) creates a GregorianCalendar object 
    using the default locale from a ZonedDateTime instance.<br/>
  - Date.from(Instant) creates a Date object from an Instant.<br/>
  - Date.toInstant() converts a Date object to an Instant.<br/>
  - TimeZone.toZoneId() converts a TimeZone object to a ZoneId.<br/>
  </li>
  </ul>
   
  Java 9 <a href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>REF</a>
  <ul xxxsmall zoom >
  <li>A number of parsing and formatting changes have been incorporated in Java 9 to 
bring the functionality closer to Unicode Locale Data Markup Language (LDML). 
These changes have been supervised by Stephen Colebourne, creator of the popular
 date-time library JodaTime, precursor of the new java.time component in Java 8.
Abiding by the Unicode standard will provide better interoperability with other
non-Java systems.</li>
  <li>
    LDML is the language used by the Unicode Common Locale Data Repository (CLDR), 
    a project of the Unicode Consortium to gather and store locale data from 
    different parts of the world, enabling application developers to better adapt 
    their programs to different cultures. Among other things, LDML deals with dates,
    times, and timezones, and more particularly with date formatting and parsing. 
    The following is an extract of new features coming in Java 9 that bring java.time 
    closer to the LDML specification:
    <ul>
      <li>JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as 
        specified in LDML, indicates a “Modified Julian day”; this is different from a 
        normal Julian day in the sense that a) it depends on local time, rather than GMT,
        and b) it demarcates days at midnight, as opposed to noon.</li>
      <li>JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML
        formats to indicate “generic non-location format”, e.g. “Pacific Time”, as 
        opposed to the “generic location format” with specifies a city, like 
        “Los Angeles Time”.</li>
      <li>JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML
        doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current 
        behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the
        total number of milliseconds elapsed in the day, with variable width, but 
        currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it
        will fail to parse any value that is further than 99 milliseconds in the day. 
        ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds 
        within the second, and nanoseconds within the day, respectively.</li>
      <li>JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit
        day-of-year value: similar to the previous problem, but with ‘D’ representing 
        days within a year. If one specifies “DD” as a pattern, it will fail to parse 
        “123” as the 123th day of the year.</li>
    </ul>
  </li>
  <li>As previously mentioned, a better alignment with the LDML will ease 
interoperability across systems, since there are multiple technologies that 
have adopted the LDML to some degree. Microsoft .NET uses LDML for general 
interexchange of locale data, and there are packages available for Node.js 
and Ruby, just to mention a few.</li>
  </ul>
</td>
<td>
    java.time. Package
<pre xxxsmall zoom {>
                   Description
-----------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and 
                   time using a time-zone.
-----------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
-----------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
-----------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system, 
                   such as 2007-12-03.
-----------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar 
                   system, such as 2007-12-03T10:15:30.
-----------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system, 
                   such as 10:15:30.
-----------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
-----------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 2007-12-03T10:15:30+01:00.
-----------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601 
                   calendar system, such as 10:15:30+01:00.
-----------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system,
                    such as '2 years, 3 months and 4 days'.
-----------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
-----------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12
-----------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03T10:15:30+01:00 Europe/Paris.
-----------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
-----------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
-----------------------------------------------------------------------------------


Enum               Description
-----------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
-----------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
-----------------------------------------------------------------------------------

Exception          Description
-----------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.
</pre } >
    java.text.MessageFormat:
<pre xxxsmall zoom {>
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale()) 
  
time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())
</pre }>
</td>
<td colsep> </td>
<td>
  ANNOTATIONS
  <ul xxxsmall zoom { >
    <li>
    Annotation types are a form of interface:
<pre {>
DECLARATION(interface is preceded by the @ sign)| USAGE
  @interface ClassPreamble {                    |   @ClassPreamble (
     String   author        ()              ;   |      author         = "John Doe"      ,
     String   date          ()              ;   |      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;   |      currentRev     = 6               ,
     String   lastModified  () default "N/A";   |      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";   |      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;   |      reviewers      = {"Alice", "Bob"}
  }                                             |   )
                                                | public class Generation3List extends Generation2List {
                                                |     // ...
                                                | }
</pre }> 
    </li>
    <li>
      Annotations can be applied to declarations of: classes, fields, methods, other program elements. 
      When used on a declaration, each annotation often appears, *by convention*, on its own line.<br/>
      As of the Java SE 8 release, annotations can also be applied to the use of types. A few examples of where
      types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses
<pre {>I
Ex. Class instance creation expression:      new @Interned MyObject();
----------------------------------------------------------------------
Ex. Type cast:                            |  myString = (@NonNull String) str;
------------------------------------------+---------------------------
Ex. implements clause:                    |  class UnmodifiableList<T> implements
                                          |        @Readonly List<@Readonly T> { ... }
------------------------------------------+---------------------------
Ex. thrown exception declaration:         |  void monitorTemperature() throws 
                                          |        @Critical TemperatureException { ... }
------------------------------------------+---------------------------
</pre }>I
    </li>
    <li>
Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, 
annotate the @ClassPreamble DECLARATION wih @Documented annotation like:
<pre {>
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
   ...
} 
</pre }>I
    </li>
    <li>
        predefined annotation types defined in java.lang:
        @Deprecated   @Override   @SuppressWarnings
<pre { >
Ex: @SuppressWarnings(value = "unchecked")
    void myMethod() { ... }
    @SuppressWarnings({"unchecked", "deprecation"})
    void myMethod() { ... }
</pre }>
    </li>
    <li>@SafeVarargs (Java ?+) when applied to a method or constructor, asserts that the code does not perform potentially 
    unsafe operations on its varargs parameter. Unchecked warnings relating to varargs usage are suppressed.
    </li>
  </ul>
</td>
<td>
  META-ANNOTATIONS
  <ul xxxsmall zoom >
  <li>Annotations that apply to other annotations.<br/>
    There are several meta-annotation types defined in java.lang.annotation.<br/>
    @Retention: specifies how the marked annotation is stored:
<pre { >
RetentionPolicy.SOURCE: annotation is retained only in source level and is ignored by the compiler.
RetentionPolicy.CLASS: annotation is retained by compiler, but ignored by the (JVM)
RetentionPolicy.RUNTIME: annotation is retained by the JVM, can be used@RunTime 
</pre }>
    @Documented: indicates that whenever the specified annotation is used those
    elements should be documented using the Javadoc tool. (By default, annotations
    are not included in Javadoc.)<br/>
    @Target meta-annotation marks another annotation to restrict what kind of 
    Java elements the annotation can be applied to.
<pre { >
ElementType.ANNOTATION_TYPE can be applied to an annotation type.
ElementType.CONSTRUCTOR can be applied to a constructor.
ElementType.FIELD can be applied to a field or property.
ElementType.LOCAL_VARIABLE can be applied to a local variable.
ElementType.METHOD can be applied to a method-level annotation.
ElementType.PACKAGE can be applied to a package declaration.
ElementType.PARAMETER can be applied to the parameters of a method.
ElementType.TYPE can be applied to any element of a class.
</pre }>
   @Inherited meta-annotation indicates that the annotation type can be inherited
   from the super class. (This is not true by default.) When the user queries 
   the annotation type and the class has no annotation for this type, the class'
   superclass is queried for the annotation type. This annotation applies only 
   to class declarations.<br/>
   @Repeatable annotation (Java 8+), indicates that the marked annotation can be applied more than once to the same declaration or type use.
Ref: http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
<pre { >
Ex:
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
</pre }>
  </li>
  </ul>
  <hr xxxsmall />
  <a href="https://www.slf4j.org/">SLF4j Logging</a>
<pre xxxsmall zoom>
Simple Log Facade or abstraction for various logging frameworks 
(e.g. java.util.logging, logback, log4j) allowing the end user
to plug in the desired logging framework at deployment time. 

pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
  &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;
    ______________________________
    Adding logback facade to slf4j (pom.xml):
    | &lt;dependency&gt;
    |   &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    |   &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    |   &lt;exclusions&gt;
    |     &lt;!-- Avoid problem:
    |          SLF4J: Class path contains multiple SLF4J bindings.
    |     SLF4J: Found binding in [jar:file:/home/azureuser/.m2/repository/org/slf4j/slf4j-jdk14/1.7.21/slf4j-jdk14-1.7.21.jar!/org/slf4j/impl/StaticLoggerBinder.class]
    |     SLF4J: Found binding in [jar:file:/home/azureuser/.m2/repository/ch/qos/logback/logback-classic/1.1.7/logback-classic-1.1.7.jar!/org/slf4j/impl/StaticLoggerBinder.class]
    |     --&gt;
    |     &lt;exclusion&gt;
    |       &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    |       &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
    |     &lt;/exclusion&gt;
    |   &lt;/exclusions&gt;
    |   &lt;version&gt;1.1.7&lt;/version&gt;
    | &lt;/dependency&gt;
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    logback configuration:
    | (src/main/resources/)logback.xml
    | &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    | &lt;configuration&gt;
    |     &lt;!-- &lt;jmxConfigurator /&gt; --&gt;
    |     &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    |         &lt;file&gt;log&lt;/file&gt;
    |         &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
    |             &lt;!-- daily rollover --&gt;
    |             &lt;fileNamePattern&gt;%d{yyyy-MM-dd}.log.zip&lt;/fileNamePattern&gt;
    |             &lt;maxFileSize&gt;1MB&lt;/maxFileSize&gt; 
    |             &lt;!-- keep 2 days' worth of history capped at 1MB total size --&gt;
    |             &lt;maxHistory&gt;2&lt;/maxHistory&gt;
    |             &lt;totalSizeCap&gt;2MB&lt;/totalSizeCap&gt;
    |         &lt;/rollingPolicy&gt;
    |         &lt;encoder&gt;
    |             &lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;
    |         &lt;/encoder&gt;
    |     &lt;/appender&gt;
    |       
    |     &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    |         &lt;encoder&gt;
    |             &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    |         &lt;/encoder&gt;
    |     &lt;/appender&gt;
    | 
    |     &lt;logger name="my.company.package" level="INFO"/&gt;        
    |     &lt;logger name="my.company.package.subpackage" level="DEBUG"/&gt;
    |     &lt;logger name="org.eclipse.jetty" level="INFO"/&gt;
    | 
    |     &lt;root level="WARN"&gt;
    |         &lt;appender-ref ref="STDOUT" /&gt;
    |         &lt;appender-ref ref="FILE" /&gt;
    |     &lt;/root&gt;  
    | &lt;/configuration&gt;
______________________________
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
...
  class MyClass {
    private static final Logger log = LoggerFactory.getLogger(AbstractRequestHandler.class);
    ...
    if (log.isDebugEnabled()) {  
        //  <b>^ Avoid the slow String construction if log not enabled</b>
        log.debug("Lorem ipsum... @{} {}", "debug param1", "debug param2");
    }
    ...

</pre>
</td>
</tr }>
</table>
<table>
<tr {>
  <th colspan=12 header_delimit >Java Collections</th></li>
</tr }>
<tr {>
<td>
  <ul xxxsmall zoom> 
  <li>
<pre xxxsmall zoom>
Standard SDK (non-concurrent):
              ←───────────────────────────────────── IMPLEMENTATIONS   ─────────────────────────────────────────→
              Hash Table       Resizable Array       Balanced Tree       Linked List     Hash Table + Linked List
↓INTERFACES↓
       Set    <a href="http://download.oracle.com/javase/6/docs/api/java/util/HashSet.html">HashSet</a>                                <a href="http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html">TreeSet</a>                             <a href="http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashSet.html">LinkedHashSet</a>
      List                     <a href="http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html">ArrayList</a> <a href="http://download.oracle.com/javase/6/docs/api/index.html">Vector</a>                          <a href="http://download.oracle.com/javase/6/docs/api/java/util/LinkedList.html">LinkedList</a>
      Map     <a href="http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> <a href="http://download.oracle.com/javase/6/docs/api/index.html">Hashtable</a>                      <a href="http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html">TreeMap</a>                             <a href="http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>

<a href="http://files.zeroturnaround.com/pdf/zt_java_collections_cheat_sheet.pdf">ref</a>
┌─────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────┐
│Collection       │ Thread-safe                ┃          YOUR DATA              ┃           OPERATIONS    ALLOWED       │
│                 │ alternative                ┃─────────────────────────────────┃───────────────────────────────────────┤
│class            │                            ┃Individu│Key-val.│Duplica│Primite┃ Iteration Order │Fast │ Random Access │
│                 │                            ┃elements│  pairs │element│support┃FIFO │Sorted│LIFO│'has'│By  │By   │By  │
│                 │                            ┃        │        │support│       ┃     │      │    │check│Key │Val  │Idx │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashMap          │ ConcurrentHashMap          ┃        │YES     │       │       ┃     │      │    │YES  │ YES│     │    │
│                 │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashBiMap(Guava) │ Maps.syncrhonizedBiMap     ┃        │YES     │       │       ┃     │      │    │YES  │ YES│YES  │    │
│                 │ (new HashBiMap())          ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayListMultimap│ Maps.synchronizedMultiMap  ┃        │YES     │YES    │       ┃     │      │    │YES  │ YES│     │    │
│   (Guava)       │ (new ArrayListMultimap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│LinkedHashMap    │ Collections.syncrhonizedMap┃        │YES     │       │       ┃YES  │      │    │YES  │ YES│     │    │
│                 │ (new LinkedHashMap())      ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│TreeMap          │ ConcurrentSkipListMap      ┃        │YES     │       │       ┃     │YES   │    │YES  │ YES│     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│Int2IntMap       │                            ┃        │YES     │       │YES    ┃     │      │    │YES  │ YES│     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayList        │ CopyOnWriteArrayList       ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │YES │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashSet          │ Collections.newSetFromMap  ┃YES     │        │       │       ┃     │      │    │YES  │    │YES  │    │
│                 │ (new ConcurrentHashMap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│IntArrayList     │                            ┃YES     │        │YES    │YES    ┃YES  │      │YES │     │    │     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│PriorityQueue    │ PriorityBlockingQueue      ┃YES     │        │YES    │       ┃     │YES   │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayDeque       │ ArrayBlockingQueue         ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │    │
└─────────────────┴────────────────────────────┃────────┴────────┴───────┴───────┃─────┴──────┴────┴─────┴────┴─────┴────┘

 Collection class │  Random access by idx/key │ Search/Contains │ Instert
 ─────────────────┼───────────────────────────┼─────────────────┼───────────
 ArrayList        │  O(1)                     │ O(n)            │ O(n)
 HashSet          │  O(1)                     │ O(1)            │ O(1)
 HashMap          │  O(1)                     │ O(1)            │ O(1)
 TreeMap          │  O(log(n))                │ O(log(n))       │ O(log(n))

</pre>
  </li>
  </ul>
</td>
<td>
  Initialization
<pre xxxsmall zoom>
// ****************************
// *** Initializing a list: ***
// ****************************
final List&lt;String&gt; myList = Arrays.asList("one", "two", "three");
                   myList.add("four");       // *1 Correct
                   myList = new ArrayList(); //     Compiler error 
// Non-modifiable version of list
final List&lt;String&gt; myInmmutableList Collections.unmodifiableList(myList);
// *1: "final" avoid reasigning myList to a new collection by it's still
//      possible to add/remove elements from the collection "pointed to" by myList

// ****************************
// *** Initializing a Map:  ***
// ****************************
final Map&lt;String,String&gt; myMap = new HashMap&lt;String,String&gt;();
        myMap.put("k1", "k2");
        myMap.put("v1", "v2");
// Non-modifiable version of map
final Map&lt;String,String&gt; myInmutableMap = Collections.unmodifiableMap(temp);

// *** Java 7+ ***
HashMap<String,String> data = HashMapBuilder.build("k1","v1","k2","v2");

// *** Java 9+ ***
// Java 9+: Syntax 1: From list with even elements
final Map&lt;String, String&gt; test = Map.of("k1", "k2", "v1", "v2");

// Java 9+: Syntax 2: ofEntries
Map&lt;String, String&gt; test2 = Map.ofEntries( entry("k1", "k2"), entry("v1", "v2"));

// *****************************************
// *** Guava ImmutableMap initialization ***
// *****************************************
Map&lt;String, String&gt; test = ImmutableMap.of("k1", "v1", "k2", "v2");

This works for up to 5 key/value pairs, otherwise you can use its builder:

Map&lt;String, String&gt; test = ImmutableMap.&lt;String, String&gt;builder()
    .put("k1", "v1")
    .put("k2", "v2")
    ...
    .build();
</pre>
</td>
<td>
  Walk-over/iterate
<pre xxxsmall zoom>
for (int idx = 0; idx < collection<span orange>.length</span>; idx++) {
    // WARN: Very slow for LinkedLists
    //       Fastest for other List implementations
  type array_element = collection<span orange>.get(idx);</span>

}

// Useful when we also want to remove elements at iteration time
for (Iterator iterator = collection<span orange>.iterator()</span>; <span orange>iterator.hasNext();</span>) {
  type type = (type) iterator<span orange>.next()</span>;   
}

// Best option when not removing or modifying elements
for (iterable_type iterable_element <span orange>: collection</span>) { ...  }


// Streams (Java 8+)
collection<span orange>.forEach</span>((<span orange>it</span>) -> { System.out::println(<span orange>it</span>) });
// Even Shorter: 
collection<span orange></span>.forEach<span orange></span>(<span orange>System.out::println<span orange></span>);

---------- WALK-OVER/ITERATE OVER MAP ----------
Map<String, String> map = ...
// Alt 1: Java 5+
for (<span orange>Map.Entry&lt;String, String></span> entry : map<span orange>.entrySet()</span>)
{
    System.out.println(entry.getKey() + "/" + entry.getValue());
}

// Alt 2: Using iterators:
long i = 0;
Iterator&lt;Map.Entry&lt;Integer, Integer>> it = map.entrySet()<span orange>.iterator()</span>;
while (it<span orange>.hasNext()</span>) {
    Map.Entry<Integer, Integer> pair = it<span orange>.next()</span>;
    i += pair.getKey() + pair.getValue();
}

// Alt 3: Using for-each
long i = 0;
for (Map.Entry&lt;Integer, Integer> pair : map<span orange>.entrySet()</span>) {
    i += pair.getKey() + pair.getValue();
}

// Alt 4: forEach (java 8+)
final long[] i = {0};
map<span orange>.forEach</span>((k, v) -&lt; i[0] += k + v);

// Alt 5: iterating over keySet:
long i = 0;
Iterator&lt;Integer> itr2 = map<span orange>.keySet().iterator()</span>;
while (itr2.hasNext()) {
    Integer key = itr2.next();
    i += key + map.get(key);
}

// Alt 6: for + Map.Entry
Using for and Map.Entry

long i = 0;
for (Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = 
    map.entrySet().iterator(); entries.hasNext(); ) {
    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();
    i += entry.getKey() + entry.getValue();
}
// Alt 7: Using the Java 8 Stream API
final long[] i = {0};
map<span orange>.entrySet().stream()</span>.forEach(
  e -&gt; i[0] += e.getKey() + e.getValue());

// Alt 8: Using java 8+ Stream API parallel
final long[] i = {0};
map<span orange>.entrySet().stream().parallel().forEach</span>(
  e -&gt; i[0] += e.getKey() + e.getValue())

</pre>
  <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html">java.util.Collections</a>
<pre xxxsmall zoom>
Collections.EMPTY_LIST // The empty (immutable) list
Collections.EMPTY_MAP  // The empty (immutable) map 
Collections.EMPTY_SET  // The empty (immutable) set

boolean      Collections.addAll(Collection c, T... elements)                           Adds all of the specified elements to the specified collection.
Queue        Collections.asLifoQueue(Deque deque)                                      Returns a view of a Deque as a Last-in-first-out (Lifo) Queue.
int          Collections.binarySearch(List list, T key)                                Searches the specified list for the specified object using the binary search algorithm.
int          Collections.binarySearch(List list, T key, Comparator c)                  Searches the specified list for the specified object using the binary search algorithm.
Collection   Collections.checkedCollection(Collection c, Class type)                   Returns a dynamically typesafe view of the specified collection.
List         Collections.checkedList(List list, Class type)                            Returns a dynamically typesafe view of the specified list.
Map          Collections.checkedMap(Map m, Class keyType, Class valueType)             Returns a dynamically typesafe view of the specified map.
Set          Collections.checkedSet(Set s, Class type)                                 Returns a dynamically typesafe view of the specified set.
SortedMap    Collections.checkedSortedMap(SortedMap m, Class keyType, Class valueType) Returns a dynamically typesafe view of the specified sorted map.
SortedSet    Collections.checkedSortedSet(SortedSet s, Class type)                     Returns a dynamically typesafe view of the specified sorted set.
void         Collections.copy(List dest, List src)                                     Copies all of the elements from one list into another.
boolean      Collections.disjoint(Collection c1, Collection c2)                        Returns true if the two specified collections have no elements in common.
Enumeration  Collections.emptyEnumeration()                                            Returns an enumeration that has no elements.
Iterator     Collections.emptyIterator()                                               Returns an iterator that has no elements.
List         Collections.emptyList()                                                   Returns the empty list (immutable)                                              .
ListIterator Collections.emptyListIterator()                                           Returns a list iterator that has no elements.
Map          Collections.emptyMap()                                                    Returns the empty map (immutable)                                              .
Set          Collections.emptySet()                                                    Returns the empty set (immutable)                                              .
Enumeration  Collections.enumeration(Collection c)                                     Returns an enumeration over the specified collection.
void         Collections.fill(List list, T obj)                                        Replaces all of the elements of the specified list with the specified element.
int          Collections.frequency(Collection c, Object o)                             Returns the number of elements in the specified collection equal to the specified object.
int          Collections.indexOfSubList(List source, List target)                      Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.
int          Collections.lastIndexOfSubList(List source, List target)                  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.
ArrayList    Collections.list(Enumeration e)                                           Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration.
T            Collections.max(Collection coll)                                          Returns the maximum element of the given collection, according to the natural ordering of its elements.
T            Collections.max(Collection coll, Comparator comp)                         Returns the maximum element of the given collection, according to the order induced by the specified comparator.
T            Collections.min(Collection coll)                                          Returns the minimum element of the given collection, according to the natural ordering of its elements.
T            Collections.min(Collection coll, Comparator comp)                         Returns the minimum element of the given collection, according to the order induced by the specified comparator.
List         Collections.nCopies(int n, T o)                                           Returns an immutable list consisting of n copies of the specified object.
Set          Collections.newSetFromMap(Map map)                                        Returns a set backed by the specified map.
boolean      Collections.replaceAll(List list, T oldVal, T newVal)                     Replaces all occurrences of one specified value in a list with another.
void         Collections.reverse(List list)                                            Reverses the order of the elements in the specified list.
Comparator   Collections.reverseOrder()                                                Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface.
Comparator   Collections.reverseOrder(Comparator cmp)                                  Returns a comparator that imposes the reverse ordering of the specified comparator.
void         Collections.rotate(List list, int distance)                               Rotates the elements in the specified list by the specified distance.
void         Collections.shuffle(List list)                                            Randomly permutes the specified list using a default source of randomness.
void         Collections.shuffle(List list, Random rnd)                                Randomly permute the specified list using the specified source of randomness.
Set          Collections.singleton(T o)                                                Returns an immutable set containing only the specified object.
List         Collections.singletonList(T o)                                            Returns an immutable list containing only the specified object.
Map          Collections.singletonMap(K key, V value)                                  Returns an immutable map, mapping only the specified key to the specified value.
void         Collections.sort(List list)                                               Sorts the specified list into ascending order, according to the natural ordering of its elements.
void         Collections.sort(List list, Comparator c)                                 Sorts the specified list according to the order induced by the specified comparator.
void         Collections.swap(List list, int i, int j)                                 Swaps the elements at the specified positions in the specified list.
Collection   Collections.synchronizedCollection(Collection c)                          Returns a synchronized (thread-safe) collection backed by the specified collection.
List         Collections.synchronizedList(List list)                                   Returns a synchronized (thread-safe) list backed by the specified list.
Map          Collections.synchronizedMap(Map m)                                        Returns a synchronized (thread-safe) map backed by the specified map.
Set          Collections.synchronizedSet(Set s)                                        Returns a synchronized (thread-safe) set backed by the specified set.
SortedMap    Collections.synchronizedSortedMap(SortedMap m)                            Returns a synchronized (thread-safe) sorted map backed by the specified sorted map.
SortedSet    Collections.synchronizedSortedSet(SortedSet s)                            Returns a synchronized (thread-safe) sorted set backed by the specified sorted set.
Collection   Collections.unmodifiableCollection(Collection c)                          Returns an unmodifiable view of the specified collection.
List         Collections.unmodifiableList(List list)                                   Returns an unmodifiable view of the specified list.
Map          Collections.unmodifiableMap(Map m)                                        Returns an unmodifiable view of the specified map.
Set          Collections.unmodifiableSet(Set s)                                        Returns an unmodifiable view of the specified set.
SortedMap    Collections.unmodifiableSortedMap(SortedMap m)                            Returns an unmodifiable view of the specified sorted map.
SortedSet    Collections.unmodifiableSortedSet(SortedSet s)                            Returns an unmodifiable view of the specified sorted set.
</pre>
</td>
<td>
  <a href="http://fastutil.di.unimi.it/">Fastutil</a>
  <ul xxxsmall zoom>
  <li>Fast and compact type-specific collections for Java
    Great default choice for collections of primitive types,
    like int or long. Also handles big collections with more than 2
    31 elements well</li>
  </ul>
</td>
<td>
  <a href="https://www.eclipse.org/collections/">Eclipse Collections</a>
  <ul xxxsmall zoom>
  <li>Features you want with the collections you need
    Previously known as gs-collections, this library 
    includes almost any collection you might 
    need: primitive type collections, multimaps, 
    bidirectional maps and so on. </li>
  </ul>
</td>
<td>
  <a href="https://github.com/google/guava">Guava Collections</a>
  <ul xxxsmall zoom>
  <li>Google Core Libraries for Java 6+
    Perhaps the default collection library for Java 
    projects. Contains a magnitude of convenient 
    methods for creating collection, like fluent 
    builders, as well as advanced collection types</li>
  </ul>
</td>
</tr }>
</table>

<table>
<tr {>
  <th colspan=12 header_delimit >Java NIO</th></li>
</tr }>
<tr {>
<td>
  NIO (1.4+) <a href="http://tutorials.jenkov.com/java-nio/buffers.html">REF</a>
  <ul xxxsmall>
  <li>
<pre>
 blocking IO    vs  NIO
 ---------------+---------------------------
 byte streams   |   <b blue>CHANNELS </b> (File|Datagram/*UDP*/|Socket/*TCP*/|ServerSocket/*listening TCP*/)Channel
 char streams   |   <b blue>BUFFERS  </b> (Byte|Char|Double|Float|Int|Long|Short|MappedByte)Buffer
                |   <b blue>SELECTORS</b>
                |   
                |   channelIn → (data) → buffer
                |   buffer   → (data) → channelOut
                | 
                |   Buffer attributes:
                |   ==================
                |   capacity: fixed size of memory block implementing the buffer
                |   
                |             | write mode         |  read mode
                |             +--------------------+----------------------------
                |   position  | starts at 0,       |  starts at 0 (after "flip")
                |             | increase at each   |  increase at each
                |   ----------+--------------------+----------------------------
                |             | element written    |  element read
                |   limit     | == capacity        |  == last written position
                |   ------------------------------------------------------------
                |   Buffer methods:
                |   ==================
                |   rewind()
                |   clear()/ compact()  
                |   mark() / reset()     "bookmark position" and return to "bookmark"
                |   equals() / compareTo() : (check only remaining to read bytes)
</pre>
  </li>
  <li>non-blocking: 
    <ol>
    <li>a thread request a channel the intention to read/write data into a buffer.</li>
    <li>While the channel moves data into/from the buffer, the thread continues another job</li>
    <li>When data is ready, the thread is notified</li>
    </ol>
  </li>
  <li>Channels, buffers and selectors from the "core". Other components like Pipe and FileLock 
    can be considered "utility classes" supporting the first three ones.</li>
  <li>Channels are read/write (old stream api are ussually one-way only)</li>
  <li>Using a Buffer to read and write data typically follows next sequence:
    <ol>
    <li>Write data into the Buffer</li>
    <li>Call buffer.flip(): switch writing/reading mode</li>
    <li>Read data out of the Buffer</li>
    <li><code>buffer.clear()   /*clear all buffer*/    </code> or<br/>
        <code>buffer.compact() /*clear only data read*/</code> </li>
    </ol>
<pre>
try (  /* try-with 1.7+ */
  RandomAccessFile <b green>aFile</b> = new RandomAccessFile("data/nio-data.txt", "rw") 
) throws IOException {
  FileChannel <b blue>inChannel</b> = <b green>aFile</b>.getChannel();
  
  ByteBuffer <b brown>buf</b> = ByteBuffer.<b>allocate</b>(48 /* capacity*/);
  
  int <b orange>bytesRead</b> = <b blue>inChannel</b>.read(<b brown>buf</b>); // <b brown>buf</b> now in write mode
  <b>while</b> (<b orange>bytesRead</b> != -1) <b>{</b>
    <b brown>buf</b>.flip();                            // <b brown>buf</b> now in read mode
    while(<b brown>buf</b>.hasRemaining()){
        // alt. read data directly, 1 byte at a time
        System.out.print((char) <b brown>buf</b>.get()); 
        // alt. read data in channel
        // anotherChannel.write(<b brown>buf</b>)
    }
  
    <b brown>buf</b>.clear(); //make buffer ready for writing
    <b orange>bytesRead</b> = <b blue>inChannel</b>.read(<b brown>buf</b>); // <b brown>buf</b> now in write mode
  <b>}</b>
}
</pre>    
  </li>
  <li>"selectors" objects monitor one+ channels for events (connection opened, data arrived, ..).
    Thus, a single thread can monitor multiple channels for data.  <b>Very handy in the app has
    many connections (Channels) open (many clients) but with low traffic on each connection.</b><br/>
    To use selectors:
    <ol>
    <li>Instantiate the selector </li>
    <li>Register one+ channels with it</li>
    </ol>
  </li>
  </ul>
  API tree
<pre xxxsmall zoom >
JDK 8
./java/nio/
           Bits ByteOrder CharBufferSpliterator
           ByteBufferAs(Char|Double|Float|...)Buffer(B|L|...
           (|Float|Double|StringChar)Buffer
           HeapByteBuffer Heap(Byte|Char|...)Buffer(R) HeapCharBuffer
           (Int|Long|...)Buffer
           (Mapped|Direct)ByteBuffer(R)
           Direct(Byte|Char|Double|...)Buffer

./java/nio/channels/
                    Channel Channels CompletionHandler FileLock MembershipKey Pipe Selector SelectionKey
                    Asynchronous(|Byte)Channel
                    AsynchronousChannelGroup
                    AsynchronousFileChannel
                    AsynchronousServerSocketChannel
                    AsynchronousSocketChannel
                    (Byte|Datagram|File|GatheringByte|Interruptible|Multicast|
                     Network|ReadableByte|ScatteringByte|SeekableByte|Selectable|
                     ServerSocket|Socket|WritableByte)Channel
                   /spi/Abstract(Interruptible|Selectable)Channel
                        Abstract(SelectionKey|Selector)
                        (AsynchronousChannel|Selector)Provider

./java/nio/charset/
                   Charset(|Decoder|Encoder) StandardCharsets
                   CoderResult CodingErrorAction
                  /spi/CharsetProvider

./java/nio/file/attribute/AclEntry(|Flag|Permission|Type)
                          (|AclFile|BasicFile|DosFile|File|
                            FileOwner|FileStore|PosixFile|
                            UserDefinedFile)AttributeView
                          (BasicFile|DosFile|PosixFile)Attributes
                          FileAttribute FileTime
                          GroupPrincipal
                          
                          UserPrincipal(LookupService)
./java/nio/file/
                AccessMode CopyMoveHelper CopyOption DirectoryStream Files
                LinkOption LinkPermission Path        PathMatcher        Paths
                SecureDirectoryStream
                File(Store|System|Systems|TreeIterator|TreeWalker|VisitOption|Visitor|VisitResult)
                SimpleFileVisitor
                OpenOption    Standard(Copy|Open)Option
                StandardWatchEventKinds
                StandardWatchEventKinds$StdWatchEventKind
                TempFileHelper
                Watchable      Watch(Event|Key|Service)
                spi/FileSystemProvider
                    FileTypeDetector
</pre>
</td>
<td>
  Scatter/Gather 
  <ul xxxsmall zoom>
  <li>A scattering read from a channel reads data into more than one buffer.
<pre>
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
ByteBuffer[] <b orange>bufferArray</b> = { header, body };
 <b blue>channel</b>channel.read(<b orange>bufferArray</b>); // <b blue>channel</b> → ( header, body)
</pre>
   scattering reads fill up one buffer before moving on to the next, that implies that
   it is <b>not suited for undefined size messages, but only for fixed size ones</b>
  </li>
  <li>A gathering-write to a channel writes data from more than one buffer into
      a single channel.
<pre>
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
ByteBuffer[] <b orange>bufferArray</b> = { header, body };
 <b blue>channel</b>channel.write(<b orange>bufferArray</b>); // ( header, body) → <b blue>channel</b>
</pre>
  </li>
  </ul>
  Channel to Channel
  <ul xxxsmall zoom>
  <li>If one the the channels is FileChannel data can be directly moved between channels
    using the FileChannel transferTo()/transferFrom().
</li>
  <li>FileChannel.transferFrom()
<pre>
RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"),
                   toFile = new RandomAccessFile(  "toFile.txt", "rw");
FileChannel      fromChannel = fromFile.getChannel(),
                   toChannel =   toFile.getChannel();

long count    = fromChannel.size();
toChannel.transferFrom(
     fromChannel,
     0, /* position where in the destination file to start writing */
     count /* how max bytes to transfer, fewer if source has fewer than count */);  
</pre>
  WARN: Some SocketChannel implementations may transfer only the data the SocketChannel 
      has ready in its internal buffer here and now
</li>
  <li>FileChannel.transferTo()
<pre>
RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"),
                   toFile = new RandomAccessFile(  "toFile.txt", "rw");
FileChannel      fromChannel = fromFile.getChannel(),
                   toChannel = toFile.getChannel();
long position = 0;
long count    = fromChannel.size();
fromChannel.transferTo(
    position,
    count,
    toChannel);
</pre>
  </li>
  </ul>
</td>
<td>
  Selectors
  <ul xxxsmall zoom>
  <li>A Selector can examine one+ Channels and determine which ones are ready for
       connect,accept,read,write</li>
  <li>This way a single thread can manage multiple channels, and thus multiple network connections</li>
  <li>Creating Selector and asigning channels:
<pre>
Selector <b orange>selector</b> = Selector.open();

// channel must be in non-blocking mode.

channel.configureBlocking(false);
<b>SelectionKey key</b> = channel.register(
            <b orange>selector</b>,
            SelectionKey.OP_READ | SelectionKey.OP_WRITE /* event "interest set" */);
/* Event can be one of:
 *    SelectionKey.OP_CONNECT   SelectionKey.OP_ACCEPT   SelectionKey.OP_READ   SelectionKey.OP_WRITE */
</pre>

</li>
  <li>FileChannel can NOT be switched into non-blocking mode and so they can NOT be used with
    selectors.</li>
  <li>A channel that "fires an event" is also said to be "ready" for that event.</li>
  <li>The SelectionKey object contains a few interesting properties appart of the associated Channel and Selector:
    <ul>
    <li>The interest set: You can read and write that interest set via the SelectionKey like this:
<pre>
int <b orange>interestSet</b> = selectionKey<b>.interestOps()</b>;
boolean isInterestedInAccept  = <b orange>interestSet</b> &amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = <b orange>interestSet</b> &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = <b orange>interestSet</b> &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = <b orange>interestSet</b> &amp; SelectionKey.OP_WRITE;    
</pre>
    </li>
    <li>The ready set of operations the channel is ready for, used after a selection, explained later:
<pre>
// Alt 1:
int readySet = selectionKey.readyOps();
boolean isAcceptable  = readySet &amp; SelectionKey.OP_ACCEPT;
boolean isConnectable = readySet &amp; SelectionKey.OP_CONNECT;
boolean isReadable    = readySet &amp; SelectionKey.OP_READ;
boolean isWritable    = readySet &amp; SelectionKey.OP_WRITE;
// Alt 2:
selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable()  ; selectionKey.isWritable();
</pre>
    </li>
    <li>An (optional) user attached object, handy way to recognize a given channel,
      or attaching extra information like the buffer/s used with the channel...
<pre>
selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
// attach an object at channel registration:
SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
</pre>
    </li>
    </ul>
  </li>
  </ul>

  Using selectors
  <ul xxxsmall zoom>
  <li>After registering  one+ channels with a selector you can call one of the select() methods
    returnin the channels "ready" for the events you are interested in (connect, accept, read or write).
<pre>
int select()                  // blocks until at least one channel is ready for the events you registered for
int select(long milliseconds) // select() blocking for max of milliseconds timeout 
int selectNow()               // doesn't block, returning any channels ready (if any).
^ The returned int indicates how many channels became ready since last time select() was called.
</pre>
  <li>Once select() indicates that one+ channels are ready, examine selected keys like:
<pre>
Set<SelectionKey> selectedKeys = selector.<b orange>selectedKeys()</b>;
Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(false) {
    } else if (key<b>.isAcceptable ()</b>) { ...// connection was accepted by ServerSocketChannel
    } else if (key<b>.isConnectable()</b>) { ...// connection was established with a remote server
    } else if (key<b>.isReadable   ()</b>) { ...// channel is ready for reading
    } else if (key<b>.isWritable   ()</b>) { ...// channel is ready for writing
    }
    keyIterator.remove();
}
</pre>
  </li>
  <li>The channel returned by the SelectionKey.channel() method should be cast to
      the proper channel (ServerSocketChannel, SocketChannel, ...)
  </li>
  <li>A thread blocked by a call to select() can be forced to leave the select() method,
    even if no channels are yet ready by having a different thread call the <code>Selector.<b>wakeup()</b></code>
    method on the Selector which the first thread has called select() on.
    The thread waiting inside select() will then return immediately.<br/>
    If a different thread calls wakeup() and no thread is currently blocked inside select(), 
    the next thread that calls select() will "wake up" immediately.
  </li>
  <li>Selector.close(): must be called after finishing ussage, invalidating all SelectionKey
      instances registered with this Selector. The channels themselves are not closed.
  </li>
  </ul>
</td>
<td colsep> </td>
<td>
  <span xsmall>FileChannel</span>
  <ul xxxsmall zoom>
  <li>A Java NIO FileChannel is a channel that is connected to a file allowing to
      read data from  and write data to a file.</li>
  </li>A FileChannel cannot be set into non-blocking mode. It always runs in blocking mode<li>
  <li>Reading from FileChannel (Writting to buffer):
<pre>
/* You cannot open a FileChannel directly, 
 * first you obtain a FileChannel via an (Input|Output)Stream or a RandomAccessFile
 */
RandomAccessFile aFile     = new RandomAccessFile("data/nio-data.txt", "rw");
// Reading from channel 
try (  /* try-with 1.7+ */
  RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw") 
) throws IOException {
  FileChannel inChannel = aFile.getChannel();
 
  ByteBuffer buf = ByteBuffer.allocate(48 /* capacity*/);
  
  int bytesRead = inChannel.read(buf); // buf now in write mode
  while (bytesRead != -1) {
    buf.flip();                            // buf now in read mode
    while(buf.hasRemaining()){
        // alt. read data directly, 1 byte at a time
        System.out.print((char) buf.get()); 
        // alt. read data in channel
        // anotherChannel.write(buf)
    }
  
    buf.clear(); //make buffer ready for writing
    bytesRead = inChannel.read(buf); // buf now in write mode
  }
</pre>
  <li>Writing to a FileChannel (reading from buffer)
<pre>
String newData = "......" + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip(); // change buffer from write to read
<b>while(buf.hasRemaining()) {</b> channel<b orange>.write</b>(buf); <b>}</b>
channel.close();    
</pre>
  </li>
  <li>FileChannel Position
<pre>
long pos = fileChannel.position(); // obtain current position
fileChannel.position(pos +123); // change position

- If you set the position after the end of the file, and try to read from the channel, you will get -1
- If you set the position after the end of the file, and write to the channel, the file will be expanded 
  to fit the position and written data. This may result in a "file hole", where the physical file on 
  the disk has gaps in the written data.
</pre>
  </li>
  <li>FileChannel Size
<pre>
long fileSize = fileChannel.size(); // returns size of the file connected to the channel.
</pre>
  <li>FileChannel Truncate (cut file to a given length)
<pre>
fileChannel.truncate(1024);
</pre>
  </li>
  <li>FileChannel Force (flushes all unwritten data from the channel and OS cache to the disk)
<pre>
channel.force(true /* flush also file meta-data like permissions....*/);
</pre>
  </li>
  </ul>
  <span xsmall>Pipe</span>
  (one-way data connection between two threads)
  <ul xxxsmall zoom>
  <li>Pipe = (sink channel, source channel). One thread writes to sink and another one reads from source</li>
  <li>
<pre>
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

// WRITING TO PIPE
Pipe pipe = Pipe.open();
Pipe.SinkChannel sinkChannel = pipe.sink();
String newData = "..." + System.currentTimeMillis();
buf.flip();
while(buf.hasRemaining()) { sinkChannel.write(buf); }

// READING FROM A PIPE
To read from a Pipe you need to access the source channel. Here is how that is done:
Pipe.SourceChannel sourceChannel = pipe.source();
int bytesRead = inChannel.read(buf2);
</pre>
  </li>
  </ul>

</td>
<td>
  <span xsmall>SocketChannel</span>
<pre xxxsmall zoom>
There are two ways a SocketChannel can be created:

// Opening a SocketChannel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

// Reading (writing to buffer) 
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf); // If -1 is returned, the end-of-stream is reached (connection is closed)

// Writing to a SocketChannel
String newData = "..." + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) { channel.write(buf); }

socketChannel.close();    
</pre>

  <span xsmall>Non-blocking Mode</span>
  <ul xxxsmall zoom>
  <li><code>socketChannel<b>.configureBlocking(false)</b>;</code></li>
  <li>Calls connect(), read() and write() will not block</li>
  <li>In non-blocking mode connect() calls may return before the connection is established.
      To determine whether the connection is established use  finishConnect() like this:
<pre>
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

while(! socketChannel.finishConnect() ){
    //wait, or do something else...    
}
</pre>
  </li>
  <li>non-blocking works much better with Selector's</li>
  </ul>
</pre>
  <span xsmall>ServerSocketChannel</span>
<pre xxxsmall zoom>
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept(); // in blocking mode waits until incoming connection arrives
    if(socketChannel != null /* always false in blocking mode */){
        //do something with socketChannel...
    }

    //do something with socketChannel...
}

serverSocketChannel.close()
</pre>

  <span xsmall>Datagram Channel</span>
  <ul xxxsmall zoom>
  <li>Since UDP is a connection-less network protocol, you cannot just by default read and write to a DatagramChannel like you do from other channels. Instead you send and receive packets of data</li>
  <li> </li>
  <li> </li>
  <li> </li>
  </ul>
<pre xxxsmall zoom>
DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
// WARN: if read data is bigger than buffer size remaining data is discarded silently
channel.receive(buf); 

// Write to channel
String newData = "..." + System.currentTimeMillis();
buf.clear();
buf.put(newData.getBytes());
buf.flip();


// WARN:  No notice is received about packet delivery (UDP does not make any guarantees)
int bytesSent = channel.send(buf, new InetSocketAddress("jenkov.com", 80));

// Alternatively you can "Connect" to a Specific Address. Since UDP is connection-less,
// connecting to a remote address just means that the DatagramChannel can only send/receive 
// data packets from a given specific address.
channel.connect(new InetSocketAddress("jenkov.com", 80));    
int bytesRead = channel.read(buf);    
int bytesSent = channel.write(buf);
</pre>
</td>
<td>
  <span xsmall>NonBlocking Server</span> <a xsmall href="http://tutorials.jenkov.com/java-nio/non-blocking-server.html">REF</a>
<a xsmall href="https://github.com/jjenkov/java-nio-server">GitHub</a>
  <ul xxxsmall zoom>
  <li>The ideas described in this tutorial are designed around Java NIO. However, I believe that the ideas can be reused in other languages as long as they have some kind of Selector-like construct.  As far as I know, such constructs are provided by the underlying OS, so there is a good chance that you can get access to this in other languages too.</li>
  <li>Non-blocking IO Pipelines:
<pre>
read-write pipeline: <b>channelIn</b> → selector → component → ... → componentN → <b>channelOut</b>
read-only  pipeline: <b>channelIn</b> → selector → component → ... → componentN
write-only pipeline:                        component → ... → componentN → <b>channelOut</b>
Note: It is the component that initiates reading of data from the Channel via the Selector
read-pipeline read from stream/channelIn and split data into messages like:

Data   → Message → Message
Stream   Reader    Stream
</pre>

  <li>A blocking Message Reader/Writer is simpler, sin it has never to handle situations where no data was read from the stream,
      or where only a partial message was read from the stream and message parsing needs to be resumed later.</li>
  <li>The drawback of blocking is the requirement of separate threads for each parallel stream, which is a problem if the
       server has thousands of concurrent connections</li>
  <li>Each thread will take between 320K (32 bit JVM) and 1024K (64 bit JVM) memory for its stack</li>
  <li>Queue messages can be used to reduce the problem. However, this design requires that the inbound client  streams           
     send data reasonably often and input is processed fast. If the inbound client stream may be inactive for longer periods
     attached to hidden clients, a high number of inactive connections may actually block all the threads in the thread pool.
     That means that the server becomes slow to respond or even unresponsive.  </li>
  <li>A non-blocking IO pipeline can use a single thread to read messages from multiple non-blocking streams. 
    When in non-blocking mode, a stream may return 0 or more bytes when you attempt to read data from it.
    When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances ("connected clients")
    that actually has data to read. 
<pre>
Component ──→ STEP 1: select() ──→ Selector ←──┬─→ Channel1
    ↑                                │         ┼─→ Channel2
    └───← STEP 2: ready channels ←───┘         └─→ Channel3
</pre>
  </li>
  <li>Reading Partial Messages: Data sent by "ready" channels can contain fractions/incomplete messages:
    The Message Reader looks needs to check if the data block contains at least one full message, adn storing partial ones.
    (maybe using one Message Reader per Channel to avoid mixing messages)
  </li>
  <li>To store Partial Messages two design should be considered:
    <ol>
    <li>copy data as little as possible for better performance</li>
    <li>We want full messages to be stored in consecutive byte to make parsing messages easier</li>
  </li>
  <li>Some protocol message formats are encoded using a TLV format (Type, Length, Value).  
     Memory management is much easier since we known immediately how much memory to allocate 
     for the message. No memory is wasted at the end of a buffer that is only partially used.
  </li>
  <li>The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 
    is such a terrible protocol. That is one of the problems trying to be fixed in HTTP 2.0 where
    data is transported in LTV encoded frames.</li>
  <li>Writing Partial Messages: channelOut.write(ByteBuffer) in non-blocking mode gives no guarantee
     about how many of the bytes in the ByteBuffer is being written. The method returns how many bytes
     were written, so it is possible to keep track of the number of written bytes.<br/>
     Just like with the Message Reader, a Message Writer is used per channel to handle all the details. 
     (partial writes, message queues, resizable buffers, protocol aware tricks,...)
</li>
  <li>All in all a non-blocking server ends up with three "pipelines" it needs to execute regularly:
    <ol>
    <li>The read pipeline which checks for new incoming data from the open connections.</li>
    <li>The process pipeline which processes any full messages received.</li>
    <li>The write pipeline which checks if it can write any outgoing messages to any of the open connections</li>
    </ol>

Here is a diagram illustrating the full server loop:
The full server loop of a non-blocking server.
  </li>
  </ul>
<!--

-->
</td>

<td>
  <span xsmall>Path (1.7+)</span>
<pre xxxsmall zoom>
- Represents a file/directory path in the FS
- Similar to java.io.File but with some minor differences. 
// Ussage
import java.nio.file.Path;
import java.nio.file.Paths;

Path path = Paths.get("/var/lib/myAppData/myfile.txt");
System.out.println("Current dir:"+Paths.get(".").toAbsolutePath());
</pre>

  <span xsmall>Files</span>
<pre xxxsmall zoom>
- java.nio.file.Files provides several methods for manipulating FS files/directories:
- uses Path instances:

boolean pathExists = <b>Files.exists</b>(pathInstance,
            new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});

Path newDir = <b>Files.createDirectory</b>(path);

<b>Files.copy</b>(sourcePath, destinationPath);
<b>Files.copy</b>(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

<b>Files.move</b>(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

<b>Files.delete</b>(path);

Files.walkFileTree(Paths.get("data"), new FileVisitor<Path>() {
  @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }
});

</pre>
  <span xsmall>Asyncrhonous FileChannel 1.7+</span>
<pre xxxsmall zoom>
read/write data from/to files asynchronously

Path path = Paths.get("data/test.xml");
AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

// Reading Data, Alt 1: Via a Future
  Future<Integer> operation = fileChannel.read(/*ByteBuffer*/buffer, 0 /*start position to read from */);
  while(!operation.isDone());  // WARN: not a very efficient use of the CPU
  buffer.flip();
  byte[] data = new byte[buffer.limit()];
  buffer.get(data);
  System.out.println(new String(data));
  buffer.clear();

// Reading Data Alt 2: Via a CompletionHandler
fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {
    @Override
    public void completed(Integer numBytesRead, ByteBuffer attachment) {
        // NOTE: attachment is a reference to the third parameter passed to .read read()
        System.out.println("numBytesRead = " + numBytesRead);
        attachment.flip();
        byte[] data = new byte[attachment.limit()];
        attachment.get(data);
        System.out.println(new String(data));
        attachment.clear();
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) { ...  }
});

// Writing data:
AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

// Writing Data: Alt 1: Via a Future
  ...
  Future<Integer> operation = fileChannel.write(buffer, position);
  buffer.clear();
  while(!operation.isDone());

// Writing Data: Alt 2: Via CompletionHandler
...
  fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {
  
      @Override public void completed(Integer result, ByteBuffer attachment) { /* ... */ } 
      @Override public void failed   (Throwable exc , ByteBuffer attachment) { /* ... */ }
  });

</pre>
</td>
</table>

<table>
<tr>
  <th colspan=4 header_delimit >Concurrent Programming <a href="https://cs.nyu.edu/~lerner/spring12/Preso03-JavaPrimitives.pdf">REF</a></th>
</tr>
<td>
  Concurrency Basics
  <ul xxxsmall zoom>
  <li>Concurrency problems arise from the desire to use CPU resources more efficiently. Non concurrent
    applications (single threaded/single process) are complete Touring machines that can potentially 
    solve any problem with enough time and memory. In practice having a CPU assigned to single thread
    will be very inneficient since the CPU will stand-by while the thread is waiting for input/output
    operations. Also, many algorithms allows to split processed data in isolated regions that can be
    processed in parallel by different CPU/CPU cores</li>
  <li>Concurrent tries to solve the problem of multiple independents CPUs or threads accesing share
    resources (memory)</li>
  <li>Locks is the simples concurrent primite to protect code or data from concurrent
    access in situations where there are many threads of execution. Locks can be classified like:
<pre>
According to lock ussage:
   Cooperative   A thread is encouraged (but not forced) to cooperate with other
                 threads by adquiring a lock before accessing the associated data
                 
   Mandatory     a thread trying to access an already locked resource will throw
                 an exception
_________________________________________________
According to lock rescheduing strategy:
   Blocking      The OS block the thread requesting the lock and rescheduled another thread

   Spinlock      The thread waits in a loop until the requested lock becomes available. 
                 It's more efficient if threads are blocked for very short time (smaller than
                 the time needed by the OS to reschedule another thread into the current CPU)
                 It's inneficient if the lock is held for a long time since a CPU core is
                 waisted on the spinlock loop
_________________________________________________
According to granularity: (measure of the ammount of data the lock is protecting)
   Coarse        Protect large segments of data (few locks). Results in less lock overhead
                 for a single thread, but worse performance for many threads running concurrently
                 (most thread will be lock-contended waiting for share resource access)

   Fine          Protrect small amounts of data. Require more lock instances reducing lock
                 contention
</pre>
  </li>
  <li>Locks require CPU atomic instructions for efficient implementations suchs as 
      "test-and-set", "fetch-and-add", or "compare-and-swap", whether there are blocking
      (managed by the OS) or spinlocks (managed by the thread)</li>
  <li>Uniprocessors can just disable interruptions to implement locks, while multiprocessors
    using shared-memory will require complex hardware and/or software support</li>
  <li><b>Monitors wrap mutex-locks with condition variables (container of threads waiting
     for certain condition)</b>. They are implemented as thread-safe classes </li>
  </ul>
</td>
<td>
  Java monitors
  <ul xxxsmall zoom { >
  <li>The simplest form of synchronization in Java is the mutual exclusion of
    threads to shared resources using monitors</li>
  <li>Monitors also have the ability to wait(block a thread) for a certain condition
    to become true, and signal other threads that their condition has been met</li>
  <li><b>Monitors provide a mechanism for threads to temporarily give up exclusive access in
    order to wait for some condition to be met, before regaining exclusive access and
    resuming their task</b></li>
  <li>each java object can be used as a monitor.</li>
  <li>Methods/blocks of code requiring mutual exclusion must be explicitly marked with the
    <code orange>synchronized keyword</code></li>
  <li>Instead of explicit condition variables, each monitor(/object) is equipped with
    a single wait queue in addition to its entrance queue.</li>
  <li>All waiting is done on this single wait queue and all <code orange>notify/notifyAll</code>
    operations apply to this queue.
<pre {>
             enter
               |
 +---+-------- | --+
 |  notified   v   |
 | ----->          |
 |                 |
 | O |         O   |
 | O |         O   |
 | O +--------   --+--+
 | O |                |
 |   |                |
 |  <-- wait   O      |
 |   |      (Running  |
 +---+       thread)  |
     |                |
     |     leave      |
     |        |       |
     +------- | ------+
              v
</pre }>
<!--
TODO Concurrent
@ma: https://en.wikipedia.org/wiki/Monitor_(synchronization)
     https://cs.nyu.edu/~lerner/spring12/Preso03-JavaPrimitives.pdf
     https://en.wikipedia.org/wiki/Concurrent_computing 
     http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
-->
  </li>

  </ul }>
  </td>
<td>
  Concurrent code
  <ul xxxsmall zoom { >
  <li>
<pre {>
 +------------+ |               [[Executor]]
 |[[Runnable]]| |                   ^
 |------------| |                   |
 |+run()      | |           [[ExecutorService]]
 +------------+ |                   ^
       ^        |        +----------+--------------+
       |        |        |                         |
 +------------+ | AbstractExecutorService  [[ScheduledExecutorService]]
 |   Thread   | |        ^                         ^
 |------------| | ThreadPoolExecutor               |
 |+run()      | |        ^                         |
 |+start()    | | ScheduledThreadPoolExecutor -----+
 |+sleep()    | |
 |....        | |
 |------------| |
 +------------+ |
</pre }>
  </li>
  <li>
    ExecutorService(Thread Pool): managed collection of threads available to execute tasks.<br/>
    To use a thread pool, you can use an implementation of the interface 
    ExecutorService, such as ThreadPoolExecutor or ScheduledThreadPoolExecutor.
    However, more convenient factory methods are provided in the Executors class
    as follows:<br/>
    Using thread pool:
    <ol>
      <li>Write worker thread class implementing <<Runnable>> run()</li>
      <li>STEP 2: Create ExecutorService using:
<pre {>
Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int numThreads)
Executors.newCachedThreadPool(): <-- unbounded pool, with automatic reclamation
Executors.newSingleThreadScheduledExecutor()
Executors.newScheduledThreadPool(int size)
</pre }>
       </li>
       <li>Use executor(Service)Instance.execute(/*Runnable */workerThreadInstance)
         to add a Runnable task to thread pool. Executes task at some time in the
         future in a new thread, in a thread pool, or in the calling thread, 
         depending on the implementation of Executor</li>
     </ol>
<pre {>
 [[java.util.concurrent.ExecutorService]]
 + public     void      shutdown(); // Initiates orderly shutdown of pool
 + public <T> Future<T> submit(Callable<T> task); // schedule callable task for execution
</pre }>
  </li>
  </ul>
  <a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'>CompletableFuture (Java 8+)</a>
  <ul xxxsmall zoom >
    A Future that may be explicitly completed (setting its value and status), 
    and may be used as a CompletionStage, supporting dependent functions and 
    actions that trigger upon its completion.<br/>
    When two or more threads attempt to complete, completeExceptionally, or 
    cancel a CompletableFuture, only one of them succeeds.
  </li>
  <li>
<pre>
[[ java.util.concurrent.Callable&lt;V&gt; ]]
   +public V call()  (vs run() in Runnable)
   similar to a Runnable, but allows to return a result/Exception to the thread triggering the Callable
   returns a result of type &lt;V&gt;, or throws an exception if unable to do so.
  
[[ Future&lt;V&gt; ]] 
   +V get()           // blocks waiting for result
   +V get(long timeout, TimeUnit unit)
   +boolean cancel(boolean mayInterruptIfRunning)
   +boolean isCancelled()
   +boolean isDone()  // return true if this task completed
</pre>
  </li>
  <li>Barriers (<code orange>allOf</code>):
<pre>
CompletableFuture&lt;Void&gt;[] future_list = new CompletableFuture[list.size()];
        int idx=0;
        log.info("Connecting plugins ...");
        for (Object el : list) {
            final CompletableFuture&lt;Void&gt; connectFuture = new CompletableFuture&lt;&gt;();
            asyncMethod(connectFuture);
            ...
        }
        return CompletableFuture.<b orange>allOf</b>(future_list);
    }
</pre>
  </li>
  </ul>
</td>
<td>
  Example 1 ThreadPoolTest:
<pre xxxsmall zoom { >
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {

   public static void main(String[] args) {
      ExecutorService pool = Executors.newFixedThreadPool(10);
      MyWorker[] workers = new MyWorker[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) pool.execute(new MyWorker(i+1));
      pool.shutdown();
   }
}
</pre }>
  Example 2: CallableThreadPoolTest:
<pre xxxsmall zoom {>
import java.util.concurrent.Callable;
import java.util.concurrent.*;

public class CallableThreadPoolTest {

    public class MyCallableWorkerThread implements Callable&lt;String> {
       MyCallableWorkerThread(int workerNumber) { ... }
       public String call() { 
          Thread.sleep((int)(Math.random() * 1000));
          return "worker " + workerNumber;
       }
    }

   public static void main(String[] args) {
      int numWorkers = 10;
      ExecutorService pool = Executors.newCachedThreadPool();
      MyCallableWorkerThread workers[] = new MyCallableWorkerThread[numWorkers];
      Future                 futures[] = new Future                [numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new MyCallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
                                 try {
            System.out.println(futures[i].get() + " ended");
                                 } catch (InterruptedException ex) {
            ex.printStackTrace();
                                 } catch (ExecutionException ex) {
            ex.printStackTrace();
                                 }
      }
   }
}
</pre>
</td>
<td>
  Guava ListenableFuture
  <a href='https://github.com/google/guava/wiki/ListenableFutureExplained'>REF</a><br/>
  <ul xxxsmall zoom >
  <li>Concurrency is a hard problem, but it is significantly simplified by working with powerful and simple abstractions. To simplify matters, Guava extends the Future interface of the JDK with ListenableFuture.<br/></li>
  <li>
    <span cite>"""We strongly advise that you always use ListenableFuture instead
    of Future in all of your code, because:<br/>
    - Most Futures methods require it.<br/>
    - It's easier than changing to ListenableFuture later.<br/>
    - Providers of utility methods won't need to provide Future and ListenableFuture
      variants of their methods.</span>
  </li>
  </ul>
  ListenableFuture vs Java CompletableFuture 
  <a href="https://stackoverflow.com/questions/38744943/listenablefuture-vs-completablefuture">REF</a><br/>
  <ul xxxsmall zoom { >
  <li>
<pre { >
          ListenableFuture                           |               CompletableFuture
-----------------------------------------------------+---------------------------------------------------
                                                     | It is different from ListenableFuture in that it
                                                     | can be completed from any thread that wants it to complete
-----------------------------------------------------+---------------------------------------------------
ListenableFuture listenable = service.submit(...);   | CompletableFuture completableFuture =
  Futures.addCallback(listenable,                    |     new CompletableFuture();
                      new FutureCallback&lt;Object>() { | completableFuture.whenComplete(new BiConsumer() {
    @Override                                        |   @Override
    public void onSuccess(Object o) {                |   public void accept(Object o, Object o2) {
        //handle on success                          |       //handle complete
    }                                                |   }
                                                     | }); // complete the task
    @Override                                        | completableFuture.complete(new Object())
    public void onFailure(Throwable throwable) {     |            
       //handle on failure                           | When a thread calls complete on the task,
    }                                                | the value received from a call to get() is
  })                                                 | set with the parameter value if the task is
                                                     | not already completed.
</pre } >
  </li>
  <li cite>..."CompletableFuture is dangerous because it exposes *compete* methods."  </li>
  <li cite>..."CompletableFuture would have been good if it extended Future and did not expore toCompletableFuture,... and they could have named it something meaningful like ChainableFuture "  </li>
  </ul } >
  
  </td>
</tr }>
</table>

<table>
<tr {>
  <th colspan=3 header_delimit >Async/Reactive Programming</th>
</tr }>
<tr {>
<td>
  Summary
  <ul xxxsmall zoom >
  <li>addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation style APIs — as popularized by CompletableFuture and ReactiveX, that allow declarative composition of asynchronous logic. At the programming model level Java 8 enabled Spring WebFlux to offer functional web endpoints alongside with annotated controllers.
  </li>
  <li>The term "reactive" refers to programming models that are built around reacting to change — network component reacting to I/O events, UI controller reacting to mouse events, etc. In that sense non-blocking is reactive because instead of being blocked we are now in the mode of reacting to notifications as operations complete or data becomes available.
  </li>
  <li>Spring Reactive Streams is a small spec, also adopted in Java 9, that defines the interaction between asynchronous components with back pressure. For example a data repository — acting as Publisher, can produce data that an HTTP server — acting as Subscriber, can then write to the response. The main purpose of Reactive Streams is to allow the subscriber to control how fast or how slow the publisher will produce data.
  </li>
  <li>Reactive Streams plays an important role for interoperability. It is of interest to libraries and infrastructure components but less useful as an application API because it is too low level. What applications need is a higher level and richer, functional API to compose async logic — similar to the Java 8 Stream API but not only for collections. This is the role that reactive libraries play.
  </li>
  </ul>
</td>
<td>
  <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">java.util.concurrent.Flow (1.9+)</a><br/>
  <ul xxxsmall zoom>
  <li>Reactive Streams was adopted by the JDK in the form of the java.util.concurrent.Flow API.
  <li>It allows two different libraries that support asynchronous streaming to connect to each other,
    with well specified semantics about how each should behave, so that backpressure, completion, cancellation 
    and error handling is predictably propagated between the two libraries. </li>
  <li>There is a rich ecosystem of open source libraries that support Reactive Streams, 
    and since its inclusion in JDK9, there are a few in development implementations that are
    targetting the JDK, including the incubating <a href="http://openjdk.java.net/jeps/321">JDK9 HTTP Client</a>,
    and the <a href="https://twitter.com/brunoborges/status/915302682939711488">Asynchronous Database Adapter (ADBA)</a> 
    effort that have also adopted it</li>
  <li>(See also <a href="http://www.eclipse.org/community/eclipse_newsletter/2018/may/reactivestreams-ee4j.php">What can Reactive Streams offer to EE4J</a>)</li>
  </ul>
</td>
<td>
    RxJava (<a href="https://github.com/ReactiveX/RxJava">REF</a>)<br/>
<pre xxxsmall zoom > 
            Java 8 Stream
+       CompletableFuture
+ "Back-presure" measures *1
-------------------------
            rx.Observable
*1 probably an intermediate buffer for incomming/outgoing messages that acts 
async. when not full, and sync when full.
</pre> 
  </td>
</tr }>
</table>
<br/>
<table>
<tr {>
<td>
  JSON
  <ul xxxsmall zoom { >
    <li><a href='https://www.infoq.com/news/2017/03/json-processing-public-review'>REF:JSON processing public review</a></li>
    <li>
Public review of JSR 374: Java API for JSON Processing (JSON-P) version 1.1 is now open. 
This version is expected to be included in the release of J2EE 8 and keeps JSON-P current with JSON IETF standards. It includes support for:
      <ul>
      <li>JSON Pointer</li>
      <li>JSON Patch</li>
      <li>JSON Merge Patch</li>
      <li>Query and transformation operations</li>
      <li>Java 8 streams and lambdas</li>
      </ul>
    </li>
    <li>JSON-P was introduced in 2013 with the release of J2EE 7, as an alternative to Gson and Jackson. It was designed to parse, generate, 
and query standard JSON documents.

JSR-367: Java API for JSON Binding (JSON-B), will also be included in the release of J2EE 8.
    </li>
  </ul }>
    tags: [JSON Parsing, HTTP GET/POST, TLS, Basic Authorization]
<pre xxxsmall zoom {>
package com.mycomp.project1;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.json.JSONObject;

import java.security.cert.X509Certificate;
import java.util.Date;

import java.util.Scanner;

public class TestAPI<JSONArray> {
    static String userpass = "operator1:ecllqy";
    private static SSLSocketFactory sslSocketFactory = null;

    private JSONObject sendPost(String url, String post_body, String token) throws Exception 
    {
        URL obj = new URL(url);
        String basicAuth = "Basic " +
            javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

        HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

        setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

        con.setRequestMethod("POST"); //add request header
        con.setRequestProperty("Content-Type", "application/json");
        con.setRequestProperty("Cache-Control", "no-cache");
        if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
        } else               { con.setRequestProperty("Authorization", "Bearer "+token);
        }
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(post_body);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();

        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        StringBuffer response = new StringBuffer();
        String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
        in.close();
        return new JSONObject(response.toString()); //String myJSONStr
    }


    /********************************************************************************/
    /**
     * Overrides the SSL TrustManager and HostnameVerifier to allow
     * all certs and hostnames.
     * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
     * environment.
     *
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     */
    protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
        // Create the socket factory.
        // Reusing the same socket factory allows sockets to be
        // reused, supporting persistent connections.
        if( null == sslSocketFactory) {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
            sslSocketFactory = sc.getSocketFactory();
        }

        connection.setSSLSocketFactory(sslSocketFactory);

        // Since we may be using a cert with a different name, we need to ignore
        // the hostname as well.
        connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
    }

    private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {}
            public void checkServerTrusted(X509Certificate[] certs, String authType) {}
        }
    };

    private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
}
</pre } >
</td>
<td>
  [QA] Restassured: JSON REST API Test
<pre xxxsmall zoom>
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;scala-support&lt;/artifactId&gt;
    &lt;version&gt;3.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt;
    &lt;version&gt;3.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
___________________________
package com.mycompany.myproject.mymodule;

import static junit.framework.TestCase.assertTrue;
import static org.hamcrest.Matchers.*;

import com.everis.trinity.server.common.StatusResult;

import static io.restassured.RestAssured.given;

import io.restassured.RestAssured;
import io.restassured.config.HttpClientConfig;
import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import junit.framework.TestCase;
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.SystemDefaultHttpClient;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.eclipse.jetty.http.HttpStatus;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.BeforeClass;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;

import java.util.Base64;
import java.util.Map;

// <b>FullJourney == Simulate full (REST) API in expected order</b>
public class FullJourneyTest { 

    // Custom regex matcher for RestAssured Framework
    public static class RegexMatcher extends BaseMatcher<Object>{
        private final String regex;

        public RegexMatcher(String regex){
            this.regex = regex;
        }

        public boolean matches(Object o){
            return ((String)o).matches(regex);

        }

        public void describeTo(Description description){
            description.appendText("matches regex=");
        }

        public static RegexMatcher matches(String regex){
            return new RegexMatcher(regex);
        }
    }

     public static class Base64Matcher extends BaseMatcher<Object>{

        public Base64Matcher(){}

        public boolean matches(Object o){
            try {
                Base64.getDecoder().decode((String)o);
                return true;
            }catch (Exception e){
                return false;
            }
        }

        public void describeTo(Description description){
            description.appendText("can be parsed as Base64");
        }

        public static Base64Matcher isBase64Encoded(){
            return new Base64Matcher();
        }
    }
    private static final String AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;

    protected static RequestSpecification setupCommonHeaders() {
        return given().header("Authorization", AUTH_HEADER_VALUE)
                      .header("Accept"       , "application/json")
                      .header("content-type" , "application/json;charset=utf-8")
        .log().all();
    }


    final String
        NAME="COMMUNITY_1", SYMBOL="SY1";

    Response response;
    @BeforeClass
    public static void setup() {
        RestAssured.port     = ServerConfig.serverPort;
        RestAssured.basePath = "/";
        RestAssured.baseURI  = "http://localhost";

        HttpClientConfig clientConfig = RestAssured.config().getHttpClientConfig();
        clientConfig = clientConfig.httpClientFactory(new HttpClientConfig.HttpClientFactory() {
            @Override
            public HttpClient createHttpClient() {
                HttpClient rv =  new SystemDefaultHttpClient();
                HttpParams httpParams = rv.getParams();
                //  Wait 5s max for a connection
                HttpConnectionParams.setConnectionTimeout(httpParams, 5 * 1000);
                // Default session is 60s
                HttpConnectionParams.setSoTimeout(httpParams, 60 * 1000); 
                return rv;
            }
        });
        // This is necessary to ensure, that the client is reused.
        clientConfig = clientConfig.reuseHttpClientInstance();
        RestAssured.config = RestAssured.config().httpClient(clientConfig);
    }

    @Test
    public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
        String jsonBody =
            "{ " +
                " \"name\": \""+NAME+"\", " +
                " \"symbol\": \"" + SYMBOL + "\","
            "}";
        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/01")</b>;
        System.out.println(response.body().prettyPrint());
        response.then()
            /* <b>get sure JSON serializer do not include extra (maybe sensitive) info</b> */
            .body("size()", <b orange>is(5)                          </b>)
            .body("id"    , <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>RegexMatcher.matches("^*{65}$")</b>)
            .body("pubkey", <b orange>Base64Matcher.isBase64Encoded()</b>)
            .body("name"  , <b orange>equalTo(NAME)                  </b>)
            .body("symbol", <b orange>equalTo(SYMBOL)                </b>)
            .statusCode(HttpStatus.ACCEPTED_202);
        String <b blue>NEW_ID = response.getBody().jsonPath().get("id")</b>;

        // Next related test to execute synchronously after fetching NEW_ID
        String jsonBody =
            "{ " +
                <b blue>" \"FK_ID\": \""+NEW_ID+"\", " +</b>
                ...
            "}";

        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/02")</b>;
        ...
    }

}


</pre>
</td>
<td colsep></td>
<td>
  Functional Programing<br/>
  Lambdas
<pre xxxsmall zoom>
Sytnax:
(parameters) -&gt; expression
(parameters) -&gt;  { statements; }

// takes a Long, returns a String
Function&lt;Long, String&gt; f = (l) -&gt; l.toString();

// takes nothing, gives you Thread
Supplier&lt;Thread&gt; s = Thread::currentThread;

//  takes a string as the parameter
Consumer&lt;String&gt; c = System.out::println;

// use lambdas in streams
new ArrayList&lt;String&gt;().stream()....

// peek: Debug streams without changes
peek ( e -&gt; System.out.println(e)). ...

// map: Convert every element into something
map ( e -&gt; e.hashCode())...

// filter (hc -&gt; (hc % 2) == 0) ...

// collect all values from the stream
collect(Collectors.toCollection(TreeSet::new))
</pre>

https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html

  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html"><code>java.util.function 1.8+</code></a>
  <ul xxxsmall zoom>
  <li>INcomplete but good enough to cover the "shape" of many lambda expressions and method references
      representing abstract concepts like functions, actions, or predicates</li>
  <li>The <code>@FunctionalInterface</code> is used to capture design intent (not needed by compiler).</li>
  <li>In documenting functional interfaces, or referring to variables typed as 
      functional interfaces, it is common to refer directly to those abstract concepts,
      for example using "this function" instead of "the function represented by this object".</li>
  <li>Each functional interface has a single abstract method, called the functional method for that 
    functional interface, to which the lambda expression's parameter and return types are matched or adapted.</li>
   <li> Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation,
     or cast context:
<pre>
Predicate&lt;String&gt; p = String::isEmpty;           // Assignment context
stream.filter(e -&gt; e.getSize() &gt; 10)...          // Method invocation context
stream.map((ToIntFunction) e -&gt; e.getSize())...  // Cast context
</pre>
  </li>
  <li>Defined functions in 1.8:
<pre>
────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────
           Interface Summary                │           Interface Description
────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────
                  BiConsumer‹T,U›           │opt. accepting two input arguments and returns no result
  (|Double|Int|Long)Consumer‹T›             │opt. accepting a single (Object|double|int|long)input argument and returns no result
Obj(Double|Int|Long)Consumer‹T›             │opt. accepting an object-valued and a (double|int|long)-valued argument, and returns no result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
        (|Double|Long|Int)Function‹(T,)R›   │func. that accepts an (T|double,long,int) argument and produces a result
       (|Double|Long)ToIntFunction          │func. that accepts a (T|double|long)argument and produces an int-valued result
(ToDouble|ToLong|ToInt|)BiFunction‹(T,)U,R› │func. that accepts two arguments and produces an (T,double,long,int) result.
           To(Double|Long)Function‹T›       │func. that produces a (double|long)-valued result
(Int|Long|Double)To(Int|Long|Double)Function│func. that accepts a (int|long|double) argument and produces a (int|long|double) result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
 (|Int|Long|Double)UnaryOperator‹T›         │op. on a single (T|int|long|double) operand that produces a result of the same type
(Double|Long|Int|)BinaryOperator‹T›         │op. upon two (T|int|long|double) operands and producing a result of the same type
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
                BiPredicate‹T,U›            │predicate (boolean-valued function) of two arguments
(|Int|Long|Double)Predicate‹T›              │predicate (boolean-valued function) of one (T|int|long|double) argument
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
(|Boolean|Int|Long|Double)Supplier(‹T›)     │supplier of (T|Boolean|Int|long|double) results
────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────
</pre>
  </li>
  </ul>
</td>
<td colsep></td>
<td>
  [QA] Exceptions
  <ul xxxsmall zoom {>
  <li>(compiler) checked vs unchecked (Error, RuntimeException and their subclasses).</li>
  <li>Checked: All except Error, RuntimeException and their subclasses</li>
  <li>Error: Exceptional conditions external to the application.</li>
<pre { >
java.lang.Object
   java.lang.Throwable
       java.lang.Exception
           java.lang.RuntimeException (non-checked)
           java.lang.*Exception       (checked -A)
       java.lang.Error                (non-checked)
</pre }>
    
  <li>The Throwable class is the superclass of all errors and exceptions in the Java language.  Only objects that are instances of this class (or one of its subclasses) are thrown by the JVM or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.</li>
     <li>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.</li>
  </ul>
  <hr xxxsmall />

  <b>[QA] Avoiding Nulls<br/><b>
  <code>java.util.Optional</code>
<pre xxxsmall zoom>
<a href="http://files.zeroturnaround.com/pdf/zt_java8_best_practices.pdf">REF</a>
// Create an optional
Optional<Sgtring> optional = Optional.ofNullable(a);

// Process the optional
optional.map ( s -> "RebelLabs:" + s);

// map a function that retunrs Optional
optional.flatMap( s -> Optional.ofNullable(s));

// run if the value is ther
optional.ifPresent(System.out::println);

// get the value or thorw an exception
optional.get();

// return the value or the given value
optional.orElse("Hello world!");

// return empty Optional if not satisfied
optional.filter( s -> s.startsWith("RebelLabs"));
</pre>

</td>
<td>
  [QA] Checker framework
  <ul xxxsmall zoom {>
  <li>
    <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>REF: Oracle Java 8 new Type Annotations</a>
Java SE 8 allows type annotations anywhere that a type is used. Previously, 
annotations were only allowed on definitions. 
The Checker Framework provides a few Type Annotations that could benefit both 
library and application developers, such as:
<pre {>
@NonNull: compiler can determine cases where a code path might receive a null.

@ReadOnly: compiler will flag any attempt to change the object.

@Regex – compile-time verification that a String intended to be used 
    as a regular expression is a properly formatted regular expression.

@Tainted and @Untainted: Identity types of data that should not be used
    together, such as remote user input being used in system commands, 
    or sensitive information in log streams.

@m – Units of measure ensures that numbers used for measuring objects 
    are used and compared correctly, or have undergone the proper unit
    conversion.
</pre }>
  </li>
  <li TODO >installation process:<br/>
    Download the Checker Framework distribution: 
      https://checkerframework.org/checker-framework-2.1.8.zip. <br/>
    Configure your IDE, build system, or command shell to include the 
    Checker Framework on the classpath. Choose the appropriate section of 
    Chapter 30 for javac (Section 30.1), Ant (Section 30.2), Maven (Section 30.3),
    Gradle (Section 30.4), IntelliJ IDEA (Section 30.6), Eclipse (Section 30.7),
    or tIDE (Section 30.8).<br/>
    Option 1: Add directory .../checker-framework-2.1.8/checker/bin to your path, before any other directory that contains a javac executable.</li>
  <li>The Nullness Checker supports several annotations that specify method 
      behavior. <br/>
     These are declaration annotations, not type annotations:<br/>
     they apply to the method itself rather than to some particular type.<br/>
     @RequiresNonNull (precondition): annotated method expects the specified 
     variables to be non-null when the method is invoked.<br/>
       @EnsuresNonNull (postcondition): the given expressions are non-null 
     after the method returns;<br/>
       @EnsuresNonNullIf: if annotated method returns true|false, then the 
     given expressions are non-null.<br/>
  </li>
  <li>The Lock Checker prevents certain concurrency errors by enforcing a 
    locking discipline. A locking discipline indicates which locks must be 
    held when a given operation occurs. You express the locking discipline by 
    declaring a variable’s type to have the qualifier @GuardedBy("lockexpr"). 
    This indicates that the variable’s value may be dereferenced only if the 
    given lock is held.</li>
  <li>@GuardedBy(exprSet): If a variable x has type @GuardedBy("expr"), then a thread may dereference the value referred to by x only when the thread holds the lock that expr currently evaluates to. It can list multiple expressions, as in @GuardedBy({"expr1", "expr2"}), in which case the dereference is permitted only if the thread holds all the locks.</li>
  <li>Method pre-conditions and post-conditions<br/>
@Holding(String[] locks): All the given lock expressions are held at the method call site.<br/>
@EnsuresLockHeld(String[] locks): The given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that acquires a lock such as ReentrantLock.lock().<br/>
@EnsuresLockHeldIf(String[] locks, boolean result): If the annotated method returns the given boolean value (true or false), the given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that conditionally acquires a lock. See Section 6.4.4 for examples.</li>
  <li>Side effect specifications<br/>
@LockingFree: The method does not acquire or release locks, directly or indirectly. The method is not synchronized, it contains no synchronized blocks, it contains no calls to lock or unlock methods, and it contains no calls to methods that are not themselves @LockingFree. <br/>
    Since @SideEffectFree implies @LockingFree, if both are applicable then you only need to write @SideEffectFree.<br/>
@ReleasesNoLocks: The method maintains a strictly nondecreasing lock hold count on the current thread for any locks that were held prior to the method call. The method might acquire locks but then release them, or might acquire locks but not release them (in which case it should also be annotated with @EnsuresLockHeld or @EnsuresLockHeldIf).<br/>
    This is the default for methods being type-checked that have no @LockingFree, @MayReleaseLocks, @SideEffectFree, or @Pure annotation.<br/>
  </li>
  <li>The Format String Checker prevents use of incorrect format strings in format methods such as System.out.printf and String.format. Ej:
<pre>
void printFloatAndInt(@Format({FLOAT, INT}) String fs) {
        System.out.printf(fs, 3.1415, 42);
    }
</pre>
  </li>
  <li>Here are the examples of errors that the I18n Format Checker detects at compile time
<pre {>
// Warning: the second argument is missing.
MessageFormat.format("{0} {1}", 3.1415);
// String argument cannot be formatted as Time type.
MessageFormat.format("{0, time}", "my string");
// Invalid format string: unknown format type: thyme.
MessageFormat.format("{0, thyme}", new Date());
// Invalid format string: missing the right brace.
MessageFormat.format("{0", new Date());
// Invalid format string: the argument index is not an integer.
MessageFormat.format("{0.2, time}", new Date());
// Invalid format string: "#.#.#" subformat is invalid.
MessageFormat.format("{0, number, #.#.#}", 3.1415);
</pre } >
  </li>
  <li>The Property File Checker ensures that a property file or resource bundle (both of which act like maps from keys to values) is only accessed with valid keys. Accesses without a valid key either return null or a default value, which can lead to a NullPointerException or hard-to-trace behavior. The Property File Checker (Section 12.1) ensures that the used keys are found in the corresponding property file or resource bundle.</li>
  <li>One of the most prevalent GUI-related bugs is invalid UI update or invalid thread access: accessing the UI directly from a background thread.

Most GUI frameworks (including Android, AWT, Swing, and SWT) create a single distinguished thread — the UI event thread — that handles all GUI events and updates. To keep the interface responsive, any expensive computation should be offloaded to background threads (also called worker threads). If a background thread accesses a UI element such as a JPanel (by calling a JPanel method or reading/writing a field of JPanel), the GUI framework raises an exception that terminates the program. To fix the bug, the background thread should send a request to the UI thread to perform the access on its behalf.

It is difficult for a programmer to remember which methods may be called on which thread(s). The GUI Effect Checker solves this problem. The programmer annotates each method to indicate whether:

    It accesses no UI elements (and may run on any thread); such a method is said to have the “safe effect”.
    It may access UI elements (and must run on the UI thread); such a method is said to have the “UI effect”. 
  </li>
  <li>The following kind of (physical) UNIT annotations are defined:
<pre { >
@Acceleration @Angle @Area @Current @Length @Luminance @Mass
@Speed @Substance @Temperature @Time

For each kind of unit, the corresponding SI unit of measurement is defined:

For @Acceleration: Meter Per Second Square @mPERs2
For @Angle: Radians @radians, and the derived unit Degrees @degrees
For @Area: the derived units square millimeters @mm2, square meters @m2, and square kilometers @km2
For @Current: Ampere @A
For @Length: Meters @m and the derived units millimeters @mm and kilometers @km
For @Luminance: Candela @cd
For @Mass: kilograms @kg and the derived unit grams @g
For @Speed: meters per second @mPERs and kilometers per hour @kmPERh
For @Substance: Mole @mol
For @Temperature: Kelvin @K and the derived unit Celsius @C
For @Time: seconds @s and the derived units minutes @min and hours @h 
</pre }>
  </li>
  <li>The Signedness Checker guarantees that signed and unsigned values are not mixed together in a computation. In addition, it prohibits meaningless operations, such as division on an unsigned value.
@Unsigned  @Signed
  </li>
  <li>A type alias or typedef is a type that shares the same representation as another type but is conceptually distinct from it. For example, some strings in your program may be street addresses; others may be passwords; and so on. You wish to indicate, for each string, which one it is, and to avoid mixing up the different types of strings. Likewise, you could distinguish integers that are offsets from those that are absolute values.</li>
  <li>SPARTA is a security toolset aimed at preventing malware from appearing in an app store. SPARTA provides an information-flow type-checker that is customized to Android but can also be applied to other domains. The SPARTA toolset is available from https://checkerframework.org/sparta/. The paper “Collaborative verification of information flow for a high-assurance app store” appeared in CCS 2014.</li>
  <li>Example:
<pre { >
@NonNull List&lt;String>

List&lt;@NonNull String> 

@Regex String validation = "(Java|JDK) [7,8]"

private String getInput(String parameterName){
 final String retval = @Tainted request.getParameter(parameterName);
 return retval;
} 

private void runCommand(@Untainted String… commands){
 // the previously tainted String must be validated before being passed in here.
 ProcessBuilder processBuilder = new ProcessBuilder(command);
 Process process = processBuilder.start();
}
</pre }>
  </li>
  </ul>
</td>
<td>
  [QA] Eclipse Static Code Analasys
<pre xxxsmall zoom {>
Eclipse -> Properties -> Java -> Compiler -> Errors/Warnings -> Null analysis:
  Null pointer access
  Potential null pointer access
  Redundant null check:
    x Include 'assert' in null analysis
    x Enable annotation-based null analysis
      Violation of null specification
      Conflict between null annotations an null inference
      Unchecked conversion from non-annotated type to @NonNull type
      Problems detected by pessimistic analysis fro free type variables
      Unsafe "@Nonnull" interpretation of the free type variable from library
      Redundant null anotation:
      "@NonNull" parametere not annotated in overriding method
      Missing "@NonNullByDefault" annotation on package
      x Use default annotations for null specifications (configure)
      x Inherit null annotations
      x Enable syntatic null analisys for fields
  x Treat above errors like fatal compile erros (make compiled code not executable) 
</pre } >
</td>

</tr }>
</table>



</body>
<!--
-------------------------------------------------
TODO_start:
-------------------------------------------------
- http://picodotdev.github.io/blog-bitix/ , http://elblogdepicodev.blogspot.com.es/
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw

-------------------------------------------------
{
Java programming language provides multiple mechanisms for communicating between threads:
- The most basic of these methods is synchronization, which is implemented using monitors.
  Each object in Java is associated with a monitor, which a thread can lock or unlock.
 Only one thread at a time may hold a lock on a monitor. Any other threads attempting to
 lock that monitor are blocked until they can obtain a lock on that monitor. A thread t
 may lock a particular monitor multiple times; each unlock reverses the effect of one
 lock operation.
The synchronized statement (§14.19) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 A synchronized method (§8.4.3.6) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.
 Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.
Every object, in addition to having an associated monitor, has an associated wait-set. A wait-set is a set of threads.
 When an object is first created, its wait set is empty. Elementary actions that add threads to and remove threads from wait sets are atomic. Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll.

Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
  - A notify action being performed on m in which t is selected for removal from the wait set.
  - A notifyAll action being performed on m. 
  - An interrupt action being performed on t. 
  - If this is a timed wait, an internal action removing t from m's wait set that occurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse since the beginning of this wait action. 
  - An internal action by the implementation. Implementations are permitted, although not encouraged, to perform "spurious wake-ups",
    that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
  
 Notification actions occur upon invocation of methods notify and notifyAll.

Memory that can be shared between threads is called shared memory or heap memory. All instance fields, static fields, and array elements are stored in heap memory. In this chapter, we use the term variable to refer to both fields and array elements. Local variables (Â§14.4), formal method parameters (Â§8.4.1), and exception handler parameters (Â§14.20) are never shared between threads and are unaffected by the memory model.
}
-------------------------------------------------
-------------------------------------------------
Java Value Types proposal:
https://www.infoq.com/news/2017/11/ValueTypesNov10
--------------------------------
JAVA Enhancements proposals:
http://openjdk.java.net/jeps/0
-------------------------------
REF: http://www.baeldung.com/java-completablefuture
  |In asynchronous computation, actions are represented as callbacks, handling errors might occur at any step.
  |
  |Java 5+: Future: Represent an asynchronous computation
  |Java 8+: CompletableFuture : Extends Future with methods to combine and handle errors
  |                            Extends the CompletionStage interface
  |                              - Contract for an asynchronous computation step that
  |                                can be combined with other steps.
  |                            About 50 different methods for composing, combining, executing async computation
  |
  |
  |Using CompletableFuture as a Simple Future (no-arg constructor) 
  |
  |In the example below we have a method that creates a CompletableFuture instance, then spins off some computation in another thread and returns the Future immediately.
  |
  |  1  public Future<String> calculateAsync() throws InterruptedException {
  |  2      Future<String> result = new CompletableFuture<>();
  |  3     
  |  4      Executors.newCachedThreadPool().submit(() -> {
  |  5          Thread.sleep(500);
  |  6          completableFuture.complete("Hello");
  |  7          return null;
  |  8      });
  |  9   
  |  10     return completableFuture;
  |  11 }
  |  Line 2: Alternatively when the result of computation is known:
  |          Future<String> result = CompletableFuture.
  |             completedFuture("Hello");
  |  
  |  Line 6: Alternatively completableFuture.cancel(false);
  |  Line 5: any other mechanism can be used to compute 
  |    
  |
  |  1 Future<String> completableFuture = calculateAsync();
  |  2  
  |  3 // ... 
  |  4  
  |  5 String result = completableFuture.get();
  |  6 assertEquals("Hello", result);
  |
  |Line 5: get() blocks until .complete("...") is called in other thread
  |Line 5: get()can raise 
  |           ExecutionException: error during computation
  |           InterruptedException: thread executing method interrupted
  |
  |4. CompletableFuture with Encapsulated Computation Logic (runAsync -<<Runnable>>-, supplyAsync -<<Supplier>>-)
  |
  |<<Supplier>>: generic functional interface with single method (zero arguments, returns value)
  |
  |  1 CompletableFuture<String> future
  |  2   = CompletableFuture.supplyAsync(/*supplier lambda*/ () -> "Hello")
  |  3 .thenApply(/* "processor" lambda */ s -> s + " World") /* returns CompletableFuture */;
  |  4 .thenAccept(/*consumer lambda */ 
  |  5    s -> System.out.println("Computation returned: " + s));
  |    Line 4: Alternatively (ignrore result)
  |    .thenRun(/*Runnable lambda*/ () -> System.out.println("Computation finished."));
  |
  |5. Combining Futures (monadic design pattern in functional languages)
  |
  |  1 CompletableFuture<String> completableFuture 
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCompose(
  |  4           s -> CompletableFuture.supplyAsync(() -> s + " World"));
  |  4  
  |  5 assertEquals("Hello World", completableFuture.get());
  |    
  |6. Execute two independent Futures and do something with their results
  |
  |  1 CompletableFuture future  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCombine(CompletableFuture.supplyAsync(
  |  4       () -> " World"), (s1, s2) -> s1 + s2));
  |  5  
  |  6 assertEquals("Hello World", future.get());
  |    
  |(Simpler case - nothing to do with resulting value-)
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3   .thenAcceptBoth(CompletableFuture.supplyAsync(
  |  4      () -> " World"), (s1, s2) -> log(s1 + s2));
  |    
  |7. Running Multiple Futures in Parallel:  wait for all to execute and process combined results
  |
  |  1  CompletableFuture<String> future1  
  |  2    = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  CompletableFuture<String> future2  
  |  4    = CompletableFuture.supplyAsync(() -> "Beautiful");
  |  5  CompletableFuture<String> future3  
  |  6    = CompletableFuture.supplyAsync(() -> "World");
  |  7   
  |  8  CompletableFuture<Void> combinedFuture 
  |  9    = CompletableFuture.allOf(future1, future2, future3);
  |  10  
  |  11 // ...
  |  12  
  |  13 combinedFuture.get();
  |  14  
  |  15 String combined = Stream.of(future1, future2, future3)
  |  16   .map(CompletableFuture::join)
  |  17   .collect(Collectors.joining(" "));
  |  18 assertEquals("Hello Beautiful World", combined);
  |
  |    Line 16: join() is similar to get, but throws unchecked exception if the Future does not complete normally.
  |
  |8. Handling Errors
  |
  |   Instead of catching an exception in a syntactic block, the CompletableFuture class allows you to handle it in a special handle method. This method receives two parameters: a result of a computation (if it finished successfully) and the exception thrown (if some computation step did not complete normally).
  |
  |
  |
  |Capture async exception:
  |           
  |  1  CompletableFuture<String> completableFuture  
  |  2    =  CompletableFuture.supplyAsync(() -> {
  |  3        ... if(errorDetected) 
  |  4               throw new RuntimeException("Computation error!");
  |  6        return "Hello ";
  |  7    })}).handle((s, t) -> s != null ? s : "Hello, Stranger!");
  |  8   
  |  9  assertEquals("Hello, Stranger!", completableFuture.get());
  |Alt: 
  |  1  completableFuture.completeExceptionally(
  |  2    new RuntimeException("Calculation failed!"));
  |  3  ...  
  |  4  completableFuture.get(); // ExecutionException
  |                                                                            
  |9. Async Methods
  | - The methods without the Async postfix run next execution stage using a calling thread.
  |
  | - The Async method without the Executor argument runs a step using the common fork/join pool implementation of Executor 
  |   that is accessed with the ForkJoinPool.commonPool() method.
  |
  | - The Async method with an Executor argument runs a step using the passed Executor.
  |
  | Ex.: process result of computation with a Function instance
  |  1 CompletableFuture<String> completableFuture  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  
  |  4 CompletableFuture<String> future = completableFuture
  |  5   .thenApplyAsync(s -> s + " World");
  |  6  
  |  7 assertEquals("Hello World", future.get());
  |
  |    Line 5: under the hood the application of a function is wrapped into a ForkJoinTask instance 
  |    (for more information on the fork/join framework, see the article ?Guide to the Fork/Join Framework in Java?).
  |    This allows to parallelize your computation even more and use system resources more efficiently.

--------------
QA: 
  - Static analysis tool for Java / C/C++ / Objective C
       http://fbinfer.com/ 

  - FindBugs:

  - Junit:
    https://www.infoq.com/news/2018/01/VSCodeJunit

___________________________
Douglas Craigs Schmidt Java Lessons: 
https://github.com/douglascraigschmidt/LiveLessons
___________________________
Bug en Java: Boolean.parseBoolean   http://forums.java.net/jive/thread.jspa?threadID=55408
___________________________
Java Monitoring {{{
http://java.sun.com/developer/technicalArticles/J2SE/monitoring/
     ______
https://visualvm.github.io/
   VisualVM is a visual tool integrating commandline JDK tools and lightweight profiling capabilities.
   Designed for both development and production time use. 
}}}
___________________________
Terracotta Brings Real-Time Analytics to the (Java) Masses  http://www.nytimes.com/external/gigaom/2011/02/15/15gigaom-terracotta-brings-real-time-analytics-to-the-java-77320.html?partner=rss&emc=rss&mkt_tok=3RkMMJWWfF9wsRonu6vOZKXonjHpfsX54u8rWbHr08Yy0EZ5VunJEUWy2YUBWoEnZ9mMBAQZC811xR5KG%2BOaaJRB
___________________________
Non-Blocking I/O Made Possible in Java  http://www.developer.com/java/article.php/3837316/Non-Blocking-IO-Made-Possible-in-Java.htm
In this article we will review non-blocking IO, a feature of java.nio (New I/O) package that is a part of Java v1.4, v1.5 and v1.6 and introduce the java.nio.file (NIO.2) package. NIO.2 will be included in the upcoming Java SE7 ("Dolphin") release.

The Selector for Single-Thread Multi-Socket I/O

A Selector allows processing of multiple sockets I/O read & write operations in a single thread, also known as multiplexing, solving the
limitation of 'one dedicated thread per socket connection.' It manages SelectableChannels (gateway for registering/deregistering channels), 
SelectionKeys (glue that associates Selectors, Channels and their I/O events) and monitors concurrent thread executions involved in network operations.
___________________________
Thread Synchronization  http://www.artima.com/insidejvm/ed2/threadsynch.html
Inside the Java Virtual Machine http://www.artima.com/insidejvm/ed2/index.html
___________________________
Tribe: Unlike JGroups, Tribe only targets reliable multicast (no probabilistic delivery) and is optimized for cluster communications.   http://tribe.ow2.org/
JGroups is a toolkit for reliable multicast communication.  http://www.jgroups.org/
________________
JSRs: Java Specification Requests
JSR 305: Annotations for Software Defect Detection

____________________
Jooq, the easiest way to write SQL in java:
https://www.jooq.org/
____________________
Java async frameworks:

Spring Reactor:

  https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html

  """Why Reactor when there's already RxJava2?

   RxJava2 is java 6 while for Reactor the Spring team decided to go all in and focus only on Java 8. This means that you can make use of all the new and fancy Java 8 features.

If you are going to use Spring 5, Reactor might be the better option.

But if you are happy with your RxJava2, there is no direct need to migrate to Reactor."""

https://spring.io/blog/2013/05/13/reactor-a-foundation-for-asynchronous-applications-on-the-jvm

https://spring.io/guides/gs/async-method/
____________________

Apache MINA vs Netty: https://www.youtube.com/watch?v=A2pWsxPWJuc

Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily. It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and UDP/IP via Java NIO.

Apache MINA is often called:

    NIO framework library,
    client server framework library, or
    a networking socket library

Apache MINA comes with many subprojects :

    Asyncweb : An HTTP server build on top of MINA asynchronous framework
    FtpServer : A FTP server
    SSHd : A Java library supporting the SSH protocol
    Vysper : An XMPP server

- - - - - - - - - - - -
________________
https://github.com/akullpp/awesome-java
_______
Project Loom:
Project Loom's mission is to make it easier to write, debug, profile and maintain concurrent applications meeting today's requirements. Threads, provided by Java from its first day, are a natural and convenient concurrency construct (putting aside the separate question of communication among threads) which is being supplanted by less convenient abstractions because their current implementation as OS kernel threads is insufficient for meeting modern demands, and wasteful in computing resources that are particularly valuable in the cloud. Project Loom will introduce fibers as lightweight, efficient threads managed by the Java Virtual Machine, that let developers use the same simple abstraction but with better performance and lower footprint. We want to make concurrency simple(r) again! A fiber is made of two components — a continuation and a scheduler. As Java already has an excellent scheduler in the form of ForkJoinPool, fibers will be implemented by adding continuations to the JVM.

RELATED: http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf
_______
Google Guava:
_______
Java to Javascript transpiler:
JSweet.org

http://teavm.org/
"https://en.wikipedia.org/wiki/Java_virtual_machine#Compilation_to_JavaScript

""Main JVM bytecode to JavaScript compilers are TeaVM,[20] the compiler contained in Dragome Web SDK,[21] Bck2Brwsr,[22] and j2js-compiler.[23]"""
-------------------------------------------------

_________________
    <li>JAVA 8+ <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>Ref</a>
    <table xxsmall>
    <tr>
    <td>@NonNull</td>
    <td>compiler can determine cases where a code path might receive a null value, 
        without ever having to debug a NullPointerException. The compiler just print a warning, but it continues to compile!!!</td>
    </tr>
    <tr>
    <td>@ReadOnly </td>
    <td>compiler will flag any attempt to change the object. This is similar to Collections.unmodifiableList, 
    but more general and verified at compile time.</td>
    </tr>
    <tr>
    <td>@Regex</td>
    <td>Provides compile-time verification that a String intended to be used as a regular expression is a properly formatted 
    regular expression.</td>
    </tr>
    <tr>
    <td>@(Un)Tainted</td>
    <td>Identity types of data that should not be used together, such as remote user input being used in 
    system commands, or sensitive information in log streams</td>
    </tr>
    <tr>
    <td>@m</td>
    <td>Units of measure ensures that numbers used for measuring objects are used and compared correctly, or have undergone the
    proper unit conversion.</td>
    </tr>
    <tr>
    <td>@FunctionalInterface</td>
    <td>indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Spec.</td>
    </tr>
    </table> 
    Ex:
<pre xxsmall>
Annotation                                         Meaning
@NonNull List<String>                              A non-null list of Strings.
List<@NonNull String>                              A list of non-null Strings.
@Regex String validation = "(Java|JDK) [7,8]"      Check at compile time that this String is a valid regular expression.
private String getInput(String parameterName){     The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval = 
      @Tainted request.getParameter(parameterName);
  return retval;
}
        
private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
  ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

  Process process = processBuilder.start();
}
</pre>
  </li>
<td>
Java Cryptographic API (JCA)
  <a href="./BCFipsIn100.pdf">Bounce Castle FIPS JCA provider</a>
</td>
________________
https://picodotdev.github.io/blog-bitix/
__________________
https://dzone.com/articles/5-things-java-programmer-should-learn-in-2018
 - Java Performance Tuning
 - Profile Your Java application Once a Month
 - Java 9 
 - Spring 5.0
 - Spring Security 5.0
___________________
[QA] SonarQube
_____________________
______________________
Curso Java Concurrencia:
https://www.youtube.com/watch?v=8yD0hHAz3cs&list=PLw8RQJQ8K1ySGcb3ZP66peK4Za0LKf728&index=4
_________________
Annotation processors: JSR 269
(Dagger, Data Binding, Lombok, ...)
_____________________________

TODO: Google Guice
http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers
""" Although Spring provides many benefits, it was created in a pre-Java-5 world. The Guice framework takes DI to the next level, leveraging the full power of Java typing, especially annotations and generics"""

https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger
 
Q: Why use/develop Guice, when You have Spring and Dagger? [closed]
  To my knowledge, Dagger does generate code, while Guice and Spring rely on 
runtime processing, thus Dagger works faster, but requires more work on 
programmer side. Because of performance edge it's good for mobile (Android)
 development.

However, when we are left with Guice and Spring, the latter has lots of 
integrations. What's the point of developing/using Guice, if we can use
Spring Framework (that does basically same thing, but offers ex. easier 
database access)?

Isn't Google trying to reinvent wheel by creating their own DI tool,
instead of using (and possibly contributing to) Spring Framework?

I am looking for decision tree, that guides through choosing DI tool.

A: t's important to realize that Dagger was created after Guice, by one 
of Guice's creators ("Crazy Bob" Lee) after his move to Square:
  - Spring was originally released in October 2002.
  - Google originally publicly released Guice in March 2007.
  - JSR-330 formalized javax.inject annotations in October 2009, 
    with heavy input from Google (Bob Lee), Spring, and other industry 
    players.
  - Square originally released Dagger 1 publicly in May 2013.
  - Google originally released Dagger 2 publicly in April 2015.
  - Square marked Dagger 1 as deprecated 10 days ago, 
    on September 15, 2016.

In that sense, the continued curation of Guice isn't "reinventing the 
  wheel" so much as maintenance on a long-running and widely-consumed
 software package that thoroughly predates any version of Dagger. To 
list and amend to the differences you have above:

    Spring is a relatively-heavyweight framework with a lot of
 integrations, an XML configuration language, and runtime/reflective 
bindings. Applications already using Spring can use Spring's dependency
 injection framework with very little extra work.
    Guice is a relatively-lightweight framework with fewer integrations,
 Java instance configuration, and runtime/reflective bindings. With the
 use of Java bindings, you get compile-time type checking and IDE
 autocomplete integration.
    Dagger is a very lightweight framework with very few integrations,
 Java interface/annotation configuration, and compile-time code-generated
 bindings. The code generation aspect makes Dagger very performant 
overall and particularly in resource-limited and mobile environments.
(Android's different VM makes reflection especially slow, so Dagger is
especially useful here.)
    All three of the above frameworks support JSR-330 (Dependency
Injection for Java) , so a well-crafted library or application can
 be mostly agnostic to the DI container used.  
JSR-330:

Beyond that, keep an eye out for maintenance/deprecation patterns and policies among any framework you use, but leave it up to the integrations and performance you need alongside your team's technical judgment.
_________________________
https://www.infoq.com/news/2013/05/lmax-zing
LMAX Exchange Getting Up To 50% Improvement in Latency From Azul's Zing JVM 
Interesting points about GC tunning.
_________________________
TODO: Tunning the GC. See GC improvements in JDK 9+
______________________
Inter-thread communications in Java at the speed of light
https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications#anch104956

_____________________
_______________
https://github.com/OpenHFT/
   - Chronicle-Queue: Micro second messaging that stores everything to disk 
   - Chronicle-Accelerate: HFT meets Blockchain in Java platform 
         XCL is a new cryptocurrency project that, learning from the previous 
         Blockchain implementations, aims to solve the issues limiting adoption 
         by building an entirely new protocol that can scale to millions of 
         transactions per second, delivering consistent sub-second latency. Our 
         platform will leverage AI to control volatility and liquidity, require
         low energy and simplify compliance with integrated KYC and AML support.
         
         The XCL platform combines low latencies (sub millisecond), IoT transaction
         rates (millions/s), open source AI volatility controls and blockchain for
         transfer of value and exchange of value for virtual fiat and crypto 
         currencies. This system could be extended to other asset classes such as
         securities and fixed income. It uses a federated services model and 
         regionalized payment systems making it more scalable than a blockchain 
         which requires global consensus.
         
         The platform makes use of Chronicle-Salt for encryption and Chronicle-Bytes.
       
         on Chronicle Core’s direct memory and OS system call access.
         
        
     
   - Chronicle-Logger: A sub microsecond java logger, supporting standard logging
                      APIs such as Slf &amp; Log4J  
   
<table>
<tr>
<td>
  <a href="http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf">Disruptor</a>
  <a xsmall href="http://prisconapoli.github.io/development/2015/08/01/Disruptor">See also</a>
  <a href="https://lmax-exchange.github.io/disruptor/">lmax-exchange.github.com</a>

  <a href="https://dzone.com/articles/when-disruptor-not-good-fit">When Disruptor is not good fit</a>
</td>
</tr>
</td>
</tr>
</table>
_____________________
http://www.graalvm.org/
_____________________
  Concurrency:
  <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html">
    <code>java.util.concurrent.TimeUnit (v1.5+)</code></a>
  <ul xxxsmall zoom>
  <li>Represents time durations at a given unit of granularity and 
    provides utility methods to convert across units, and to perform
    timing and delay operations in these units.  </li>
  <li>
<pre>
Enums: DAYS HOURS MICROSECONDS MILLISECONDS MINUTES NANOSECONDS SECONDS
           
  void      sleep(long timeout)
  void  timedJoin(Thread thread, long timeout)
  void   timedWait(Object obj, long timeout)
  ...
</pre>
  </li>
  </ul>
___________________________
Java Erasure: Type Erasure is a technique employed by the Java compiler to support the use of Generics.
https://developer.ibm.com/recipes/tutorials/java-language-type-erasure/
______________
Java Fibers: (fast threads for java)
  - http://docs.paralleluniverse.co/quasar/
______________________
Collections NavigationMap
______________________
Document error: 
java.lang.UnsupportedClassVersionError: javax/money/Monetary has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0
__________________
Found in String.class source code: What's the @Contract annotation?
@NotNull @Contract(pure=true)
    public String[] split(String regex) {
___________________
https://dzone.com/articles/5-things-java-programmer-should-learn-in-2018
______________
about:reader?url=https%3A%2F%2Fdzone.com%2Farticles%2Fmicroprofile-5-things-you-need-to-know
__________________
https://stackoverflow.com/questions/29787684/java-8-stream-vs-collection-storage
____________________
https://www.logicbig.com/tutorials/core-java-tutorial/java-collections/java-collection-cheatsheet/images/choosing.png
______
https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html
From: https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map
NavigableMap is another useful extension - this is a SortedMap with 
additional methods for finding entries by their ordered position in the key 
set. So potentially this can remove the need for iterating in the first place 
- you might be able to find the specific entry you are after using the 
higherEntry, lowerEntry, ceilingEntry, or floorEntry methods. The 
descendingMap method even gives you an explicit method of reversing the 
traversal order.
_____________________
http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html
https://www.infoq.com/news/2018/06/open-source-jmc
_________________________
Pronghorn:
https://opensource.com/article/18/6/writing-applications-java-pronghorn
New (2018) Akka, Vert.X alternative using FIX "standard" finance network protocol for message passing
_____________________
https://hc.apache.org/httpcomponents-client-ga/index.html
______________
https://github.com/square/javapoet
-->

</html>
