<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>JAVA map(v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<table>
<tr {>
<td>
<pre xxxsmall zoom>
<span xsmall>Ext.Links</span>
-<a href="https://docs.oracle.com/javase/specs/">Lang&amp;VM specs</a>
-<a href="https://docs.oracle.com/javase/8/docs/api/index.html">API</a>
https://hg.openjdk.java.net/jdk/jdk
-<a href="https://hg.openjdk.java.net/jdk/">OpenJDK@Mercurial</a>

-<a href="https://zeroturnaround.com/wp-content/uploads/2014/06/jtnt-mindmap.png">JAVA MIND-MAP</a>
-<a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">(Active) Java JVM List</a>
-<a href="https://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-improve_code_quality.htm&cp=1_3_9">Eclipe Tools for [QA]</a>
-<a href="https://picodotdev.github.io/blog-bitix/tags/java/">Excellent Java Blog (spanish)</a>
-<a href="https://openjdk.java.net/jeps/0">JAVA Enhancements proposals</a>
-<a href="https://github.com/douglascraigschmidt/LiveLessons">Douglas Craigs Schmidt Java Lessons:</a>
-<a href="https://github.com/akullpp/awesome-java">Awesome Java</a>
</pre>

<pre xxxsmall zoom>
<span TODO xsmall>Who-is-Who</span>
- James Arthur Gosling:  Founder and lead-designer of the Java Programming Language
  @[https://en.wikipedia.org/wiki/James_Gosling]

- Joshua J. Bloch:
  @[https://en.wikipedia.org/wiki/Joshua_Bloch]
  - Author of the book "Effective Java" (a must read)
    and co-author of two other books:
    - Java Puzzlers (2005)
    - Java Concurrency in Practice (2006)
  - Led the design and implementation of numerous
    Java platform features, including the
    Java Collections Framework, the java.math package,
    and the assert mechanism.

- Ben Evans:
  - jClarity Co-founder.
  - Java Champion, author, speaker, consultant
  - voting member on Java’s governing
  - Author of 5 books
    - “The Well-Grounded Java Developer”,
    - new editions of “Java in a Nutshell”,
    - “Java: The Legend” and “Optimizing Java”.
    - Track lead for Java / JVM at InfoQ.
  @[https://www.jbcnconf.com/2019/infoTalk.html?id=5c64983638da16483151bb37]
  IMPLEMENTING A SIMPLE JVM IN JAVA AND RUST
  ... I will explain how we might start to implement a JVM from scratch.. then
   we will show how the Rust programming language provides a good alternative
   implementation language for our simple JVM. We will showcase some basic Rust
   language features and show how they can be used to provide a version of our
   JVM that is much cleaner and easier to understand, even if you've never
   seen Rust code before!"""

- https://community.oracle.com/community/groundbreakers/java/java-champions
- https://blogs.oracle.com/java/new-java-champions-in-2017
</pre>

</td>
<td>
<pre xxxsmall zoom {>
    <span xsmall>JavaDoc</span>
-----------------------+-------------------------------------+-------------------------+-------   Example
Tag& Parameter         | Usage                               | Applies to              | Since    /**
-----------------------+-------------------------------------+-------------------------+-------    * Short one line description.
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * Longer description. ...
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |           * ...here.
                       | Max one per Class or Interface.     |                         |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * And even more explanations to follow
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |           * in consecutive paragraphs
                       | has first existed.                  | Field, Method           |           *
-----------------------+-------------------------------------+-------------------------+-------    * @author John Bla
@seereference          | Provides a link to other element    | Class, Interface, Enum, |           * @param  variable Description ....
                       | of documentation.                   | Field, Method           |           * @return Description ....
-----------------------+-------------------------------------+-------------------------+-------    */
@paramname descrip     | Describes a method parameter.       | Method                  |          public int methodName (...) {
-----------------------+-------------------------------------+-------------------------+-------       // method body with a return statement
@return description    | Describes the return value.         | Method                  |          }
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | <code>{@literal}</code>.            | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
</pre }>
</td>
<td colsep></td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>Inside the JVM</span>
@[https://www.artima.com/insidejvm/ed2/index.html]
</pre>
</td>
<td>
    <span title>Memory</span><br/>
<pre xxxsmall zoom>
  <span xsmall>JVM MEMORY</span>
(<a href="https://dzone.com/articles/java-memory-management">REF</a>)
JAVA MEMORY MODEL:

         |    STACK ("SMALL")          |   HEAP  ("HUGE")
         | private to each Thread      |   Shared by Threads
---------+-----------------------------+--------------------
Contain  | references ───────────────────→ objects
         | value types                 |

* 1: Ref(erence) types on the stack point to real object in HEAP memory.

Reference Types regarding how the object on the heap is eligible for garbage collection
┌─────────┬───────────────────────────────────────────────────────────────────────────
│ STRONG  │ - Most popular.
│         │ - The object on the heap it is not garbage collected
│         │   while there is a strong reference pointing to it, or if it is
│         │   strongly reachable through a chain of strong references.
├─────────┼───────────────────────────────────────────────────────────────────────────
│ WEAK    │ - most likely to not survive after the next garbage collection process.
│         │ - Is created like
│         │    WeakReference&lt;StringBuilder&gt; reference = new WeakReference&lt;&gt;(new StringBuilder());
│         │ - *Ex.use case: caching:*
│         │   We let the GC remove the object pointed to by the weak reference,
│         │   after which a null will be returned
│         │   See JDK implementation at
│         │   @[https://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html]
├─────────┼───────────────────────────────────────────────────────────────────────────
│ SOFT    │ - used for more memory-sensitive scenarios
│         │ - Will be garbage collected only when the application is running low on memory.
│         │ - *Java guarantees that all soft referenced objects
│         │   are cleaned up before throwing OutOfMemoryError*
│         │ - is created as follows:
│         │   SoftReference&lt;StringBuilder&gt; reference = new SoftReference&lt;&gt;(new StringBuilder());
├─────────┼───────────────────────────────────────────────────────────────────────────
│ PHANTOM │ - Used to schedule post-mortem cleanup actions, since we know for
│         │   sure that objects are no longer alive.
│         │ - Used only with a reference queue, since the .get() method of
│         │   such references will always return null.
│         │ - <b>These types of references are considered preferable to finalizers</b>
└─────────┴───────────────────────────────────────────────────────────────────────────
</pre>

<pre xxxsmall zoom>
<span xsmall>Force string pool reuse</span>
- Strings are immutable.
- Stored on the heap
- Java manages a string pool in memory,
  reusing strings whenever possible.

String string01 = "297",                                string01 == string02 : true
       string02 = "297",                                string01 == string03 : <b red>false</b> *1
       string03 = new Integer(297).toString(),          string01 == string04 : true  *2
       string04 = new Integer(297).toString()<b>.intern()</b>; *2

*1: <b red>Pool reuse does not work for dynamically created strings</b>
*2: If we consider that the computed String will be used quite often,
    we can force the JVM to add it to the string pool by adding the
    .intern() method at the end of computed string:
</pre>

<pre xxxsmall zoom>
<span xsmall>"MARK&amp;SWEEP"</span>
JVM analyzes the variables from the stack and "marks" all the objects that need to be kept alive.
Then, all the unused objects are cleaned up.

The more garbage there is, and the fewer that objects are marked alive, the faster the process is.

To optimize even more heap memory actually consists of multiple parts (Java 8+):

HEAP     |
SPACES   |
---------+-------------------------------------
Eden     | - object are place here upon creation.
         | - "small" -→ gets full quite fast.
         | - GC runs on the Eden space and marks objects as alive
---------+-------------------------------------
S0       | - Eden Objects surviving 1st GC are moved here
         |
---------+-------------------------------------
S1       | - Eden Objects surviving 2nd GC are moved here
         | - S0   Objects surviving     GC are moved here
---------+-------------------------------------
Old      | - Object survives for "N" rounds of GC (N depends on implementation),
         |   most likely that it will survive forever, and get moved here
         | - Bigger than Eden and S0,S1. GC doesn't run so often
---------+-------------------------------------
Metaspace| - metadata about loaded classes
         | (PermGen Before Java 8)
---------+-------------------------------------
String   |
  pool   |
---------+-------------------------------------
</pre>
<pre xxxsmall zoom>
<span xsmall>GC Types</span>
- default GC type is based on the underlying hardware
- programmer can choose which one should be used


   GC TYPE     | Description  / Use-Cases
+--------------+-----------------------------------------------------------------------------
|Serial GC     | - Single thread collector.
|              | - <b>Halt all app threads while executing</b>
|              | - Mostly applies to <b>small apps with small data usage</b>
|              | - Can be enabled through : <b orange>-XX:+UseSerialGC</b>
+--------------+-----------------------------------------------------------------------------
|Parallel GC   | - Multiple threads used for GC
|              | - <b>Halt all app threads while executing</b>
|              | - Also known as throughput collector
|              | - Can be enabled through : <b orange>-XX:+UseParallelGC</b>
+--------------+-----------------------------------------------------------------------------
|Mostly        | - works concurrent to the application, "mostly" not halting threads
|Concurrent GC | - "mostly": There is a period of time for which the threads are paused.
|              |    Still, the pause is kept as short as possible to achieve the best GC performance.
|              | - 2 types of mostly concurrent GCs:
|              |   * Garbage First - high throughput with a reasonable application pause time.
|              |                   - Enabled with the option: <b orange>-XX:+UseG1GC</b>
|              |   * Concurrent Mark Sweep: app pause is kept to minimum. <b>Deprecated as Java9+</b>
|              |                   - Enabled with the option: <b orange>-XX:+UseConcMarkSweepGC</b>
+--------------+-----------------------------------------------------------------------------
</pre>

<pre xxxsmall zoom>
<span xsmall>Optimization Tips</span>
- To minimize the memory footprint, limit the scope of the variables as much as possible.

- Explicitly refer to null obsolete references making them eligible for GC.

- Avoid finalizers. They slow down the process and they do not guarantee anything.
  Prefer phantom references for cleanup work.

- Do not use strong references where weak or soft references apply.
  <b>The most common memory pitfalls are caching scenarios,when data
     is held in memory even if it might not be needed.</b>

- Explicitly specify heap size for the JVM when running the application:
  -  allocate a reasonable initial and maximum amount of memory for the heap.
   o*Initial heap size -Xms512m * – set initial heap     size to  512 megabytes
   o*Maximum heap size -Xmx1024m* – set maximum heap     size to 1024 megabytes
   o*Thread stack size -Xss128m * – set thread stack     size to  128 megabytes
   o*Young genera.size -Xmn256m * – set young generation size to  256 megabytes


- If app OutOfMemoryError-crashes, extra info about memory leak can be obtained through
  o*–XX:HeapDumpOnOutOfMemory*, creating a heap dump file

- Use o*-verbose:gc* to get the garbage collection output.

- Eclipse Memory Analyzer Manual:
@[https://help.eclipse.org/2019-06/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fwelcome.html&cp=62]
</pre>

<pre xxxsmall zoom>
<span xsmall>Profiling:</span>
JVisualVM (standard on the JDK) displays memory usage and other useful things:
- The only thing you have to do is install a plugin named Visual GC,
  which allows you to see how the memory is actually structured.
- JVisualVM also has the functionality to make a heap dump at a certain point,
 so you could analyze, per class, how much memory it occupies.
</pre>
</td>
<td colsep> </td>
<td>
<span title>Time<br/></span>
<pre xxxsmall zoom>
<code xsmall>java.time</b>.*</code>
- JDK 1.8+
- "deprecates" java.util.(Date|Calendar|TimeZome)
- All the classes are IMMUTABLE and THREAD-SAFE
o*import java.time.Instant;*
o*import java.time.ZonedDateTime;*
o*import java.time.ZoneId;*
o*import java.util.concurrent.TimeUnit;*
...
o*Instant*b*timestamp* = o*Instant*.now();              // Create from system clock
          b*timestamp*.plus(Duration.ofSeconds(10));    // Add 10 seconds

  │o*Instant* to String                 │ o*Instant* from String
  │(format with time-zone)              │ (parse string)
  ├─────────────────────────────────────┼───────────────────────────────────────────────────
  │o*ZonedDateTime* zdt1 =              │
  │     o*ZonedDateTime*.of             │ String sExpiresAt="2013-05-30T23:38:23.085Z";
  │       (                             │ o*ZonedDateTime*zdt2 = o*ZonedDateTime*.parse(sExpiresAt);
  │         2017, 6, 30           ,     │
  │         1, 2, 3               ,     │ o*Instant*i1 = o*Instant*.from(zdt1),
  │         (int) TimeUnit.             │           i2 = o*Instant*.from(zdt2);
  │               MILLISECONDS.         │
  │               toNanos(100),         │
  │         ZoneId.of("Europe/Paris")   │
  │       );          ^^^               │
  │     Ex: "Z","-02:00","Asia/Tokyo",..│
  │String s1 = zdt1.toString();         │
          ^^
  2017-06-30T01:02:03.100+02:00[Europe/Madrid]

java.text.MessageFormat:
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())

time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())

*Compatibility with Java ˂=1.7*
- (java.util.) Date, Calendar and TimeZone
  "buggy" classes/subclasses were used.
  ^^^^^^^
  - Calendar class was NOT type safe
  - Mutable non-threadsafe classes
  - Favored programming errors
    (unusual numbering of months,..)

- Next compatibility conversion methods were added in 1.8:
  - Calendar.toInstant()
  - GregorianCalendar.toZonedDateTime()
  - GregorianCalendar.from(ZonedDateTime) (Using default local)
  - Date.from(Instant)
  - Date.toInstant()
  - TimeZone.toZoneId()

*java.time. Package summary*
                   Description
-----------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and
                   time using a time-zone.
-----------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
-----------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
-----------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03.
-----------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar
                   system, such as 2007-12-03T10:15:30.
-----------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system,
                   such as 10:15:30.
-----------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
-----------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 2007-12-03T10:15:30+01:00.
-----------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 10:15:30+01:00.
-----------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system,
                    such as '2 years, 3 months and 4 days'.
-----------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
-----------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12
-----------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03T10:15:30+01:00 Europe/Paris.
-----------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
-----------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
-----------------------------------------------------------------------------------


Enum               Description
-----------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
-----------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
-----------------------------------------------------------------------------------

Exception          Description
-----------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.

<a xsmall href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>Java 9</a>
- A number of parsing and formatting changes have been incorporated in Java 9 to
bring the functionality closer to Unicode Locale Data Markup Language (LDML).
These changes have been supervised by Stephen Colebourne, creator of the popular
 date-time library JodaTime, precursor of the new java.time component in Java 8.
Abiding by the Unicode standard will provide better interoperability with other
non-Java systems.

- LDML is the language used by the Unicode Common Locale Data Repository (CLDR),
  a project of the Unicode Consortium to gather and store locale data from
  different parts of the world, enabling application developers to better adapt
  their programs to different cultures. Among other things, LDML deals with dates,
  times, and timezones, and more particularly with date formatting and parsing.
  The following is an extract of new features coming in Java 9 that bring java.time
  closer to the LDML specification:

  - JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as
    specified in LDML, indicates a “Modified Julian day”; this is different from a
    normal Julian day in the sense that a) it depends on local time, rather than GMT,
    and b) it demarcates days at midnight, as opposed to noon.
  - JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML
    formats to indicate “generic non-location format”, e.g. “Pacific Time”, as
    opposed to the “generic location format” with specifies a city, like
    “Los Angeles Time”.
  - JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML
    doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current
    behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the
    total number of milliseconds elapsed in the day, with variable width, but
    currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it
    will fail to parse any value that is further than 99 milliseconds in the day.
    ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds
    within the second, and nanoseconds within the day, respectively.
  - JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit
    day-of-year value: similar to the previous problem, but with ‘D’ representing
    days within a year. If one specifies “DD” as a pattern, it will fail to parse
    “123” as the 123th day of the year.
- As previously mentioned, a better alignment with the LDML will ease
  interoperability across systems, since there are multiple technologies that
  have adopted the LDML to some degree. Microsoft .NET uses LDML for general
  interexchange of locale data, and there are packages available for Node.js
  and Ruby, just to mention a few.
  </ul>
</td>
<td colsep> </td>
<td>

<pre xxxsmall zoom>
<a xsmall href="http://docs.oracle.com/javase/tutorial/java/annotations/">ANNOTATIONS</a>
*predefined annotation types in java.lang:*
- @Deprecated
- @Override
- @SuppressWarnings
- @SafeVarargs (SDK 1.? +) applied to a method/constructor,
                           asserts that the code does not perform
                           potentially unsafe operations
                           on its varargs parameter.
                           removing  related warnings

*Annotation types are a form of interface*
DECLARATION(interface is preceded by the @ sign) │ USAGE
  @Documented                                    │
  @interface ClassPreamble {                     │   @ClassPreamble (
     String   author        ()              ;    │      author         = "John Doe"      ,
     String   date          ()              ;    │      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;    │      currentRev     = 6               ,
     String   lastModified  () default "N/A";    │      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";    │      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;    │      reviewers      = {"Alice", "Bob"}
  }                                              │   )
                                                 │ public class Generation3List extends Generation2List {
                                                 │     // ...
                                                 │ }
<span xsmall>EXAMPLES</span>
new @Interned MyObject();              ← Class instance creation expression

myString = (@NonNull String) str;      ← Type cast (1.8+)

class UnmodifiableList˂T˃ implements   ← implements clause
      @Readonly List˂@Readonly T˃
      { ... }

void monitorTemperature() throws       ← throws exception declaration
@Critical TemperatureException { ... }

@SuppressWarnings(value = "unchecked") ← Predefined standard annotations
void myMethod() { ... }
@SuppressWarnings({"unchecked", "deprecation"})
void myMethod() { ... }
</pre>
<pre xxxsmall zoom >
<span xsmall>META-ANNOTATTONS</span>
(Annotations applying to other annotations)

<span xsmall>@Retention</span>
<span xsmall>(Source,class,Runtime)</span>
RetentionPolicy.SOURCE: retained only in source (ignored by the compiler)
RetentionPolicy.CLASS : retained by compiler    (ignored by the JVM)
RetentionPolicy.RUNTIME:retained by JVM, can be queried at Runtime

<span xsmall>@Documented</span>
- indicates that whenever the specified annotation
  is used those elements should be documented using
  the Javadoc tool. (By default, annotations
  are not included in Javadoc.)

<span xsmall>@Target</span>
<span xsmall>(field,type,class..)</span>
- restrict targeted java-language elements where the annotation can be applied:
  - ElementType.ANNOTATION_TYPE
  - ElementType.CONSTRUCTOR
  - ElementType.FIELD
  - ElementType.LOCAL_VARIABLE
  - ElementType.METHOD
  - ElementType.PACKAGE
  - ElementType.PARAMETER
  - ElementType.TYPE (1.8+)

<span xsmall>@Inherited</span>
- targeted annotation type can be inherited
  from the super class. (false by default.)
  When the user queries the annotation type and the class
  has no annotation for this type, the class'superclass is
  queried for the annotation type.
<span xsmall>@Repeatable</span>
- (1.8+)
- targeted annotation can be applied more than
  once to the same declaration or type use.
  Ex:
  @Author(name = "Jane Doe")
  @Author(name = "John Smith")
  class MyClass { ... }
</pre>
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://www.slf4j.org/">SLF4j Logging</a>
Simple Log Facade or abstraction for various logging frameworks
(e.g. java.util.logging, logback, log4j) allowing the end user
to plug in the desired logging framework at deployment time.

─────────┬──────────────────────────────────────────────────────────┬────────────────────────┬─────────────────────────────────────────────────────────
*pom.xml*│                                                          │b*logback* configuration│
─────────┘                                                          ├────────────────────────┘
                                                                    │ (src/main/resources/)logback.xml
˂dependency˃*                                                       │ ˂?xml version="1.0" encoding="UTF-8"?˃
  ˂groupId˃org.slf4j˂/groupId˃                                      │ ˂configuration˃
  ˂artifactId˃slf4j-api˂/artifactId˃                                │     ˂!-- ˂jmxConfigurator /˃ --˃
  ˂version˃1.7.21˂/version˃                                         │     ˂appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"˃
˂/dependency˃                                                       │         ˂file˃log˂/file˃
...                                                                 │         ˂rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"˃
˂dependency˃                                                        │             ˂!-- daily rollover --˃
  ˂groupId˃ch.qos.logback˂/groupId˃                                 │             ˂fileNamePattern˃%d{yyyy-MM-dd}.log.zip˂/fileNamePattern˃
  ˂artifactId˃logback-classic˂/artifactId˃  ← add b*logback* facade │             ˂maxFileSize˃1MB˂/maxFileSize˃
  ˂exclusions˃                                                      │             ˂!-- keep 2 days' worth of history capped at 1MB total size --˃
    ˂!-- Avoid problem:                                             │             ˂maxHistory˃2˂/maxHistory˃
         SLF4J: Class path contains multiple SLF4J bindings.        │             ˂totalSizeCap˃2MB˂/totalSizeCap˃
    ...   slf4j-jdk14-1.7.21.jar!...StaticLoggerBinder.class        │         ˂/rollingPolicy˃
    ...logback-classic-1.1.7.jar!...StaticLoggerBinder.class        │         ˂encoder˃
    --˃                                                             │             ˂pattern˃%date %level [%thread] %logger{10} [%file:%line] %msg%n˂/pattern˃
    ˂exclusion˃                                                     │         ˂/encoder˃
      ˂groupId˃org.slf4j˂/groupId˃                                  │     ˂/appender˃
      ˂artifactId˃slf4j-jdk14˂/artifactId˃                          │
    ˂/exclusion˃                                                    │     ˂appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"˃
  ˂/exclusions˃                                                     │         ˂encoder˃
  ˂version˃1.1.7˂/version˃                                          │             ˂pattern˃%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n˂/pattern˃
˂/dependency˃                                                       │         ˂/encoder˃
─────────────────────────────┬──────────────────────────────────────│     ˂/appender˃
*Example Ussage in Java code*│                                      │
─────────────────────────────┘                                      │     ˂logger name="my.company.package" level="INFO"/˃
import org.slf4j.Logger;                                            │     ˂logger name="my.company.package.subpackage" level="DEBUG"/˃
import org.slf4j.LoggerFactory;                                     │     ˂logger name="org.eclipse.jetty" level="INFO"/˃
...                                                                 │
  class MyClass {                                                   │     ˂root level="WARN"˃
    private static final Logger log =                               │         ˂appender-ref ref="STDOUT" /˃
       LoggerFactory.getLogger(AbstractRequestHandler.class);       │         ˂appender-ref ref="FILE" /˃
    ...                                                             │     ˂/root˃
    if (log.isDebugEnabled()) {                                     │ ˂/configuration˃
    //  ^ Avoid slow String construction                            │──────────────────────────────────────────────────────────────────────────────────
    //    if log*NOT*enabled                                        │
        log.debug("Lorem ipsum... @{} {}", "param1", "param2");     │
    }                                                               │
    ...                                                             │
</pre>
</td>
</tr }>
</table>
<table>
<tr>
<td title>Collections</td>
<td>
<pre xxxsmall zoom>
   <span xsmall>Comparative</span>
Standard r*non-concurrent* SDK:
       ┌──────────────────────────────────────────────────────────────────────────────────────────
       │                                IMPLEMENTATIONS
       ├──────────────────────────────────────────────────────────────────────────────────────────
       │ Hash Table        │ Resizable Array   │Balanced Tree │ Linked List │ HashTable+LinkedList
       │                   │                   │              │             │
┌──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│˂Set˃ │ HashSet           │                   │  TreeSet     │             │ LinkedHashSet
│      │                   │                   │              │             │
├──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│˂List˃│                   │ ArrayList         │              │ LinkedList  │
│      │                   │ Vector            │              │ LinkedList  │
├──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│˂Map˃ │ HashMap,Hashtable │                   │  TreeMap     │             │ LinkedHashMap
└──────┴───────────────────┴───────────────────┴──────────────┴─────────────┴─────────────────────
*INTERFACES*
@[http://download.oracle.com/javase/6/docs/api/java/util/HashSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedList.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html]
@[http://download.oracle.com/javase/6/docs/api/index.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html]


<a href="http://files.zeroturnaround.com/pdf/zt_java_collections_cheat_sheet.pdf">ref</a>
┌─────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────┐
│Collection       │ Thread-safe                ┃          YOUR DATA              ┃           OPERATIONS    ALLOWED       │
│                 │ alternative                ┃─────────────────────────────────┃───────────────────────────────────────┤
│class            │                            ┃Individu│Key-val.│Duplica│Primite┃ Iteration Order │Fast │ Random Access │
│                 │                            ┃elements│  pairs │element│support┃FIFO │Sorted│LIFO│'has'│By  │By   │By  │
│                 │                            ┃        │        │support│       ┃     │      │    │check│Key │Val  │Idx │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashMap          │ ConcurrentHashMap          ┃        │YES     │       │       ┃     │      │    │YES  │ YES│     │    │
│                 │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashBiMap(Guava) │ Maps.syncrhonizedBiMap     ┃        │YES     │       │       ┃     │      │    │YES  │ YES│YES  │    │
│                 │ (new HashBiMap())          ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayListMultimap│ Maps.synchronizedMultiMap  ┃        │YES     │YES    │       ┃     │      │    │YES  │ YES│     │    │
│   (Guava)       │ (new ArrayListMultimap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│LinkedHashMap    │ Collections.syncrhonizedMap┃        │YES     │       │       ┃YES  │      │    │YES  │ YES│     │    │
│                 │ (new LinkedHashMap())      ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│TreeMap          │ ConcurrentSkipListMap      ┃        │YES     │       │       ┃     │YES   │    │YES  │ YES│     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│Int2IntMap       │                            ┃        │YES     │       │YES    ┃     │      │    │YES  │ YES│     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayList        │ CopyOnWriteArrayList       ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │YES │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashSet          │ Collections.newSetFromMap  ┃YES     │        │       │       ┃     │      │    │YES  │    │YES  │    │
│                 │ (new ConcurrentHashMap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│IntArrayList     │                            ┃YES     │        │YES    │YES    ┃YES  │      │YES │     │    │     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│PriorityQueue    │ PriorityBlockingQueue      ┃YES     │        │YES    │       ┃     │YES   │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayDeque       │ ArrayBlockingQueue         ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │    │
└─────────────────┴────────────────────────────┃────────┴────────┴───────┴───────┃─────┴──────┴────┴─────┴────┴─────┴────┘

 Collection class │  Random access by idx/key │ Search/Contains │ Instert
 ─────────────────┼───────────────────────────┼─────────────────┼───────────
 ArrayList        │  O(1)                     │ O(n)            │ O(n)
 HashSet          │  O(1)                     │ O(1)            │ O(1)
 HashMap          │  O(1)                     │ O(1)            │ O(1)
 TreeMap          │  O(log(n))                │ O(log(n))       │ O(log(n))
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Initialization</span>
*INITIALIZING A LIST*
final List˂String˃ myList =                  ← final forbid re-asigning the list,
      Arrays.asList("one", "two", "three");     but its content is still mutable
      myList.add("four");

final List˂String˃ myInmmutableList =        ← inmutable version (thread safe)
      Collections.unmodifiableList(myList);

*INITIALIZING A MAP*
final Map˂String,String˃ myMap =             ← Mutable map (even if 'final' used)
      new HashMap˂String,String˃();
        myMap.put("k1", "k2");
        myMap.put("v1", "v2");
final Map˂String,String˃ myInmutableMap =    ← Inmutable version of map
      Collections.unmodifiableMap(temp);

final HashMap˂String,String˃ data =          ← Java 7+
      HashMapBuilder.build(
          "k1","v1",                         ← must have an even number of elements
          "k2","v2");

final Map˂String, String˃ test =             ← Java 9+
      Map.of("k1", "k2", "v1", "v2");        ← must have an even number of elements

final Map˂String, String˃ test2 =            ← Java 9+
      Map.ofEntries( entry("k1", "k2"),...);

final Map˂String, String˃ test =             ← Guava ImmutableMap
      ImmutableMap.of("k1","v1", ...);         works only with up to 5 key/value pairs

final Map˂String, String˃ test =             ← Guava ImmutableMap alternative
      ImmutableMap.˂String, String˃builder()
      .put("k1", "v1")
      .put("k2", "v2")
      ...
      .build();
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Walk-over/iterate</span>
*for collection walk*
 │for (
 │     int idx = 0;
 │     idx ˂*collection*o*.length*;
 │     idx++) {
 │  //r*WARN:
 │  //  - Very slow for LinkedLists*
 │  //  - Faster for other List implementations
 │  type array_element =*collection*o*.get(idx);*
 │}

 │for (                                                │ for (
 │     Iterator iterator =*collection*o*.iterator()*;  │      iterable_type iterable_element o*:collection*
 │     o*iterator.hasNext();*) {                       │     ) {
 │  //*Best option when removing/modifying elements*/  │   //*Best option when NOT remov./modify. elements*/
 │  type type = (type) o*iterator.next()*;             │   ...
 │}                                                    │ }


*STREAMS (Java 8+)*
*collection*o*.forEach*((o*it*) -˃ {
    System.out::println(o*it*)
});
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 Shorter alternative:
*collection*o*.forEach*(System.out::println);

*WALK-OVER/ITERATE A MAP*

*entrySet Java 5+*                         | *USING ITERATORS*                           | *USING FOR-EACH*
 Map˂String, String˃ map = ...             |  Iterator˂Map.Entry˂Integer, Integer˃˃*it*= |  long i = 0;
 for (                                     |      map.entrySet()o*.iterator()*;          |  for (
      Map.Entry˂String, String˃ o*entry* : |  while (*it*o*.hasNext()*) {                |       Map.Entry˂Integer, Integer˃ pair :
     *map*o*.entrySet()*)                  |      Map.Entry˂Integer, Integer˃ pair =     |         *myMap*o*.entrySet()*) {
 {                                         |       *it*o*.next()*;                       |    log.debug( "{}:{}"      ,
   log.debug( "{}:{}"          ,           |    log.debug( "{}:{}"      ,                |             pair.getKey()  ,
            o*entry*.getKey()  ,           |             pair.getKey()  ,                |             pair.getValue() );
            o*entry*.getValue());          |             pair.getValue() );              |  }
 }                                         |  }

*forEach (java 8+)*                        |*iterating over keySet*          | *for + Map.Entry*
 final long[] i = {0};                     | long i = 0;                     |  for (
 *map*o*.forEach*((k, v) -˂ i[0] += k + v);| Iterator˂Integer˃ itr2 =        |     Iterator˂Map.Entry˂Integer, Integer˃˃
                                           |    mapo*.keySet().iterator()*;  |        entries = map.entrySet().iterator() ;
                                           | while (itr2.hasNext()) {        |     entries.hasNext();
                                           |     Integer key = itr2.next();  |     ) {
                                           |     i += key + map.get(key);    |   Map.Entry˂Integer, Integer˃
                                           | }                               |      entry = entries.next();
                                                                             |   log.debug( "{}:{}"      ,
                                                                             |           entry.getKey()  ,
                                                                             |           entry.getValue() );
                                                                             |  }
|*Stream API (1.8+)*              |*Stream API parallel (1.8+)*
| final long[] i = {0};           | final long[] i = {0};
| *map*o*.entrySet().stream()*    | *map*o*.entrySet().stream()*.
|  .forEach(                      |   parallel()*.forEach(e -˃
|    ...e.getKey(), e.getValue()  |    ... e.getKey() , e.getValue()
| );                              | )
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>java.util.Collections</span>
<span xsmall>Utility class</span>
@[https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html]
- Utility class with static methods that operate on or return collections

Collections.EMPTY_LIST // The empty (immutable) list
Collections.EMPTY_MAP  // The empty (immutable) map
Collections.EMPTY_SET  // The empty (immutable) set

Enumeration  Collections.emptyEnumeration()  // Returns an enumeration that has no elements.
Iterator     Collections.emptyIterator()     // Returns an iterator that has no elements.
List         Collections.emptyList()         // Returns the empty list (immutable)                                              .
ListIterator Collections.emptyListIterator() // Returns a list iterator that has no elements.
Map          Collections.emptyMap()          // Returns the empty map (immutable)                                              .
Set          Collections.emptySet()          // Returns the empty set (immutable)                                              .



boolean      Collections.addAll(Collection c, T... elements)           Adds all elements to collection 'c'
Queue        Collections.asLifoQueue(Deque deque)                      deque → LIFO Queue view
int          Collections.binarySearch(List list, T key)                Searches key into List using binary search.
int          Collections.binarySearch(List list, T key, Comparator c)  Searches key into List using binary search an comparator.

Collection   Collections.checkedCollection(Collection c, Class type)   Returns a dynamically typesafe view of input collection/list/...
List         Collections.checkedList(List list, Class type)
Map          Collections.checkedMap
                         (Map m, Class keyType, Class valueType)
Set          Collections.checkedSet(Set s, Class type)
SortedMap    Collections.checkedSortedMap
                         (SortedMap m, Class keyType, Class valueType)
SortedSet    Collections.checkedSortedSet(SortedSet s, Class type)
void         Collections.copy(List dest, List src)                     Copies src list elements to dest list
boolean      Collections.disjoint(Collection c1, Collection c2)        true if c1/c2 have no elements in common.

Enumeration  Collections.enumeration(Collection c)                     Returns an enumeration over the specified collection.

void         Collections.fill(List list, T obj)                        Replaces all of the elements of the specified list with the specified element.
int          Collections.frequency(Collection c, Object o)             Returns the number of elements in the specified collection equal to the specified object.
int          Collections.indexOfSubList(List source, List target)      Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.
int          Collections.lastIndexOfSubList(List source, List target)  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.
ArrayList    Collections.list(Enumeration e)                           Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration.
T            Collections.max(Collection coll)                          Returns the maximum element of the given collection, according to the natural ordering of its elements.
T            Collections.max(Collection coll, Comparator comp)         Returns the maximum element of the given collection, according to the order induced by the specified comparator.
T            Collections.min(Collection coll)                          Returns the minimum element of the given collection, according to the natural ordering of its elements.
T            Collections.min(Collection coll, Comparator comp)         Returns the minimum element of the given collection, according to the order induced by the specified comparator.
List         Collections.nCopies(int n, T o)                           Returns an immutable list consisting of n copies of the specified object.
Set          Collections.newSetFromMap(Map map)                        Returns a set backed by the specified map.
boolean      Collections.replaceAll(List list, T oldVal, T newVal)     Replaces all occurrences of one specified value in a list with another.
void         Collections.reverse(List list)                            Reverses the order of the elements in the specified list.
Comparator   Collections.reverseOrder()                                Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface.
Comparator   Collections.reverseOrder(Comparator cmp)                  Returns a comparator that imposes the reverse ordering of the specified comparator.
void         Collections.rotate(List list, int distance)               Rotates the elements in the specified list by the specified distance.
void         Collections.shuffle(List list)                            Randomly permutes the specified list using a default source of randomness.
void         Collections.shuffle(List list, Random rnd)                Randomly permute the specified list using the specified source of randomness.
Set          Collections.singleton(T o)                                Returns an immutable set containing only the specified object.
List         Collections.singletonList(T o)                            Returns an immutable list containing only the specified object.
Map          Collections.singletonMap(K key, V value)                  Returns an immutable map, mapping only the specified key to the specified value.
void         Collections.sort(List list)                               Sorts the specified list into ascending order, according to the natural ordering of its elements.
void         Collections.sort(List list, Comparator c)                 Sorts the specified list according to the order induced by the specified comparator.
void         Collections.swap(List list, int i, int j)                 Swaps the elements at the specified positions in the specified list.
Collection   Collections.synchronizedCollection(Collection c)          Returns a synchronized (thread-safe) collection backed by the specified collection.
List         Collections.synchronizedList(List list)                   Returns a synchronized (thread-safe) list backed by the specified list.
Map          Collections.synchronizedMap(Map m)                        Returns a synchronized (thread-safe) map backed by the specified map.
Set          Collections.synchronizedSet(Set s)                        Returns a synchronized (thread-safe) set backed by the specified set.
SortedMap    Collections.synchronizedSortedMap(SortedMap m)            Returns a synchronized (thread-safe) sorted map backed by the specified sorted map.
SortedSet    Collections.synchronizedSortedSet(SortedSet s)            Returns a synchronized (thread-safe) sorted set backed by the specified sorted set.
Collection   Collections.unmodifiableCollection(Collection c)          Returns an unmodifiable view of the specified collection.
List         Collections.unmodifiableList(List list)                   Returns an unmodifiable view of the specified list.
Map          Collections.unmodifiableMap(Map m)                        Returns an unmodifiable view of the specified map.
Set          Collections.unmodifiableSet(Set s)                        Returns an unmodifiable view of the specified set.
SortedMap    Collections.unmodifiableSortedMap(SortedMap m)            Returns an unmodifiable view of the specified sorted map.
SortedSet    Collections.unmodifiableSortedSet(SortedSet s)            Returns an unmodifiable view of the specified sorted set.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="http://fastutil.di.unimi.it/">Fastutil</a>
- Fast and compact type-specific collections for Java
  Great default choice for collections of primitive types,
  like int or long. Also handles big collections with more than 2
  31 elements well.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://www.eclipse.org/collections/">Eclipse Collections</a>
(Originated from Goldman Sachs gs-collection:
 @[https://github.com/goldmansachs/gs-collections])
- Features you want with the collections you need
  Previously known as gs-collections, this library
  includes almost any collection you might
  need: primitive type collections, multimaps,
  bidirectional maps and so on.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/google/guava">Guava Collections</a>
- Google Core Libraries for Java 6+
  Perhaps the default collection library for Java
  projects. Contains a magnitude of convenient
  methods for creating collection, like fluent
  builders, as well as advanced collection types
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall>˂˂Enumeration˃˃(1.0)</span>
<span xsmall>vs</span>
<span xsmall>˂˂Iterator˃˃(1.7)</span>
@[https://stackoverflow.com/questions/948194/difference-between-java-enumeration-and-iterator]

- both interfaces will give successive elements

- Iterators allow the caller to remove elements from
  the underlying collection during the iteration with
  well-defined semantics.
  (additional remove method)
- Iterators Method names have been improved.

- Iterators are fail-fast:
  - If thread A changes the collection, while
       thread B is traversing it, the iterator implementation
       will try to throw a ConcurrentModificationException
       (best effort since it can not always be guaranteed)
  - The fail-fast behavior of iterators can be used only to
    detect bugs sin the best effort doesn't warrant its trigger.
  - newer 'concurrent' collections will never throw it.
    Reading thread B will traverse the collection "snapshot" at
    the start of read.



-*Iterator should be preferred over Enumeration*
  taking the place of Enumeration in collections framework


  Enumeration     │ Iterator
  ────────────────┼────────────
  hasMoreElement()│ hasNext()
  nextElement()   │ next()
                  │ remove() ← optional: not implemented in many classes
</pre>
</td>


</tr>
</table>

<table>
<tr {>
<td title> NIO </td>
<td>
<pre xxxsmall zoom>
<a xsmall href="http://tutorials.jenkov.com/java-nio/buffers.html">NIO (1.4+)</a>
- Replaced OLD blocking IO based on [ byte/char, read-or-write streams ]
┌──────────┐     ┌──────────────┐                                  ┌───────────────┐
│*CORE NIO*│     │*NON─BLOCKING*│                                  │ *NON─CORE NIO*│
├──────────┴───┐ ├──────────────┴────────────────────────────────┐ ├───────────────┴───────────────────────────────────────────
│ ─b*CHANNELS *│ │· a thread requests a channel the intention    │ │ ─ components like Pipe and FileLock can be considered
│  ─ read/write│ │  to read/write data into a buffer:            │ │   "utility classes" supporting the first three ones.
│ ─b*BUFFERS  *│ │  · While the channel moves data into/from     │ │
│ ─b*SELECTORS*│ │   the buffer, the thread continues another job│ │ ─ "SELECTORS" objects monitor one+ channels for events
└──────────────┘ │  · When data is ready, the thread is notified │ │   (connection opened, data arrived, ..):
                 └───────────────────────────────────────────────┘ │   ─ Thus, a single thread can monitor multiple channels for data.
Channel  : File,Datagram/UDP,Socket/TCP,ServerSocket,...           │     (Very handy if app has many connections/Channels/clients open
Buffer of: Byte|Char|Double|Float|Int|Long|Short|MappedByte)Buffer │     but with low traffic on each connection.
                                                                   │   ─ To use selectors:
                                                                   │     ─ Instantiate the selector
                                                                   │     ─ Register one+ channels with it
                                                                   └───────────────────────────────────────────────────────────────
┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│*BUFFER*                                                                                          │
│ *ATTRIBUTES*                                            *METHODS*                                │
│          ┌─────────────────┬───────────────────────────┐ ┌─────────────┬───────────────────────┐ │
│          │*write*mode      │ *read*mode                │ │rewind()     │                       │ │
│ ┌────────┼─────────────────┴───────────────────────────┤ │             │                       │ │
│ │capacity│ fixed size of memory block implementing     │ ├─────────────┼───────────────────────│ │
│ │        │ the buffer                                  │ │clear()      │                       │ │
│ ├────────┼─────────────────┬───────────────────────────┤ │compact()    │                       │ │
│ │position│ starts at 0,    │ starts at 0 (after "flip")│ ├─────────────┼───────────────────────│ │
│ │        │ increase at each│ increase at each          │ │mark()       │"bookmark position"    │ │
│ ├────────┼─────────────────┼───────────────────────────┤ │reset()      │ and return "bookmark" │ │
│ │   limit│ element written │ element read              │ ├─────────────┼───────────────────────│ │
│ │        │ == capacity     │ == last written position  │ │equals()     │using only the         │ │
│ └────────┴─────────────────┴───────────────────────────┘ │compareTo()  │remaining-to-read bytes│ │
│                                                          │             │for the computation    │ │
│                                                          └─────────────┴───────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────
│*SEQUENCE TO READ/WRITE DATA*                  ┌───────┐
│try (  /* try-with 1.7+ */                     │SUMMARY│
│  RandomAccessFile g*aFile* =                  ├───────┴──────────────────────────
│    new RandomAccessFile("nio-data.txt", "rw") │-1 ) Write data into the Buffer
│) throws IOException {                         │-2 ) Call buffer.*flip()*
│  FileChannel b*inChannel* =                   │     switch writing/reading mode
│    g*aFile*.getChannel();                     │-3 ) Read data out of the Buffer
│                                               │-4a) buffer.clear();  ← alt1: clear all buffer
│  ByteBuffer o*buf*=                           │-4b) buffer.compact() ← alt2: clear only data read
│      ByteBuffer.allocate(48 /*capacity*/);    ├────────────────────────────────────
│                                               │ channelIn → (data) → buffer
│                                               │ buffer    → (data) → channelOut
│  int *bytesRead*=                             └────────────────────────────────────
│       b*inChannel*.read(o*buf*);  // ← o*buf* now
│                                          in write mode
│r*while* (*bytesRead* != -1)
│r*{*
│    o*buf*.*flip*();               // ← o*buf* now
│    while(o*buf*.hasRemaining()){         in read mode
│        System.out.print(
│           (char) o*buf*.get()     // ← alt.1: read 1 byte
│        );                                     at a time
│        // channel2.write(o*buf*)  // ← alt.2: read data
│    }                                         in channel2
│    o*buf*.clear();                // ← make buffer
│                                        ready-for-writing
│    *bytesRead* = b*inChannel*     // ← o*buf* now
│                    .read(o*buf*);        in write mode
│r*}*
│}
*SCATTER-GATHER*
┌──────────────────────────────────────────────────┬──────────────────────────────────────────────────┐
│ *scattering channel read*                        │*scattering-write to channel*                     │
│ - channel → read to → buffer1, buffer2, ....     │ - buffer1, buffer2, ...→ write to → channel      │
│ - Ex:                                            │ - ex:                                            │
│   ByteBuffer header = ByteBuffer.allocate(128);  │   ByteBuffer header = ByteBuffer.allocate(128);  │
│   ByteBuffer body   = ByteBuffer.allocate(1024); │   ByteBuffer body   = ByteBuffer.allocate(1024); │
│   ByteBuffer[] o*bufferArray* = { header, body };│   ByteBuffer[] o*bufferArray* = { header, body };│
│ b*channel*.read(o*bufferArray*);                 │ b*channel*.write(o*bufferArray*);                │
│            ^^^^                                  │                                                  │
│ fill up one buffer before moving on to the next  │                                                  │
│ (*not suited for undefined size messages)        │                                                  │
└──────────────────────────────────────────────────┴──────────────────────────────────────────────────┘

*CHANNEL-TO-CHANNEL*
-*If one the the channels is FileChannel*:
  - FileChannel*transferTo()/transferFrom()* can be used to move data between channels
  r*WARN:*Some SocketChannel implementations may transfer only the data the SocketChannel
    has ready in its internal buffer here and now
  ┌─────────┐
  │Examples.│
  ├─────────┴───────────────────────────────────┬─────────────────────────────────────────────┐
  │  FileChannelg*fromChannel*=                 │  FileChannelg*fromChannel*=                 │
  │     (new RandomAccessFile("from.txt", "rw"))│     (new RandomAccessFile("from.txt", "rw"))│
  │     .getChannel(),                          │     .getChannel(),                          │
  │  FileChannel b*toChannel*=                  │  FileChannel b*toChannel*=                  │
  │     (new RandomAccessFile(  "to.txt", "rw"))│     (new RandomAccessFile(  "to.txt", "rw"))│
  │     .getChannel();                          │     .getChannel();                          │
  │  long count    =g*fromChannel*.size();      │  long count    = ;                          │
  │b*toChannel**.transferFrom*(                 │g*fromChannel**.transferTo*(                 │
  │     g*fromChannel*,                         │      0 /*position*/,                        │
  │       0       , // posit.in dest-file to    │    g*fromChannel*.size() /*count*/,         │
  │                 // start writing from       │    b*toChannel*);                           │
  │       maxCount  /* max-bytes to transfer*/  │                                             │
  │  );                ^^^^^^^^^                │                                             │
  │                    constrained by data      │                                             │
  │                    in source                │                                             │
  └─────────────────────────────────────────────┴─────────────────────────────────────────────┘
</pre>
<td>
<pre xxxsmall zoom >
<span xsmall>API tree</span>
JDK 8
./java/nio/
           Bits ByteOrder CharBufferSpliterator
           ByteBufferAs(Char|Double|Float|...)Buffer(B|L|...
           (|Float|Double|StringChar)Buffer
           HeapByteBuffer Heap(Byte|Char|...)Buffer(R) HeapCharBuffer
           (Int|Long|...)Buffer
           (Mapped|Direct)ByteBuffer(R)
           Direct(Byte|Char|Double|...)Buffer

./java/nio/channels/
                    Channel Channels CompletionHandler FileLock MembershipKey Pipe Selector SelectionKey
                    Asynchronous(|Byte)Channel
                    AsynchronousChannelGroup
                    AsynchronousFileChannel
                    AsynchronousServerSocketChannel
                    AsynchronousSocketChannel
                    (Byte|Datagram|File|GatheringByte|Interruptible|Multicast|
                     Network|ReadableByte|ScatteringByte|SeekableByte|Selectable|
                     ServerSocket|Socket|WritableByte)Channel
                   /spi/Abstract(Interruptible|Selectable)Channel
                        Abstract(SelectionKey|Selector)
                        (AsynchronousChannel|Selector)Provider

./java/nio/charset/
                   Charset(|Decoder|Encoder) StandardCharsets
                   CoderResult CodingErrorAction
                  /spi/CharsetProvider

./java/nio/file/attribute/AclEntry(|Flag|Permission|Type)
                          (|AclFile|BasicFile|DosFile|File|
                            FileOwner|FileStore|PosixFile|
                            UserDefinedFile)AttributeView
                          (BasicFile|DosFile|PosixFile)Attributes
                          FileAttribute FileTime
                          GroupPrincipal

                          UserPrincipal(LookupService)
./java/nio/file/
                AccessMode CopyMoveHelper CopyOption DirectoryStream Files
                LinkOption LinkPermission Path        PathMatcher        Paths
                SecureDirectoryStream
                File(Store|System|Systems|TreeIterator|TreeWalker|VisitOption|Visitor|VisitResult)
                SimpleFileVisitor
                OpenOption    Standard(Copy|Open)Option
                StandardWatchEventKinds
                StandardWatchEventKinds$StdWatchEventKind
                TempFileHelper
                Watchable      Watch(Event|Key|Service)
                spi/FileSystemProvider
                    FileTypeDetector
</pre>
</td>
<td>

</td>
<td>
<pre xxxsmall zoom>
<span xsmall>SELECTORS</span>
@[https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html]

- A Selector allows a single thread to manage multiple channels
 (network connections), by examining which ones are
  ready for connect,accept,read,write

- A channel that "fires an event" is also said to be "ready" for that event.

*REGISTERING A SELECTOR*                              │*USING SELECTORS*
*AND ASSIGNING CHANNELS*                              │
    │  Selector b*selector* = Selector.open();        │ *STEP 1*
    │  channel.configureBlocking(false);              │  call one of the select() methods
    │          ^^^^^^^^^^^^^^^^^^^^^^^^               │  (upon registering 1+ channels)
    │   //     non-blocking-mode required             │  int select(long mSecTimeout) ← block until channel/s ready
    │   // r*WARN:* FileChannel can NOT be switched   │             └────(optional)┘
    │   //   into NON-blocking mode and so            │  int selectNow()              ← Don't block even if none read
    │   //   they can NOT be used with selectors.     │  └┬┘
┌───→g*SelectionKey key* = channel.register(          │  indicates how many channels became ready since last select() call.
│   │    b*selector*,                                 │
│   │    SelectionKey.OP_READ |                       │ *STEP 2*
│   │    SelectionKey.OP_WRITE);                      │  examine ready channels returned by select like:
│   │                 ^^^^^^^                         │  Set˂SelectionKey˃ selectedKeys =
│   │                 Or-set of interest:             │                    b*selector*.o*selectedKeys()*;
│   │                 OP_CONNECT / OP_ACCEPT          │  Iterator˂SelectionKey˃ keyIterator =
│   │                 OP_READ    / OP_WRITE           │                    selectedKeys.iterator();
│   │  ^^^^^^^^^^^^^^^^                               │  while(keyIterator.hasNext()) {
│   │                                                 │    g*SelectionKey key*= keyIterator.next();
│ ┌─→g*key*.attach(extraInfoObject);                  │      //  "cast to proper channel"
│ │ │  Object attachedObj =                           │             if (g*key*.isAcceptable ()) {
│ │ │     selectionKey.attachment();                  │        ... connection accepted by ServerSocketChannel
│ │ │                                                 │      } else if (g*key*.isConnectable()) {
│ │ │                                                 │        ... connection established with remote server
│ │ │ // After selection                              │      } else if (g*key*.isReadable   ()) {
│ │ │ // ^^^^^^^^^^^^^^^                              │        ... channel ready for reading
│ │ │ // explained later                              │      } else if (g*key*.isWritable   ()) {
│ │ │                                                 │        ... channel ready for writing
│ │ │ // Alternative 1:                               │      }
│ │ │ int o*readySet*= g*key*.readyOps();             │      keyIterator.remove();
│ │ │ boolean isAcceptable  =                         │  }
│ │ │         o*readySet* & SelectionKey.OP_ACCEPT;   │ *STEP 3*
│ │ │ ...                                             │b*selector*.close()
│ │ │ // Alternative 2:                               │            ^^^^^
│ │ │ g*key*.isAcceptable();                          │   must be called after finishing ussage,
│ │                                                   │   invalidating all SelectionKey instances
│ └─── (optional) user attached object,               │   registered with this Selector.
│      handy way to recognize a given                 │   The channels themselves are not closed.
│      channel, provide extra info
│      (buffer/s,...)
│
└─── g*key* can be queried like:
       into*interestSet* = g*key*.interestOps()*;
       boolean isInterestedInAccept
           = o*interestSet* &amp; SelectionKey.OP_ACCEPT;



NOTE:
-  A thread blocked by a call to select() can be forced to leave the select() method,
   even if no channels are yet ready by having a different thread call
   the b*selector*.*wakeup()* method on the Selector which the first thread has
   called select() on:
   - The thread waiting inside select() will then return immediately.
   - If a different thread calls wakeup() and no thread is currently
     blocked inside select(), the next thread that calls select()
     will "wake up" immediately.
</pre>
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<span xsmall>FileChannel</span>
- Java NIO FileChannel: channel connected to a file allowing to
      read data from  and write data to a file.
- A FileChannel canNOT be set into non-blocking mode:
  It always runs in blocking mode

- Reading from FileChannel (Writting to buffer):
  |/* You cannot open a FileChannel directly,
  | * first you obtain a FileChannel via an (Input|Output)Stream or a RandomAccessFile
  | */
  |RandomAccessFile g*aFile*     = new RandomAccessFile("data/nio-data.txt", "rw");
  |// Reading from channel
  |try (  /* try-with 1.7+ */
  |  RandomAccessFile g*aFile* = new RandomAccessFile("data/nio-data.txt", "rw")
  |) throws IOException {
  |  FileChannel b*inChannel* = g*aFile*.getChannel();
  |
  |  ByteBuffer o*buf* = ByteBuffer.allocate(48 /* capacity*/);
  |
  |  int *bytesRead* = b*inChannel*.read(o*buf*); // o*buf* now in write mode
  |  while (*bytesRead* != -1) {
  |    o*buf*.flip();                            // o*buf* now in read mode
  |    while(o*buf*.hasRemaining()){
  |        // alt. read data directly, 1 byte at a time
  |        System.out.print((char) o*buf*.get());
  |        // alt. read data in channel
  |        // anotherChannel.write(o*buf*)
  |    }
  |
  |    o*buf*.clear(); //make buffer ready for writing
  |    *bytesRead* = b*inChannel*.read(o*buf*); // o*buf* now in write mode
  |  }

- Writing to a FileChannel (reading from buffer)
  | String newData = "......" + System.currentTimeMillis();
  | ByteBuffer o*buf* = ByteBuffer.allocate(48);
  | o*buf*.clear();
  | o*buf*.put(newData.getBytes());
  | o*buf*.flip(); // change buffer from write to read
  | <b>while(o*buf*.hasRemaining()) {</b> channel<b orange>.write</b>(o*buf*); <b>}</b>
  | channel.close();


- FileChannel Position
  | long pos = fileChannel.position(); // obtain current position
  | fileChannel.position(pos +123); // change position

   - If you set the position after the end of the file,
     and try to read from the channel, you will get -1
   - If you set the position after the end of the file,
     and write to the channel, the file will be expanded
     to fit the position and written data. This may result
     in a "file hole", where the physical file on
     the disk has gaps in the written data.

- FileChannel Size
  | long fileSize = fileChannel.size();
                                ^^^^^^
                            size of the file
                            connected to channel

- FileChannel (file) Truncate
  | fileChannel.truncate(1024 /*length*/);

- FileChannel Force:
  flushes all unwritten data from the channel and OS cache to the disk
  | channel.force(true /* flush also file meta-data like permissions....*/);
</pre>

<pre xxxsmall zoom>
<span xsmall>Pipe</span>
- one-way data connection between two threads
- Pipe =   source channel   ← One threads writes to sink
        +    sink channel   ← One threads reads from source

Ex:
  ByteBuffer o*buf* = ByteBuffer.allocate(48);
  o*buf*.clear();
  o*buf*.put(newData.getBytes());

  // WRITING TO PIPE
  Pipe pipe = Pipe.open();
  Pipe.SinkChannel sinkChannel = pipe.sink();
  String newData = "..." + System.currentTimeMillis();
  o*buf*.flip();
  while(o*buf*.hasRemaining()) { sinkChannel.write(o*buf*); }

  // READING FROM A PIPE
  To read from a Pipe you need to access the source channel. Here is how that is done:
  Pipe.SourceChannel sourceChannel = pipe.source();
  int *bytesRead* = b*inChannel*.read(buf2);
</pre>
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<span xsmall>SocketChannel</span>
There are two ways a SocketChannel can be created:

// Opening a SocketChannel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

// Reading (writing to buffer)
ByteBuffer o*buf* = ByteBuffer.allocate(48);
int *bytesRead* = socketChannel.read(o*buf*); // If -1 is returned, the end-of-stream is reached (connection is closed)

// Writing to a SocketChannel
String newData = "..." + System.currentTimeMillis();
ByteBuffer o*buf* = ByteBuffer.allocate(48);
o*buf*.clear();
o*buf*.put(newData.getBytes());
o*buf*.flip();
while(o*buf*.hasRemaining()) { channel.write(o*buf*); }

socketChannel.close();
</pre>

<pre xxxsmall zoom>
<span xsmall>Non-blocking Mode</span>
- socketChannel<b>.configureBlocking(false)</b>;
- Calls to connect(), read() and write() will not block
- In non-blocking mode connect() calls may return before
  the connection is established:
  - To determine whether the connection is established
    use finishConnect() like this:

  | socketChannel.configureBlocking(false);
  | socketChannel.connect(
  |   new InetSocketAddress("http://jenkov.com", 80));
  |
  | while(! socketChannel.finishConnect() ){
  |     //wait, or do something else...
  | }

NOTE: non-blocking works much better with Selector's
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>ServerSocketChannel</span>
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept(); // in blocking mode waits until incoming connection arrives
    if(socketChannel != null /* always false in blocking mode */){
        //do something with socketChannel...
    }

    //do something with socketChannel...
}

serverSocketChannel.close()
</pre>

<pre xxxsmall zoom>
<span xsmall>Datagram Channel</span>
- Since UDP is a connection-less network protocol, you cannot just
  by default read and write to a DatagramChannel like you do from
  other channels. Instead you send and receive packets of data

  | DatagramChannel channel = DatagramChannel.open();
  | channel.socket().bind(new InetSocketAddress(9999));
  |
  | ByteBuffer o*buf* = ByteBuffer.allocate(48);
  | o*buf*.clear();
  | // WARN: if read data is bigger than buffer size remaining data is discarded silently
  | channel.receive(o*buf*);
  |
  | // Write to channel
  | String newData = "..." + System.currentTimeMillis();
  | o*buf*.clear();
  | o*buf*.put(newData.getBytes());
  | o*buf*.flip();
  |
  |
  | // WARN:  No notice is received about packet delivery (UDP does not make any guarantees)
  | int bytesSent = channel.send(o*buf*, new InetSocketAddress("jenkov.com", 80));
  |
  | // Alternatively you can "Connect" to a Specific Address. Since UDP is connection-less,
  | // connecting to a remote address just means that the DatagramChannel can only send/receive
  | // data packets from a given specific address.
  | channel.connect(new InetSocketAddress("jenkov.com", 80));
  | int *bytesRead* = channel.read(o*buf*);
  | int bytesSent = channel.write(o*buf*);
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>NonBlocking Server</span>
REF:
- @[http://tutorials.jenkov.com/java-nio/non-blocking-server.html]
- @[https://github.com/jjenkov/java-nio-server]
- Non-blocking IO Pipelines:
read-write pipeline: <b>channelIn</b> → selector → component → ... → componentN → <b>channelOut</b>
read-only  pipeline: <b>channelIn</b> → selector → component → ... → componentN
write-only pipeline:                        component → ... → componentN → <b>channelOut</b>
Note: It is the component that initiates reading of data from the Channel via the Selector
read-pipeline read from stream/channelIn and split data into messages like:

Data   → Message → Message
Stream   Reader    Stream
<b>
- A blocking Message Reader/Writer is simpler, since it
  has never to handle situations where no data was read
  from the stream, or where only a partial message was
  read from the stream and message parsing needs to be
  resumed later.
- The drawback of blocking is the requirement of separate
  threads for each parallel stream, which is a problem if the
  server has thousands of concurrent connections</b>
- Each thread will take between 320K (32 bit JVM) and
  1024K (64 bit JVM) memory for its stack
- Queue messages can be used to reduce the problem. However,
  this design requires that the inbound client  streams
  send data reasonably often and input is processed fast.
   If the inbound client stream may be inactive for longer periods
  attached to hidden clients, a high number of inactive
  connections may actually block all the threads in the thread
  pool.
  That means that the server becomes slow to respond or even
  unresponsive.
- A non-blocking IO pipeline can use a single thread to
  read messages from multiple non-blocking streams.
    When in non-blocking mode, a stream may return 0 or more
  bytes when you attempt to read data from it.
  When you call select() or selectNow() on the Selector it
  gives you only the SelectableChannel instances ("connected
  clients") that actually has data to read.
<b bgorange>
Component ──→ STEP 1: select() ──→ Selector ←──┬─→ Channel1
    ↑                                │         ┼─→ Channel2
    └───← STEP 2: ready channels ←───┘         └─→ Channel3</b>


- Reading Partial Messages: Data sent by "ready" channels can
  contain fractions/incomplete messages:
  - The Message Reader looks needs to check if the data block
    contains at least one full message, adn storing partial ones.
    (maybe using one Message Reader per Channel to avoid mixing messages)
  - To store Partial Messages two design should be considered:
    - copy data as little as possible for better performance
    - We want full messages to be stored in consecutive byte to
      make parsing messages easier
  - Some protocol message formats are encoded using a TLV format
    (Type, Length, Value).
    Memory management is much easier since we known immediately
    how much memory to allocate for the message. No memory is
    wasted at the end of a buffer that is only partially used.
  - The fact that TLV encodings makes memory management easier is
    one of the reasons why HTTP 1.1 is such a terrible protocol.
    That is one of the problems trying to be fixed in HTTP 2.0 where
    data is transported in LTV encoded frames.
  - Writing Partial Messages: channelOut.write(ByteBuffer) in
    non-blocking mode gives no guarantee about how many of the
    bytes in the ByteBuffer is being written. The method returns
    how many bytes were written, so it is possible to keep track
    of the number of written bytes.
  - Just like with the Message Reader, a Message Writer is used
    per channel to handle all the details.
   (partial writes, message queues, resizable buffers, protocol aware tricks,...)

- <b>All in all a non-blocking server ends up with three "pipelines" it
   needs to execute regularly:</b>
  - The read pipeline which checks for new incoming data from
    the open connections.
  - The process pipeline which processes any full messages received.
  - The write pipeline which checks if it can write any outgoing
    messages to any of the open connections
</pre>
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<span xsmall>Path (1.7+)</span>
- Represents a file/directory path in the FS
- Similar to java.io.File but with some minor differences.
// Ussage
import java.nio.file.Path;
import java.nio.file.Paths;

Path path = Paths.get("/var/lib/myAppData/myfile.txt");
System.out.println("Current dir:"+Paths.get(".").toAbsolutePath());
</pre>

<pre xxxsmall zoom>
<span xsmall>Files</span>
- java.nio.file.Files provides several methods for manipulating FS files/directories:
- uses Path instances:

boolean pathExists = <b>Files.exists</b>(pathInstance,
            new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});

Path newDir = <b>Files.createDirectory</b>(path);

<b>Files.copy</b>(sourcePath, destinationPath);
<b>Files.copy</b>(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

<b>Files.move</b>(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

<b>Files.delete</b>(path);

Files.walkFileTree(Paths.get("data"), new FileVisitor<Path>() {
  @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }
});

</pre>
<pre xxxsmall zoom>
<span xsmall>Asyncrhonous FileChannel 1.7+</span>
read/write data from/to files asynchronously

Path path = Paths.get("data/test.xml");
AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

// Reading Data, Alt 1: Via a Future
  Future<Integer> operation = fileChannel.read(/*ByteBuffer*/buffer, 0 /*start position to read from */);
  while(!operation.isDone());  // WARN: not a very efficient use of the CPU
  buffer.flip();
  byte[] data = new byte[buffer.limit()];
  buffer.get(data);
  System.out.println(new String(data));
  buffer.clear();

// Reading Data Alt 2: Via a CompletionHandler
fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {
    @Override
    public void completed(Integer numBytesRead, ByteBuffer attachment) {
        // NOTE: attachment is a reference to the third parameter passed to .read read()
        System.out.println("numBytesRead = " + numBytesRead);
        attachment.flip();
        byte[] data = new byte[attachment.limit()];
        attachment.get(data);
        System.out.println(new String(data));
        attachment.clear();
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) { ...  }
});

// Writing data:
AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

// Writing Data: Alt 1: Via a Future
  ...
  Future<Integer> operation = fileChannel.write(buffer, position);
  buffer.clear();
  while(!operation.isDone());

// Writing Data: Alt 2: Via CompletionHandler
...
  fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {

      @Override public void completed(Integer result, ByteBuffer attachment) { /* ... */ }
      @Override public void failed   (Throwable exc , ByteBuffer attachment) { /* ... */ }
  });

</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>OkHTTP</span>
https://square.github.io/okhttp/
HTTP is the way modern applications network. It’s how we exchange data & media
. Doing HTTP efficiently makes your stuff load faster and saves bandwidth.
OkHttp is an HTTP client that’s efficient by default:

- HTTP/2 support allows all requests to the same host to share a socket.
- Connection pooling reduces request latency (if HTTP/2 isn’t available).
- Transparent GZIP shrinks download sizes.
- Response caching avoids the network completely for repeat requests.

- OkHttp perseveres when the network is troublesome: it will silently recover
  from common connection problems. If your service has multiple IP addresses
  OkHttp will attempt alternate addresses if the first connect fails. This is
  necessary for IPv4+IPv6 and for services hosted in redundant data centers.
  OkHttp supports modern TLS features (TLS 1.3, ALPN, certificate pinning). It
  can be configured to fall back for broad connectivity.

- Using OkHttp is easy. Its request/response API is designed with fluent
  builders and immutability. It supports both synchronous blocking calls and
  async calls with callbacks.

- OkHttp supports Android 5.0+ (API level 21+) and Java 8+.
</pre>
<pre xxxsmall zoom>
<span TODO xsmall>okIO</span>
<span xsmall>complements java.nio</span>
@[https://github.com/square/okio]
- makes it much easier to access, store, and process your data.
- It started as a component of OkHttp, the capable HTTP client
  included in Android. It's well-exercised and ready to solve new problems.
</pre>
</td>


<td title>
    Debug &amp;<br/>
    Profile
</td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>JVisualVM (standard on the JDK)</span>
- displays memory usage and other useful things:

<span TODO xsmall>Deadlock analysis</span>
@[https://avaldes.com/java-thread-deadlock-example-and-thread-dump-analysis-using-visualvm/]
</pre>
<pre xxxsmall zoom>
<span xsmall>Flight Recorder</span>
- Free of use starting with Java 11+
- (JEP 328)
- profiling tool gathering diagnostics and profiling data
- negligible performance overhead (˂1%):
-*Can be used in production*
</pre>


<pre xxxsmall zoom>
<span TODO xsmall>Monitoring Overview</span>
@[http://java.sun.com/developer/technicalArticles/J2SE/monitoring/]
</pre>


<pre xxxsmall zoom>
<span TODO xsmall>Eclipse Mem.Analizer</span>
@[https://www.eclipse.org/mat/]
"""he Eclipse Memory Analyzer is a fast and feature-rich Java heap
  analyzer that helps you find memory leaks and reduce memory consumption.

  Use the Memory Analyzer to analyze productive heap dumps with hundreds of
  millions of objects, quickly calculate the retained sizes of objects, see
  who is preventing the Garbage Collector from collecting objects, run a
  report to automatically extract leak suspects.
"""

It can provide reports and warnings similar to:
  (REF: @[https://www.youtube.com/watch?v=5joejuE2rEM])
  The classloader/component "sum.misc.Launcher$AppClassLoader@0x123412"
  occupies 607,654,123(38,27%) bytes.
r*The memory is accumulated in one instance* of
  java.util.LinkedList$Entry loaded by 'system class loader'
</pre>


<pre xxxsmall zoom>
<span xsmall>VisualVM</span>
@[https://visualvm.github.io/]
- r*WARN: Deprecated by Flight Recorder?*
  @[https://stackoverflow.com/questions/40272599/do-java-mission-control-and-flight-recorder-deliver-same-functionality-as-visual]
- Visual tool integrating commandline JDK tools and
  lightweight profiling capabilities.
- Designed for both development and production time use.
</pre>
</td>
</table>

<table>
</tr>
<td>
<td title>
    Concurrent <br/>
    Programming <br/>
    <a href="https://cs.nyu.edu/~lerner/spring12/Preso03-JavaPrimitives.pdf">REF</a>
</td>
<pre xxxsmall zoom>
  <span xsmall>Concurrency Basics</span>
  - Concurrency problems arise from the desire to use CPU resources more efficiently. Non concurrent
    applications (single threaded/single process) are complete Touring machines that can potentially
    solve any problem with enough time and memory. In practice having a CPU assigned to single thread
    will be very inneficient since the CPU will stand-by while the thread is waiting for input/output
    operations. Also, many algorithms allows to split processed data in isolated regions that can be
    processed in parallel by different CPU/CPU cores</li>
  - Concurrent tries to solve the problem of multiple independents CPUs or threads accesing share
    resources (memory)
  - Locks is the simples concurrent primite to protect code or data from concurrent
    access in situations where there are many threads of execution. Locks can be classified like:
    | According to lock ussage:
    |    Cooperative   A thread is encouraged (but not forced) to cooperate with other
    |                  threads by adquiring a lock before accessing the associated data
    |
    |    Mandatory     a thread trying to access an already locked resource will throw
    |                  an exception
    | _________________________________________________
    | According to lock rescheduing strategy:
    |    Blocking      The OS block the thread requesting the lock and rescheduled another thread
    |
    |    Spinlock      The thread waits in a loop until the requested lock becomes available.
    |                  It's more efficient if threads are blocked for very short time (smaller than
    |                  the time needed by the OS to reschedule another thread into the current CPU)
    |                  It's inneficient if the lock is held for a long time since a CPU core is
    |                  waisted on the spinlock loop
    | _________________________________________________
    | According to granularity: (measure of the ammount of data the lock is protecting)
    |    Coarse        Protect large segments of data (few locks). Results in less lock overhead
    |                  for a single thread, but worse performance for many threads running concurrently
    |                  (most thread will be lock-contended waiting for share resource access)
    |
    |    Fine          Protrect small amounts of data. Require more lock instances reducing lock
                 contention

  - Locks require CPU atomic instructions for efficient implementations suchs as
      "test-and-set", "fetch-and-add", or "compare-and-swap", whether there are blocking
      (managed by the OS) or spinlocks (managed by the thread)
  - Uniprocessors can just disable interruptions to implement locks, while multiprocessors
    using shared-memory will require complex hardware and/or software support
  -  *Monitors wrap mutex-locks with condition variables (container of threads waiting*
     *for certain condition)*. They are implemented as thread-safe classes


</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>monitors</span>
- The simplest form of synchronization in Java is the mutual exclusion of
  threads to shared resources using monitors
  Other alternatives include:
  - reads and writes of volatile variables
  @[https://avaldes.com/examining-volatile-keyword-with-java-threads-example/]
    Volatile keyword is typically in applications when one thread will
    be making changes to the variables and the others all reading or
    consumers of the data. If you have multiple threads making changes to
    the data it will be best to stick with synchronized block or use
    java.util.concurrent library package.
    (volatile is actually simpler than monitors, but not universal)
    Important Points on Volatile Variables:
    - Volatile variables are*not cached in registers or in caches*:
     *All read and writes are done in main memory, never done thread-locally*
    - Example Ussage: status flags used in spin loops
    - Volatile keyword*guarantees visibility and ordering*
  - use of classes in the java.util.concurrent package
- Monitors also have the ability to wait(block a thread) for a certain condition
  to become true, and signal other threads that their condition has been met
-*Monitors provide a mechanism for threads to temporarily give up exclusive access in*
 *order to wait for some condition to be met, before regaining exclusive access and  *
 *resuming their task*
- each java object can be used as a monitor.
- Methods/blocks of code requiring mutual exclusion must be explicitly marked with the
o*synchronized keyword*:
  - The synchronized statement computes a reference to an object;
    it then attempts to perform a lock action on that object's monitor and does not
    proceed further until the lock action has successfully completed.
    After the lock action has been performed, the body of the synchronized statement
    is executed. If execution of the body is ever completed, either normally or abruptly,
    an unlock action is automatically performed on that same monitor.
  - r*WARN*: The Java programming language neither prevents nor requires detection
    of deadlock conditions.
- Instead of explicit condition variables, each monitor(/object) is equipped with
  a single wait queue in addition to its entrance queue.
- All waiting is done on this single wait queue and allo*notify/notifyAll*
  operations apply to this queue.
             enter
               │
 ┌───┬──────── │ ──┐       - Wait sets are manipulated solely and atomically
 │  notified   v   │         through the methods*Object.wait, Object.notify, and Object.notifyAll*
 │ ─────→          │
 │                 │
 │ O │         O   │
 │ O │         O   │
 │ O ├────────   ──┴──┐
 │ O │                │
 │   │                │
 │  ←── wait   O      │
 │   │      (Running  │
 └───┤       thread)  │
     │                │
     │     leave      │
     │        │       │
     └─────── │ ──────┘
              v
Let thread t be the thread executing the wait method on object m, and let n be
the number of lock actions by t on m that have not been matched by unlock actions.
  - A notify action being performed on m in which t is selected for removal from the wait set.
  - A notifyAll action being performed on m.
  - An interrupt action being performed on t.
  - If this is a timed wait, an internal action removing t from m's wait set that
    occurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse
    since the beginning of this wait action.
  - An internal action by the implementation. Implementations are permitted, although
    not encouraged, to perform "spuriou wake-ups",
    that is, to remove threads from wait sets and thus enable resumption without
    explicit instructions to do so.

Notification actions occur upon invocation of methods notify and notifyAll.

Memory that can be shared between threads is called shared memory or heap
memory. All instance fields, static fields, and array elements are stored in
heap memory. In this chapter, we use the term variable to refer to both
fields and array elements. Local variables (Â§14.4), formal method parameters
(Â§8.4.1), and exception handler parameters (Â§14.20) are never shared
between threads and are unaffected by the memory model.

<!--
TODO Concurrent
@ma: https://en.wikipedia.org/wiki/Monitor_(synchronization)
     https://cs.nyu.edu/~lerner/spring12/Preso03-JavaPrimitives.pdf
     https://en.wikipedia.org/wiki/Concurrent_computing
     http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
-->
</pre>
</td>
<td>
<pre xxxsmall zoom { >
<span xsmall>Concurrent code</span>
 ┌────────────┐ │
 │[[Runnable]]│ │              [[Executor]]
 │────────────│ │                   ↑
 │┼run()      │ │           [[ExecutorService]]
 └────────────┘ │                   ↑
       ^        │        ┌──────────┴──────────────┐
       │        │        │                         │
 ┌────────────┐ │ AbstractExecutorService  [[ScheduledExecutorService]]
 │   Thread   │ │        ↑                         ↑
 │────────────│ │ ThreadPoolExecutor               │
 │+run()      │ │        ↑                         │
 │+start()    │ │ ScheduledThreadPoolExecutor ─────┘
 │+sleep()    │ │
 │....        │ │
 │────────────│ │
 └────────────┘ │

-   ExecutorService(Thread Pool): managed collection of threads available to execute tasks.
    To use a thread pool, you can use an implementation of the interface
    ExecutorService, such as ThreadPoolExecutor or ScheduledThreadPoolExecutor.
    However, more convenient factory methods are provided in the Executors class
    as follows:
    Using thread pool:
    - Write worker thread class implementing ˂˂Runnable˃˃ run()
    - STEP 2: Create ExecutorService using:
Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int numThreads)
Executors.newCachedThreadPool(): // ← unbounded pool, with automatic reclamation
Executors.newSingleThreadScheduledExecutor()
Executors.newScheduledThreadPool(int size)


- Use executor(Service)Instance.execute(/*Runnable */workerThreadInstance)
  to add a Runnable task to thread pool. Executes task at some time in the
  future in a new thread, in a thread pool, or in the calling thread,
  depending on the implementation of Executor

 [[java.util.concurrent.ExecutorService]]
 + public     void      shutdown(); // Initiates orderly shutdown of pool
 + public <T> Future<T> submit(Callable<T> task); // schedule callable task for execution
</pre>
</td>
<td>
<pre xxxsmall zoom >
<a xsmall href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'>Completable Future </a>
(Java 8+)
- A Future that may be explicitly completed (setting its value and status),
    and may be used as a CompletionStage, supporting dependent functions and
    actions that trigger upon its completion.
- When two or more threads attempt to complete, completeExceptionally, or
    cancel a CompletableFuture, only one of them succeeds.
[[ java.util.concurrent.Callable&lt;V&gt; ]]
   +public V call()  (vs run() in Runnable)
   similar to a Runnable, but allows to return a result/Exception to the thread triggering the Callable
   returns a result of type &lt;V&gt;, or throws an exception if unable to do so.

[[ Future&lt;V&gt; ]]
   +V get()           // blocks waiting for result
   +V get(long timeout, TimeUnit unit)
   +boolean cancel(boolean mayInterruptIfRunning)
   +boolean isCancelled()
   +boolean isDone()  // return true if this task completed

<b>Barriers (<code orange>allOf</code>):</b>

CompletableFuture&lt;Void&gt;[] future_list = new CompletableFuture[list.size()];
        int idx=0;
        log.info("Connecting plugins ...");
        for (Object el : list) {
            final CompletableFuture&lt;Void&gt; connectFuture = new CompletableFuture&lt;&gt;();
            asyncMethod(connectFuture);
            ...
        }
        return CompletableFuture.<b orange>allOf</b>(future_list);
    }
</pre>
</td>
<td>
<pre xxxsmall zoom { >
<span xsmall>Ex1 ThreadPoolTest:</span>
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {

   public static void main(String[] args) {
      ExecutorService pool = Executors.newFixedThreadPool(10);
      MyWorker[] workers = new MyWorker[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) pool.execute(new MyWorker(i+1));
      pool.shutdown();
   }
}
</pre }>
<pre xxxsmall zoom {>
<span xsmall>Ex2: CallableThreadPoolTest:</span>
import java.util.concurrent.Callable;
import java.util.concurrent.*;

public class CallableThreadPoolTest {

    public class MyCallableWorkerThread implements Callable&lt;String> {
       MyCallableWorkerThread(int workerNumber) { ... }
       public String call() {
          Thread.sleep((int)(Math.random() * 1000));
          return "worker " + workerNumber;
       }
    }

   public static void main(String[] args) {
      int numWorkers = 10;
      ExecutorService pool = Executors.newCachedThreadPool();
      MyCallableWorkerThread workers[] = new MyCallableWorkerThread[numWorkers];
      Future                 futures[] = new Future                [numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new MyCallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
                                 try {
            System.out.println(futures[i].get() + " ended");
                                 } catch (InterruptedException ex) {
            ex.printStackTrace();
                                 } catch (ExecutionException ex) {
            ex.printStackTrace();
                                 }
      }
   }
}
</pre>
</td>
<td>
<ul xxxsmall zoom >
<span xsmall>Guava ListenableFuture</span>
@[https://github.com/google/guava/wiki/ListenableFutureExplained]
- Concurrency is a hard problem, but it is significantly simplified by
  working with powerful and simple abstractions. To simplify matters,
  Guava extends the Future interface of the JDK with ListenableFuture.

- """We strongly advise that you always use ListenableFuture instead
  of Future in all of your code, because:
  - Most Futures methods require it.
  - It's easier than changing to ListenableFuture later.
  - Providers of utility methods won't need to provide Future and ListenableFuture
      variants of their methods.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Listenable vs Completable Futures</span>
@[https://stackoverflow.com/questions/38744943/listenablefuture-vs-completablefuture]
          ListenableFuture                           │               CompletableFuture
─────────────────────────────────────────────────────┼───────────────────────────────────────────────────
                                                     │ It is different from ListenableFuture in that it
                                                     │ can be completed from any thread that wants it to complete
─────────────────────────────────────────────────────┼───────────────────────────────────────────────────
ListenableFuture listenable = service.submit(...);   │ CompletableFuture completableFuture =
  Futures.addCallback(listenable,                    │     new CompletableFuture();
                      new FutureCallback˂Object˃() { │ completableFuture.whenComplete(new BiConsumer() {
    @Override                                        │   @Override
    public void onSuccess(Object o) {                │   public void accept(Object o, Object o2) {
        //handle on success                          │       //handle complete
    }                                                │   }
                                                     │ }); // complete the task
    @Override                                        │ completableFuture.complete(new Object())
    public void onFailure(Throwable throwable) {     │
       //handle on failure                           │ When a thread calls complete on the task,
    }                                                │ the value received from a call to get() is
  })                                                 │ set with the parameter value if the task is
                                                     │ not already completed.

  ..."CompletableFuture is dangerous because it exposes *compete* methods."
  ..."CompletableFuture would have been good if it extended Future and did not expore
      toCompletableFuture,... and they could have named it something
      meaningful like ChainableFuture "
</pre>
</td>
</tr }>
</table>

<table>
<tr {>
<td title>
    Async/Reactive<br/>
    Programming
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>Summary</span>
addition of lambda expressions in Java 8 created opportunities for functional
APIs in Java. This is a boon for non-blocking applications and continuation
style APIs — as popularized by CompletableFuture and ReactiveX, that allow
declarative composition of asynchronous logic. At the programming model level
Java 8 enabled Spring WebFlux to offer functional web endpoints alongside
with annotated controllers.

The term "reactive" refers to programming models that are built around
reacting to change — network component reacting to I/O events, UI controller
reacting to mouse events, etc. In that sense non-blocking is reactive because
instead of being blocked we are now in the mode of reacting to notifications
as operations complete or data becomes available.

Spring Reactive Streams is a small spec, also adopted in Java 9, that defines
the interaction between asynchronous components with back pressure. For
example a data repository — acting as Publisher, can produce data that an
HTTP server — acting as Subscriber, can then write to the response. The main
purpose of Reactive Streams is to allow the subscriber to control how fast or
how slow the publisher will produce data.

Reactive Streams plays an important role for interoperability. It is of
interest to libraries and infrastructure components but less useful as an
application API because it is too low level. What applications need is a
higher level and richer, functional API to compose async logic — similar to
the Java 8 Stream API but not only for collections. This is the role that
reactive libraries play.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>java.util.concurrent.Flow</span>
@[https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html]
- JDK 1.9+
- Reactive Streams was adopted by the JDK in the form of the java.util.concurrent.Flow API.
- It allows two different libraries that support asynchronous streaming to connect to each other,
    with well specified semantics about how each should behave, so that backpressure, completion, cancellation
    and error handling is predictably propagated between the two libraries.
- There is a rich ecosystem of open source libraries that support Reactive Streams,
    and since its inclusion in JDK9, there are a few in development implementations that are
    targetting the JDK, including the incubating <a href="http://openjdk.java.net/jeps/321">JDK9 HTTP Client</a>,
    and the <a href="https://twitter.com/brunoborges/status/915302682939711488">Asynchronous Database Adapter (ADBA)</a>
    effort that have also adopted it
- (See also <a href="http://www.eclipse.org/community/eclipse_newsletter/2018/may/reactivestreams-ee4j.php">What can Reactive Streams offer to EE4J</a>)
</pre>
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>RxJava</span>
@[https://github.com/ReactiveX/RxJava]
            Java 8 Stream
+       CompletableFuture
+ "Back-presure" measures *1
-------------------------
            rx.Observable
*1 probably an intermediate buffer for incomming/outgoing messages that acts
async. when not full, and sync when full.
</pre>
  </td>
</tr }>
</table>
<br/>
<table>
<tr {>
<td>
<pre TODO xxxsmall zoom>
<span xsmall>JSON</span>
- <a href='https://www.infoq.com/news/2017/03/json-processing-public-review'>REF:JSON processing public review</a></li>

Public review of JSR 374: Java API for JSON Processing (JSON-P) version 1.1 is now open.
This version is expected to be included in the release of J2EE 8 and keeps JSON-P current with JSON IETF standards. It includes support for:
    - JSON Pointer</li>
    - JSON Patch</li>
    - JSON Merge Patch</li>
    - Query and transformation operations</li>
    - Java 8 streams and lambdas</li>
- JSON-P was introduced in 2013 with the release of J2EE 7, as
  an alternative to Gson and Jackson. It was designed to parse, generate,
  and query standard JSON documents.
  SR-367: Java API for JSON Binding (JSON-B), will also be included in the release of J2EE 8.
<span xsmall>Example</span>
tags: [JSON Parsing, HTTP GET/POST, TLS, Basic Authorization]
package com.mycomp.project1;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.json.JSONObject;

import java.security.cert.X509Certificate;
import java.util.Date;

import java.util.Scanner;

public class TestAPI<JSONArray> {
    static String userpass = "operator1:ecllqy";
    private static SSLSocketFactory sslSocketFactory = null;

    private JSONObject sendPost(String url, String post_body, String token) throws Exception
    {
        URL obj = new URL(url);
        String basicAuth = "Basic " +
            javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

        HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

        setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

        con.setRequestMethod("POST"); //add request header
        con.setRequestProperty("Content-Type", "application/json");
        con.setRequestProperty("Cache-Control", "no-cache");
        if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
        } else               { con.setRequestProperty("Authorization", "Bearer "+token);
        }
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(post_body);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();

        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        StringBuffer response = new StringBuffer();
        String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
        in.close();
        return new JSONObject(response.toString()); //String myJSONStr
    }


    /********************************************************************************/
    /**
     * Overrides the SSL TrustManager and HostnameVerifier to allow
     * all certs and hostnames.
     * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
     * environment.
     *
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     */
    protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
        // Create the socket factory.
        // Reusing the same socket factory allows sockets to be
        // reused, supporting persistent connections.
        if( null == sslSocketFactory) {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
            sslSocketFactory = sc.getSocketFactory();
        }

        connection.setSSLSocketFactory(sslSocketFactory);

        // Since we may be using a cert with a different name, we need to ignore
        // the hostname as well.
        connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
    }

    private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {}
            public void checkServerTrusted(X509Certificate[] certs, String authType) {}
        }
    };

    private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
}
</pre } >
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>[QA] Restassured: JSON REST API Test</span>
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;scala-support&lt;/artifactId&gt;
    &lt;version&gt;3.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt;
    &lt;version&gt;3.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
___________________________
package com.mycompany.myproject.mymodule;

import static junit.framework.TestCase.assertTrue;
import static org.hamcrest.Matchers.*;

import com.everis.trinity.server.common.StatusResult;

import static io.restassured.RestAssured.given;

import io.restassured.RestAssured;
import io.restassured.config.HttpClientConfig;
import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import junit.framework.TestCase;
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.SystemDefaultHttpClient;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.eclipse.jetty.http.HttpStatus;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.BeforeClass;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;

import java.util.Base64;
import java.util.Map;

// <b>FullJourney == Simulate full (REST) API in expected order</b>
public class FullJourneyTest {

    // Custom regex matcher for RestAssured Framework
    public static class RegexMatcher extends BaseMatcher<Object>{
        private final String regex;

        public RegexMatcher(String regex){
            this.regex = regex;
        }

        public boolean matches(Object o){
            return ((String)o).matches(regex);

        }

        public void describeTo(Description description){
            description.appendText("matches regex=");
        }

        public static RegexMatcher matches(String regex){
            return new RegexMatcher(regex);
        }
    }

     public static class Base64Matcher extends BaseMatcher<Object>{

        public Base64Matcher(){}

        public boolean matches(Object o){
            try {
                Base64.getDecoder().decode((String)o);
                return true;
            }catch (Exception e){
                return false;
            }
        }

        public void describeTo(Description description){
            description.appendText("can be parsed as Base64");
        }

        public static Base64Matcher isBase64Encoded(){
            return new Base64Matcher();
        }
    }
    private static final String AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;

    protected static RequestSpecification setupCommonHeaders() {
        return given().header("Authorization", AUTH_HEADER_VALUE)
                      .header("Accept"       , "application/json")
                      .header("content-type" , "application/json;charset=utf-8")
        .log().all();
    }


    final String
        NAME="COMMUNITY_1", SYMBOL="SY1";

    Response response;
    @BeforeClass
    public static void setup() {
        RestAssured.port     = ServerConfig.serverPort;
        RestAssured.basePath = "/";
        RestAssured.baseURI  = "http://localhost";

        HttpClientConfig clientConfig = RestAssured.config().getHttpClientConfig();
        clientConfig = clientConfig.httpClientFactory(new HttpClientConfig.HttpClientFactory() {
            @Override
            public HttpClient createHttpClient() {
                HttpClient rv =  new SystemDefaultHttpClient();
                HttpParams httpParams = rv.getParams();
                //  Wait 5s max for a connection
                HttpConnectionParams.setConnectionTimeout(httpParams, 5 * 1000);
                // Default session is 60s
                HttpConnectionParams.setSoTimeout(httpParams, 60 * 1000);
                return rv;
            }
        });
        // This is necessary to ensure, that the client is reused.
        clientConfig = clientConfig.reuseHttpClientInstance();
        RestAssured.config = RestAssured.config().httpClient(clientConfig);
    }

    @Test
    public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
        String jsonBody =
            "{ " +
                " \"name\": \""+NAME+"\", " +
                " \"symbol\": \"" + SYMBOL + "\","
            "}";
        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/01")</b>;
        System.out.println(response.body().prettyPrint());
        response.then()
            /* <b>get sure JSON serializer do not include extra (maybe sensitive) info</b> */
            .body("size()", <b orange>is(5)                          </b>)
            .body("id"    , <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>RegexMatcher.matches("^*{65}$")</b>)
            .body("pubkey", <b orange>Base64Matcher.isBase64Encoded()</b>)
            .body("name"  , <b orange>equalTo(NAME)                  </b>)
            .body("symbol", <b orange>equalTo(SYMBOL)                </b>)
            .statusCode(HttpStatus.ACCEPTED_202);
        String <b blue>NEW_ID = response.getBody().jsonPath().get("id")</b>;

        // Next related test to execute synchronously after fetching NEW_ID
        String jsonBody =
            "{ " +
                <b blue>" \"FK_ID\": \""+NEW_ID+"\", " +</b>
                ...
            "}";

        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/02")</b>;
        ...
    }

}
</pre>
</td>
<td colsep></td>
<td>
<pre xxxsmall zoom>
<span xsmall>Lambdas</span>
Sytnax:
(parameters) -&gt; expression
(parameters) -&gt;  { statements; }

// takes a Long, returns a String
Function&lt;Long, String&gt; f = (l) -&gt; l.toString();

// takes nothing, gives you Thread
Supplier&lt;Thread&gt; s = Thread::currentThread;

//  takes a string as the parameter
Consumer&lt;String&gt; c = System.out::println;

// use lambdas in streams
new ArrayList&lt;String&gt;().stream()....

// peek: Debug streams without changes
peek ( e -&gt; System.out.println(e)). ...

// map: Convert every element into something
map ( e -&gt; e.hashCode())...

// filter (hc -&gt; (hc % 2) == 0) ...

// collect all values from the stream
collect(Collectors.toCollection(TreeSet::new))
</pre>
<pre xxxsmall zoom>
  <a xsmall href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html"><code>java.util.function</code></a>
- JDK 1.8+</li>
- <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">
      https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html</a>
- Incomplete but good enough to cover the "shape" of many lambda expressions and method references
      representing abstract concepts like functions, actions, or predicates</li>
- The <code>@FunctionalInterface</code> is used to capture design intent (not needed by compiler).</li>
- In documenting functional interfaces, or referring to variables typed as
  functional interfaces, it is common to refer directly to those abstract concepts,
  for example using "this function" instead of "the function represented by this object".</li>
- Each functional interface has a single abstract method, called the functional method for that
  functional interface, to which the lambda expression's parameter and return types are matched or adapted.</li>
- Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation,
  or cast context:
  |Predicate&lt;String&gt; p = String::isEmpty;           // Assignment context
  |stream.filter(e -&gt; e.getSize() &gt; 10)...          // Method invocation context
  |stream.map((ToIntFunction) e -&gt; e.getSize())...  // Cast context
</pre>
<pre xxxsmall zoom>
<span xsmall>Defined functions in 1.8</span>
────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────
           Interface Summary                │           Interface Description
────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────
                  BiConsumer‹T,U›           │opt. accepting two input arguments and returns no result
  (|Double|Int|Long)Consumer‹T›             │opt. accepting a single (Object|double|int|long)input argument and returns no result
Obj(Double|Int|Long)Consumer‹T›             │opt. accepting an object-valued and a (double|int|long)-valued argument, and returns no result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
        (|Double|Long|Int)Function‹(T,)R›   │func. that accepts an (T|double,long,int) argument and produces a result
       (|Double|Long)ToIntFunction          │func. that accepts a (T|double|long)argument and produces an int-valued result
(ToDouble|ToLong|ToInt|)BiFunction‹(T,)U,R› │func. that accepts two arguments and produces an (T,double,long,int) result.
           To(Double|Long)Function‹T›       │func. that produces a (double|long)-valued result
(Int|Long|Double)To(Int|Long|Double)Function│func. that accepts a (int|long|double) argument and produces a (int|long|double) result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
 (|Int|Long|Double)UnaryOperator‹T›         │op. on a single (T|int|long|double) operand that produces a result of the same type
(Double|Long|Int|)BinaryOperator‹T›         │op. upon two (T|int|long|double) operands and producing a result of the same type
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
                BiPredicate‹T,U›            │predicate (boolean-valued function) of two arguments
(|Int|Long|Double)Predicate‹T›              │predicate (boolean-valued function) of one (T|int|long|double) argument
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
(|Boolean|Int|Long|Double)Supplier(‹T›)     │supplier of (T|Boolean|Int|long|double) results
────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────
</pre>
</td>
<td colsep></td>
<td title>QA</td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>SonarQube</span>
</pre>
<pre xxxsmall zoom>
<span TODO xsmall>FbInfer</span>
<span xsmall>(Static analysis Java/C/...)</span>
-@[http://fbinfer.com/]
</pre>
<pre xxxsmall zoom>
<span TODO xsmall>FindBugs</span>
</pre>
<pre xxxsmall zoom>
<span xsmall>Junit</span>
- https://www.infoq.com/news/2018/01/VSCodeJunit
</pre>
<pre xxxsmall zoom>
<span xsmall>Boolean.parseBoolean BUG</span>
@[http://forums.java.net/jive/thread.jspa?threadID=55408]
</pre>
<pre xxxsmall zoom>
<span TODO xsmall>JDepend</span>
@[https://github.com/clarkware/jdepend]
https://htmlpreview.github.io/?https://github.com/clarkware/jdepend/blob/master/docs/JDepend.html

 What Is It?
  -----------
  JDepend traverses Java class and source file directories and
  generates*design-quality-metrics for each Java package*
 *in terms of its extensibility, reusability, and maintainability*
 *to effectively manage and control package dependencies.*
</pre>
</td>
<td>
<pre xxxsmall zoom {>
<span xsmall bgorange>[QA] Exceptions</span>
- (compiler) checked vs unchecked (Error, RuntimeException and their subclasses).</li>
- Checked: All except Error, RuntimeException and their subclasses</li>
- Error: Exceptional conditions external to the application.</li>
java.lang.Object
   java.lang.Throwable
       java.lang.Exception
           java.lang.RuntimeException (non-checked)
           java.lang.*Exception       (checked -A)
       java.lang.Error                (non-checked)

- The Throwable class is the superclass of all errors and exceptions in the
  Java language.  Only objects that are instances of this class (or one of
  its subclasses) are thrown by the JVM or can be thrown by the Java throw
  statement. Similarly, only this class or one of its subclasses can be the
  argument type in a catch clause. For the purposes of compile-time checking
  of exceptions, Throwable and any subclass of Throwable that is not also a
  subclass of either RuntimeException or Error are regarded as checked
  exceptions.</li>
- An Error is a subclass of Throwable that indicates serious problems that a
  reasonable application should not try to catch. Most such errors are
  abnormal conditions. The ThreadDeath error, though a "normal" condition, is
  also a subclass of Error because most applications should not try to catch it.
  </ul>

<span xsmall>[QA] Optional: Avoid Nulls</span>
<a href="http://files.zeroturnaround.com/pdf/zt_java8_best_practices.pdf">REF</a>
import java.util.Optional;
Optional<Sgtring> optional = Optional.ofNullable(a); // ← Create an optional
optional.map ( s -> "RebelLabs:" + s);               // ← Process the optional
optional.flatMap( s -> Optional.ofNullable(s));      // ← map a function that retunrs Optional
optional.ifPresent(System.out::println);             // ← run if the value is ther

optional.get();                                      // ← Alt 1: get the value or throw an exception
optional.orElse("Hello world!");                     // ← Alt 2: get the value or default

optional.filter( s -> s.startsWith("RebelLabs"));    // ← return empty Optional if not satisfied
</pre>
<pre xxxsmall zoom {>
<span xsmall>[QA] Eclipse Static Code Analasys</span>
Eclipse → Properties → Java → Compiler → Errors/Warnings → Null analysis:
  Null pointer access
  Potential null pointer access
  Redundant null check:
    x Include 'assert' in null analysis
    x Enable annotation-based null analysis
      Violation of null specification
      Conflict between null annotations an null inference
      Unchecked conversion from non-annotated type to @NonNull type
      Problems detected by pessimistic analysis fro free type variables
      Unsafe "@Nonnull" interpretation of the free type variable from library
      Redundant null anotation:
      "@NonNull" parametere not annotated in overriding method
      Missing "@NonNullByDefault" annotation on package
      x Use default annotations for null specifications (configure)
      x Inherit null annotations
      x Enable syntatic null analisys for fields
  x Treat above errors like fatal compile erros (make compiled code not executable)
</pre } >

<pre xxxsmall zoom>
<span xsmall>[QA]JSR Annotations</span>
<span xsmall> for*Defect Detection*</span>
https://stackoverflow.com/questions/1476757/jsr305-vs-jsr308-java-type-anotations-which-is-going-to-be-the-standard
</pre>

<pre xxxsmall zoom>
<a xsmall href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>[QA]Type Annotations</a>
----
@NonNull              compiler can determine cases where a      │ @(Un)Tainted          Identity types of data that should
                      code path might receive a null value,     │                       not be used together, such as remote
                      without ever having to debug a            │                       user input being used in system
                      NullPointerException. The compiler        │                       commands, or sensitive information in
                      just print a warning, but it              │                       log streams
                      continues to compile!!!                   │
                                                                │ @m                    Units of measure ensures that numbers
@ReadOnly             compiler will flag any attempt to         │                       used for measuring objects are used
                      change the object. This is similar to     │                       and compared correctly, or have
                      Collections.unmodifiableList, but         │                       undergone the proper unit
                      more general and verified at compile time.│                       conversion.
                                                                │
@Regex                Provides compile-time verification        │ @FunctionalInterface  indicates that the type declaration
                      that a String intended to be used as      │                       is intended to be a functional
                      a regular expression is a properly        │                       interface, as defined by the Java
                      formatted regular expression.             │                       Language Spec.

*Examples*:
Annotation
@NonNull List<String>                              ← A non-null list of Strings.
List<@NonNull String>                              ← A list of non-null Strings.
@Regex String validation = "(Java|JDK) [7,8]"      ← Check at compile time that this String is a valid regular expression.
private String getInput(String parameterName){     ← The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval =
      @Tainted request.getParameter(parameterName);
  return retval;
}

private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
  ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

  Process process = processBuilder.start();
}

</pre>

<pre xxxsmall zoom>
<span xsmall>[QA] Checker framework</span>
installation process:
- Download the Checker Framework distribution:
  https://checkerframework.org/checker-framework-2.1.8.zip.
- Configure your IDE, build system, or command shell to include the
  Checker Framework on the classpath. Choose the appropriate section of
  Chapter 30 for javac (Section 30.1), Ant (Section 30.2), Maven (Section 30.3),
  Gradle (Section 30.4), IntelliJ IDEA (Section 30.6), Eclipse (Section 30.7),
  or tIDE (Section 30.8).
  -  Option 1: Add directory .../checker-framework-2.1.8/checker/bin to your path,
     before any other directory that contains a javac executable.</li>

- The Nullness Checker supports several annotations that specify method behavior.
  These are declaration annotations, not type annotations:
  they apply to the method itself rather than to some particular type.
  - @RequiresNonNull (precondition): annotated method expects the specified
    variables to be non-null when the method is invoked.
  - @EnsuresNonNull (postcondition): the given expressions are non-null
    after the method returns
  - @EnsuresNonNullIf: if annotated method returns true|false, then the
     given expressions are non-null.

- The Lock Checker prevents certain concurrency errors by enforcing a
  locking discipline. A locking discipline indicates which locks must be
  held when a given operation occurs. You express the locking discipline by
  declaring a variable’s type to have the qualifier @GuardedBy("lockexpr").
  This indicates that the variable’s value may be dereferenced only if the
  given lock is held.
  - @GuardedBy(exprSet): If a variable x has type @GuardedBy("expr"), then a
  thread may dereference the value referred to by x only when the thread holds
  the lock that expr currently evaluates to. It can list multiple expressions,
  as in @GuardedBy({"expr1", "expr2"}), in which case the dereference is permitted
  only if the thread holds all the locks.

- Method pre-conditions and post-conditions:
  - @Holding(String[] locks): All the given lock expressions are held at the
    method call site.
  - @EnsuresLockHeld(String[] locks): The given lock expressions are locked upon
    method return if the method terminates successfully. This is useful for
    annotating a method that acquires a lock such as ReentrantLock.lock().
  - @EnsuresLockHeldIf(String[] locks, boolean result): If the annotated
    method returns the given boolean value (true or false), the given lock
    expressions are locked upon method return if the method terminates
    successfully. This is useful for annotating a method that conditionally
    acquires a lock. See Section 6.4.4 for examples.
- Side effect specifications:
  - @LockingFree: The method does not acquire or release locks, directly or
    indirectly. The method is not synchronized, it contains no synchronized blocks,
    it contains no calls to lock or unlock methods, and it contains no calls to
    methods that are not themselves @LockingFree.
    Since @SideEffectFree implies @LockingFree, if both are applicable then you
    only need to write @SideEffectFree.<br/>
  - @ReleasesNoLocks: The method maintains a strictly nondecreasing lock hold count
    on the current thread for any locks that were held prior to the method call.
    The method might acquire locks but then release them, or might acquire locks
    but not release them (in which case it should also be annotated with
    @EnsuresLockHeld or @EnsuresLockHeldIf).<br/>
    This is the default for methods being type-checked that have no
    @LockingFree, @MayReleaseLocks, @SideEffectFree, or @Pure annotation.

- The Format String Checker prevents use of incorrect format strings in format
  methods such as System.out.printf and String.format. Ej:
void printFloatAndInt(@Format({FLOAT, INT}) String fs) {
  System.out.printf(fs, 3.1415, 42);
}
  *examples errors that the I18n Format Checker detects at compile time*
  // Warning: the second argument is missing.
  MessageFormat.format("{0} {1}", 3.1415);
  // String argument cannot be formatted as Time type.
  MessageFormat.format("{0, time}", "my string");
  // Invalid format string: unknown format type: thyme.
  MessageFormat.format("{0, thyme}", new Date());
  // Invalid format string: missing the right brace.
  MessageFormat.format("{0", new Date());
  // Invalid format string: the argument index is not an integer.
  MessageFormat.format("{0.2, time}", new Date());
  // Invalid format string: "#.#.#" subformat is invalid.
  MessageFormat.format("{0, number, #.#.#}", 3.1415);

- The Property File Checker ensures that a property file or resource
  bundle (both of which act like maps from keys to values) is only
  accessed with valid keys. Accesses without a valid key either return
  null or a default value, which can lead to a NullPointerException or
  hard-to-trace behavior. The Property File Checker (Section 12.1) ensures
  that the used keys are found in the corresponding property file or
  resource bundle.
- One of the most prevalent GUI-related bugs is invalid UI update or
  invalid thread access: accessing the UI directly from a background thread.

  Most GUI frameworks (including Android, AWT, Swing, and SWT) create a single
  distinguished thread — the UI event thread — that handles all GUI events and
  updates. To keep the interface responsive, any expensive computation should
  be offloaded to background threads (also called worker threads). If a
  background thread accesses a UI element such as a JPanel (by calling a JPanel
  method or reading/writing a field of JPanel), the GUI framework raises an
  exception that terminates the program. To fix the bug, the background thread
  should send a request to the UI thread to perform the access on its behalf.

  It is difficult for a programmer to remember which methods may be called on
  which thread(s). The GUI Effect Checker solves this problem. The programmer
  annotates each method to indicate whether:

  - It accesses no UI elements (and may run on any thread); such a method is said to have the “safe effect”.
  - It may access UI elements (and must run on the UI thread); such a method is said to have the “UI effect”.

- The following kind of (physical) UNIT annotations are defined:
  @Acceleration @Angle @Area @Current @Length @Luminance @Mass
  @Speed @Substance @Temperature @Time

  For each kind of unit, the corresponding SI unit of measurement is defined:
  For @Acceleration: Meter Per Second Square @mPERs2
  For @Angle: Radians @radians, and the derived unit Degrees @degrees
  For @Area: the derived units square millimeters @mm2, square meters @m2, and square kilometers @km2
  For @Current: Ampere @A
  For @Length: Meters @m and the derived units millimeters @mm and kilometers @km
  For @Luminance: Candela @cd
  For @Mass: kilograms @kg and the derived unit grams @g
  For @Speed: meters per second @mPERs and kilometers per hour @kmPERh
  For @Substance: Mole @mol
  For @Temperature: Kelvin @K and the derived unit Celsius @C
  For @Time: seconds @s and the derived units minutes @min and hours @h

- The Signedness Checker guarantees that signed and unsigned values are not
  mixed together in a computation. In addition, it prohibits meaningless operations,
  such as division on an unsigned value.
  @Unsigned  @Signed
- A type alias or typedef is a type that shares the same representation as
  another type but is conceptually distinct from it. For example, some strings
  in your program may be street addresses; others may be passwords; and so on.
  You wish to indicate, for each string, which one it is, and to avoid mixing
  up the different types of strings. Likewise, you could distinguish integers
  that are offsets from those that are absolute values.
- SPARTA is a security toolset aimed at preventing malware from appearing in
  an app store. SPARTA provides an information-flow type-checker that is
  customized to Android but can also be applied to other domains. The SPARTA
  toolset is available from https://checkerframework.org/sparta/. The paper
  “Collaborative verification of information flow for a high-assurance app store
  ” appeared in CCS 2014.
  Example:
  @NonNull List˂String˃
  List˂@NonNull String>
  @Regex String validation = "(Java|JDK) [7,8]"

  private String getInput(String parameterName){
   final String retval = @Tainted request.getParameter(parameterName);
   return retval;
  }

  private void runCommand(@Untainted String… commands){
   // the previously tainted String must be validated before being passed in here.
   ProcessBuilder processBuilder = new ProcessBuilder(command);
   Process process = processBuilder.start();
  }
</pre>
</td>
</tr }>
</table>
<hr/>
<table>
<tr>
<td> Maven</td>
<td>
<pre xxxsmall zoom>
<b xsmall>GOAL</b>
- unit of work.
- A goal accepts configuration properties (parameters) to customize
  its run-time behavior
- Ex: Compiler:compile defines a set of parameters to specify target
  JDK version or switching on/off compiler optimizations
  - An <b>ordered list</b> of goals can be attached to a <b blue>lifecycle phase</b>.
Ex:
                               Executes next goals in order
mvn <b blue>package</b>      | resources:resources →
    ^Lifecicle  | compiler:compile →
                | resources:testResources →
                | compiler:testCompile →
                | surefire:test jar:jar

<b xsmall>SNAPSHOTS</b>
Q: What exactly is a Maven Snapshot and why do we need it?
A: <span xbig>A snapshot version is one that has not been released (<b orange>future release</b>)</span>.<br/>
   The idea is that <b>before</b> a "1.0" release is done, there exists
   a 1.0<b orange>-SNAPSHOT</b>. That version is what might become 1.0. It's
   basically <b orange>"1.0 under development"</b>. This might be close to a real
   1.0 release, or pretty far (right after the 0.9 release, for ex.)<br/>

   The difference between a "real" version and a snapshot version is
   that <b>snapshots might get updates</b>.  That means that downloading
   1.0-SNAPSHOT today might give a different file than downloading it
   yesterday or tomorrow.<br/>
   In contrast <b orange>Released versions are inmutables</b>:<br/>
   updates to "1.0.0" requires new version "1.0.1".<br/>
   <br/>
   Snapshot dependencies should only exist during development.
   <b>Released versions (i.e. no non-snapshot) should NEVER have a
   dependency on snapshots</b>

&lt;repository>
    ...
    &lt;snapshots>
        &lt;enabled>true&lt;/enabled>
        &lt;updatePolicy>
          always|daily(default)|
          "X"minutes|never
        &lt;/updatePolicy>
    &lt;/snapshots>
&lt;/repository>
</pre>
<pre xxxsmall zoom>
<span xsmall>Standard Lifecycles</span>
<b xsmall>CLEAN,DEFAULT,SITE</b>
| DEFAULT LIFECYCLE         | CLEAN LIFECYCLE | SITE LIFECYCLE
| process-resources         | TODO            | TODO
|  compile
|   process-classes
|    process-test-resources
|     test-compile
|      test
|       prepare-package
|        package
|         install
</pre>
  </ul>
</td>
<td>
<pre xxxsmall zoom { >
<span xsmall>Compiling &amp; Installing</span>
  Command                           Description
$ mvn clean                         Remove the (current_working_directory/)target folder
$ mvn compile                       (goal list: clean>compile)
$ mvn clean package                 Compiles and generates the (JAR/WAR/...) package
$ mvn clean install                 (goal list: clean>compile>test>package>install_local )
                                    # : skip tests
$ mvn clean install \               (goal list: clean>compile>     package>install_local )
  -Dmaven.test.skip=true
$ mvn clean deploy                  Compile... and installs into remote ("corporate") server
                                    ( clean>compile>test>package>install_local>install_pub )
-----------------------------------------------------------
Common options:
 –U                   Force library (download) update
 –P myProfileX        Execute profile myProfileX
 –o                   offline mode. Search deps in local repo.
 -Dgenerate.pom=true  Generates the pom locally for an artefact when installing
                      and compiling. Very useful to make offilne mode work properly.
-----------------------------------------------------------
help:active-profiles   : List (project|user|global)
                        active profile for the build
help:effective-pom     : Displays effective POM for
                          current build
help:effective-settings: Prints calculated settings
help:describe groupId artifactId: Describes plugin attributes



</pre } >
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>Dependency Manag.</span>
<span xsmall>mvn dependency:analyze</span>
list two things:
Dependencies used but not declared.
 If found in the parent pom, there is no
 problem when compiling, but must be
 included at runtime on the server.

Dependencies declared but not used for
the scope provided (compile, provided…).
They can be in the parent pom too.
Noneless, can be needed at runtime.

<span xsmall>mvn dependency:tree</span>

</pre>
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>POM BEST PRACTICES:</span>
- update pom dependency to latest version
   Ex. Update org.checkerframework.*:
   $ mvn versions:use-latest-versions -Dincludes="org.checkerframework:*"

REF: @[http://geertschuring.wordpress.com/2011/02/23/maven-best-practices/]
- Replace references like ${artifactId} or ${pom.artifactId} with new
 *${project.artifactId}*syntax. This syntax follows the XML document
  structure, making it easy to remember and predict the value that the
  reference will result in.

- Try to avoid using inherited properties. Developers can easily forget
  that a certain property is used by a child POM and change the value
  breaking the build in an unexpected place. Secondly, its quite annoying
  not to be able to easily lookup a property without having to find
  and examine the parent POM.

- Use the dependency management section of the parent pom to define
  all dependency versions, but do not set a scope here so that all
  dependencies have scope compile by default.

- Use properties to define the dependency versions. This way you can
  get an overview of all versions quickly.

- Use the pluginmanagement section of parent pom to define versions for
  *all* plugins that your build uses, even standard maven plugins like
  maven-compile-plugin and maven-source-plugin. This way your build will
  not suddenly behave differently when a new version of a plugin is released.

- When using a parent POM not located in the directory directly above
  the current POM define an empty relativePath element in your parent section.

- Use the dependency plugin to check your project for both unnecessary
  dependencies and undeclared-but-used-none-the-less dependencies.
  The goal is called ‘analyze’, so run the following command on the
  console: “mvn dependency:analyze

- Make sure the pom files contain all the repository references needed
  to download all dependencies. If you want to use a local repository
  instead of downloadin strait from the internet then use the maven
  settings file to define mirrors for the individual repositories that
  are defined in the poms.

- If you use Nexus, then do not create repository groups containing both
  hosted and proxied repositories. This will dramaticly reduce the
  responsiveness because Nexus will check the remote locations of the
  proxied repositories even if a hosted repository contains the requested
  artifact.
</pre>
<pre xxxsmall zoom>
<span xsmall>IC Best Practices</span>
<a TODO href="http://www.sonatype.com/people/2009/01/maven-continuous-integration-best-practices/">REF</a>
</pre>
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>New skeleton:</span>
mvn archetype:generate -DgroupId=my.groupId \
   -DartifactId=myArtifact \
   -DarchetypeArtifactId=maven-archetype-quickstart \
   -DinteractiveMode=false
</pre>
<pre xxxsmall zoom >
<span xsmall>Show ordered-by-phace list of goals executed:</span>
(Very useful to skip slow/non-important goals like doc, style-checks,...)
$ mvn fr.jcgay.maven.plugins:buildplan-maven-plugin:list \
  -Dbuildplan.tasks=install
</pre>
</td>
<td>
<pre xxxsmall zoom >
<span xsmall>Quick local install </span>
(bypass tests/style-checks/...)
 $ mvn resources:resources \
       compiler:compile \
       jar:jar \
       install:install
</pre>
<pre xxxsmall zoom>
<span xsmall>Add non-standard src dir</span>
- Useful when some tool auto-generates code outside the standard
  src/main/java diretory.
˂build˃
   ...
   ˂sourceDirectory˃
     src/main/generated_java
   ˂/sourceDirectory˃

   ˂testDirectory˃
     src/functionalTest/java
   ˂/testDirectory˃
˂/build˃
<span xsmall>add local jar dependency</span>
(vs. maven central repository):
˂dependency˃
  ˂groupId˃   ...˂/groupId˃
  ˂artifactId˃...˂/artifactId˃
  ˂version˃   ...˂/version˃
  ˂scope˃...˂/scope˃
  ˂systemPath˃/local/path/in/my/file/system/myjar.jar˂/systemPath˃
˂/dependency˃
</pre>

</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://maven.apache.org/pom.html">pom.xml</a>
<b>Reuse constants:</b>
${project.groupId}         ← Reuse project groupId in POM
${project.artifactId}      ← Reuse project artifactId in POM
${project.version}         ← Reuse project version in POM

<b>${my.property.name}</b> ← Reuse <a href="https://maven.apache.org/pom.html#Properties">properties</a> in POM


&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
<b>&lt;!-- project coordinates { --&gt;</b>
  &lt;groupId&gt;com.mycompany.mygroupid&lt;/groupId&gt;
  &lt;artifactId&gt;myArtifactId&lt;/artifactId&gt;
<b>&lt;!-- packaging value := jar|war|ear|pom|maven-plugin|ejb|rar|par|aar|apklib|... --&gt;</b>
  &lt;packaging&gt;jar&lt;/packaging&gt;
<b>&lt;!-- See <a href='https://semver.org/'>Semantic Versioning</a> for more info
   Version X.W.Z
    X MAJOR  Must differ for non-compatible API changes,
    W MINOR  W increase with new functionality backwards-compatible with X.(W-1) version
    Z PATCH  backwards-compatible bug fixes that does NOT add new functionality
--&gt;</b>
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; <b>&lt;!-- Remember: SNAPSHOT refers to development/future release --&gt;</b>
<b>&lt;!-- } --&gt;</b>
  &lt;name&gt;MyPackageDescriptiveName&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
  &lt;dependencies&gt;

<b>&lt;!-- Typical dependencies for in-memory data-collection handling { --&gt;</b>
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
        &lt;artifactId&gt;guava&lt;/artifactId&gt;
        &lt;version&gt;21.0&lt;/version&gt;
    &lt;/dependency&gt;
<b>&lt;!-- } --&gt;</b>

<b>&lt;!-- Typical dependencies for logging { --&gt;</b>
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;exclusions&gt;
            &lt;!-- Avoid problem:
            SLF4J: Class path contains multiple SLF4J bindings.
            SLF4J: Found binding in [jar:file:/home/azureuser/.m2/repository/org/slf4j/slf4j-jdk14/1.7.21/slf4j-jdk14-1.7.21.jar!/org/slf4j/impl/StaticLoggerBinder.class]
            SLF4J: Found binding in [jar:file:/home/azureuser/.m2/repository/ch/qos/logback/logback-classic/1.1.7/logback-classic-1.1.7.jar!/org/slf4j/impl/StaticLoggerBinder.class]
            --&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
        &lt;version&gt;1.1.7&lt;/version&gt;
    &lt;/dependency&gt;
<b>&lt;!-- } --&gt;</b>

<b>&lt;!-- Typical dependencies for JSON handling { --&gt;</b>
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;version&gt;2.8.8&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.9.0.pr3&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt;
        &lt;version&gt;2.8.8&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.web3j&lt;/groupId&gt;
        &lt;artifactId&gt;core&lt;/artifactId&gt;
        &lt;version&gt;3.2.0&lt;/version&gt;
    &lt;/dependency&gt;
<b>&lt;!-- } --&gt;</b>

<b>&lt;!-- test dependencies (Not included in production system) { --&gt;</b>
    <b>&lt;!-- Unit test dependencies { --&gt;</b>
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    <b>&lt;!-- } --&gt;</b>

    <b>&lt;!--  REST API (Functional) test dependencies { --&gt;</b>
    &lt;dependency&gt;
        &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
        &lt;artifactId&gt;scala-support&lt;/artifactId&gt;
        &lt;version&gt;3.0.6&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
        &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt;
        &lt;version&gt;3.0.6&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    <b>&lt;!-- } --&gt;</b>
<b>&lt; } --&gt;</b>


  &lt;/dependencies&gt;
&lt;/project&gt;
</pre>
</td>
</tr>
</table>
<table>
<tr>
<td>
<pre xxxsmall zoom { >
<span xsmall>set parent/child pom</span>
- Allows to inherit project dependency in children projects

.../parent/pom.xml              | .../parent/child1/pom.xml

&lt;modelVersion>4.0.0             | &lt;parent>
&lt;/modelVersion>                 |   &lt;groupId>...&lt;/groupId>
&lt;groupId>....&lt;/groupId>         |   &lt;artifactId>parent&lt;/artifactId>
&lt;artifactId>parent&lt;/artifactId> |   &lt;version>1&lt;/version>
&lt;version>0.1.0&lt;/version>        |   &lt;relativePath>
&lt;packaging>pom&lt;/packaging>      |      ../pom.xml&lt;/relativePath>
                                | &lt;/parent>
                                | &lt;dependecies>
&lt;modules>                       |   &lt;dependency>
  &lt;module>./child1&lt;/module>     |     &lt;groupId>...&lt;/groupId>
  &lt;module>./child2&lt;/module>     |     &lt;artifactId>...&lt;/artifactId>
&lt;/modules>                      |   &lt;/dependency>...
                                | &lt;/dependecies>
&lt;dependencyManagement>          |
  &lt;dependencies>                |
  &lt;dependency>                  |
    &lt;groupId>...&lt;/groupId>      |
    &lt;artifactId>...&lt;/artifactId>| no need to repeat version/scope
    &lt;version>X.Y.Z&lt;/version>    | in childs
    &lt;scope>compile&lt;/scope>    &lt;-| compile | provided
  &lt;/dependency>...              |
  &lt;dependencies>                |
&lt;/dependencyManagement>
</pre } >

<pre xxxsmall zoom>
<span xsmall>Reactor(POM aggregate vs inherit)</span>
 Maven supports both project inheritance (set a parent project) and aggregation (reactor mechanism).

MVN reactor allows to execute a goal (build,...) over a set of projects.
 The reactor will determine the build order according to defined dependencies on each pom.
MVN 2 improved reactor making it transparent to users. Anyway a plugin exists to customize the interaction
with the reactor: maven-reactor-plugin

If we launch compilation in a multi-module (like AbsisParentPom) and something goes wrong, we can always
re-start from the last failed module with the '--resume-from' option like:
 $ mvn --resume-from=com.myCompany.myModule:MyArtifact clean install -P myProfile -DskipTests=true
</pre>


</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="http://search.maven.org/">Artifact Search Engine</a>
</pre>
<pre xxxsmall zoom { >
<span xsmall>Install non-mavenized jar:</span>
mvn install:install-file -Dfile=&lt;path to local file&gt; -DgroupId=&lt;groupIf&gt; \
   -DartifactId=&lt;artifactId&gt; -Dversion=&lt;version&gt; -Dpackaging=&lt;packaging&gt;
</pre } >
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<span xsmall>Publish artifacts to MVN Central</span>
@[http://maven.apache.org/repository/guide-central-repository-upload.html]

<a href="http://central.sonatype.org/pages/requirements.html">Requirements</a>

NOTE: <b orange>Only releases allowed</b> (Not snapshots)
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="... http://.../maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.u1.training&lt;/groupId&gt;
  &lt;artifactId&gt;ossrh-demo&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;${project.groupId}:${project.artifactId}&lt;/name&gt;
  &lt;description&gt;demo deploy via OSSRH&lt;/description&gt;
  &lt;url&gt;http://github.com/u1/ossrh-demo&lt;/url&gt;

  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;

  &lt;developers&gt;
    &lt;developer&gt;
      &lt;name&gt;Manfred Moser&lt;/name&gt;
      &lt;email&gt;manfred@sonatype.com&lt;/email&gt;
      &lt;organization&gt;Sonatype&lt;/organization&gt;
      &lt;organizationUrl&gt;
        http://www.sonatype.com
      &lt;/organizationUrl&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;

  &lt;scm&gt;
    &lt;connection&gt;scm:git:git://github.com/u1/a.git&lt;/connection&gt;
    &lt;developerConnection&gt;
      scm:git:ssh://github.com:u1/a.git
    &lt;/developerConnection&gt;
    &lt;url&gt;http://github.com/u1/a/tree/master&lt;/url&gt;
   &lt;/scm&gt;

...

&lt;/project&gt;

- All projects except pom-packaging ones have to supply
  <b orange>JAR files containing Javadoc and sources</b>
- Supply Javadoc and Sources:  The naming convention is like:
  artifactId"-"version"-"classifier"."packaging"
  Ex:
  my-artifact-id-1.4.7-sources.jar
  my-artifact-id-1.4.7-javadoc.jar

- All files need to be signed with GPG/PGP including the
  matching *.asc file. E.g.
  example-application-1.4.7.pom          → example-application-1.4.7.pom.asc
  example-application-1.4.7.jar          → example-application-1.4.7.jar.asc
  example-application-1.4.7-sources.jar  → example-application-1.4.7-sources.jar.asc
  example-application-1.4.7-javadoc.jar  → example-application-1.4.7-javadoc.jar.asc
- we discourage the usage of &lt;repositories&gt; and
  &lt;pluginRepositories&gt; and instead publish any required
  components to the Central Repository
</pre>

<pre xxxsmall zoom>
<a xsmall href="http://central.sonatype.org/pages/working-with-pgp-signatures.html ">PGP Signature</a>
- Allow to validate artifact at download against a public key server
- PGP signatures is required for artifacts (all files except checksums),
  and matching public key uploaded to a server like
  <a href="http://pgp.mit.edu">http://pgp.mit.edu</a>
- <a TODO href="http://central.sonatype.org/pages/working-with-pgp-signatures.html#using-build-tools-for-signing">Build tool integration</a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Publish Best patterns</span>
- Use approved repository hosting location:
  <a href="http://www.apache.org/">Apache Software Foundation</a> (for all Apache projects)</li>
  <a href="http://www.fusesource.org/forge/">FuseSource Forge</a> (focused on FUSE related projects)</li>
  <a href="http://www.nuiton.org">Nuiton.org</a></li>

- User automatic publication in "forges" that provide hosting services</li>

- <a xsmall href="http://central.sonatype.org/pages/ossrh-guide.html">OSS Repository Hosting</a>
  - Approved repository provided by Sonatype for OSS Project that want to
    get their artifacts into Central Repository.</li>
  - Open an account as explained at
    @[http://central.sonatype.org/pages/ossrh-guide.html]
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Post-namespace registration</span>
(e-mail received after Namespace correct registration)
[ <a href="https://issues.sonatype.org/browse/OSSRH-39644?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel">Issue@Jira</a> ]
Thad Watson resolved OSSRH-39644: Resolution: Fixed

Configuration has been prepared, now you can:
* Deploy snapshot artifacts into repository
  <a href="https://oss.sonatype.org/content/repositories/snapshots">https://oss.sonatype.org/content/repositories/snapshots</a>

* Deploy release artifacts into the staging repository
  <a href="https://oss.sonatype.org/service/local/staging/deploy/maven2">https://oss.sonatype.org/service/local/staging/deploy/maven2</a>
* Promote staged artifacts into repository 'Releases'
* Download snapshot and release artifacts from group
  <a href="https://oss.sonatype.org/content/groups/public">https://oss.sonatype.org/content/groups/public</a>

* Download snapshot, release and staged artifacts from
  staging group
  <a href="https://oss.sonatype.org/content/groups/staging">https://oss.sonatype.org/content/groups/staging</a>
<b>please comment on this ticket when you promoted
   your first release, thanks</b>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://www.apache.org/dev/publishing-maven-artifacts.html#test-your-settings">Test settings</a>
- Make sure there are <strong>no dependencies on snapshots</strong> in the POMs to be released.
  However, the project you want to stage must be a SNAPSHOT version</li>
- Check that your POMs will not lose content when they are rewritten
  during the release process:</li>
- Verify that all <em>pom.xml</em> files have an SCM definition</li>
- Do a dryRun release: <code orange>mvn release:prepare -DdryRun=true</code>.<br/>
  Postcript: You may also wish to pass <code orange>-DautoVersionSubmodules=true</code>
  as this will save you time if your project is multi-moduled.
- Diff the original file <em>pom.xml</em> with the one called <em>pom.xml.tag</em> to
  see if the license or any other info has been removed. This has been known
  to happen if the starting <em>&lt;project&gt;</em> tag is <strong>not</strong> on a single
  line. The only things that should be different between these files are the
  <em>&lt;version&gt;</em> and <em>&lt;scm&gt;</em> elements. Any other changes you must
  backport yourself to the original <em>pom.xml</em> file and commit before
  proceeding with the release.</p>
</pre>
<pre xxxsmall zoom>
<a xsmall href="https://www.apache.org/dev/publishing-maven-artifacts.html#publish-snapshot">Deploy snapshot</a>
  mvn deploy
  ...
  [INFO] [deploy:deploy]
  [INFO] Retrieving previous build number from apache.snapshots.https
  ...
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://www.apache.org/dev/publishing-maven-artifacts.html#prepare-release">Prepare release</a>
mvn release:clean
mvn release:prepare # creates new tag in SVN, automatically checking in.
</pre>
<pre xxxsmall zoom>
<a xsmall href="https://www.apache.org/dev/publishing-maven-artifacts.html#stage-release-vote">Stage release for a vote</a>
mvn release:perform
# release will be automatically inserted in a temp staging dir
</pre>
<pre xxxsmall zoom>
<span TODO xsmall>Troubleshooting</span>
@[https://www.apache.org/dev/publishing-maven-artifacts.html#troubleshooting]
</pre>
</td>
</tr>
</table>
<hr/>
<table>
<tr>
<td title>What's new</td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>JAVA 13 (future)</span>
@[https://www.infoq.com/news/2019/06/java13-feature-freeze/]
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>JAVA 11(LTS) 2018/09</span>
@[https://www.journaldev.com/24601/java-11-features]
@[https://www.infoq.com/news/2018/09/java11-released]

new major features:
- Autocompilation(JEP 330). Next code will execute:
  $ java someFile.java

- New string methods:
  - isBlank(): true for Empty or only white spaces strings
  - lines()  : returns string[] that collects all substrings split by lines.
    System.out.println(
       "JD\nJD\nJD".str.lines().collect(Collectors.toList())
    );
  - strip()         : similar to trim() but unicode-aware
    stripLeading()
    stripTrailing()
  - repeat(int n)     : repeats string  n times.


- Local-Variable Syntax for Lambda Parameters (JEP 323)
  (var s1, var s2) -> s1 + s2
  - While it's possible to  just skip the type in the lambda
    it becomes a need when for annotations like @Nullable

- Nested Based Access Control
  (fix some issues when using (discouraged-)reflection.

- Dynamic Class-File Constants(JEP 309)
  - class-file format now extends support a new constant pool form:
    -*CONSTANT_Dynamic*, reduce the cost and disruption of developing
      new forms of materializable class-file constraints.

- Epsilon: A No-Op Garbage Collector(JEP 318):
  - Experimental
  - Unlike the JVM GC which is responsible for allocating memory
    and releasing it, Epsilon only allocates memory. Useful for:
    -*Extremely short lived jobs*
    - Performance testing
    - Memory pressure testing
    - VM interface testing
    - Last-drop latency improvements
    - Last-drop throughput improvements

- Remove the JavaEE and CORBA Modules(JEP 320):
  java.xml.ws, java.xml.bind, java.activation,
  java.xml.ws.annotation, java.corba, java.transaction,
  java.se.ee, jdk.xml.ws, jdk.xml.bind
 r*WARN*: EE modules contain the support for JAXB and SOAP,
          still in relatively widespread use.
        - Check carefully whether build scripts need to
          be modified.

- Flight Recorder(JEP 328)
  - profiling tool gathering diagnostics and profiling data
  - negligible performance overhead (˂1%):
    -*Can be used in production*

- HTTP Client (JEP 321)
  - HTTP/1.1,*HTTP/2 and WebSockets*
  - Designed to improve overall performance of
    sending requests by a client and receiving
    responses from the server.

- TLS 1.3

- Convenient Reading/Writing Strings to/from Files
  - readString()
  - writeString()
  Path path = Files*.writeString*(
    Files.createTempFile("test", ".txt"),
    "This was posted on JD");
  System.out.println(path);
  String s = Files*.readString*(path);
  System.out.println(s); //This was posted on JD

- ChaCha20,Poly1305 Crypto (JEP 329)
  - implemented in the SunJCE provider.

- Improve (string and array)Aarch64 processor Intrinsics(JEP 315)
  - implement also new intrinsics for
    (java.lang.Math) sin, cos, and log functions.

- ZGC:(JEP 333)
  - Scalable Low-Latency Garbage Collector
  - Experimental
  - low latency GC.
  - sub-10ms pause times, less than 15% perf.penalty.
- Deprecate Nashorn JS Engine(JEP 335)
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>JAVA 10 (2018/03)</span>
- Application Data-Class Sharing (JEP ???)
  -  extends existing Class-Data Sharing ("CDS")
     for allowing application classes to be placed in
     the shared archive in order to improve startup
     and footprint.
- Parallel Full GC for G1
  - improves G1 worst-case latencies
- Garbage Collector Interface
  - improves source code isolation of different GCs.
- Consolidate JDK Forest into a Single Repository
- Local-Variable Type Inference
  - declarations of local variables with initializers
  - introduces*var*
- Remove Native-Header Generator Tool (javah)
  superseded by superior functionality in javac.
- Thread-Local Handshakes:
  - Allows to execute a callback on threads without
    performing a global VM safepoint. Makes it both
    possible and cheap to stop individual threads and
    not just all threads or none.
- Time-Based Release Versioning
- Root Certificates, providing a default set of root
  CAs in the JDK.
- Heap Allocation on Alternative Memory Devices:
  - enables the HotSpot VM to allocate the Java object
    heap on an alternative memory device, such as an
    NV-DIMM, specified by the user.
- Experimental Java-Based JIT Compiler Graal:
  - Linux/x64 platform only

- Additional Unicode Language-Tag Extensions

- Removed Features and Options:
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>JAVA 9(2017/09)</span>
- Java Platform Module System:
  - based on Project Jigsaw
  - divides the JDK into a set of modules for
    combining at run, compile, or build time.
  - enabling understanding of dependencies across modules.
  - allows developers to more easily assemble and
    maintain sophisticated applications.
  - allows to scale down to smaller devices.
  - improves security and performance.
  - aspects include:
    - application packaging
    - JDK modularization
    - reorganizing source code into modules.
    - Build system is enhanced to compile modules
      and enforce module boundaries at build time.
  (Java 9 allows illegal reflective access to help migration)

- ahead-of-time (AoT) compilation (experimental)
  - improve startup time, with limited impact on peak performance.
-*REPL (read-eval-print loop)*
  - jShell: interactively evaluates statements "a la script".
    - tab completion
    - automatic addition of needed terminal semicolons.
    - jShell API for IDE integration.

  - jShell: interactively evaluates statements "a la script".

- Streams API Enhancements
  - Java 8 Stream API allows processing data declaratively
    while leveraging multicore architectures.
  - Java 9 adds methods to conditionally take and drop items
    from Stream, iterate over Stream elements, and create a
    stream from a nullable value while expanding the set of
    Java SE APIs that can serve as Streams sources.

- Code cache can be divided in Java 9
  - code cache can now be divided into segments to
    improve performance and allow extensions such as
    fine-grained locking resulting in improved sweep
    times
- (Datagram Transport Layer Security) DTLS security API
  - prevent eavesdropping, tampering, and message forgery
    in client/server communications.

- Java 9 deprecates and removes:
  - Applet API and appletviewer (alternative: Java Web Start)
  - Concurrent Mark Sweep (CMS) GC.
  - JVM TI (Tool Interface) hprof (Heap Profiling) agent,
    superseded in the JVM.
  - jhat tool, obsoleted by superior heap visualizers and analyzers.
</pre>
</td>
</tr>
</table>
<hr/>
Non-Classiffied<br/>
<pre xxxsmall zoom>
<span TODO xsmall>Java Value Types proposal</span>
@[https://www.infoq.com/news/2017/11/ValueTypesNov10]
</pre>
<pre xxxsmall zoom>
<span xsmall>About Completable Futures</span>
@[http://www.baeldung.com/java-completablefuture]
In asynchronous computation, actions are represented as callbacks, handling errors might occur at any step.

Java 5+: Future: Represent an asynchronous computation
Java 8+: CompletableFuture : Extends Future with methods to combine and handle errors
                            Extends the CompletionStage interface
                              - Contract for an asynchronous computation step that
                                can be combined with other steps.
                            About 50 different methods for composing, combining, executing async computation

Using CompletableFuture as a Simple Future (no-arg constructor)

In the example below we have a method that creates a CompletableFuture instance, then spins off some computation in another thread and returns the Future immediately.

  1  public Future<String> calculateAsync() throws InterruptedException {
  2      Future<String> result = new CompletableFuture<>();
  3
  4      Executors.newCachedThreadPool().submit(() -> {
  5          Thread.sleep(500);
  6          completableFuture.complete("Hello");
  7          return null;
  8      });
  9
  10     return completableFuture;
  11 }
  Line 2: Alternatively when the result of computation is known:
          Future<String> result = CompletableFuture.
             completedFuture("Hello");

  Line 6: Alternatively completableFuture.cancel(false);
  Line 5: any other mechanism can be used to compute


  1 Future<String> completableFuture = calculateAsync();
  2
  3 // ...
  4
  5 String result = completableFuture.get();
  6 assertEquals("Hello", result);

Line 5: get() blocks until .complete("...") is called in other thread
Line 5: get()can raise
           ExecutionException: error during computation
           InterruptedException: thread executing method interrupted

4. CompletableFuture with Encapsulated Computation Logic (runAsync -<<Runnable>>-, supplyAsync -<<Supplier>>-)

<<Supplier>>: generic functional interface with single method (zero arguments, returns value)

  1 CompletableFuture<String> future
  2   = CompletableFuture.supplyAsync(/*supplier lambda*/ () -> "Hello")
  3 .thenApply(/* "processor" lambda */ s -> s + " World") /* returns CompletableFuture */;
  4 .thenAccept(/*consumer lambda */
  5    s -> System.out.println("Computation returned: " + s));
    Line 4: Alternatively (ignrore result)
    .thenRun(/*Runnable lambda*/ () -> System.out.println("Computation finished."));

5. Combining Futures (monadic design pattern in functional languages)

  1 CompletableFuture<String> completableFuture
  2   = CompletableFuture.supplyAsync(() -> "Hello")
  3     .thenCompose(
  4           s -> CompletableFuture.supplyAsync(() -> s + " World"));
  4
  5 assertEquals("Hello World", completableFuture.get());

6. Execute two independent Futures and do something with their results

  1 CompletableFuture future
  2   = CompletableFuture.supplyAsync(() -> "Hello")
  3     .thenCombine(CompletableFuture.supplyAsync(
  4       () -> " World"), (s1, s2) -> s1 + s2));
  5
  6 assertEquals("Hello World", future.get());

(Simpler case - nothing to do with resulting value-)
  2   = CompletableFuture.supplyAsync(() -> "Hello")
  3   .thenAcceptBoth(CompletableFuture.supplyAsync(
  4      () -> " World"), (s1, s2) -> log(s1 + s2));

7. Running Multiple Futures in Parallel:  wait for all to execute and process combined results

  1  CompletableFuture<String> future1
  2    = CompletableFuture.supplyAsync(() -> "Hello");
  3  CompletableFuture<String> future2
  4    = CompletableFuture.supplyAsync(() -> "Beautiful");
  5  CompletableFuture<String> future3
  6    = CompletableFuture.supplyAsync(() -> "World");
  7
  8  CompletableFuture<Void> combinedFuture
  9    = CompletableFuture.allOf(future1, future2, future3);
  10
  11 // ...
  12
  13 combinedFuture.get();
  14
  15 String combined = Stream.of(future1, future2, future3)
  16   .map(CompletableFuture::join)
  17   .collect(Collectors.joining(" "));
  18 assertEquals("Hello Beautiful World", combined);

    Line 16: join() is similar to get, but throws unchecked exception if the Future does not complete normally.

8. Handling Errors

   Instead of catching an exception in a syntactic block, the CompletableFuture class allows you to handle it in a special handle method. This method receives two parameters: a result of a computation (if it finished successfully) and the exception thrown (if some computation step did not complete normally).



Capture async exception:

  1  CompletableFuture<String> completableFuture
  2    =  CompletableFuture.supplyAsync(() -> {
  3        ... if(errorDetected)
  4               throw new RuntimeException("Computation error!");
  6        return "Hello ";
  7    })}).handle((s, t) -> s != null ? s : "Hello, Stranger!");
  8
  9  assertEquals("Hello, Stranger!", completableFuture.get());
Alt:
  1  completableFuture.completeExceptionally(
  2    new RuntimeException("Calculation failed!"));
  3  ...
  4  completableFuture.get(); // ExecutionException

9. Async Methods
 - The methods without the Async postfix run next execution stage using a calling thread.

 - The Async method without the Executor argument runs a step using the common fork/join pool implementation of Executor
   that is accessed with the ForkJoinPool.commonPool() method.

 - The Async method with an Executor argument runs a step using the passed Executor.

 Ex.: process result of computation with a Function instance
  1 CompletableFuture<String> completableFuture
  2   = CompletableFuture.supplyAsync(() -> "Hello");
  3
  4 CompletableFuture<String> future = completableFuture
  5   .thenApplyAsync(s -> s + " World");
  6
  7 assertEquals("Hello World", future.get());

    Line 5: under the hood the application of a function is wrapped into a ForkJoinTask instance
    (for more information on the fork/join framework, see the article ?Guide to the Fork/Join Framework in Java?).
    This allows to parallelize your computation even more and use system resources more efficiently.
</pre>

<pre xxxsmall zoom>
<span xsmall>Annotation processors: JSR 269</span>
<span xsmall>(Dagger, Data Binding, Lombok, ...)</span>
</pre>


<pre xxxsmall zoom>
<span TODO xsmall>User-mode threads</span>
@[https://openjdk.java.net/jeps/353]
</pre>


<pre xxxsmall zoom>
<span TODO xsmall>Jooq</span>
<span xsmall> SQL made simple</span>
@[https://www.jooq.org/]
</pre>

<div>
<pre xxxsmall zoom>
<span xsmall>Tribe</span>
<span xsmall>reliable multicast</span>
@[http://tribe.ow2.org/]
- Unlike JGroups, Tribe only targets reliable multicast
 (no probabilistic delivery) and is optimized for cluster
 communications.
</pre>
<pre xxxsmall zoom>
<span xsmall>JGroups multicast</span>
@[http://www.jgroups.org/]
- toolkit for reliable multicast communication.
</pre>
<pre xxxsmall zoom>
<span xsmall>Spring Reactor</span>
<span xsmall>Spring-Async</span>
@[https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html]
@[https://spring.io/blog/2013/05/13/reactor-a-foundation-for-asynchronous-applications-on-the-jvm]
@[https://spring.io/guides/gs/async-method/]
"""Why Reactor when there's already RxJava2?
   RxJava2 is java 6 while for Reactor the Spring team decided to go all in
   and focus only on Java 8. This means that you can make use of all the new
   and fancy Java 8 features.

   If you are going to use Spring 5, Reactor might be the better option.

   But if you are happy with your RxJava2, there is no direct need to migrate to Reactor."""

</pre>
<pre xxxsmall zoom>
<span xsmall>Apache MINA</span>
<span xsmall>(Netty Alter.)</span>
Apache MINA vs Netty: https://www.youtube.com/watch?v=A2pWsxPWJuc

Apache MINA is a network application framework which helps users develop high
performance and high scalability network applications easily. It provides an
abstract event-driven asynchronous API over various transports such as TCP/IP
and UDP/IP via Java NIO.

Apache MINA is often called:
- NIO framework library,
- client server framework library, or
- a networking socket library

Apache MINA comes with many subprojects :
- Asyncweb : An HTTP server build on top of MINA asynchronous framework
- FtpServer : A FTP server
- SSHd : A Java library supporting the SSH protocol
- Vysper : An XMPP server
</pre>
</div>

<pre xxxsmall zoom>
<span TODO xsmall>Awaitility</span>
<span xsmall>Sync-the-Async</span>
<span xsmall>Java DSL</span>
</pre>

<pre xxxsmall zoom>
<span xsmall>OpenJPA</span>
https://openjpa.apache.org/
</pre>

<pre xxxsmall zoom>
<span TODO xsmall>Project Loom:</span>
Project Loom's mission is to make it easier to write, debug, profile and
maintain concurrent applications meeting today's requirements. Threads,
provided by Java from its first day, are a natural and convenient concurrency
construct (putting aside the separate question of communication among threads
) which is being supplanted by less convenient abstractions because their
current implementation as OS kernel threads is insufficient for meeting
modern demands, and wasteful in computing resources that are particularly
valuable in the cloud. Project Loom will introduce fibers as lightweight,
efficient threads managed by the Java Virtual Machine, that let developers
use the same simple abstraction but with better performance and lower
footprint. We want to make concurrency simple(r) again! A fiber is made of
two components — a continuation and a scheduler. As Java already has an
excellent scheduler in the form of ForkJoinPool, fibers will be implemented
by adding continuations to the JVM.

RELATED: http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf
</pre>

<pre xxxsmall zoom>
<span TODO xsmall>Google Guava</span>
</pre>

<pre xxxsmall zoom>
<span xsmall>JS transpilers</span>
- JSweet.org: Java to Javascript transpiler:

- http://teavm.org/
  TeaVM is an ahead-of-time compiler for Java bytecode that emits JavaScript
  and WebAssembly that runs in a browser. Its close relative is the well-known
  GWT. The main difference is that TeaVM does not require source code, only
  compiled class files. Moreover, the source code is not required to be Java,
  so TeaVM successfully compiles Kotlin and Scala.

- @[https://www.infoq.com/news/2019/05/j2cl-java-javascript-transpiler/?itm_source=infoq&itm_medium=popular_widget&itm_campaign=popular_content_list&itm_content=]
"https://en.wikipedia.org/wiki/Java_virtual_machine#Compilation_to_JavaScript
""Main JVM bytecode to JavaScript compilers are TeaVM,[20] the compiler
contained in Dragome Web SDK,[21] Bck2Brwsr,[22] and j2js-compiler.[23]"""
</pre>


<pre xxxsmall zoom>
<span xsmall TODO>Crypto.API(JCA)</a>
- See also:
  <a href="./BCFipsIn100.pdf">Bounce Castle FIPS JCA provider</a>
</pre>

<pre xxxsmall zoom>
<span xsmall>Google Guice</span>
<span xsmall>(Inver of Control)</span>
http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers
""" Although Spring provides many benefits, it was created in a pre-Java-5
world. The Guice framework takes DI to the next level, leveraging the full
power of Java typing, especially annotations and generics"""

https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger

Q: Why use/develop Guice, when You have Spring and Dagger? [closed]
  To my knowledge, Dagger does generate code, while Guice and Spring rely on
runtime processing, thus Dagger works faster, but requires more work on
programmer side. Because of performance edge it's good for mobile (Android)
 development.

However, when we are left with Guice and Spring, the latter has lots of
integrations. What's the point of developing/using Guice, if we can use
Spring Framework (that does basically same thing, but offers ex. easier
database access)?

Isn't Google trying to reinvent wheel by creating their own DI tool,
instead of using (and possibly contributing to) Spring Framework?

I am looking for decision tree, that guides through choosing DI tool.

A: t's important to realize that Dagger was created after Guice, by one
of Guice's creators ("Crazy Bob" Lee) after his move to Square:
  - Spring was originally released in October 2002.
  - Google originally publicly released Guice in March 2007.
  - JSR-330 formalized javax.inject annotations in October 2009,
    with heavy input from Google (Bob Lee), Spring, and other industry
    players.
  - Square originally released Dagger 1 publicly in May 2013.
  - Google originally released Dagger 2 publicly in April 2015.
  - Square marked Dagger 1 as deprecated 10 days ago,
    on September 15, 2016.

In that sense, the continued curation of Guice isn't "reinventing the
  wheel" so much as maintenance on a long-running and widely-consumed
 software package that thoroughly predates any version of Dagger. To
list and amend to the differences you have above:

    Spring is a relatively-heavyweight framework with a lot of
 integrations, an XML configuration language, and runtime/reflective
bindings. Applications already using Spring can use Spring's dependency
 injection framework with very little extra work.
    Guice is a relatively-lightweight framework with fewer integrations,
 Java instance configuration, and runtime/reflective bindings. With the
 use of Java bindings, you get compile-time type checking and IDE
 autocomplete integration.
    Dagger is a very lightweight framework with very few integrations,
 Java interface/annotation configuration, and compile-time code-generated
 bindings. The code generation aspect makes Dagger very performant
overall and particularly in resource-limited and mobile environments.
(Android's different VM makes reflection especially slow, so Dagger is
especially useful here.)
    All three of the above frameworks support JSR-330 (Dependency
Injection for Java) , so a well-crafted library or application can
 be mostly agnostic to the DI container used.
JSR-330:

Beyond that, keep an eye out for maintenance/deprecation patterns and
policies among any framework you use, but leave it up to the integrations and
performance you need alongside your team's technical judgment.
</pre>

<pre xxxsmall zoom>
<span TODO xsmall>GraalVM</span>
https://technology.amis.nl/2018/11/23/comparing-jvm-performance-zulu-openjdk-openjdk-oracle-jdk-graalvm-ce/
</pre>

<pre xxxsmall zoom>
<span xsmall>LMAX Disruptor</span>
<span xsmall>High Perf Inter-Thread</span>
<span xsmall> Messaging Library</span>
@[https://lmax-exchange.github.io/disruptor/]

See also:
@[https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications/]

@[https://www.infoq.com/news/2013/05/lmax-zing]
LMAX Exchange Getting Up To 50% Improvement in Latency From Azul's Zing JVM
Interesting points about GC tunning.
</pre>

<pre xxxsmall zoom>
<span TODO xsmall>Javalin</span>
<span xsmall>Simple Kotlin/Java</span>
<span xsmall>web framework </span>
@[https://javalin.io]
- Inspired by Javascript KOA.js framework

Ex: Declare server and API in the same place
  | import io.javalin.ApiBuilder.*;
  | import io.javalin.Javalin;
  |
  | Javalin app = Javalin.create(config -> {
  |     config.defaultContentType = "application/json";
  |     config.addStaticFiles("/public");
  |     config.enableCorsForAllOrigins();
  | }).routes(() -> {
  |     path("users", () -> {
  |         get(UserController::getAll);
  |         post(UserController::create);
  |         path(":user-id", () -> {
  |             get(UserController::getOne);
  |             patch(UserController::update);
  |             delete(UserController::delete);
  |         });
  |         ws("events", userController::webSocketEvents);
  |     });
  | }).start(port);
</pre>
<pre xxxsmall zoom>
<span xsmall>Snappy</span>
<span xsmall>Fast</span>
<span xsmall>de/compressor</span>
@[https://github.com/xerial/snappy-java]
- Java port of the snappy http://code.google.com/p/snappy/
</pre>

<pre xxxsmall zoom>
<span xsmall>JNR(JNI/UNIX friendly)</span>
( used by Netty and others...)
-@[https://github.com/jnr/jnr-ffi]
   load native libraries without writing JNI code by hand, or using tools such as SWIG.
-@[https://github.com/jnr/jnr-unixsocket]
   jnr-unixsocket: UNIX domain sockets (AF_UNIX) for Java
-@[https://github.com/jnr/jnr-enxio]
   Java Native Runtime Enhanced X-platform I/O
-@[https://github.com/jnr/jnr-x86asm]
   Pure java x86 and x86_64 assembler
-@[https://github.com/jnr/jnr-a64asm]
  AArch64 assembler for the Java Native Runtime 
-@[https://github.com/jnr/jnr-process]
  A ProcessBuilder look-alike based entirely on native POSIX APIs
-...
</pre>
</body>
</html>
<!--
__________________
https://dzone.com/articles/5-things-java-programmer-should-learn-in-2018
 - Java Performance Tuning
 - Profile Your Java application Once a Month
 - Java 9
 - Spring 5.0
 - Spring Security 5.0
___________________
Curso Java Concurrencia:
https://www.youtube.com/watch?v=8yD0hHAz3cs&list=PLw8RQJQ8K1ySGcb3ZP66peK4Za0LKf728&index=4
______________________
Inter-thread communications in Java at the speed of light
https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications#anch104956
_______________
https://github.com/OpenHFT/
   - Chronicle-Queue: Micro second messaging that stores everything to disk
   - Chronicle-Accelerate: HFT meets Blockchain in Java platform
         XCL is a new cryptocurrency project that, learning from the previous
         Blockchain implementations, aims to solve the issues limiting adoption
         by building an entirely new protocol that can scale to millions of
         transactions per second, delivering consistent sub-second latency. Our
         platform will leverage AI to control volatility and liquidity, require
         low energy and simplify compliance with integrated KYC and AML support.

         The XCL platform combines low latencies (sub millisecond), IoT transaction
         rates (millions/s), open source AI volatility controls and blockchain for
         transfer of value and exchange of value for virtual fiat and crypto
         currencies. This system could be extended to other asset classes such as
         securities and fixed income. It uses a federated services model and
         regionalized payment systems making it more scalable than a blockchain
         which requires global consensus.

         The platform makes use of Chronicle-Salt for encryption and Chronicle-Bytes.

         on Chronicle Core’s direct memory and OS system call access.



   - Chronicle-Logger: A sub microsecond java logger, supporting standard logging
                      APIs such as Slf &amp; Log4J

<table>
<tr>
<td>
  <a href="http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf">Disruptor</a>
  <a xsmall href="http://prisconapoli.github.io/development/2015/08/01/Disruptor">See also</a>
  <a href="https://lmax-exchange.github.io/disruptor/">lmax-exchange.github.com</a>

  <a href="https://dzone.com/articles/when-disruptor-not-good-fit">When Disruptor is not good fit</a>
</td>
</tr>
</td>
</tr>
</table>
_____________________
http://www.graalvm.org/
_____________________
  Concurrency:
  <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html">
    <code>java.util.concurrent.TimeUnit (v1.5+)</code></a>
  <ul xxxsmall zoom>
  <li>Represents time durations at a given unit of granularity and
    provides utility methods to convert across units, and to perform
    timing and delay operations in these units.  </li>
  <li>
<pre>
Enums: DAYS HOURS MICROSECONDS MILLISECONDS MINUTES NANOSECONDS SECONDS

  void      sleep(long timeout)
  void  timedJoin(Thread thread, long timeout)
  void   timedWait(Object obj, long timeout)
  ...
</pre>
  </li>
  </ul>
___________________________
Java Erasure: Type Erasure is a technique employed by the Java compiler to support the use of Generics.
https://developer.ibm.com/recipes/tutorials/java-language-type-erasure/
______________
Java Fibers: (fast threads for java)
  - http://docs.paralleluniverse.co/quasar/
______________________
Collections NavigationMap
______________________
Document error:
java.lang.UnsupportedClassVersionError: javax/money/Monetary has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0
__________________
Found in String.class source code: What's the @Contract annotation?
@NotNull @Contract(pure=true)
    public String[] split(String regex) {
___________________
https://dzone.com/articles/5-things-java-programmer-should-learn-in-2018
______________
about:reader?url=https%3A%2F%2Fdzone.com%2Farticles%2Fmicroprofile-5-things-you-need-to-know
__________________
https://stackoverflow.com/questions/29787684/java-8-stream-vs-collection-storage
____________________
https://www.logicbig.com/tutorials/core-java-tutorial/java-collections/java-collection-cheatsheet/images/choosing.png
______
https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html
From: https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map
NavigableMap is another useful extension - this is a SortedMap with
additional methods for finding entries by their ordered position in the key
set. So potentially this can remove the need for iterating in the first place
- you might be able to find the specific entry you are after using the
higherEntry, lowerEntry, ceilingEntry, or floorEntry methods. The
descendingMap method even gives you an explicit method of reversing the
traversal order.
_____________________
http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html
https://www.infoq.com/news/2018/06/open-source-jmc
_________________________
Pronghorn:
https://opensource.com/article/18/6/writing-applications-java-pronghorn
New (2018) Akka, Vert.X alternative using FIX "standard" finance network protocol for message passing
_____________________
https://hc.apache.org/httpcomponents-client-ga/index.html
______________
https://github.com/square/javapoet
____________________
https://readytalk.github.io/avian/  ("Embedded java")
Avian is a lightweight virtual machine and class library designed to provide a useful subset of Java’s features, suitable for building self-contained applications.

From Mike's blog: https://blog.plan99.net/kotlin-native-310ffac94af2
  | Enter Avian
  |
  |     “Avian is a lightweight virtual machine and class library designed to provide a useful subset of Java’s features, suitable for building self-contained applications.”
  |
  | So says the website. They aren’t joking. The example app demos use of the native UI toolkit on Windows, MacOS X or Linux. It’s not a trivial Hello World app at all, yet it’s a standalone self-contained binary that clocks in at only one megabyte. In contrast, “Hello World” in Go generates a binary that is 1.1mb in size, despite doing much less.
  |
  | Avian can get these tiny sizes because it’s fully focused on doing so: it implements optimisations and features the standard HotSpot JVM lacks, like the use of LZMA compression and ProGuard to strip the standard libraries. Yet it still provides a garbage collector and a JIT compiler.
____________________
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html
____________________
_______________________
[profiling]
https://www.infoq.com/news/2018/08/uber-jvm-profiler
__________________
MVN/Gradle Java Container Image Builder without Docker/Dockerfile
https://www.infoq.com/news/2018/08/jib?utm_source=infoq&utm_medium=popular_widget&utm_campaign=popular_content_list&utm_content=homepage
https://github.com/GoogleContainerTools/jib
_________
**** **** https://dzone.com/articles/a-quick-catch-up-before-java-11
_____________________
https://dzone.com/articles/stringvalueofobject-versus-objectstostringobject
__________________________________________
Spring  Batch:
FROM https://stackoverflow.com/questions/33188368/spring-batch-vs-quartz-jobs
Quartz is a scheduling framework. Like "execute something every hour or every last friday of the month"

Spring Batch is a framework that defines that "something" that will be executed. You can define a job, that consists of steps. Usually a step is something that consists of item reader, optional item processor and item writer, but you can define a custom stem. You can also tell Spring batch to commit on every 10 items and a lot of other stuff.  From Spring 2 , it can also schedule tasks
(See also https://jcp.org/en/jsr/detail?id=352, Batch applications for the Java Platform)
______________________
___________________________________________
____________________________
https://www.infoq.com/news/2018/10/springone-r2dbc
  Experimental Reactive Relational Database Connectivity Driver, R2DBC, Announced at SpringOne
____________________________
https://www.infoq.com/news/2018/10/the-road-to-micronaut-1.0
_____________________________
https://www.infoq.com/news/2018/10/codeone-java-keynote
_____________________________
- Nailgun is a client, protocol, and server for running Java programs
  from the command line without incurring the JVM startup overhead.
  https://github.com/facebook/nailgun
_____________________________
https://stackoverflow.com/questions/53452713/why-is-2-i-i-faster-than-2-i-i-in-java
_____________________________
JBehave:
 JBehave is a framework for Behaviour-Driven Development (BDD). BDD is an evolution of test-driven development (TDD) and acceptance-test driven design, and is intended to make these practices more accessible and intuitive to newcomers and experts alike. It shifts the vocabulary from being test-based to behaviour-based, and positions itself as a design philosophy.

1 Write story
Scenario: A trader is alerted of status
Given a stock and a threshold of 15.0
When stock is traded at 5.0
Then the alert status should be OFF
When stock is traded at 16.0
Then the alert status should be ON

2 Map to java

3 Configure Stories

4 Run Stories
___________________
https://www.infoq.com/presentations/effective-java-third-edition
______________________
https://www.oracle.com/technetwork/articles/java/nbneural-317387.html

Neuroph Studio is a Java neural network development environment built on top of the NetBeans Platform and Neuroph Framework. It is an IDE-like environment customized for neural network development. Neuroph Studio is a GUI that sits on top of Neuroph Framework. Neuroph Framework is a full-featured Java framework that provides classes for building neural networks.
_______________________
https://shipilev.net/jvm-anatomy-park/
https://shipilev.net/jvm-anatomy-park/22-safepoint-polls/
https://www.reddit.com/r/java/comments/acarqq/graalvm_in_2018/
_______________________
http://www.jutils.com/
 Lint4j ("Lint for Java") is a static Java source and byte code
analyzer that detects locking and threading issues, performance and
scalability problems, and checks complex contracts such as Java
serialization by performing type, data flow, and lock graph analysis.
__________________________
Profiling:
- 9 tools to help you with Java Performance Tuning
  https://blog.idrsolutions.com/2014/06/java-performance-tuning-tools/
- Ref: http://java.jiderhamn.se/2012/02/26/classloader-leaks-v-common-mistakes-and-known-offenders/
  Logging frameworks such as Apache Commons Logging (ACL) – formerly Jakarta Commons Logging (JCL) –
  log4j and java.util.logging (JUL) will cause classloader leaks under some circumstances.
  Apache Commons Logging will cause trouble if the logging framework is supplied outside of the
  web application, such as within the Application Server. In such a case, you need to add a bit of
   cleanup code to the ServletContextListener we’ve talked about:
  org.apache.commons.logging.LogFactory.release(Thread.currentThread().getContextClassLoader());
  or
  org.apache.commons.logging.LogFactory.release(this.getClass().getClassLoader());
  There is an article about this on the Apache Commons Wiki. It is also mentioned in the guide and FAQ.
____________________
Strings:
http://blog.jessitron.com/2012/03/strong-typing-in-java-religious.html
 Strong Typing in Java: a religious argument
Strings:
http://blog.jessitron.com/2012/03/strong-typing-in-java-religious.html
 Strong Typing in Java: a religious argument
________________________
http://2.bp.blogspot.com/-_bIW8fQby8o/UmaW1XZBVZI/AAAAAAAAAX4/xRmpOCwT24g/s640/Java-Topics.jpg
______________________
https://www.reddit.com/r/java/comments/akb76q/review_highperformance_java_persistence_video/?utm_source=reddit-android
_____________________
http://www.jenv.be/
___________________________
<a href="https://en.wikipedia.org/wiki/Java_Class_Library">Java Class Library (JCL, rt.jar)</a>
_____________________________
https://howtodoinjava.com/java7/nio/3-ways-to-read-files-using-java-nio/

________________________
https://www.infoq.com/news/2019/03/redhat-release-quarkus
___________________________
https://github.com/alibaba/dragonwell8/wiki/Alibaba-Dragonwell8-FAQ
_______________________
https://github.com/goldmansachs/obevo
Obevo is a database deployment tool that handles enterprise scale schemas and complexity
_______________________
https://github.com/goldmansachs/tablasco
Tablasco is a JUnit rule for comparing tables and Spark module for comparing large data sets
______________________
https://github.com/goldmansachs/reladomo
Reladomo is an enterprise grade object-relational mapping framework for Java.
______________________
https://www.infoq.com/articles/upgrading-java-8-to-12?itm_source=infoq&itm_medium=popular_widget&itm_campaign=popular_content_list&itm_content=
Upgrading from Java 8 to Java 12
______________________
Red Hat DevNation tech talk: Hibernate with Panache presented by Emmanuel Bernard.
Quarkus is Supersonic Subatomic Java. Not only does it boot extremely fast
and with low memory footprint, it also brings supersonic development time to
developers with live reload, fast tests and streamlined code for the 80% common usages.
One of the massively streamlined areas is data persistence. Write your Hibernate
and queries and repositories like never before. We call it Hibernate with Panache.
Come join Emmanuel Bernard to see Hibernate with Panache in action.

About the speaker:
Emmanuel is Java Champion, Distinguished Engineer and Chief Architect Data at
Red Hat (middleware). His work is Open Source. He is most well known for his
contributions and lead of the Hibernate projects as well as his contribution
to Java standards. His most recent endeavour is Quarkus (A Kubernetes Native
Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of
breed Java libraries and standards). He speaks regularly at various conferences
and JUGs, including JavaOne, Red Hat Summit and Devoxx. He hosts several
podcasts including Les Cast Codeurs. You can follow him on twitter at @emmanuelbernard.
______________________
Java Champions 2017
https://blogs.oracle.com/java/new-java-champions-in-2017
_____________________________
______________________
https://www.infoq.com/news/2019/06/apache-dubbo/
Apache Dubbo is an open source, remote procedure call framework based on Java. It was originally developed at Alibaba, open sourced in 2011, and entered the Apache Incubator in February 2018.
_______________________________

https://avaldes.com/?s=java+thread
____________________
https://docs.oracle.com/javase/6/docs/api/java/util/WeakHashMap.html
_______________________________



_______________________________
-->
