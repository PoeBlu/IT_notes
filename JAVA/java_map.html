<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>JAVA map(alpha)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table>
<tr {>
<td >
  Ext.Links
  <ul xxxsmall zoom > 
  <li> <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share">OpenJDK@Mercurial</a></li>
  <li> <a href="https://zeroturnaround.com/wp-content/uploads/2014/06/jtnt-mindmap.png">JAVA MIND-MAP</a></li>
  <li> <a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">(Active) Java JVM List</a> </li>
  </ul> 
  <b xsmall>JavaDoc</b>
<pre xxxsmall zoom {>
-----------------------+-------------------------------------+-------------------------+-------   Example
Tag& Parameter         | Usage                               | Applies to              | Since    /**
-----------------------+-------------------------------------+-------------------------+-------    * Short one line description.
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * Longer description. ... 
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |           * ...here.
                       | Max one per Class or Interface.     |                         |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * And even more explanations to follow 
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |           * in consecutive paragraphs
                       | has first existed.                  | Field, Method           |           *
-----------------------+-------------------------------------+-------------------------+-------    * @author John Bla
@seereference          | Provides a link to other element    | Class, Interface, Enum, |           * @param  variable Description ....
                       | of documentation.                   | Field, Method           |           * @return Description ....
-----------------------+-------------------------------------+-------------------------+-------    */
@paramname descrip     | Describes a method parameter.       | Method                  |          public int methodName (...) {
-----------------------+-------------------------------------+-------------------------+-------       // method body with a return statement
@return description    | Describes the return value.         | Method                  |          }
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |  
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | <code>{@literal}</code>.            | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
</pre }>
</td>
<td>
  <code><b orange>java.time</b>.*(1.8+)</code>
  <span xxsmall>("deprecates" java.util.(Date|Calendar|TimeZome)</span>
  <ul xxxsmall zoom >
  <li>All the classes are immutable and thread-safe</li>
  </ul>
  <span orange>Parsing DateTime Ex:</span>
<pre xxxsmall zoom { >
import java.time.Instant;
// Build from "now", current time
Instant timestamp = Instant.now(); 
        timestamp.plus(Duration.ofSeconds(10)).
// Build from ZonedDateTime "20170630010203.100Z",
Instant.from(ZonedDateTime.of(2017, 6, 30, 1, 2, 3, (int) TimeUnit.MILLISECONDS.toNanos(100), ZoneId.of("Z"))) 
// ZoneId: ZoneId.of("-02:00"), ZoneId.of("Z"), ZoneId.of("Asia/Tokyo")
// Build from ZonedDateTime String
Instant.from(ZonedDateTime.parse(sExpiresAt)) 
// Ej: 
timestamp.toString() // Produces something like similar to 2013-05-30T23:38:23.085Z
</pre } >
  <spam xsmall>Up to 1.8 compatibility:</span>
  <ul xxxsmall zoom >
  <li>Prior to the Java SE 8 release, the Java date and time mechanism was provided 
    by the  java.util.Date, java.util.Calendar, and java.util.TimeZone classes, as 
    well as their subclasses, such as java.util.GregorianCalendar.
  </li>
  <li>These classes had several drawbacks, including:<br/>
  - The Calendar class was not type safe.<br/>
  - classes were mutable, could NOT be used in multithreaded applications.<br/>
  - Bugs in application code were common due to the unusual numbering of 
    months and the lack of type safety.
  </li>
  <li>JDK 8+ add conversion methods between java.util and java.time:<br/>
  - Calendar.toInstant() converts the Calendar object to an Instant.
  - GregorianCalendar.toZonedDateTime() converts a GregorianCalendar instance 
    to a ZonedDateTime.<br/>
  - GregorianCalendar.from(ZonedDateTime) creates a GregorianCalendar object 
    using the default locale from a ZonedDateTime instance.<br/>
  - Date.from(Instant) creates a Date object from an Instant.<br/>
  - Date.toInstant() converts a Date object to an Instant.<br/>
  - TimeZone.toZoneId() converts a TimeZone object to a ZoneId.<br/>
  </li>
  </ul>
  Java 9 <a href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>REF</a>
  <ul xxxsmall zoom >
  <li>A number of parsing and formatting changes have been incorporated in Java 9 to 
bring the functionality closer to Unicode Locale Data Markup Language (LDML). 
These changes have been supervised by Stephen Colebourne, creator of the popular
 date-time library JodaTime, precursor of the new java.time component in Java 8.
Abiding by the Unicode standard will provide better interoperability with other
non-Java systems.</li>
  <li>
    LDML is the language used by the Unicode Common Locale Data Repository (CLDR), 
    a project of the Unicode Consortium to gather and store locale data from 
    different parts of the world, enabling application developers to better adapt 
    their programs to different cultures. Among other things, LDML deals with dates,
    times, and timezones, and more particularly with date formatting and parsing. 
    The following is an extract of new features coming in Java 9 that bring java.time 
    closer to the LDML specification:
    <ul>
      <li>JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as 
        specified in LDML, indicates a “Modified Julian day”; this is different from a 
        normal Julian day in the sense that a) it depends on local time, rather than GMT,
        and b) it demarcates days at midnight, as opposed to noon.</li>
      <li>JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML
        formats to indicate “generic non-location format”, e.g. “Pacific Time”, as 
        opposed to the “generic location format” with specifies a city, like 
        “Los Angeles Time”.</li>
      <li>JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML
        doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current 
        behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the
        total number of milliseconds elapsed in the day, with variable width, but 
        currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it
        will fail to parse any value that is further than 99 milliseconds in the day. 
        ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds 
        within the second, and nanoseconds within the day, respectively.</li>
      <li>JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit
        day-of-year value: similar to the previous problem, but with ‘D’ representing 
        days within a year. If one specifies “DD” as a pattern, it will fail to parse 
        “123” as the 123th day of the year.</li>
    </ul>
  </li>
  <li>As previously mentioned, a better alignment with the LDML will ease 
interoperability across systems, since there are multiple technologies that 
have adopted the LDML to some degree. Microsoft .NET uses LDML for general 
interexchange of locale data, and there are packages available for Node.js 
and Ruby, just to mention a few.</li>
  </ul>
</td>
<td >
    java.time. Package
<pre xxxsmall zoom {>
                   Description
-----------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and 
                   time using a time-zone.
-----------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
-----------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
-----------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system, 
                   such as 2007-12-03.
-----------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar 
                   system, such as 2007-12-03T10:15:30.
-----------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system, 
                   such as 10:15:30.
-----------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
-----------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 2007-12-03T10:15:30+01:00.
-----------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601 
                   calendar system, such as 10:15:30+01:00.
-----------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system,
                    such as '2 years, 3 months and 4 days'.
-----------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
-----------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12
-----------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03T10:15:30+01:00 Europe/Paris.
-----------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
-----------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
-----------------------------------------------------------------------------------


Enum               Description
-----------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
-----------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
-----------------------------------------------------------------------------------

Exception          Description
-----------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.
</pre } >
    java.text.MessageFormat:
<pre xxxsmall zoom {>
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale()) 
  
time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())
</pre }>
</td>
<td >
  ANNOTATIONS
  <ul xxxsmall zoom { >
    <li>
    Annotation types are a form of interface:
<pre {>
DECLARATION(interface is preceded by the @ sign)| USAGE
  @interface ClassPreamble {                    |   @ClassPreamble (
     String   author        ()              ;   |      author         = "John Doe"      ,
     String   date          ()              ;   |      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;   |      currentRev     = 6               ,
     String   lastModified  () default "N/A";   |      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";   |      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;   |      reviewers      = {"Alice", "Bob"}
  }                                             |   )
                                                | public class Generation3List extends Generation2List {
                                                |     // ...
                                                | }
</pre }> 
    </li>
    <li>
      Annotations can be applied to declarations of: classes, fields, methods, other program elements. 
      When used on a declaration, each annotation often appears, *by convention*, on its own line.<br/>
      As of the Java SE 8 release, annotations can also be applied to the use of types. A few examples of where
      types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses
<pre {>I
Ex. Class instance creation expression:      new @Interned MyObject();
----------------------------------------------------------------------
Ex. Type cast:                            |  myString = (@NonNull String) str;
------------------------------------------+---------------------------
Ex. implements clause:                    |  class UnmodifiableList<T> implements
                                          |        @Readonly List<@Readonly T> { ... }
------------------------------------------+---------------------------
Ex. thrown exception declaration:         |  void monitorTemperature() throws 
                                          |        @Critical TemperatureException { ... }
------------------------------------------+---------------------------
</pre }>I
    </li>
    <li>
Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, 
annotate the @ClassPreamble DECLARATION wih @Documented annotation like:
<pre {>
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
   ...
} 
</pre }>I
    </li>
    <li>
        predefined annotation types defined in java.lang:
        @Deprecated   @Override   @SuppressWarnings
<pre { >
Ex: @SuppressWarnings(value = "unchecked")
    void myMethod() { ... }
    @SuppressWarnings({"unchecked", "deprecation"})
    void myMethod() { ... }
</pre }>
    </li>
    <li>@SafeVarargs (Java ?+) when applied to a method or constructor, asserts that the code does not perform potentially 
    unsafe operations on its varargs parameter. Unchecked warnings relating to varargs usage are suppressed.
    </li>
  </ul>
</td>
<td>
  META-ANNOTATIONS
  <ul xxxsmall zoom >
  <li>Annotations that apply to other annotations.<br/>
    There are several meta-annotation types defined in java.lang.annotation.<br/>
    @Retention: specifies how the marked annotation is stored:
<pre { >
RetentionPolicy.SOURCE: annotation is retained only in source level and is ignored by the compiler.
RetentionPolicy.CLASS: annotation is retained by compiler, but ignored by the (JVM)
RetentionPolicy.RUNTIME: annotation is retained by the JVM, can be used@RunTime 
</pre }>
    @Documented: indicates that whenever the specified annotation is used those
    elements should be documented using the Javadoc tool. (By default, annotations
    are not included in Javadoc.)<br/>
    @Target meta-annotation marks another annotation to restrict what kind of 
    Java elements the annotation can be applied to.
<pre { >
ElementType.ANNOTATION_TYPE can be applied to an annotation type.
ElementType.CONSTRUCTOR can be applied to a constructor.
ElementType.FIELD can be applied to a field or property.
ElementType.LOCAL_VARIABLE can be applied to a local variable.
ElementType.METHOD can be applied to a method-level annotation.
ElementType.PACKAGE can be applied to a package declaration.
ElementType.PARAMETER can be applied to the parameters of a method.
ElementType.TYPE can be applied to any element of a class.
</pre }>
   @Inherited meta-annotation indicates that the annotation type can be inherited
   from the super class. (This is not true by default.) When the user queries 
   the annotation type and the class has no annotation for this type, the class'
   superclass is queried for the annotation type. This annotation applies only 
   to class declarations.<br/>
   @Repeatable annotation (Java 8+), indicates that the marked annotation can be applied more than once to the same declaration or type use.
Ref: http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html
<pre { >
Ex:
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
</pre }>
    </li>
    </ul>
  </td>
</tr }>
</table>

<table>
<tr {>
  <th colspan=12 header_delimit >Java NIO</th>
</tr }>
<tr {>
<td>
  NIO (1.4+) <a href="http://tutorials.jenkov.com/java-nio/buffers.html">REF</a>
  <ul xxxsmall>
  <li>
<pre>
 blocking IO    vs  NIO
 ---------------+---------------------------
 byte streams   |   <b blue>CHANNELS </b> (File|Datagram/*UDP*/|Socket/*TCP*/|ServerSocket/*listening TCP*/)Channel
 char streams   |   <b blue>BUFFERS  </b> (Byte|Char|Double|Float|Int|Long|Short|MappedByte)Buffer
                |   <b blue>SELECTORS</b>
                |   
                |   channelIn → (data) → buffer
                |   buffer   → (data) → channelOut
                | 
                |   Buffer attributes:
                |   ==================
                |   capacity: fixed size of memory block implementing the buffer
                |   
                |             | write mode         |  read mode
                |             +--------------------+----------------------------
                |   position  | starts at 0,       |  starts at 0 (after "flip")
                |             | increase at each   |  increase at each
                |   ----------+--------------------+----------------------------
                |             | element written    |  element read
                |   limit     | == capacity        |  == last written position
                |   ------------------------------------------------------------
                |   Buffer methods:
                |   ==================
                |   rewind()
                |   clear()/ compact()  
                |   mark() / reset()     "bookmark position" and return to "bookmark"
                |   equals() / compareTo() : (check only remaining to read bytes)
</pre>
  </li>
  <li>non-blocking: 
    <ol>
    <li>a thread request a channel the intention to read/write data into a buffer.</li>
    <li>While the channel moves data into/from the buffer, the thread continues another job</li>
    <li>When data is ready, the thread is notified</li>
    </ol>
  </li>
  <li>Channels, buffers and selectors from the "core". Other components like Pipe and FileLock 
    can be considered "utility classes" supporting the first three ones.</li>
  <li>Channels are read/write (old stream api are ussually one-way only)</li>
  <li>Using a Buffer to read and write data typically follows next sequence:
    <ol>
    <li>Write data into the Buffer</li>
    <li>Call buffer.flip(): switch writing/reading mode</li>
    <li>Read data out of the Buffer</li>
    <li><code>buffer.clear()   /*clear all buffer*/    </code> or<br/>
        <code>buffer.compact() /*clear only data read*/</code> </li>
    </ol>
<pre>
try (  /* try-with 1.7+ */
  RandomAccessFile <b green>aFile</b> = new RandomAccessFile("data/nio-data.txt", "rw") 
) throws IOException {
  FileChannel <b blue>inChannel</b> = <b green>aFile</b>.getChannel();
  
  ByteBuffer <b brown>buf</b> = ByteBuffer.<b>allocate</b>(48 /* capacity*/);
  
  int <b orange>bytesRead</b> = <b blue>inChannel</b>.read(<b brown>buf</b>); // <b brown>buf</b> now in write mode
  <b>while</b> (<b orange>bytesRead</b> != -1) <b>{</b>
    <b brown>buf</b>.flip();                            // <b brown>buf</b> now in read mode
    while(<b brown>buf</b>.hasRemaining()){
        // alt. read data directly, 1 byte at a time
        System.out.print((char) <b brown>buf</b>.get()); 
        // alt. read data in channel
        // anotherChannel.write(<b brown>buf</b>)
    }
  
    <b brown>buf</b>.clear(); //make buffer ready for writing
    <b orange>bytesRead</b> = <b blue>inChannel</b>.read(<b brown>buf</b>); // <b brown>buf</b> now in write mode
  <b>}</b>
}
</pre>    
  </li>
  <li>"selectors" objects monitor one+ channels for events (connection opened, data arrived, ..).
    Thus, a single thread can monitor multiple channels for data.  <b>Very handy in the app has
    many connections (Channels) open (many clients) but with low traffic on each connection.</b><br/>
    To use selectors:
    <ol>
    <li>Instantiate the selector </li>
    <li>Register one+ channels with it</li>
    </ol>
  </li>
  </ul>
</td>
<td>
  API tree
<pre xxxsmall zoom >
JDK 8
./java/nio/
           Bits ByteOrder CharBufferSpliterator
           ByteBufferAs(Char|Double|Float|...)Buffer(B|L|...
           (|Float|Double|StringChar)Buffer
           HeapByteBuffer Heap(Byte|Char|...)Buffer(R) HeapCharBuffer
           (Int|Long|...)Buffer
           (Mapped|Direct)ByteBuffer(R)
           Direct(Byte|Char|Double|...)Buffer

./java/nio/channels/
                    Channel Channels CompletionHandler FileLock MembershipKey Pipe Selector SelectionKey
                    Asynchronous(|Byte)Channel
                    AsynchronousChannelGroup
                    AsynchronousFileChannel
                    AsynchronousServerSocketChannel
                    AsynchronousSocketChannel
                    (Byte|Datagram|File|GatheringByte|Interruptible|Multicast|
                     Network|ReadableByte|ScatteringByte|SeekableByte|Selectable|
                     ServerSocket|Socket|WritableByte)Channel
                   /spi/Abstract(Interruptible|Selectable)Channel
                        Abstract(SelectionKey|Selector)
                        (AsynchronousChannel|Selector)Provider

./java/nio/charset/
                   Charset(|Decoder|Encoder) StandardCharsets
                   CoderResult CodingErrorAction
                  /spi/CharsetProvider

./java/nio/file/attribute/AclEntry(|Flag|Permission|Type)
                          (|AclFile|BasicFile|DosFile|File|
                            FileOwner|FileStore|PosixFile|
                            UserDefinedFile)AttributeView
                          (BasicFile|DosFile|PosixFile)Attributes
                          FileAttribute FileTime
                          GroupPrincipal
                          
                          UserPrincipal(LookupService)
./java/nio/file/
                AccessMode CopyMoveHelper CopyOption DirectoryStream Files
                LinkOption LinkPermission Path        PathMatcher        Paths
                SecureDirectoryStream
                File(Store|System|Systems|TreeIterator|TreeWalker|VisitOption|Visitor|VisitResult)
                SimpleFileVisitor
                OpenOption    Standard(Copy|Open)Option
                StandardWatchEventKinds
                StandardWatchEventKinds$StdWatchEventKind
                TempFileHelper
                Watchable      Watch(Event|Key|Service)
                spi/FileSystemProvider
                    FileTypeDetector
</pre>
</td>
<td>
  Scatter/Gather 
  <ul xxxsmall zoom>
  <li>A scattering read from a channel reads data into more than one buffer.
<pre>
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
ByteBuffer[] <b orange>bufferArray</b> = { header, body };
 <b blue>channel</b>channel.read(<b orange>bufferArray</b>); // <b blue>channel</b> → ( header, body)
</pre>
   scattering reads fill up one buffer before moving on to the next, that implies that
   it is <b>not suited for undefined size messages, but only for fixed size ones</b>
  </li>
  <li>A gathering-write to a channel writes data from more than one buffer into
      a single channel.
<pre>
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
ByteBuffer[] <b orange>bufferArray</b> = { header, body };
 <b blue>channel</b>channel.write(<b orange>bufferArray</b>); // ( header, body) → <b blue>channel</b>
</pre>
  </li>
  </ul>
  Channel to Channel
  <ul xxxsmall zoom>
  <li>If one the the channels is FileChannel data can be directly moved between channels
    using the FileChannel transferTo()/transferFrom().
</li>
  <li>FileChannel.transferFrom()
<pre>
RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"),
                   toFile = new RandomAccessFile(  "toFile.txt", "rw");
FileChannel      fromChannel = fromFile.getChannel(),
                   toChannel =   toFile.getChannel();

long count    = fromChannel.size();
toChannel.transferFrom(
     fromChannel,
     0, /* position where in the destination file to start writing */
     count /* how max bytes to transfer, fewer if source has fewer than count */);  
</pre>
  WARN: Some SocketChannel implementations may transfer only the data the SocketChannel 
      has ready in its internal buffer here and now
</li>
  <li>FileChannel.transferTo()
<pre>
RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"),
                   toFile = new RandomAccessFile(  "toFile.txt", "rw");
FileChannel      fromChannel = fromFile.getChannel(),
                   toChannel = toFile.getChannel();
long position = 0;
long count    = fromChannel.size();
fromChannel.transferTo(
    position,
    count,
    toChannel);
</pre>
  </li>
  </ul>
</td>
<td>
  Selectors
  <ul xxxsmall zoom>
  <li>A Selector can examine one+ Channels and determine which ones are ready for
       connect,accept,read,write</li>
  <li>This way a single thread can manage multiple channels, and thus multiple network connections</li>
  <li>Creating Selector and asigning channels:
<pre>
Selector <b orange>selector</b> = Selector.open();

// channel must be in non-blocking mode.

channel.configureBlocking(false);
<b>SelectionKey key</b> = channel.register(
            <b orange>selector</b>,
            SelectionKey.OP_READ | SelectionKey.OP_WRITE /* event "interest set" */);
/* Event can be one of:
 *    SelectionKey.OP_CONNECT   SelectionKey.OP_ACCEPT   SelectionKey.OP_READ   SelectionKey.OP_WRITE */
</pre>

</li>
  <li>FileChannel can NOT be switched into non-blocking mode and so they can NOT be used with
    selectors.</li>
  <li>A channel that "fires an event" is also said to be "ready" for that event.</li>
  <li>The SelectionKey object contains a few interesting properties appart of the associated Channel and Selector:
    <ul>
    <li>The interest set: You can read and write that interest set via the SelectionKey like this:
<pre>
int <b orange>interestSet</b> = selectionKey<b>.interestOps()</b>;
boolean isInterestedInAccept  = <b orange>interestSet</b> &amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = <b orange>interestSet</b> &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = <b orange>interestSet</b> &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = <b orange>interestSet</b> &amp; SelectionKey.OP_WRITE;    
</pre>
    </li>
    <li>The ready set of operations the channel is ready for, used after a selection, explained later:
<pre>
// Alt 1:
int readySet = selectionKey.readyOps();
boolean isAcceptable  = readySet &amp; SelectionKey.OP_ACCEPT;
boolean isConnectable = readySet &amp; SelectionKey.OP_CONNECT;
boolean isReadable    = readySet &amp; SelectionKey.OP_READ;
boolean isWritable    = readySet &amp; SelectionKey.OP_WRITE;
// Alt 2:
selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable()  ; selectionKey.isWritable();
</pre>
    </li>
    <li>An (optional) user attached object, handy way to recognize a given channel,
      or attaching extra information like the buffer/s used with the channel...
<pre>
selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
// attach an object at channel registration:
SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
</pre>
    </li>
    </ul>
  </li>
  </ul>

  Using selectors
  <ul xxxsmall zoom>
  <li>After registering  one+ channels with a selector you can call one of the select() methods
    returnin the channels "ready" for the events you are interested in (connect, accept, read or write).
<pre>
int select()                  // blocks until at least one channel is ready for the events you registered for
int select(long milliseconds) // select() blocking for max of milliseconds timeout 
int selectNow()               // doesn't block, returning any channels ready (if any).
^ The returned int indicates how many channels became ready since last time select() was called.
</pre>
  <li>Once select() indicates that one+ channels are ready, examine selected keys like:
<pre>
Set<SelectionKey> selectedKeys = selector.<b orange>selectedKeys()</b>;
Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(false) {
    } else if (key<b>.isAcceptable ()</b>) { ...// connection was accepted by ServerSocketChannel
    } else if (key<b>.isConnectable()</b>) { ...// connection was established with a remote server
    } else if (key<b>.isReadable   ()</b>) { ...// channel is ready for reading
    } else if (key<b>.isWritable   ()</b>) { ...// channel is ready for writing
    }
    keyIterator.remove();
}
</pre>
  </li>
  <li>The channel returned by the SelectionKey.channel() method should be cast to
      the proper channel (ServerSocketChannel, SocketChannel, ...)
  </li>
  <li>A thread blocked by a call to select() can be forced to leave the select() method,
    even if no channels are yet ready by having a different thread call the <code>Selector.<b>wakeup()</b></code>
    method on the Selector which the first thread has called select() on.
    The thread waiting inside select() will then return immediately.<br/>
    If a different thread calls wakeup() and no thread is currently blocked inside select(), 
    the next thread that calls select() will "wake up" immediately.
  </li>
  <li>Selector.close(): must be called after finishing ussage, invalidating all SelectionKey
      instances registered with this Selector. The channels themselves are not closed.
  </li>
  </ul>
</td>
<td colsep> </td>
<td>
  <span xsmall>FileChannel</span>
  <ul xxxsmall zoom>
  <li>A Java NIO FileChannel is a channel that is connected to a file allowing to
      read data from  and write data to a file.</li>
  </li>A FileChannel cannot be set into non-blocking mode. It always runs in blocking mode<li>
  <li>Reading from FileChannel (Writting to buffer):
<pre>
/* You cannot open a FileChannel directly, 
 * first you obtain a FileChannel via an (Input|Output)Stream or a RandomAccessFile
 */
RandomAccessFile aFile     = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel      inChannel = aFile.getChannel();

// Reading Data: call one of the read() methods
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel<b orange>.read</b>(buf); // The return tells how many bytes were witten: -1 → end-of-file reached
channel.close();    
</pre>
  <li>Writing to a FileChannel (reading from buffer)
<pre>
String newData = "......" + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip(); // change buffer from write to read
<b>while(buf.hasRemaining()) {</b> channel<b orange>.write</b>(buf); <b>}</b>
channel.close();    
</pre>
  </li>
  <li>FileChannel Position
<pre>
long pos = fileChannel.position(); // obtain current position
fileChannel.position(pos +123); // change position

- If you set the position after the end of the file, and try to read from the channel, you will get -1
- If you set the position after the end of the file, and write to the channel, the file will be expanded 
  to fit the position and written data. This may result in a "file hole", where the physical file on 
  the disk has gaps in the written data.
</pre>
  </li>
  <li>FileChannel Size
<pre>
long fileSize = fileChannel.size(); // returns size of the file connected to the channel.
</pre>
  <li>FileChannel Truncate (cut file to a given length)
<pre>
fileChannel.truncate(1024);
</pre>
  </li>
  <li>FileChannel Force (flushes all unwritten data from the channel and OS cache to the disk)
<pre>
channel.force(true /* flush also file meta-data like permissions....*/);
</pre>
  </li>
  </ul>
</td>
<td>
  <span xsmall>SocketChannel</span>
<pre xxxsmall zoom>
There are two ways a SocketChannel can be created:

// Opening a SocketChannel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

// Reading (writing to buffer) 
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf); // If -1 is returned, the end-of-stream is reached (connection is closed)

// Writing to a SocketChannel
String newData = "..." + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) { channel.write(buf); }

socketChannel.close();    
</pre>

  <span xsmall>Non-blocking Mode</span>
  <ul xxxsmall zoom>
  <li><code>socketChannel<b>.configureBlocking(false)</b>;</code></li>
  <li>Calls connect(), read() and write() will not block</li>
  <li>In non-blocking mode connect() calls may return before the connection is established.
      To determine whether the connection is established use  finishConnect() like this:
<pre>
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

while(! socketChannel.finishConnect() ){
    //wait, or do something else...    
}
</pre>
  </li>
  <li>non-blocking works much better with Selector's</li>
  </ul>
</pre>
  <span xsmall>ServerSocketChannel</span>
<pre xxxsmall zoom>
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept(); // in blocking mode waits until incoming connection arrives
    if(socketChannel != null /* always false in blocking mode */){
        //do something with socketChannel...
    }

    //do something with socketChannel...
}

serverSocketChannel.close()
</pre>
</td>
<td>
  <span xsmall>NonBlocking Server</span> <a xsmall href="http://tutorials.jenkov.com/java-nio/non-blocking-server.html">REF</a>
<a xsmall href="https://github.com/jjenkov/java-nio-server">GitHub</a>
  <ul xxxsmall zoom>
  <li>The ideas described in this tutorial are designed around Java NIO. However, I believe that the ideas can be reused in other languages as long as they have some kind of Selector-like construct.  As far as I know, such constructs are provided by the underlying OS, so there is a good chance that you can get access to this in other languages too.</li>
  <li>Non-blocking IO Pipelines:
<pre>
channel → selector → component → channel
</pre>


  </li>
  <li>
  </li>
  <li>
  </li>
  <li>
  </li>
  <li>
  </li>
  </ul>


<!--

A non-blocking IO pipeline does not need to both read and write data. Some pipelines may only read data, and some pipelines may only write data.

The above diagram only shows a single component. A non-blocking IO pipeline may have more than one component process incoming data. The length of a non-blocking IO pipeline depends on what the pipeline needs to do.

A non-blocking IO pipeline may also be reading from multiple Channels at the same time. For instance, reading data from multiple SocketChannels.

The flow of control in the above diagram is also simplified. It is the component that initiates the reading of data from the Channel via the Selector. It is not the Channel that pushes the data into the Selector and from there into the component, even if that is what the above diagram suggests.
Non-blocking vs. Blocking IO Pipelines

The biggest difference between a non-blocking and a blocking IO pipeline is how data is read from the underlying Channel (socket or file).

IO pipelines typically read data from some stream (from a socket or file) and split that data into coherent messages. This is similar to breaking a stream of data into tokens for parsing using a tokenizer. Instead, you break the stream of data into bigger messages. I will call the component breaking the stream into messages for a Message Reader. Here is an illustration of a Message Reader breaking a stream into messages:
A Message Reader breaking a stream into messages.

A blocking IO pipeline can use an InputStream-like interface where one byte at a time can be read from the underlying Channel, and where the InputStream-like interface blocks until there is data ready to read. This results in a blocking Message Reader implementation.

Using a blocking IO interface to a stream simplifies the implementation of a Message Reader a lot. A blocking Message Reader never has to handle situations where no data was read from the stream, or where only a partial message was read from the stream and message parsing needs to be resumed later.

Similarly, a blocking Message Writer (a component that writes messages to a stream) never has to handle the situation where only part of a message was written, and where message writing has to be resumed later.
Blocking IO Pipeline Drawbacks

While a blocking Message Reader is easier to implement, it has the unfortunate drawback of requiring a separate thread for each stream that needs to be split into messages. The reason this is necessary is that the IO interface of each stream blocks until there is some data to read from it. That means that a single thread cannot attempt to read from one stream, and if there is no data, read from another stream. As soon as a thread attempts to read data from a stream, the thread blocks until there is actually some data to read.

If the IO pipeline is part of a server which has to handle lots of concurrent connections, the server will need one thread per active ingoing connection. This may not be a problem if the server only has a few hundred concurrent connections at any time. But, if the server has millions of concurrent connections, this type of design does not scale so well. Each thread will take between 320K (32 bit JVM) and 1024K (64 bit JVM) memory for its stack. So, 1.000.000 threads will take 1 TB memory! And that is before the server has used any memory for processing the incoming messages (e.g. memory allocated for objects used during message processing).

To keep the number of threads down, many servers use a design where the server keeps a pool of threads (e.g. 100) which reads messages from the inbound connections one at a time. The inbound connections are kept in a queue, and the threads process messages from each inbound connection in the sequence the inbound connections are put into the queue. This design is illustrated here:
A pool of threads reading messages from streams in a queue.

However, this design requires that the inbound connections send data reasonably often. If the inbound connections may be inactive for longer periods, a high number of inactive connections may actually block all the threads in the thread pool. That means that the server becomes slow to respond or even unresponsive.

Some server designs try to mitigate this problem by having some elasticity in the number of threads in the thread pool. For instance, if the thread pool runs out of threads, the thread pool might start more threads to handle the load. This solution means that it takes a higher number of slow connections to make the server unresponsive. But remember, there is still an upper limit to how many threads you can have running. So, this would not scale well with 1.000.000 slow connections.
Basic Non-blocking IO Pipeline Design

A non-blocking IO pipeline can use a single thread to read messages from multiple streams. This requires that the streams can be switched to non-blocking mode. When in non-blocking mode, a stream may return 0 or more bytes when you attempt to read data from it. The 0 bytes is returned if the stream has no data to read. The 1+ bytes are returned when the stream actually has some data to read.

To avoid checking streams that has 0 bytes to read we use a Java NIO Selector. One or more SelectableChannel instances can be registered with a Selector. When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read. This design is illustrated here:
A component selecting channels with data to read.
Reading Partial Messages

When we read a block of data from a SelectableChannel we do not know if that data block contains less or more than a message. A data block could potentially contain a partial message (less than a message), a full message, or more than a message, for instance 1.5 or 2.5 messsages. The various partial message possibilities are illustrated here:
A data block can contain less than or more than a single message.

There are two challenges in handling partial messages:

    Detecting if you have a full message in the data block.
    What to do with partial messages until the rest of the message arrives.

Detecting full messages requires that the Message Reader looks at the data in the data block to see if the data contains at least one full message. If the data block contains one or more full messages, these messages can be sent down the pipeline for processing. The process of looking for full messages will be repeated a lot, so this process has to be as fast as possible.

Whenever there is a partial message in a data block, either by itself or after one or more full messages, that partial message needs to be stored until the rest of that message arrives from the Channel.

Both detecting full messages and storing partial messages is the responsibility of the Message Reader. To avoid mixing message data from different Channel instances we will use one Message Reader per Channel. The design looks like this:
A component reading messages via a Message Reader.

After retrieving a Channel instance which has data to read from the Selector, the the Message Reader associated with that Channel reads data and attempt to break it it into messages. If that results in any full messages being read, these message can be passed down the read pipeline to whatever component needs to process them.

A Message Reader is of course protocol specific. A Message Reader needs to know the message format of the messages it is trying to read. If our server implementation is to be reusable across protocols, it needs to be able to have the Message Reader implementation plugged in - possibly by accepting a Message Reader factory as configuration parameter somehow.
Storing Partial Messages

Now that we have established that it is the responsibility of the Message Reader to store partial messages until a full message has been received, we need to figure out how this partial message storage should be implemented.

There are two design considerations we should take into consideration:

    We want to copy message data around as little as possible. The more copying, the lower performance.
    We want full messages to be stored in consecutive byte sequences to make parsing messages easier.

A Buffer Per Message Reader

Obviously the partial messages need to be stored in some kind of buffer. The straightforward implementation would be to simply have one buffer internally in each Message Reader. However, how big should that buffer be? It would need to be big enough to be able to store even the biggest allowed messages. So, if the biggest allowed message is 1MB, then the internal buffer in each Message Reader would need to be at least 1MB.

Using 1MB per connection doesn't really work when we reach millions of connections. 1.000.000 x 1MB is still 1TB memory! And what if the maximum message size is 16MB? Or 128MB ?
Resizable Buffers

Another option would be to implement a resizable buffer for use inside each Message Reader. A resizable buffer will start small, and if a message gets too big for the buffer, the buffer is expanded. This way each connection will not necessarily require an e.g. 1MB buffer. Each connection only takes as much memory as they need to hold the next message.

There are several ways to implement a resizable buffer. All of them have advantages and disadvantages, so I will discuss them all in the following sections.
Resize by Copy

The first way to implement a resizable buffer is to start with a small buffer of e.g. 4KB. If a message cannot fit into the 4KB buffer, a larger buffer of e.g. 8KB could be allocated, and the data from the 4KB buffer copied into the bigger buffer.

The advantage of the resize-by-copy buffer implementation is that all data for a message is kept together in a single consecutive byte array. This makes parsing the message much easier.

The disadvantage of the resize-by-copy buffer implementation is that it will lead to a lot of data copying for bigger messages.

To reduce data copying you could analyze the size of the messages flowing through your system to find some buffer sizes that would reduce the amount of copying. For instance, you might see that most messages are less than 4KB because they only contain very small requests / responses. That means that the first buffer size should be 4KB.

Then you might see that if a message is larger than 4KB it is often because it contains a file. You might then notice that most of the files flowing through the system is less than 128KB. Then it makes sense to make the second buffer size 128KB.

Finally you might see that once a message is above 128KB there is no real pattern in how large the message is, so perhaps the final buffer size should just be the maximum message size.

With these 3 buffer sizes based on the size of messages flowing through your system, you will have reduced data copying somewhat. Messages below 4KB will never be copied. For 1.000.000 concurrent connections that results in 1.000.000 x 4KB = 4GB which is possible in most servers today (2015). Messages between 4KB and 128KB will get copied once, and only 4KB data will need to be copied into the 128KB buffer. Messages between 128KB and maximum message size will be copied twice. First time 4KB will get copied, second time 128KB will get copied, so a total of 132KB copying for the biggest messages. Assuming that there are not that many messages above 128KB this might be acceptable.

Once a message has been fully processed the allocated memory should be freed again. That way the next message received from the same connection starts with the smallest buffer size again. This is necessary to make sure that the memory can be shared more efficiently between connections. Most likely not all connections will need big buffers at the same time.

I have a complete tutorial about how to implement such a memory buffer that supports resizable arrays here: Resizable Arrays . The tutorial also contains a link to a GitHub repository with code showing a working implementation.
Resize by Append

Another way to resize a buffer is to make the buffer consist of multiple arrays. When you need to resize the buffer you simply allocate another byte array and write the data into that.

There are two ways to grow such a buffer. One way is to allocate separate byte arrays and keep a list of these byte arrays. Another way is to allocate slices of a larger, shared byte array, and then keep a list of the slices allocated to the buffer. Personally, I feel the slices approach is slightly better, but the difference is small.

The advantage of growing a buffer by appending separate arrays or slices to it is that no data needs to be copied during writing. All data can be copied directly from a socket (Channel) directly into an array or slice.

The disadvantage of growing a buffer this way is that the data is not stored in a single, consecutive array. This makes message parsing harder, since the parsers need to look out for both the end of every individual array and the end of all arrays at the same time. Since you need to look for the end of a message in the written data, this model is not too easy to work with.
TLV Encoded Messages

Some protocol message formats are encoded using a TLV format (Type, Length, Value). That means, that when a message arrives the total length of the message is stored in the beginning of the message. That way you know immediately how much memory to allocate for the whole message.

TLV encodings make memory management much easier. You know immediately how much memory to allocate for the message. No memory is wasted at the end of a buffer that is only partially used.

One disadvantage of TLV encodings is that you allocate all the memory for a message before all the data of the message has arrived. A few, slow connections sending big messages can thus allocate all the memory you have available, making your server unresponsive.

A workaround for this problem would be to use a message format that contains multiple TLV fields inside. Thus, memory is allocated for each field, not for the whole message, and memory is only allocated as the fields arrive. Still, a large field can have the same effect on your memory management as a large message.

Another workaround is to time out messages which have not been received within e.g. 10-15 seconds. This can make your server recover from a coincidental, simultaneous arrival of many big messages, but it will still make the server unresponsive for a while. Additionally, an intentional DoS (Denial of Service) attack can still result in full allocation of the memory for your server.

TLV encodings exist in different variations. Exactly how many bytes is used so specify the type and length of a field depends on each individual TLV encoding. There are also TLV encodings that put the length of the field first, then the type, and then the value (an LTV encoding). While the sequence of the fields is different, it is still a TLV variation.

The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 is such a terrible protocol. That is one of the problems they are trying to fix in HTTP 2.0 where data is transported in LTV encoded frames. This is also why we have designed our own network protocol for our VStack.co project that uses a TLV encoding.
Writing Partial Messages

In a non-blocking IO pipeline writing data is also a challenge. When you call write(ByteBuffer) on a Channel in non-blocking mode there is no guarantee about how many of the bytes in the ByteBuffer is being written. The write(ByteBuffer) method returns how many bytes were written, so it is possible to keep track of the number of written bytes. And that is the challenge: Keeping track of partially written messages so that in the end all bytes of a message have been sent.

To manage the writing of partial messages to a Channel we will create a Message Writer. Just like with the Message Reader, we will need a Message Writer per Channel we write messages to. Inside each Message Writer we keep track of exactly how many bytes have been written of the message it is currently writing.

In case more messages arrives for a Message Writer than it can write directly out to the Channel, the messages needs to be queued up internally in the Message Writer. The Message Writer then writes the messages as fast as it can to the Channel.

Here is a diagram showing how the partial message writing is designed so far:
A component sending messages to a Message Writer which queue them up and send them to a Channel.

For the Message Writer to be able to send messages that were only partially sent earlier, the Message Writer needs to be called from time to time, so it can send more data.

If you have a lot of connections you will have a lot of Message Writer instances. Checking e.g. a million Message Writer instances to see if they can write any data is slow. First of all, many of the Message Writer instance many not have any messages to send. We don't want to check those Message Writer instances. Second, not all Channel instances may be ready to write data to. We don't want to waste time trying to write data to a Channel that cannot accept any data anyways.

To check if a Channel is ready for writing you can register the channel with a Selector. However, we do not want to register all Channel instances with the Selector. Imagine if you have 1.000.000 connections which are mostly idle and all 1.000.000 connections were registered with the Selector. Then, when you call select() most of these Channel instances would be write-ready (they are mostly idle, remember?). You would then have to check the Message Writer of all those connections to see if they had any data to write.

To avoid checking all Message Writer instances for messages, and all Channel instances which anyways do not have any messages to be sent to them, we use this two-step approach:

    When a message is written to a Message Writer, the Message Writer registers its associated Channel with the Selector (if it is not already registered).

    When your server has time, it checks the Selector to see which of the registered Channel instances are ready for writing. For each write-ready Channel its associated Message Writer is requested to write data to the Channel. If a Message Writer writes all its messages to its Channel, the Channel is unregistered from the Selector again.

This little two-step approach makes sure that only Channel instances that have messages to be written to them are actually registered with the Selector.
Putting it All Together

As you can see, a non-blocking server needs to check for incoming data from time to time to see if there are any new full messages received. The server might need to check multiple times until one or more full messages have been received. Checking one time is not enough.

Similarly, a non-blocking server needs to check from time to time if there is any data to write. If yes, the server needs to check if any of the corresponding connections are ready to have that data written to them. Checking only when a message is queued up the first time is not enough, since the message might be written partially.

All in all a non-blocking server ends up with three "pipelines" it needs to execute regularly:

    The read pipeline which checks for new incoming data from the open connections.
    The process pipeline which processes any full messages received.
    The write pipeline which checks if it can write any outgoing messages to any of the open connections.

These three pipelines are executed repeatedly in a loop. You might be able to optimize the execution somewhat. For instance, if there are no messages queued up you can skip the write pipeline. Or, if there we no new, full messages received, perhaps you can skip the process pipeline.

Here is a diagram illustrating the full server loop:
The full server loop of a non-blocking server.

If you still find this a bit complicated, remember to check out the GitHub repository:

https://github.com/jjenkov/java-nio-server

Maybe seeing the code in action might help you understand how to implement this.
Server Thread Model

The non-blocking server implementation in the GitHub repository uses a thread model with 2 threads. The first thread accepts incoming connections from a ServerSocketChannel. The second thread processes the accepted connections, meaning reading messages, processing the messages and writing responses back to the connections. This 2 thread model is illustrated here:
The 2 thread model for the non-blocking server implemented in the GitHub repository.

The server processing loop explained in the previous section is executed by the processing thread.

-->
</td>
<td>
  <span xsmall>Datagram Channel</span>
<!--


A Java NIO DatagramChannel is a channel that can send and receive UDP packets. Since UDP is a connection-less network protocol, you cannot just by default read and write to a DatagramChannel like you do from other channels. Instead you send and receive packets of data.
Opening a DatagramChannel

Here is how you open a DatagramChannel:

DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));

This example opens a DatagramChannel which can receive packets on UDP port 9999.
Receiving Data

You receive data from a DatagramChannel by calling its receive() method, like this:

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();

channel.receive(buf);

The receive() method will copy the content of a received packet of data into the given Buffer. If the received packet contains more data than the Buffer can contain, the remaining data is discarded silently.
Sending Data

You can send data via a DatagramChannel by calling its send() method, like this:

String newData = "New String to write to file..."
                    + System.currentTimeMillis();
    
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();

int bytesSent = channel.send(buf, new InetSocketAddress("jenkov.com", 80));

This example sends the string to the "jenkov.com" server on UDP port 80. Nothing is listening on that port though, so nothing will happen. You will not be notified of whether the send packet was received or not, since UDP does not make any guarantees about delivery of data.
Connecting to a Specific Address

It is possible to "connect" a DatagramChannel to a specific address on the network. Since UDP is connection-less, this way of connecting to an address does not create a real connection, like with a TCP channel. Rather, it locks your DatagramChannel so you can only send and receive data packets from one specific address.

Here is an example:

channel.connect(new InetSocketAddress("jenkov.com", 80));    

When connected you can also use the read() and write() method, as if you were using a traditional channel. You just don't have any guarantees about delivery of the sent data. Here are a few examples:

int bytesRead = channel.read(buf);    

int bytesWritten = channel.write(buf);
-->
</td>
<td>
  <span xsmall>Pipe</span>
<!--
 A Java NIO Pipe is a one-way data connection between two threads. A Pipe has a source channel and a sink channel. You write data to the sink channel. This data can then be read from the source channel.

Here is an illustration of the Pipe principle:
Java NIO: Pipe Internals
Java NIO: Pipe Internals
Creating a Pipe

You open a Pipe by calling the Pipe.open() method. Here is how that looks:

Pipe pipe = Pipe.open();

Writing to a Pipe

To write to a Pipe you need to access the sink channel. Here is how that is done:

Pipe.SinkChannel sinkChannel = pipe.sink();

You write to a SinkChannel by calling it's write() method, like this:

String newData = "New String to write to file..." + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
    sinkChannel.write(buf);
}

Reading from a Pipe

To read from a Pipe you need to access the source channel. Here is how that is done:

Pipe.SourceChannel sourceChannel = pipe.source();

To read from the source channel you call its read() method like this:

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);

The int returned by the read() method tells how many bytes were read into the buffer
-->
</td>
<td>
  <span xsmall>Path</span>
  
<!--
 The Java Path interface is part of the Java NIO 2 update which Java NIO received in Java 6 and Java 7. The Java Path interface was added to Java NIO in Java 7. The Path interface is located in the java.nio.file package, so the fully qualified name of the Java Path interface is java.nio.file.Path.

A Java Path instance represents a path in the file system. A path can point to either a file or a directory. A path can be absolute or relative. An absolute path contains the full path from the root of the file system down to the file or directory it points to. A relative path contains the path to the file or directory relative to some other path. Relative paths may sound a bit confusing. Don't worry. I will explain relative paths in more detail later in this Java NIO Path tutorial.

Do not confuse a file system path with the path environment variable in some operating systems. The java.nio.file.Path interface has nothing to do with the path environment variable.

In many ways the java.nio.file.Path interface is similar to the java.io.File class, but there are some minor differences. In many cases though, you can replace the use of the File class with use of the Path interface.
Creating a Path Instance

In order to use a java.nio.file.Path instance you must create a Path instance. You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get(). Here is a Java Paths.get() example:

import java.nio.file.Path;
import java.nio.file.Paths;

public class PathExample {

    public static void main(String[] args) {

        Path path = Paths.get("c:\\data\\myfile.txt");

    }
}

Notice the two import statements at the top of the example. To use the Path interface and the Paths class we must first import them.

Second, notice the Paths.get("c:\\data\\myfile.txt") method call. It is the call to the Paths.get() method that creates the Path instance. The Paths.get() method is a factory method for Path instances, in other words.
Creating an Absolute Path

Creating an absolute path is done by calling the Paths.get() factory method with the absolute file as parameter. Here is an example of creating a Path instance representing an absolute path:

Path path = Paths.get("c:\\data\\myfile.txt");

The absolute path is c:\data\myfile.txt. The double \ characters are necessary in Java strings, since the \ is an escape character, meaning the following character tells what character is really to be located at this place in the string. By writing \\ you tell the Java compiler to write a single \ character into the string.

The above path is a Windows file system path. On a Unix system (Linux, MacOS, FreeBSD etc.) the above absolute path could look like this:

Path path = Paths.get("/home/jakobjenkov/myfile.txt");

The absolute path is now /home/jakobjenkov/myfile.txt .

If you used this kind of path on a Windows machine (a path starting with /) the path would be interpreted as relative to the current drive. For instance, the path

/home/jakobjenkov/myfile.txt

could be interpreted as being located on the C drive. Then the path would correspond to this full path:

C:/home/jakobjenkov/myfile.txt

Creating a Relative Path

A relative path is a path that points from one path (the base path) to a directory or file. The full path (the absolute path) of a relative path is derived by combining the base path with the relative path.

The Java NIO Path class can also be used to work with relative paths. You create a relative path using the Paths.get(basePath, relativePath) method. Here are two relative path examples in Java:

Path projects = Paths.get("d:\\data", "projects");

Path file     = Paths.get("d:\\data", "projects\\a-project\\myfile.txt");

The first example creates a Java Path instance which points to the path (directory) d:\data\projects. The second example creates a Path instance which points to the path (file) d:\data\projects\a-project\myfile.txt .

When working with relative paths there are two special codes you can use inside the path string. These codes are:

    .
    ..

The . code means "current directory". For instance, if you create a relative path like this:

Path currentDir = Paths.get(".");
System.out.println(currentDir.toAbsolutePath());

Then the absolute path the Java Path instance corresponds to will be the directory in which the application executing the above code is executed.

If the . is used in the middle of a path string it just means the same directory as the path was pointing to at that point. Here is an Path example illustrating that:

Path currentDir = Paths.get("d:\\data\\projects\.\a-project");

This path will correspond to the path:

d:\data\projects\a-project

The .. code means "parent directory" or "one directory up". Here is a Path Java example illustrating that:

Path parentDir = Paths.get("..");

The Path instance created by this example would correspond to the parent directory of the directory from which the application running this code was started.

If you use the .. code in the middle of a path string it will correspond to changing one directory up at that point in the path string. For instance:

String path = "d:\\data\\projects\\a-project\\..\\another-project";
Path parentDir2 = Paths.get(path);

The Java Path instance created by this example will correspond to this absolute path:

d:\data\projects\another-project

The .. code after the a-project directory changes directory up the the parent directory projects and then the path references down into the another-project directory from there.

The . and .. codes also work in combination with the two-string Paths.get() method. Here are two Java Paths.get() examples showing simple examples of that:

Path path1 = Paths.get("d:\\data\\projects", ".\\a-project");

Path path2 = Paths.get("d:\\data\\projects\\a-project",
                       "..\\another-project");

There are more ways that the Java NIO Path class can be used to work with relative paths. You will learn more about that later in this tutorial.
Path.normalize()

The normalize() method of the Path interface can normalize a path. Normalizing means that it removes all the . and .. codes in the middle of the path string, and resolves what path the path string refers to. Here is a Java Path.normalize() example:

String originalPath =
        "d:\\data\\projects\\a-project\\..\\another-project";

Path path1 = Paths.get(originalPath);
System.out.println("path1 = " + path1);

Path path2 = path1.normalize();
System.out.println("path2 = " + path2);

This Path example first creates a path string with a .. code in the middle. Then the example creates a Path instance from this path string, and prints that Path instance out (actually it prints Path.toString()).

The example then calls normalize() on the created Path instance, which returns a new Path instance. This new, normalized Path instance is then also printed out.

Here is the output printed from the above example:

path1 = d:\data\projects\a-project\..\another-project
path2 = d:\data\projects\another-project

As you can see, the normalized path does not contain the a-project\.. part, as this is redundant. The removed part adds nothing to the final absolute path
-->
</td>
<td>
  <span xsmall>Files</span>
<!--
The Java NIO Files class (java.nio.file.Files) provides several methods for manipulating files in the file system. This Java NIO Files tutorial will cover the most commonly used of these methods. The Files class contains many methods, so check the JavaDoc too, if you need a method that is not described here. The Files class just might have a method for it still.

The java.nio.file.Files class works with java.nio.file.Path instances, so you need to understand the Path class before you can work with the Files class.
Files.exists()

The Files.exists() method checks if a given Path exists in the file system.

It is possible to create Path instances that do not exist in the file system. For instance, if you plan to create a new directory, you would first create the corresponding Path instance, and then create the directory.

Since Path instances may or may not point to paths that exist in the file system, you can use the Files.exists() method to determine if they do (in case you need to check that).

Here is a Java Files.exists() example:

Path path = Paths.get("data/logging.properties");

boolean pathExists =
        Files.exists(path,
            new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});

This example first creates a Path instance pointing to the path we want to check if exists or not. Second, the example calls the Files.exists() method with the Path instance as the first parameter.

Notice the second parameter of the Files.exists() method. This parameter is an array of options that influence how the Files.exists() determines if the path exists or not. In this example above the array contains the LinkOption.NOFOLLOW_LINKS which means that the Files.exists() method should not follow symbolic links in the file system to determine if the path exists.
Files.createDirectory()

The Files.createDirectory() method creates a new directory from a Path instance. Here is a Java Files.createDirectory() example:

Path path = Paths.get("data/subdir");

try {
    Path newDir = Files.createDirectory(path);
} catch(FileAlreadyExistsException e){
    // the directory already exists.
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}

The first line creates the Path instance that represents the directory to create. Inside the try-catch block the Files.createDirectory() method is called with the path as parameter. If creating the directory succeeds, a Path instance is returned which points to the newly created path.

If the directory already exists, a java.nio.file.FileAlreadyExistsException will be thrown. If something else goes wrong, an IOException may get thrown. For instance, if the parent directory of the desired, new directory does not exist, an IOException may get thrown. The parent directory is the directory in which you want to create the new directory. Thus, it means the parent directory of the new directory.
Files.copy()

The Files.copy() method copies a file from one path to another. Here is a Java NIO Files.copy() example:

Path sourcePath      = Paths.get("data/logging.properties");
Path destinationPath = Paths.get("data/logging-copy.properties");

try {
    Files.copy(sourcePath, destinationPath);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}

First the example creates a source and destination Path instance. Then the example calls Files.copy(), passing the two Path instances as parameters. This will result in the file referenced by the source path to be copied to the file referenced by the destination path.

If the destination file already exists, a java.nio.file.FileAlreadyExistsException is thrown. If something else goes wrong, an IOException will be thrown. For instance, if the directory to copy the file to does not exist, an IOException will be thrown.
Overwriting Existing Files

It is possible to force the Files.copy() to overwrite an existing file. Here an example showing how to overwrite an existing file using Files.copy():

Path sourcePath      = Paths.get("data/logging.properties");
Path destinationPath = Paths.get("data/logging-copy.properties");

try {
    Files.copy(sourcePath, destinationPath,
            StandardCopyOption.REPLACE_EXISTING);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}

Notice the third parameter to the Files.copy() method. This parameter instructs the copy() method to overwrite an existing file if the destination file already exists.
Files.move()

The Java NIO Files class also contains a function for moving files from one path to another. Moving a file is the same as renaming it, except moving a file can both move it to a different directory and change its name in the same operation. Yes, the java.io.File class could also do that with its renameTo() method, but now you have the file move functionality in the java.nio.file.Files class too.

Here is a Java Files.move() example:

Path sourcePath      = Paths.get("data/logging-copy.properties");
Path destinationPath = Paths.get("data/subdir/logging-moved.properties");

try {
    Files.move(sourcePath, destinationPath,
            StandardCopyOption.REPLACE_EXISTING);
} catch (IOException e) {
    //moving file failed.
    e.printStackTrace();
}

First the source path and destination path are created. The source path points to the file to move, and the destination path points to where the file should be moved to. Then the Files.move() method is called. This results in the file being moved.

Notice the third parameter passed to Files.move() . This parameter tells the Files.move() method to overwrite any existing file at the destination path. This parameter is actually optional.

The Files.move() method may throw an IOException if moving the file fails. For instance, if a file already exists at the destination path, and you have left out the StandardCopyOption.REPLACE_EXISTING option, or if the file to move does not exist etc.
Files.delete()

The Files.delete() method can delete a file or directory. Here is a Java Files.delete() example:

Path path = Paths.get("data/subdir/logging-moved.properties");

try {
    Files.delete(path);
} catch (IOException e) {
    //deleting file failed
    e.printStackTrace();
}

First the Path pointing to the file to delete is created. Second the Files.delete() method is called. If the Files.delete() fails to delete the file for some reason (e.g. the file or directory does not exist), an IOException is thrown.
Files.walkFileTree()

The Files.walkFileTree() method contains functionality for traversing a directory tree recursively. The walkFileTree() method takes a Path instance and a FileVisitor as parameters. The Path instance points to the directory you want to traverse. The FileVisitor is called during traversion.

Before I explain how the traversal works, here is first the FileVisitor interface:

public interface FileVisitor {

    public FileVisitResult preVisitDirectory(
        Path dir, BasicFileAttributes attrs) throws IOException;

    public FileVisitResult visitFile(
        Path file, BasicFileAttributes attrs) throws IOException;

    public FileVisitResult visitFileFailed(
        Path file, IOException exc) throws IOException;

    public FileVisitResult postVisitDirectory(
        Path dir, IOException exc) throws IOException {

}

You have to implement the FileVisitor interface yourself, and pass an instance of your implementation to the walkFileTree() method. Each method of your FileVisitor implementation will get called at different times during the directory traversal. If you do not need to hook into all of these methods, you can extend the SimpleFileVisitor class, which contains default implementations of all methods in the FileVisitor interface.

Here is a walkFileTree() example:

Files.walkFileTree(path, new FileVisitor<Path>() {
  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    System.out.println("pre visit dir:" + dir);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    System.out.println("visit file: " + file);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    System.out.println("visit file failed: " + file);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    System.out.println("post visit directory: " + dir);
    return FileVisitResult.CONTINUE;
  }
});

Each of the methods in the FileVisitor implementation gets called at different times during traversal:

The preVisitDirectory() method is called just before visiting any directory. The postVisitDirectory() method is called just after visiting a directory.

The visitFile() mehtod is called for every file visited during the file walk. It is not called for directories - only files. The visitFileFailed() method is called in case visiting a file fails. For instance, if you do not have the right permissions, or something else goes wrong.

Each of the four methods return a FileVisitResult enum instance. The FileVisitResult enum contains the following four options:

    CONTINUE
    TERMINATE
    SKIP_SIBLINGS
    SKIP_SUBTREE

By returning one of these values the called method can decide how the file walk should continue.

CONTINUE means that the file walk should continue as normal.

TERMINATE means that the file walk should terminate now.

SKIP_SIBLINGS means that the file walk should continue but without visiting any siblings of this file or directory.

SKIP_SUBTREE means that the file walk should continue but without visiting the entries in this directory. This value only has a function if returned from preVisitDirectory(). If returned from any other methods it will be interpreted as a CONTINUE.
Searching For Files

Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :

Path rootPath = Paths.get("data");
String fileToFind = File.separator + "README.txt";

try {
  Files.walkFileTree(rootPath, new SimpleFileVisitor<Path>() {
    
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      String fileString = file.toAbsolutePath().toString();
      //System.out.println("pathString = " + fileString);

      if(fileString.endsWith(fileToFind)){
        System.out.println("file found at path: " + file.toAbsolutePath());
        return FileVisitResult.TERMINATE;
      }
      return FileVisitResult.CONTINUE;
    }
  });
} catch(IOException e){
    e.printStackTrace();
}

Deleting Directories Recursively

The Files.walkFileTree() can also be used to delete a directory with all files and subdirectories inside it. The Files.delete() method will only delete a directory if it is empty. By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files. Here is a recursive directory deletion example:

Path rootPath = Paths.get("data/to-delete");

try {
  Files.walkFileTree(rootPath, new SimpleFileVisitor<Path>() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      System.out.println("delete file: " + file.toString());
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
      Files.delete(dir);
      System.out.println("delete dir: " + dir.toString());
      return FileVisitResult.CONTINUE;
    }
  });
} catch(IOException e){
  e.printStackTrace();
}

Additional Methods in the Files Class

The java.nio.file.Files class contains many other useful functions, like functions for creating symbolic links, determining the file size, setting file permissions etc. Check out the JavaDoc for the java.nio.file.Files class for more information about these methods.
-->
</td>
<td>
  <span xsmall>Asyncrhonous FileChannel</span>
<!--
In Java 7 the AsynchronousFileChannel was added to Java NIO. The AsynchronousFileChannel makes it possible to read data from, and write data to files asynchronously. This tutorial will explain how to use the AsynchronousFileChannel.
Creating an AsynchronousFileChannel

You create an AsynchronousFileChannel via its static method open(). Here is an example of creating an AsynchronousFileChannel:

Path path = Paths.get("data/test.xml");

AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

The first parameter to the open() method is a Path instance pointing to the file the AsynchronousFileChannel is to be associated with.

The second parameter is one or more open options which tell the AsynchronousFileChannel what operations is to be performed on the underlying file. In this example we used the StandardOpenOption.READ which means that the file will be opened for reading.
Reading Data

You can read data from an AsynchronousFileChannel in two ways. Each way to read data call one of the read() methods of the AsynchronousFileChannel. Both methods of reading data will be covered in the following sections.
Reading Data Via a Future

The first way to read data from an AsynchronousFileChannel is to call the read() method that returns a Future. Here is how calling that read() method looks:

Future<Integer> operation = fileChannel.read(buffer, 0);

This version of the read() method takes ByteBuffer as first parameter. The data read from the AsynchronousFileChannel is read into this ByteBuffer. The second parameter is the byte position in the file to start reading from.

The read() method return immediately, even if the read operation has not finished. You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.

Here is a longer example showing how to use this version of the read() method:

AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

Future<Integer> operation = fileChannel.read(buffer, position);

while(!operation.isDone());

buffer.flip();
byte[] data = new byte[buffer.limit()];
buffer.get(data);
System.out.println(new String(data));
buffer.clear();

This example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter, along with a position of 0. After calling read() the example loops until the isDone() method of the returned Future returns true. Of course, this is not a very efficient use of the CPU - but somehow you need to wait until the read operation has completed.

Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out .
Reading Data Via a CompletionHandler

The second method of reading data from an AsynchronousFileChannel is to call the read() method version that takes a CompletionHandler as a parameter. Here is how you call this read() method:

fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {
    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        System.out.println("result = " + result);

        attachment.flip();
        byte[] data = new byte[attachment.limit()];
        attachment.get(data);
        System.out.println(new String(data));
        attachment.clear();
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {

    }
});

Once the read operation finishes the CompletionHandler's completed() method will be called. As parameters to the completed() method are passed an Integer telling how many bytes were read, and the "attachment" which was passed to the read() method. The "attachment" is the third parameter to the read() method. In this case it was the ByteBuffer into which the data is also read. You can choose freely what object to attach.

If the read operation fails, the failed() method of the CompletionHandler will get called instead.
Writing Data

Just like with reading, you can write data to an AsynchronousFileChannel in two ways. Each way to write data call one of the write() methods of the AsynchronousFileChannel. Both methods of writing data will be covered in the following sections.
Writing Data Via a Future

The AsynchronousFileChannel also enables you to write data asynchronously. Here is a full Java AsynchronousFileChannel write example:

Path path = Paths.get("data/test-write.txt");
AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

buffer.put("test data".getBytes());
buffer.flip();

Future<Integer> operation = fileChannel.write(buffer, position);
buffer.clear();

while(!operation.isDone());

System.out.println("Write done");

First an AsynchronousFileChannel is opened in write mode. Then a ByteBuffer is created and some data written into it. Then the data in the ByteBuffer is written to the file. Finally the example checks the returned Future to see when the write operation has completed.

Note, that the file must already exist before this code will work. If the file does not exist the write() method will throw a java.nio.file.NoSuchFileException .

You can make sure that the file the Path points to exists with the following code:

if(!Files.exists(path)){
    Files.createFile(path);
}

Writing Data Via a CompletionHandler

You can also write data to the AsynchronousFileChannel with a CompletionHandler to tell you when the write is complete instead of a Future. Here is an example of writing data to the AsynchronousFileChannel with a CompletionHandler:

Path path = Paths.get("data/test-write.txt");
if(!Files.exists(path)){
    Files.createFile(path);
}
AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

buffer.put("test data".getBytes());
buffer.flip();

fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {

    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        System.out.println("bytes written: " + result);
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {
        System.out.println("Write failed");
        exc.printStackTrace();
    }
});

The CompletionHandler's completed() method will get called when the write operation completes. If the write fails for some reason, the failed() method will get called instead.

Notice how the ByteBuffer is used as attachment - the object which is passed on to the CompletionHandler's methods.
-->
</td>
</table>

<table>
<tr>
  <th colspan=4 header_delimit >Concurrent Programming</th>
</tr>
<td>
  java.util.concurrent
  <ul xxxsmall zoom { >
  <li></li>
  </ul } >
  Objects as monitors<br/>
  <span xxsmall orange>mutual exclusion</span>
  <ul xxxsmall zoom { >
  <li>each java object can used as a monitor.</li>
  <li>Methods/blocks of code requiring mutual exclusion must be explicitly marked with the
    <code orange>synchronized keyword</code></li>
  <li>Instead of explicit condition variables, each monitor(/object) is equipped with
    a single wait queue in addition to its entrance queue.</li>
  <li>All waiting is done on this single wait queue and all <code orange>notify/notifyAll</code>
    operations apply to this queue.
<pre {>
             enter
               |
 +---+-------- | --+
 |  notified   v   |
 | ----->          |
 |                 |
 | O |         O   |
 | O |         O   |
 | O +--------   --+--+
 | O |                |
 |   |                |
 |  <-- wait   O      |
 |   |      (Running  |
 +---+       thread)  |
     |                |
     |     leave      |
     |        |       |
     +------- | ------+
              v
</pre }>
  </li>

  </ul }>
  </td>
<td>
  Concurrent code
  <ul xxxsmall zoom { >
  <li>
<pre {>
 +------------+ |               [[Executor]]
 |[[Runnable]]| |                   ^
 |------------| |                   |
 |+run()      | |           [[ExecutorService]]
 +------------+ |                   ^
       ^        |        +----------+--------------+
       |        |        |                         |
 +------------+ | AbstractExecutorService  [[ScheduledExecutorService]]
 |   Thread   | |        ^                         ^
 |------------| | ThreadPoolExecutor               |
 |+run()      | |        ^                         |
 |+start()    | | ScheduledThreadPoolExecutor -----+
 |+sleep()    | |
 |....        | |
 |------------| |
 +------------+ |
</pre }>
  </li>
  <li>
    ExecutorService(Thread Pool): managed collection of threads available to execute tasks.<br/>
    To use a thread pool, you can use an implementation of the interface 
    ExecutorService, such as ThreadPoolExecutor or ScheduledThreadPoolExecutor.
    However, more convenient factory methods are provided in the Executors class
    as follows:<br/>
    Using thread pool:
    <ol>
      <li>Write worker thread class implementing <<Runnable>> run()</li>
      <li>STEP 2: Create ExecutorService using:
<pre {>
Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int numThreads)
Executors.newCachedThreadPool(): <-- unbounded pool, with automatic reclamation
Executors.newSingleThreadScheduledExecutor()
Executors.newScheduledThreadPool(int size)
</pre }>
       </li>
       <li>Use executor(Service)Instance.execute(/*Runnable */workerThreadInstance)
         to add a Runnable task to thread pool. Executes task at some time in the
         future in a new thread, in a thread pool, or in the calling thread, 
         depending on the implementation of Executor</li>
     </ol>
<pre {>
 [[java.util.concurrent.ExecutorService]]
 + public     void      shutdown(); // Initiates orderly shutdown of pool
 + public <T> Future<T> submit(Callable<T> task); // schedule callable task for execution
</pre }>
  </li>
  </ul>
  <a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'>CompletableFuture (Java 8+)</a>
  <ul xxxsmall zoom >
    A Future that may be explicitly completed (setting its value and status), 
    and may be used as a CompletionStage, supporting dependent functions and 
    actions that trigger upon its completion.<br/>
    When two or more threads attempt to complete, completeExceptionally, or 
    cancel a CompletableFuture, only one of them succeeds.
  </li>
  <li>
<pre {>
[[ java.util.concurrent.Callable&lt;V> ]]
   +public V call()  (vs run() in Runnable)
   similar to a Runnable, but allows to return a result/Exception to the thread triggering the Callable
   returns a result of type &lt;V>, or throws an exception if unable to do so.
  
[[ Future&lt;V> ]] 
   +V get()           // blocks waiting for result
   +V get(long timeout, TimeUnit unit)
   +boolean cancel(boolean mayInterruptIfRunning)
   +boolean isCancelled()
   +boolean isDone()  // return true if this task completed
</pre }>
  </li>
  </ul>
  </td>
<td>
  Example 1 ThreadPoolTest:
<pre xxxsmall zoom { >
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {

   public static void main(String[] args) {
      ExecutorService pool = Executors.newFixedThreadPool(10);
      MyWorker[] workers = new MyWorker[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) pool.execute(new MyWorker(i+1));
      pool.shutdown();
   }
}
</pre }>
  Example 2: CallableThreadPoolTest:
<pre xxxsmall zoom {>
import java.util.concurrent.Callable;
import java.util.concurrent.*;

public class CallableThreadPoolTest {

    public class MyCallableWorkerThread implements Callable&lt;String> {
       MyCallableWorkerThread(int workerNumber) { ... }
       public String call() { 
          Thread.sleep((int)(Math.random() * 1000));
          return "worker " + workerNumber;
       }
    }

   public static void main(String[] args) {
      int numWorkers = 10;
      ExecutorService pool = Executors.newCachedThreadPool();
      MyCallableWorkerThread workers[] = new MyCallableWorkerThread[numWorkers];
      Future                 futures[] = new Future                [numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new MyCallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
                                 try {
            System.out.println(futures[i].get() + " ended");
                                 } catch (InterruptedException ex) {
            ex.printStackTrace();
                                 } catch (ExecutionException ex) {
            ex.printStackTrace();
                                 }
      }
   }
}
</pre>
</td>
<td>
  Guava ListenableFuture
  <a href='https://github.com/google/guava/wiki/ListenableFutureExplained'>REF</a><br/>
  <ul xxxsmall zoom >
  <li>Concurrency is a hard problem, but it is significantly simplified by working with powerful and simple abstractions. To simplify matters, Guava extends the Future interface of the JDK with ListenableFuture.<br/></li>
  <li>
    <span cite>"""We strongly advise that you always use ListenableFuture instead
    of Future in all of your code, because:<br/>
    - Most Futures methods require it.<br/>
    - It's easier than changing to ListenableFuture later.<br/>
    - Providers of utility methods won't need to provide Future and ListenableFuture
      variants of their methods.</span>
  </li>
  </ul>
  ListenableFuture vs Java CompletableFuture 
  <a href="https://stackoverflow.com/questions/38744943/listenablefuture-vs-completablefuture">REF</a><br/>
  <ul xxxsmall zoom { >
  <li>
<pre { >
          ListenableFuture                           |               CompletableFuture
-----------------------------------------------------+---------------------------------------------------
                                                     | It is different from ListenableFuture in that it
                                                     | can be completed from any thread that wants it to complete
-----------------------------------------------------+---------------------------------------------------
ListenableFuture listenable = service.submit(...);   | CompletableFuture completableFuture =
  Futures.addCallback(listenable,                    |     new CompletableFuture();
                      new FutureCallback&lt;Object>() { | completableFuture.whenComplete(new BiConsumer() {
    @Override                                        |   @Override
    public void onSuccess(Object o) {                |   public void accept(Object o, Object o2) {
        //handle on success                          |       //handle complete
    }                                                |   }
                                                     | }); // complete the task
    @Override                                        | completableFuture.complete(new Object())
    public void onFailure(Throwable throwable) {     |            
       //handle on failure                           | When a thread calls complete on the task,
    }                                                | the value received from a call to get() is
  })                                                 | set with the parameter value if the task is
                                                     | not already completed.
</pre } >
  </li>
  <li cite>..."CompletableFuture is dangerous because it exposes *compete* methods."  </li>
  <li cite>..."CompletableFuture would have been good if it extended Future and did not expore toCompletableFuture,... and they could have named it something meaningful like ChainableFuture "  </li>
  </ul } >
  
  </td>
</tr }>
</table>

<table>
<tr {>
  <th colspan=3 header_delimit >Async/Reactive Programming</th>
</tr }>
<tr {>
<td>
  Summary
  <ul xxxsmall zoom >
  <li>addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation style APIs — as popularized by CompletableFuture and ReactiveX, that allow declarative composition of asynchronous logic. At the programming model level Java 8 enabled Spring WebFlux to offer functional web endpoints alongside with annotated controllers.
  </li>
  <li>The term "reactive" refers to programming models that are built around reacting to change — network component reacting to I/O events, UI controller reacting to mouse events, etc. In that sense non-blocking is reactive because instead of being blocked we are now in the mode of reacting to notifications as operations complete or data becomes available.
  </li>
  <li>Spring Reactive Streams is a small spec, also adopted in Java 9, that defines the interaction between asynchronous components with back pressure. For example a data repository — acting as Publisher, can produce data that an HTTP server — acting as Subscriber, can then write to the response. The main purpose of Reactive Streams is to allow the subscriber to control how fast or how slow the publisher will produce data.
  </li>
  <li>Reactive Streams plays an important role for interoperability. It is of interest to libraries and infrastructure components but less useful as an application API because it is too low level. What applications need is a higher level and richer, functional API to compose async logic — similar to the Java 8 Stream API but not only for collections. This is the role that reactive libraries play.
  </li>
  </ul>
</td>
<td>
    RxJava (<a href="https://github.com/ReactiveX/RxJava">REF</a>)<br/>
<pre xxxsmall zoom > 
            Java 8 Stream
+       CompletableFuture
+ "Back-presure" measures *1
-------------------------
            rx.Observable
*1 probably an intermediate buffer for incomming/outgoing messages that acts 
async. when not full, and sync when full.
</pre> 
  </td>
</tr }>
</table>
<br/>
<table>
<tr {>
<td>
  JSON
  <ul xxxsmall zoom { >
    <li><a href='https://www.infoq.com/news/2017/03/json-processing-public-review'>REF:JSON processing public review</a></li>
    <li>
Public review of JSR 374: Java API for JSON Processing (JSON-P) version 1.1 is now open. 
This version is expected to be included in the release of J2EE 8 and keeps JSON-P current with JSON IETF standards. It includes support for:
      <ul>
      <li>JSON Pointer</li>
      <li>JSON Patch</li>
      <li>JSON Merge Patch</li>
      <li>Query and transformation operations</li>
      <li>Java 8 streams and lambdas</li>
      </ul>
    </li>
    <li>JSON-P was introduced in 2013 with the release of J2EE 7, as an alternative to Gson and Jackson. It was designed to parse, generate, 
and query standard JSON documents.

JSR-367: Java API for JSON Binding (JSON-B), will also be included in the release of J2EE 8.
    </li>
  </ul }>
    tags: [JSON Parsing, HTTP GET/POST, TLS, Basic Authorization]
<pre xxxsmall zoom {>
package com.mycomp.project1;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.json.JSONObject;

import java.security.cert.X509Certificate;
import java.util.Date;

import java.util.Scanner;

public class TestAPI<JSONArray> {
    static String userpass = "operator1:ecllqy";
    private static SSLSocketFactory sslSocketFactory = null;

    private JSONObject sendPost(String url, String post_body, String token) throws Exception 
    {
        URL obj = new URL(url);
        String basicAuth = "Basic " +
            javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

        HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

        setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

        con.setRequestMethod("POST"); //add request header
        con.setRequestProperty("Content-Type", "application/json");
        con.setRequestProperty("Cache-Control", "no-cache");
        if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
        } else               { con.setRequestProperty("Authorization", "Bearer "+token);
        }
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(post_body);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();

        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        StringBuffer response = new StringBuffer();
        String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
        in.close();
        return new JSONObject(response.toString()); //String myJSONStr
    }


    /********************************************************************************/
    /**
     * Overrides the SSL TrustManager and HostnameVerifier to allow
     * all certs and hostnames.
     * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
     * environment.
     *
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     */
    protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
        // Create the socket factory.
        // Reusing the same socket factory allows sockets to be
        // reused, supporting persistent connections.
        if( null == sslSocketFactory) {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
            sslSocketFactory = sc.getSocketFactory();
        }

        connection.setSSLSocketFactory(sslSocketFactory);

        // Since we may be using a cert with a different name, we need to ignore
        // the hostname as well.
        connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
    }

    private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {}
            public void checkServerTrusted(X509Certificate[] certs, String authType) {}
        }
    };

    private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
}
</pre } >
</td>
<td>
  [QA]  Restassured: JSON REST API Test
<pre xxxsmall zoom>
package com.mycompany.myproject.mymodule;

import static junit.framework.TestCase.assertTrue;
import static org.hamcrest.Matchers.*;

import com.everis.trinity.server.common.StatusResult;

import static io.restassured.RestAssured.given;

import io.restassured.RestAssured;
import io.restassured.config.HttpClientConfig;
import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import junit.framework.TestCase;
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.SystemDefaultHttpClient;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.eclipse.jetty.http.HttpStatus;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.BeforeClass;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;

import java.util.Base64;
import java.util.Map;

public class FullJourneyTest {


    // Custom regex matcher for RestAssured Framework
    public static class RegexMatcher extends BaseMatcher<Object>{
        private final String regex;

        public RegexMatcher(String regex){
            this.regex = regex;
        }

        public boolean matches(Object o){
            return ((String)o).matches(regex);

        }

        public void describeTo(Description description){
            description.appendText("matches regex=");
        }

        public static RegexMatcher matches(String regex){
            return new RegexMatcher(regex);
        }
    }

     public static class Base64Matcher extends BaseMatcher<Object>{

        public Base64Matcher(){}

        public boolean matches(Object o){
            try {
                Base64.getDecoder().decode((String)o);
                return true;
            }catch (Exception e){
                return false;
            }
        }

        public void describeTo(Description description){
            description.appendText("can be parsed as Base64");
        }

        public static Base64Matcher isBase64Encoded(){
            return new Base64Matcher();
        }
    }
    private static final String AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;

    protected static RequestSpecification setupCommonHeaders() {
        return given().header("Authorization", AUTH_HEADER_VALUE)
                      .header("Accept"       , "application/json")
                      .header("content-type" , "application/json;charset=utf-8")
        .log().all();
    }


    final String
        NAME="COMMUNITY_1", SYMBOL="SY1";

    Response response;
    @BeforeClass
    public static void setup() {
        RestAssured.port     = ServerConfig.serverPort;
        RestAssured.basePath = "/";
        RestAssured.baseURI  = "http://localhost";

        HttpClientConfig clientConfig = RestAssured.config().getHttpClientConfig();
        clientConfig = clientConfig.httpClientFactory(new HttpClientConfig.HttpClientFactory() {
            @Override
            public HttpClient createHttpClient() {
                HttpClient rv =  new SystemDefaultHttpClient();
                HttpParams httpParams = rv.getParams();
                //  Wait 5s max for a connection
                HttpConnectionParams.setConnectionTimeout(httpParams, 5 * 1000);
                // Default session is 60s
                HttpConnectionParams.setSoTimeout(httpParams, 60 * 1000); 
                return rv;
            }
        });
        // This is necessary to ensure, that the client is reused.
        clientConfig = clientConfig.reuseHttpClientInstance();
        RestAssured.config = RestAssured.config().httpClient(clientConfig);
    }

    @Test
    public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
        String jsonBody =
            "{ " +
                " \"name\": \""+NAME+"\", " +
                " \"symbol\": \"" + SYMBOL + "\","
            "}";
        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/01")</b>;
        System.out.println(response.body().prettyPrint());
        response.then()
            /* <b>get sure JSON serializer do not include extra (maybe sensitive) info</b> */
            .body("size()", <b orange>is(5)                          </b>)
            .body("id"    , <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>not(isEmptyString())           </b>)
            .body("pubkey", <b orange>RegexMatcher.matches("^*{65}$")</b>)
            .body("pubkey", <b orange>Base64Matcher.isBase64Encoded()</b>)
            .body("name"  , <b orange>equalTo(NAME)                  </b>)
            .body("symbol", <b orange>equalTo(SYMBOL)                </b>)
            .statusCode(HttpStatus.ACCEPTED_202);
        String <b blue>NEW_ID = response.getBody().jsonPath().get("id")</b>;

        // Next related test to execute synchronously after fetching NEW_ID
        String jsonBody =
            "{ " +
                <b blue>" \"FK_ID\": \""+NEW_ID+"\", " +</b>
                ...
            "}";

        response = setupCommonHeaders().body(jsonBody).when().<b>post("/Route/To/REST/API/02")</b>;
        ...
    }

}


</pre>
</td>
<td summa >
  [QA] Exceptions
  <ul xxxsmall zoom {>
  <li>(compiler) checked vs unchecked (Error, RuntimeException and their subclasses).</li>
  <li>Checked: All except Error, RuntimeException and their subclasses</li>
  <li>Error: Exceptional conditions external to the application.</li>
<pre { >
java.lang.Object
   java.lang.Throwable
       java.lang.Exception
           java.lang.RuntimeException (non-checked)
           java.lang.*Exception       (checked -A)
       java.lang.Error                (non-checked)
</pre }>
    
  <li>The Throwable class is the superclass of all errors and exceptions in the Java language.  Only objects that are instances of this class (or one of its subclasses) are thrown by the JVM or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.</li>
     <li>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.</li>
    </ul>
</td>
<td>
  [QA] Checker framework
  <ul xxxsmall zoom {>
  <li>
    <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>REF: Oracle Java 8 new Type Annotations</a>
Java SE 8 allows type annotations anywhere that a type is used. Previously, 
annotations were only allowed on definitions. 
The Checker Framework provides a few Type Annotations that could benefit both 
library and application developers, such as:
<pre {>
@NonNull: compiler can determine cases where a code path might receive a null.

@ReadOnly: compiler will flag any attempt to change the object.

@Regex – compile-time verification that a String intended to be used 
    as a regular expression is a properly formatted regular expression.

@Tainted and @Untainted: Identity types of data that should not be used
    together, such as remote user input being used in system commands, 
    or sensitive information in log streams.

@m – Units of measure ensures that numbers used for measuring objects 
    are used and compared correctly, or have undergone the proper unit
    conversion.
</pre }>
  </li>
  <li TODO >installation process:<br/>
    Download the Checker Framework distribution: 
      https://checkerframework.org/checker-framework-2.1.8.zip. <br/>
    Configure your IDE, build system, or command shell to include the 
    Checker Framework on the classpath. Choose the appropriate section of 
    Chapter 30 for javac (Section 30.1), Ant (Section 30.2), Maven (Section 30.3),
    Gradle (Section 30.4), IntelliJ IDEA (Section 30.6), Eclipse (Section 30.7),
    or tIDE (Section 30.8).<br/>
    Option 1: Add directory .../checker-framework-2.1.8/checker/bin to your path, before any other directory that contains a javac executable.</li>
  <li>The Nullness Checker supports several annotations that specify method 
      behavior. <br/>
     These are declaration annotations, not type annotations:<br/>
     they apply to the method itself rather than to some particular type.<br/>
     @RequiresNonNull (precondition): annotated method expects the specified 
     variables to be non-null when the method is invoked.<br/>
       @EnsuresNonNull (postcondition): the given expressions are non-null 
     after the method returns;<br/>
       @EnsuresNonNullIf: if annotated method returns true|false, then the 
     given expressions are non-null.<br/>
  </li>
  <li>The Lock Checker prevents certain concurrency errors by enforcing a 
    locking discipline. A locking discipline indicates which locks must be 
    held when a given operation occurs. You express the locking discipline by 
    declaring a variable’s type to have the qualifier @GuardedBy("lockexpr"). 
    This indicates that the variable’s value may be dereferenced only if the 
    given lock is held.</li>
  <li>@GuardedBy(exprSet): If a variable x has type @GuardedBy("expr"), then a thread may dereference the value referred to by x only when the thread holds the lock that expr currently evaluates to. It can list multiple expressions, as in @GuardedBy({"expr1", "expr2"}), in which case the dereference is permitted only if the thread holds all the locks.</li>
  <li>Method pre-conditions and post-conditions<br/>
@Holding(String[] locks): All the given lock expressions are held at the method call site.<br/>
@EnsuresLockHeld(String[] locks): The given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that acquires a lock such as ReentrantLock.lock().<br/>
@EnsuresLockHeldIf(String[] locks, boolean result): If the annotated method returns the given boolean value (true or false), the given lock expressions are locked upon method return if the method terminates successfully. This is useful for annotating a method that conditionally acquires a lock. See Section 6.4.4 for examples.</li>
  <li>Side effect specifications<br/>
@LockingFree: The method does not acquire or release locks, directly or indirectly. The method is not synchronized, it contains no synchronized blocks, it contains no calls to lock or unlock methods, and it contains no calls to methods that are not themselves @LockingFree. <br/>
    Since @SideEffectFree implies @LockingFree, if both are applicable then you only need to write @SideEffectFree.<br/>
@ReleasesNoLocks: The method maintains a strictly nondecreasing lock hold count on the current thread for any locks that were held prior to the method call. The method might acquire locks but then release them, or might acquire locks but not release them (in which case it should also be annotated with @EnsuresLockHeld or @EnsuresLockHeldIf).<br/>
    This is the default for methods being type-checked that have no @LockingFree, @MayReleaseLocks, @SideEffectFree, or @Pure annotation.<br/>
  </li>
  <li>The Format String Checker prevents use of incorrect format strings in format methods such as System.out.printf and String.format. Ej:
<pre>
void printFloatAndInt(@Format({FLOAT, INT}) String fs) {
        System.out.printf(fs, 3.1415, 42);
    }
</pre>
  </li>
  <li>Here are the examples of errors that the I18n Format Checker detects at compile time
<pre {>
// Warning: the second argument is missing.
MessageFormat.format("{0} {1}", 3.1415);
// String argument cannot be formatted as Time type.
MessageFormat.format("{0, time}", "my string");
// Invalid format string: unknown format type: thyme.
MessageFormat.format("{0, thyme}", new Date());
// Invalid format string: missing the right brace.
MessageFormat.format("{0", new Date());
// Invalid format string: the argument index is not an integer.
MessageFormat.format("{0.2, time}", new Date());
// Invalid format string: "#.#.#" subformat is invalid.
MessageFormat.format("{0, number, #.#.#}", 3.1415);
</pre } >
  </li>
  <li>The Property File Checker ensures that a property file or resource bundle (both of which act like maps from keys to values) is only accessed with valid keys. Accesses without a valid key either return null or a default value, which can lead to a NullPointerException or hard-to-trace behavior. The Property File Checker (Section 12.1) ensures that the used keys are found in the corresponding property file or resource bundle.</li>
  <li>One of the most prevalent GUI-related bugs is invalid UI update or invalid thread access: accessing the UI directly from a background thread.

Most GUI frameworks (including Android, AWT, Swing, and SWT) create a single distinguished thread — the UI event thread — that handles all GUI events and updates. To keep the interface responsive, any expensive computation should be offloaded to background threads (also called worker threads). If a background thread accesses a UI element such as a JPanel (by calling a JPanel method or reading/writing a field of JPanel), the GUI framework raises an exception that terminates the program. To fix the bug, the background thread should send a request to the UI thread to perform the access on its behalf.

It is difficult for a programmer to remember which methods may be called on which thread(s). The GUI Effect Checker solves this problem. The programmer annotates each method to indicate whether:

    It accesses no UI elements (and may run on any thread); such a method is said to have the “safe effect”.
    It may access UI elements (and must run on the UI thread); such a method is said to have the “UI effect”. 
  </li>
  <li>The following kind of (physical) UNIT annotations are defined:
<pre { >
@Acceleration @Angle @Area @Current @Length @Luminance @Mass
@Speed @Substance @Temperature @Time

For each kind of unit, the corresponding SI unit of measurement is defined:

For @Acceleration: Meter Per Second Square @mPERs2
For @Angle: Radians @radians, and the derived unit Degrees @degrees
For @Area: the derived units square millimeters @mm2, square meters @m2, and square kilometers @km2
For @Current: Ampere @A
For @Length: Meters @m and the derived units millimeters @mm and kilometers @km
For @Luminance: Candela @cd
For @Mass: kilograms @kg and the derived unit grams @g
For @Speed: meters per second @mPERs and kilometers per hour @kmPERh
For @Substance: Mole @mol
For @Temperature: Kelvin @K and the derived unit Celsius @C
For @Time: seconds @s and the derived units minutes @min and hours @h 
</pre }>
  </li>
  <li>The Signedness Checker guarantees that signed and unsigned values are not mixed together in a computation. In addition, it prohibits meaningless operations, such as division on an unsigned value.
@Unsigned  @Signed
  </li>
  <li>A type alias or typedef is a type that shares the same representation as another type but is conceptually distinct from it. For example, some strings in your program may be street addresses; others may be passwords; and so on. You wish to indicate, for each string, which one it is, and to avoid mixing up the different types of strings. Likewise, you could distinguish integers that are offsets from those that are absolute values.</li>
  <li>SPARTA is a security toolset aimed at preventing malware from appearing in an app store. SPARTA provides an information-flow type-checker that is customized to Android but can also be applied to other domains. The SPARTA toolset is available from https://checkerframework.org/sparta/. The paper “Collaborative verification of information flow for a high-assurance app store” appeared in CCS 2014.</li>
  <li>Example:
<pre { >
@NonNull List&lt;String>

List&lt;@NonNull String> 

@Regex String validation = "(Java|JDK) [7,8]"

private String getInput(String parameterName){
 final String retval = @Tainted request.getParameter(parameterName);
 return retval;
} 

private void runCommand(@Untainted String… commands){
 // the previously tainted String must be validated before being passed in here.
 ProcessBuilder processBuilder = new ProcessBuilder(command);
 Process process = processBuilder.start();
}
</pre }>
  </li>
  </ul>
</td>
<td>
  [QA] Eclipse Static Code Analasys
<pre xxxsmall zoom {>
Eclipse -> Properties -> Java -> Compiler -> Errors/Warnings -> Null analysis:
  Null pointer access
  Potential null pointer access
  Redundant null check:
    x Include 'assert' in null analysis
    x Enable annotation-based null analysis
      Violation of null specification
      Conflict between null annotations an null inference
      Unchecked conversion from non-annotated type to @NonNull type
      Problems detected by pessimistic analysis fro free type variables
      Unsafe "@Nonnull" interpretation of the free type variable from library
      Redundant null anotation:
      "@NonNull" parametere not annotated in overriding method
      Missing "@NonNullByDefault" annotation on package
      x Use default annotations for null specifications (configure)
      x Inherit null annotations
      x Enable syntatic null analisys for fields
  x Treat above errors like fatal compile erros (make compiled code not executable) 
</pre } >
</td>

</tr }>
</table>



</body>
<!--
-------------------------------------------------
TODO_start:
-------------------------------------------------
- http://picodotdev.github.io/blog-bitix/ , http://elblogdepicodev.blogspot.com.es/
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw
-------------------------------------------------
https://www.youtube.com/channel/UCyhuNcrGetIRY9SdD92Uigw

TODO: Google Guice
http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers
""" Although Spring provides many benefits, it was created in a pre-Java-5 world. The Guice framework takes DI to the next level, leveraging the full power of Java typing, especially annotations and generics"""
-------------------------------------------------
{
Java programming language provides multiple mechanisms for communicating between threads:
- The most basic of these methods is synchronization, which is implemented using monitors.
  Each object in Java is associated with a monitor, which a thread can lock or unlock.
 Only one thread at a time may hold a lock on a monitor. Any other threads attempting to
 lock that monitor are blocked until they can obtain a lock on that monitor. A thread t
 may lock a particular monitor multiple times; each unlock reverses the effect of one
 lock operation.
The synchronized statement (§14.19) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 A synchronized method (§8.4.3.6) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

 The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.
 Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.
Every object, in addition to having an associated monitor, has an associated wait-set. A wait-set is a set of threads.
 When an object is first created, its wait set is empty. Elementary actions that add threads to and remove threads from wait sets are atomic. Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll.

Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
  - A notify action being performed on m in which t is selected for removal from the wait set.
  - A notifyAll action being performed on m. 
  - An interrupt action being performed on t. 
  - If this is a timed wait, an internal action removing t from m's wait set that occurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse since the beginning of this wait action. 
  - An internal action by the implementation. Implementations are permitted, although not encouraged, to perform "spurious wake-ups",
    that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
  
 Notification actions occur upon invocation of methods notify and notifyAll.

Memory that can be shared between threads is called shared memory or heap memory. All instance fields, static fields, and array elements are stored in heap memory. In this chapter, we use the term variable to refer to both fields and array elements. Local variables (Â§14.4), formal method parameters (Â§8.4.1), and exception handler parameters (Â§14.20) are never shared between threads and are unaffected by the memory model.
}
-------------------------------------------------
-------------------------------------------------
Java Value Types proposal:
https://www.infoq.com/news/2017/11/ValueTypesNov10
--------------------------------
JAVA Enhancements proposals:
http://openjdk.java.net/jeps/0
-------------------------------
REF: http://www.baeldung.com/java-completablefuture
  |In asynchronous computation, actions are represented as callbacks, handling errors might occur at any step.
  |
  |Java 5+: Future: Represent an asynchronous computation
  |Java 8+: CompletableFuture : Extends Future with methods to combine and handle errors
  |                            Extends the CompletionStage interface
  |                              - Contract for an asynchronous computation step that
  |                                can be combined with other steps.
  |                            About 50 different methods for composing, combining, executing async computation
  |
  |
  |Using CompletableFuture as a Simple Future (no-arg constructor) 
  |
  |In the example below we have a method that creates a CompletableFuture instance, then spins off some computation in another thread and returns the Future immediately.
  |
  |  1  public Future<String> calculateAsync() throws InterruptedException {
  |  2      Future<String> result = new CompletableFuture<>();
  |  3     
  |  4      Executors.newCachedThreadPool().submit(() -> {
  |  5          Thread.sleep(500);
  |  6          completableFuture.complete("Hello");
  |  7          return null;
  |  8      });
  |  9   
  |  10     return completableFuture;
  |  11 }
  |  Line 2: Alternatively when the result of computation is known:
  |          Future<String> result = CompletableFuture.
  |             completedFuture("Hello");
  |  
  |  Line 6: Alternatively completableFuture.cancel(false);
  |  Line 5: any other mechanism can be used to compute 
  |    
  |
  |  1 Future<String> completableFuture = calculateAsync();
  |  2  
  |  3 // ... 
  |  4  
  |  5 String result = completableFuture.get();
  |  6 assertEquals("Hello", result);
  |
  |Line 5: get() blocks until .complete("...") is called in other thread
  |Line 5: get()can raise 
  |           ExecutionException: error during computation
  |           InterruptedException: thread executing method interrupted
  |
  |4. CompletableFuture with Encapsulated Computation Logic (runAsync -<<Runnable>>-, supplyAsync -<<Supplier>>-)
  |
  |<<Supplier>>: generic functional interface with single method (zero arguments, returns value)
  |
  |  1 CompletableFuture<String> future
  |  2   = CompletableFuture.supplyAsync(/*supplier lambda*/ () -> "Hello")
  |  3 .thenApply(/* "processor" lambda */ s -> s + " World") /* returns CompletableFuture */;
  |  4 .thenAccept(/*consumer lambda */ 
  |  5    s -> System.out.println("Computation returned: " + s));
  |    Line 4: Alternatively (ignrore result)
  |    .thenRun(/*Runnable lambda*/ () -> System.out.println("Computation finished."));
  |
  |5. Combining Futures (monadic design pattern in functional languages)
  |
  |  1 CompletableFuture<String> completableFuture 
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCompose(
  |  4           s -> CompletableFuture.supplyAsync(() -> s + " World"));
  |  4  
  |  5 assertEquals("Hello World", completableFuture.get());
  |    
  |6. Execute two independent Futures and do something with their results
  |
  |  1 CompletableFuture future  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3     .thenCombine(CompletableFuture.supplyAsync(
  |  4       () -> " World"), (s1, s2) -> s1 + s2));
  |  5  
  |  6 assertEquals("Hello World", future.get());
  |    
  |(Simpler case - nothing to do with resulting value-)
  |  2   = CompletableFuture.supplyAsync(() -> "Hello")
  |  3   .thenAcceptBoth(CompletableFuture.supplyAsync(
  |  4      () -> " World"), (s1, s2) -> log(s1 + s2));
  |    
  |7. Running Multiple Futures in Parallel:  wait for all to execute and process combined results
  |
  |  1  CompletableFuture<String> future1  
  |  2    = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  CompletableFuture<String> future2  
  |  4    = CompletableFuture.supplyAsync(() -> "Beautiful");
  |  5  CompletableFuture<String> future3  
  |  6    = CompletableFuture.supplyAsync(() -> "World");
  |  7   
  |  8  CompletableFuture<Void> combinedFuture 
  |  9    = CompletableFuture.allOf(future1, future2, future3);
  |  10  
  |  11 // ...
  |  12  
  |  13 combinedFuture.get();
  |  14  
  |  15 String combined = Stream.of(future1, future2, future3)
  |  16   .map(CompletableFuture::join)
  |  17   .collect(Collectors.joining(" "));
  |  18 assertEquals("Hello Beautiful World", combined);
  |
  |    Line 16: join() is similar to get, but throws unchecked exception if the Future does not complete normally.
  |
  |8. Handling Errors
  |
  |   Instead of catching an exception in a syntactic block, the CompletableFuture class allows you to handle it in a special handle method. This method receives two parameters: a result of a computation (if it finished successfully) and the exception thrown (if some computation step did not complete normally).
  |
  |
  |
  |Capture async exception:
  |           
  |  1  CompletableFuture<String> completableFuture  
  |  2    =  CompletableFuture.supplyAsync(() -> {
  |  3        ... if(errorDetected) 
  |  4               throw new RuntimeException("Computation error!");
  |  6        return "Hello ";
  |  7    })}).handle((s, t) -> s != null ? s : "Hello, Stranger!");
  |  8   
  |  9  assertEquals("Hello, Stranger!", completableFuture.get());
  |Alt: 
  |  1  completableFuture.completeExceptionally(
  |  2    new RuntimeException("Calculation failed!"));
  |  3  ...  
  |  4  completableFuture.get(); // ExecutionException
  |                                                                            
  |9. Async Methods
  | - The methods without the Async postfix run next execution stage using a calling thread.
  |
  | - The Async method without the Executor argument runs a step using the common fork/join pool implementation of Executor 
  |   that is accessed with the ForkJoinPool.commonPool() method.
  |
  | - The Async method with an Executor argument runs a step using the passed Executor.
  |
  | Ex.: process result of computation with a Function instance
  |  1 CompletableFuture<String> completableFuture  
  |  2   = CompletableFuture.supplyAsync(() -> "Hello");
  |  3  
  |  4 CompletableFuture<String> future = completableFuture
  |  5   .thenApplyAsync(s -> s + " World");
  |  6  
  |  7 assertEquals("Hello World", future.get());
  |
  |    Line 5: under the hood the application of a function is wrapped into a ForkJoinTask instance 
  |    (for more information on the fork/join framework, see the article ?Guide to the Fork/Join Framework in Java?).
  |    This allows to parallelize your computation even more and use system resources more efficiently.

--------------
QA: 
  - Static analysis tool for Java / C/C++ / Objective C
       http://fbinfer.com/ 

  - FindBugs:

  - Junit:
    https://www.infoq.com/news/2018/01/VSCodeJunit

___________________________
Douglas Craigs Schmidt Java Lessons: 
https://github.com/douglascraigschmidt/LiveLessons
___________________________
Bug en Java: Boolean.parseBoolean   http://forums.java.net/jive/thread.jspa?threadID=55408
___________________________
Java Monitoring {{{
http://java.sun.com/developer/technicalArticles/J2SE/monitoring/
     ______
https://visualvm.github.io/
   VisualVM is a visual tool integrating commandline JDK tools and lightweight profiling capabilities.
   Designed for both development and production time use. 
}}}
___________________________
Terracotta Brings Real-Time Analytics to the (Java) Masses  http://www.nytimes.com/external/gigaom/2011/02/15/15gigaom-terracotta-brings-real-time-analytics-to-the-java-77320.html?partner=rss&emc=rss&mkt_tok=3RkMMJWWfF9wsRonu6vOZKXonjHpfsX54u8rWbHr08Yy0EZ5VunJEUWy2YUBWoEnZ9mMBAQZC811xR5KG%2BOaaJRB
___________________________
Non-Blocking I/O Made Possible in Java  http://www.developer.com/java/article.php/3837316/Non-Blocking-IO-Made-Possible-in-Java.htm
In this article we will review non-blocking IO, a feature of java.nio (New I/O) package that is a part of Java v1.4, v1.5 and v1.6 and introduce the java.nio.file (NIO.2) package. NIO.2 will be included in the upcoming Java SE7 ("Dolphin") release.

The Selector for Single-Thread Multi-Socket I/O

A Selector allows processing of multiple sockets I/O read & write operations in a single thread, also known as multiplexing, solving the
limitation of 'one dedicated thread per socket connection.' It manages SelectableChannels (gateway for registering/deregistering channels), 
SelectionKeys (glue that associates Selectors, Channels and their I/O events) and monitors concurrent thread executions involved in network operations.
___________________________
Thread Synchronization  http://www.artima.com/insidejvm/ed2/threadsynch.html
Inside the Java Virtual Machine http://www.artima.com/insidejvm/ed2/index.html
___________________________
Tribe: Unlike JGroups, Tribe only targets reliable multicast (no probabilistic delivery) and is optimized for cluster communications.   http://tribe.ow2.org/
JGroups is a toolkit for reliable multicast communication.  http://www.jgroups.org/
________________
JSRs: Java Specification Requests
JSR 305: Annotations for Software Defect Detection

____________________
Jooq, the easiest way to write SQL in java:
https://www.jooq.org/
____________________
Java async frameworks:

Spring Reactor:

  https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html

  """Why Reactor when there's already RxJava2?

   RxJava2 is java 6 while for Reactor the Spring team decided to go all in and focus only on Java 8. This means that you can make use of all the new and fancy Java 8 features.

If you are going to use Spring 5, Reactor might be the better option.

But if you are happy with your RxJava2, there is no direct need to migrate to Reactor."""

https://spring.io/blog/2013/05/13/reactor-a-foundation-for-asynchronous-applications-on-the-jvm

https://spring.io/guides/gs/async-method/
____________________

Apache MINA vs Netty: https://www.youtube.com/watch?v=A2pWsxPWJuc

Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily. It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and UDP/IP via Java NIO.

Apache MINA is often called:

    NIO framework library,
    client server framework library, or
    a networking socket library

Apache MINA comes with many subprojects :

    Asyncweb : An HTTP server build on top of MINA asynchronous framework
    FtpServer : A FTP server
    SSHd : A Java library supporting the SSH protocol
    Vysper : An XMPP server

- - - - - - - - - - - -
________________
https://github.com/akullpp/awesome-java
_______
Project Loom:
Project Loom's mission is to make it easier to write, debug, profile and maintain concurrent applications meeting today's requirements. Threads, provided by Java from its first day, are a natural and convenient concurrency construct (putting aside the separate question of communication among threads) which is being supplanted by less convenient abstractions because their current implementation as OS kernel threads is insufficient for meeting modern demands, and wasteful in computing resources that are particularly valuable in the cloud. Project Loom will introduce fibers as lightweight, efficient threads managed by the Java Virtual Machine, that let developers use the same simple abstraction but with better performance and lower footprint. We want to make concurrency simple(r) again! A fiber is made of two components — a continuation and a scheduler. As Java already has an excellent scheduler in the form of ForkJoinPool, fibers will be implemented by adding continuations to the JVM.

RELATED: http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf
_______
Google Guava:
_______
Java to Javascript transpiler:
JSweet.org

http://teavm.org/
"https://en.wikipedia.org/wiki/Java_virtual_machine#Compilation_to_JavaScript

""Main JVM bytecode to JavaScript compilers are TeaVM,[20] the compiler contained in Dragome Web SDK,[21] Bck2Brwsr,[22] and j2js-compiler.[23]"""
-------------------------------------------------

_________________
    <li>JAVA 8+ <a href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>Ref</a>
    <table xxsmall>
    <tr>
    <td>@NonNull</td>
    <td>compiler can determine cases where a code path might receive a null value, 
        without ever having to debug a NullPointerException. The compiler just print a warning, but it continues to compile!!!</td>
    </tr>
    <tr>
    <td>@ReadOnly </td>
    <td>compiler will flag any attempt to change the object. This is similar to Collections.unmodifiableList, 
    but more general and verified at compile time.</td>
    </tr>
    <tr>
    <td>@Regex</td>
    <td>Provides compile-time verification that a String intended to be used as a regular expression is a properly formatted 
    regular expression.</td>
    </tr>
    <tr>
    <td>@(Un)Tainted</td>
    <td>Identity types of data that should not be used together, such as remote user input being used in 
    system commands, or sensitive information in log streams</td>
    </tr>
    <tr>
    <td>@m</td>
    <td>Units of measure ensures that numbers used for measuring objects are used and compared correctly, or have undergone the
    proper unit conversion.</td>
    </tr>
    <tr>
    <td>@FunctionalInterface</td>
    <td>indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Spec.</td>
    </tr>
    </table> 
    Ex:
<pre xxsmall>
Annotation                                         Meaning
@NonNull List<String>                              A non-null list of Strings.
List<@NonNull String>                              A list of non-null Strings.
@Regex String validation = "(Java|JDK) [7,8]"      Check at compile time that this String is a valid regular expression.
private String getInput(String parameterName){     The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval = 
      @Tainted request.getParameter(parameterName);
  return retval;
}
        
private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
  ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

  Process process = processBuilder.start();
}
</pre>
  </li>
<td>
Java Cryptographic API (JCA)
  <a href="./BCFipsIn100.pdf">Bounce Castle FIPS JCA provider</a>
</td>
________________
https://picodotdev.github.io/blog-bitix/
__________________
https://dzone.com/articles/5-things-java-programmer-should-learn-in-2018
 - Java Performance Tuning
 - Profile Your Java application Once a Month
 - Java 9 
 - Spring 5.0
 - Spring Security 5.0
___________________
[QA] SonarQube
-->

</html>
