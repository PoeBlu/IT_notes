<html>
   <meta charset="UTF-8">
   <title>Maven Map (v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table>

</tr }>
<tr {>
  <td>
  <b>Building blocks</b><br/>
  Goal<br/>
  <span xxxsmall zoom>
    unit of work. A goal accepts configuration properties (parameters) to customize its run-time behavior<br/>
      Ex: Compiler:compile defines a set of parameters to specify target JDK version or switching on/off compiler optimizations<br/>
      An ordered list of goals can be attached to a lifecycle phase. <br/>
      Ex: mvn package is equivalent to:
          resources:resources > compiler:compile >
           resources:testResources >  compiler:testCompile >
            surefire:test jar:jar
  </span>
  <br/>
  Snapshots<br/>
  <span xxxsmall zoom>
<span xxbig>Q: What exactly is a Maven Snapshot and why do we need it?</span><br/>
A: <span xbig>A snapshot version is one that has not been released (<b orange>future release</b>)</span>.<br/>
   The idea is that <b>before</b> a "1.0" release is done, there exists
   a 1.0<b orange>-SNAPSHOT</b>. That version is what might become 1.0. It's
   basically <b orange>"1.0 under development"</b>. This might be close to a real
   1.0 release, or pretty far (right after the 0.9 release, for ex.)<br/>

   The difference between a "real" version and a snapshot version is
   that <b>snapshots might get updates</b>.  That means that downloading
   1.0-SNAPSHOT today might give a different file than downloading it
   yesterday or tomorrow.<br/>
   In contrast <b orange>Released versions are inmutables</b>:<br/>
   updates to "1.0.0" requires new version "1.0.1".<br/>
   <br/>
   Snapshot dependencies should only exist during development.
   <b>Released versions (i.e. no non-snapshot) should NEVER have a
   dependency on snapshots</b>
<pre { >
&lt;repository>
    ...
    &lt;snapshots>
        &lt;enabled>true&lt;/enabled>
        &lt;updatePolicy>
          always|daily(default)|
          "X"minutes|never
        &lt;/updatePolicy>
    &lt;/snapshots>
&lt;/repository>
</pre } >
  </span>
  MAVEN DEFAULT LIFECYCLE
<pre xxxsmall zoom { >
process-resources
 compile
  process-classes
   process-test-resources
    test-compile
     test
      prepare-package
       package
        install
</pre } >
  </ul>
</td>
  <td  >
  Compiling/Installing
<pre xxxsmall zoom { >
$ mvn clean install
  ( clean>compile>test>package>install_local )
$ mvn clean install -Dmaven.test.skip=true
  ( clean>compile>     package>install_local )
$ mvn clean deploy
  ( clean>compile>     package>install_local>install_pub )
-----------------------------------------------------------
Common options:
 –U  Force library (download) update
 –P xxx Execute profile xxx
 –o offline mode. Search deps in local repo.
-----------------------------------------------------------
help:active-profiles   : List (project|user|global)
                        active profile for the build
help:effective-pom     : Displays effective POM for
                          current build
help:effective-settings: Prints calculated settings 
help:describe groupId artifactId: Describes plugin attributes
</pre } >
   <br/>
   Managing dependencies
   <ul xxxsmall zoom >
   <li>
     <code xbig>$ mvn dependency:analyze</code> <br/>
     list two things:
     <ol>
       <li>Dependencies used but not declared.
           If found in the parent pom, there is no
           problem when compiling, but must be
           included at runtime on the server.
      </li>
      <li>Dependencies declared but not used for
          the scope provided (compile, provided…).
          They can be in the parent pom too.
          Noneless, can be needed at runtime.
      </li>
    </ol>
   </li>
   <li><code xbig>$ mvn dependency:tree</code></li>

</td>
  <td  >
  POM BEST PRACTICES:<a href='http://geertschuring.wordpress.com/2011/02/23/maven-best-practices/'>Ref</a>
  <ol xxxsmall zoom >
      <li>
   Replace references like ${artifactId} or ${pom.artifactId} with new
   ${project.artifactId} syntax. This syntax follows the XML document
   structure, making it easy to remember and predict the value that the
   reference will result in.
      </li>
      <li>
   Try to avoid using inherited properties. Developers can easily forget
   that a certain property is used by a child POM and change the value
   breaking the build in an unexpected place. Secondly, its quite annoying
   not to be able to easily lookup a property without having to find
   and examine the parent POM.
      </li>
      <li>
   Use the dependency management section of the parent pom to define
   all dependency versions, but do not set a scope here so that all
   dependencies have scope compile by default.
      </li>
      <li>
   Use properties to define the dependency versions. This way you can
   get an overview of all versions quickly.
      </li>
      <li>
   Use the pluginmanagement section of parent pom to define versions for
   *all* plugins that your build uses, even standard maven plugins like
   maven-compile-plugin and maven-source-plugin. This way your build will
   not suddenly behave differently when a new version of a plugin is released.
      </li>
      <li>
   When using a parent POM not located in the directory directly above
   the current POM define an empty relativePath element in your parent section.
      </li>
      <li>
   Use the dependency plugin to check your project for both unnecessary
   dependencies and undeclared-but-used-none-the-less dependencies.
   The goal is called ‘analyze’, so run the following command on the
   console: “mvn dependency:analyze
      </li>
      <li>
   Make sure the pom files contain all the repository references needed
   to download all dependencies. If you want to use a local repository
   instead of downloadin strait from the internet then use the maven
   settings file to define mirrors for the individual repositories that
   are defined in the poms.
      </li>
      <li>
   If you use Nexus, then do not create repository groups containing both
   hosted and proxied repositories. This will dramaticly reduce the
   responsiveness because Nexus will check the remote locations of the
   proxied repositories even if a hosted repository contains the requested
   artifact.  
      </li>
    </ol>
</td>
</tr } >
</table>

<table>
<tr {>
  <th header_delimit >Common tasks</th>
</tr }>
</table>
<table>
<tr {>
  <td summa >
    Create new skeleton project:
    <ul xxxsmall zoom >
<pre { >
mvn archetype:generate -DgroupId=my.groupId \
   -DartifactId=myArtifact \
   -DarchetypeArtifactId=maven-archetype-quickstart \
   -DinteractiveMode=false
</pre } >
  
    Show ordered list of goals executed by a maven phase:<br/>
    Very useful to skip slow/non-important goals like doc, style-checks,...
<pre { >
$ mvn fr.jcgay.maven.plugins:buildplan-maven-plugin:list \
  -Dbuildplan.tasks=install
</pre } >
    Quick local install bypassing tests/style-checks/...
<pre { >
 $ mvn resources:resources \
       compiler:compile \
       jar:jar \
       install:install
</pre } >
</td>
  <td col1  >
    Add source/test directory<br/>
    (ex., tool generated sources):
<pre xxxsmall zoom { >
&lt;build>
   ...
   &lt;sourceDirectory>
     src/main/generated_java
   &lt;/sourceDirectory>

   &lt;testDirectory>
     src/functionalTest/java
   &lt;/testDirectory>

&lt;/build>
</pre }>
  </td>
  <td>
  <b>pom.xml</b><br/>
  parent / child pom relationship
<pre xxxsmall zoom { >
.../parent/pom.xml              | .../parent/child1/pom.xml

&lt;modelVersion>4.0.0             | &lt;parent>
&lt;/modelVersion>                 |   &lt;groupId>...&lt;/groupId>
&lt;groupId>....&lt;/groupId>         |   &lt;artifactId>parent&lt;/artifactId>
&lt;artifactId>parent&lt;/artifactId> |   &lt;version>1&lt;/version>
&lt;version>0.1.0&lt;/version>        |   &lt;relativePath>
&lt;packaging>pom&lt;/packaging>      |      ../pom.xml&lt;/relativePath>
                                | &lt;/parent>
                                | &lt;dependecies>
&lt;modules>                       |   &lt;dependency>
  &lt;module>./child1&lt;/module>     |     &lt;groupId>...&lt;/groupId>
  &lt;module>./child2&lt;/module>     |     &lt;artifactId>...&lt;/artifactId>
&lt;/modules>                      |   &lt;/dependency>...
                                | &lt;/dependecies>
&lt;dependencyManagement>          |
  &lt;dependencies>                |
  &lt;dependency>                  |
    &lt;groupId>...&lt;/groupId>      |
    &lt;artifactId>...&lt;/artifactId>| no need to repeat version/scope
    &lt;version>X.Y.Z&lt;/version>    | in childs
    &lt;scope>compile&lt;/scope>    &lt;-| compile | provided
  &lt;/dependency>...              |
  &lt;dependencies>                |
&lt;/dependencyManagement>
</pre } >
  </td>
  <td summa TODO >
  Continuous Integration Best practices
  <a href="http://www.sonatype.com/people/2009/01/maven-continuous-integration-best-practices/">REF</a>
  </td>
  <td summa >
    <b>Others</b><br/>
    Install non-mavenized jar library:
<pre xxxsmall zoom { >
mvn install:install-file -Dfile=<path to local file> -DgroupId=<groupIf> \
   -DartifactId=<artifactId> -Dversion=<version> -Dpackaging=<packaging>
</pre } >
</tr }>
</table>
</body>
<!--

1.1	Ejecuciones multi-módulo (reactor de Maven)
Maven soporta tanto herencia como agregación de proyectos. La herencia se materializa estableciendo como padre de un proyecto a otro. La agregación (agrupación de proyectos), mediante el mecanismo que se conoce como "reactor".
El reactor es la parte del core de Maven que permite ejecutar un goal sobre un conjunto de proyectos. Mientras los módulos son unidades diferenciadas de trabajo, se puede hacer un build sobre un grupo de módulos mediante el reactor. El reactor determina el orden adecuado del build de los módulos basándose en las dependencias definidas en el pom de cada proyecto, y ejecuta una serie de goals sobre ellos. Se puede usar tanto para builds como para otros goals (por ejemplo, site generation).
Resumiendo, el reactor es lo que hace posible las ejecuciones maven multi-módulo: genera el grafo de dependencias entre módulos, obtiene de dicho grafo el orden de ejecución y ejecuta entonces los goals sobre los módulos. Se pueden utilizar indistintamente los términos "ejecución multi-módulo" y "ejecución reactor".
En Maven 2 se mejoró bastante el soporte de ejecuciones multi-módulo y el reactor se transformó en algo transparente a los usuarios de Maven. De cualquier forma, existe un plugin para personalizar la interacción con el reactor si así se desea: maven-reactor-plugin.


Si lanzamos la compilación de un multi-módulo (como AbsisParentPom) y falla, siempre podemos reanudar desde el último módulo que falló activando el flag --resume-from ó -rf, como en el siguiente ejemplo:
mvn --resume-from=es.lacaixa.absis:AbsisContext clean install -P OFI-COM -DskipTests=true
que es lo mismo que:
mvn -rf=es.lacaixa.absis:AbsisContext clean install -P OFI-COM -DskipTests=true
i



1.	Anexo I: Best Practices
Se incluyen algunas best practices recomendables para evitar problemas y facilitar el mantenimiento de los Poms.
1.1	Best Practices para mantenimiento de Poms
Sacados del artículo: http://geertschuring.wordpress.com/2011/02/23/maven-best-practices/
Estas son:
1.	Dont use deprecated references like ${artifactId} or ${pom.artifactId}. Use the new ${project.artifactId} syntax. Note that this syntax follows the XML document structure, which makes it easy to remember and predict the value that the reference will result in.
2.	Try to avoid using inherited properties. Developers can easily forget that a certain property is used by a child POM and change the value breaking the build in an unexpected place. Secondly, its quite annoying not to be able to easily lookup a property without having to find and examine the parent POM.
3.	Use the dependencymanagement section of the parent pom to define all dependency versions, but do not set a scope here so that all dependencies have scope compile by default.
4.	Use properties to define the dependency versions. This way you can get an overview of all versions being used without having to scroll through multiple pages of dependency sections.
5.	Use the pluginmanagement section of the parent pom to define versions for *all* plugins that your build uses, even standard maven plugins like maven-compile-plugin and maven-source-plugin. This way your build will not suddenly behave differently when a new version of a plugin is released.
6.	When using a parent POM that is not located in the directory directly above the current POM define an empty relativePath element in your parent section.
7.	Use the dependency plugin to check your project for both unnecessary dependencies and undeclared-but-used-none-the-less dependencies. The goal is called analyze, so run the following command on the console: mvn dependency:analyze
8.	Make sure the pom files contain all the repository references needed to download all dependencies. If you want to use a local repository instead of downloadin strait from the internet then use the maven settings file to define mirrors for the individual repositories that are defined in the poms.
9.	If you use Nexus, then do not create repository groups containing both hosted and proxied repositories. This will dramaticly reduce the responsiveness because Nexus will check the remote locations of the proxied repositories even if a hosted repository contains the requested artifact.
1.2	Best Practices de Sonatype para Integración  Continua
Son las best practices recomendadas por Sonatype para mantener un entorno estable y funcional de Integración Continua. Estan recogidas en la URL: 
http://www.sonatype.com/people/2009/01/maven-continuous-integration-best-practices/

#1 Automate Snapshot Deployment
In my experience, it is best to let your CI system deploy your snapshots. This is the most reliable way to guarantee that the contents of your repository are kept in sync with your source control system. In order to do this in a practical way, you need to couple CI with a repository manager like Nexus that can automatically purge snapshots. Ive managed projects that produced >300gb of snapshots in less than a week. Using a repository manager will save your sanity.

#2 Isolate Local Repostitories
Another critical component of a good CI setup is local repository isolation. The local repository in Maven is the temporary holding spot for all artifacts downloaded and produced by Maven, and it is not currently setup to be multi-process safe.   There is a remote possibility of a conflict, but it does exist.
The main reason I like to have a local repository per project is that its the only way to test that your project is build-able against the artifacts in the corporate repository. If you dont have separate local repos, then the product on one build will be seen by another build on CI, even if its not in the corporate repository. This is important since one function of CI should be to validate that the code is buildable by a real developer.
Tip: use -Dmaven.repo.local=xxxx to define the unique local repositories for each build.
#3 Regularly Purge Local Repositories
To further validate the contents of the repository, and to manage the disk space, I purge the local repostories every night. This way if changes in the repository or artifacts are removed, the CI system will detect this. To keep it easy to purge all the local repositories, I tend to structure them under a single common folder such as /opt/repos/*.
Obviously having many local repositories requires more disk space than a single monolitic one due to dependency duplication, but even on our large grid the repos are less than 10gb total. Local repos get giant when you dont control the snapshots and purging them nightly keeps this under control.
Tip: use your CI system itself to schedule the local repo cleanup. This way anyone can clean the repos manually right from the UI if Maven gets confused.

#4 Enable Batch Mode
Tip: Enable -B (batch) mode on the build. This will make the logs shorter since it avoids the dependency download progress logging. It also ensures that the build wont hang due to waiting for user input. (to enable globally in settings.xml:<interactiveMode>false</interactiveMode>)

#5 Enable Full Stack Traces
Tip: Enable -e to cause Maven to produce the full stack trace if theres a build exception. This will make it easier to comprehend any problems in the resulting build failure log/email without having to build it again.

#6 Print Test Failures to Standard Output
Tip: Enable -Dsurefire.useFile=false. This is a favorite of mine since this causes surefire to print test failures to standard out, where it will get included in the build failure log and email. This saves you from having to dig back onto the machine to find the surefire report just to see a simple stack trace. (to enable globally in settings.xml:<properties><surefire.useFile>true</surefire.useFile></properties> in an active profile)

#7 Always check for Snapshots
Tip: Enable -U to cause Maven to always check for new snapshots. (to enable globally in settings.xml: <updatePolicy>always</updatePolicy>.this goes on a repository definition) 

 
2.	 

Hay 3 lifecycle estándar definidos en Maven:
- clean: gestiona la limpieza del proyecto
- default (conocido como build lifecycle): gestiona la compilación, tests y deployment del proyecto
- site: gestiona la generación y despliegue del site de documentación del proyecto

i


Sentencia	Descripción
mvn clean	Borra la carpeta target
mvn compile	Compila el proyecto
mvn clean package	Compila y genera el JAR
mvn clean install	Compila y copia la librería en el repositorio LOCAL
mvn clean deploy	Compila y copia la librería en el repositorio CORPORATIVO
mvn[] U	Fuerza update de las librerías, descargándolas de nuevo
mvn[] P xxx	Ejecuta el profile xxx
mvn o []	Modo offline para que busque dependencias en repositorio local, estas deben tener el pom correctamente instalado
mvn[] -Dgenerate.pom=true	Genera el pom en local de un artefacto al instalarlo o compilarlo. MUY UTIL para que funcione modo OFFLINE



-->
</html>
