<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Cryptography map(beta)</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->

<table style='width:100%'{>
<tbody>

<tr {>
  <th colspan=3 header_delimit }   >Building blocks</th>
</tr }>
<tr {>
  <td>
     <b>Symmetric primitives</b>
<pre xxxsmall zoom {>
Plain -> |Encrypt|-> C1 -> |Decrypt| -> Plain
             ^                  ^
             └─ KEY("Secret") ──┘
</pre>
     Symmetric cyrptography broadly splits into:
     <ul xxxsmall zoom>
       <li><code orange>Stream cipher</code>: inputs of "any lenght". Very difficult to implement properly<br/>
           Implementations: ChaCha, ...
           <pre { >
  INPUT     -> |Keystream | -> K0, K1, ...
(KEY, NONCE)   |Generator |           -> XOR -> C0, C1, ...
                               M0, M1, ... 
</pre } >
           "BUTS": Generate a safe (non predictive) KEY for the stream cipher is "difficult"
       <li><code orange>Block cipher</code>:  inputs must be divided into chunks of same size</li>
       <li>Hide plaintext transformation to ciphertext through:
          <ul>
            <li>*confusion*: mapping input to output hard to predict (not linear and parts of keys)</li>
            <li>*diffusion*: permutate bits</li>
          </ul>
       </li>
       <li><code orange>SP-Networks</code>:  Most block ciphers are based on SP-Networks composed of:
          <ul>
            <li>Subtitution box : "map<byte, byte>"   (replace bytes with bytes )</li>
            <li>Permutation box :  moves bits around</li>
            <li>Some substitution plus permutation are combined into a single round</li>
            <li>Rounds are then repeated enough times to ensure the algorithm is secure</li>
          </ul>
       </li>
       <li>SP-Networks alone are not enought. KEY secret is used like:
<pre>
                 ROUND1                  ROUND2
Plain -> XOR -> |Subsitution| -> XOR -> |Subsitution| -> C
         KEY    |Permutation|    KEY    |Permutation|
</pre>
       </li>
       <li><code orange>AES</code>: SP-Network based (Advanced Encryption Standard).
          <ul>
            <li>"Almost every block cipher uses AES". Supersedes DES (2002 Standard)</li>
            <li>Built around Rijndael (SP-Network with 128bit block size) and key length of 128,192, 256 bit</li>
            <li>Round count depends on key lenght: 10, 12 or 14 cycles</li>
            <li>Each Round: SubBytes, ShiftRows, MixColumns</li>
          </ul>
       </li>
       <li><code orange>Padding</code>: used when the message does exactly match a multiple of key size.</li>
       </ul>
  Modes of operation:
  <ul xxxsmall zoom >
  <li>Electronic code block (ECB):<br/>
     (WARN: Don't use it, if different messages share same data information leaks cans rise)
<pre { >
M1 -> |E_k| -> C1
M2 -> |E_k| -> C2
M3 -> |E_k| -> C3
</pre } >
       </li>
       <li>Cipher block chaining (CBC):
<pre { >
IV: Initialization vector
M1 -> |XOR(IV)| -> |E_k| -> C1
   -> |XOR(M2)| -> |E_k| -> C2 
   -> |XOR(M3)| -> C3
</pre } >
    "BUTs": 
    <ul>
      <li>Not paralelizable , and can not seek randomnly</li>
      <li>Needs an IV (Difficult to generate)</li>
    </ul>
  </li>
  <li>Counter Mode (CT):(Can be paralellized)
<pre { >
            Nonce + 0 -> |E_k| -> XOR(M1) -> C1
            Nonce + 1 -> |E_k| -> XOR(M2) -> C2
            Nonce + 2 -> |E_k| -> XOR(M3) -> C3
</pre } >
  </li>
  <li>Noces are used *once* <br/>
      IVs must be *unpredictable*
  </li>
  </ul>
  </td>  
  <td>
     <b>Asymmetric private-public key primitives</b>
     <ul xxxsmall zoom>
       <li>Two keys, public and private where Public Key can be computed easely from private key
           but the inverse in infeasible (intractable mathematical problem).<br/>
           WARN: Quantum computer will totally defeat it
       </li>
       <li>Signing "==" Encrypt using private key<br/>
         Enyone can decrypt using pub.key.</br>
         Signing probides:</br>
         <ul>
           <li>Non repudiability: Private key owner can not neglect having signed</li>
           <li>Non tampering:message can not be moddified by third parties without the priv.key</li>
         </ul>
</pre>
       </li>
       <li>Encrypt  "==" (one-directional) encrypt using public key<br/>
           One-directional: Only private key owner can de-encrypt. Priv.key owner can not encrypt, only sign
       </li>
       <li>Diffie-Hellman: two non-local parties can jointly agree a shared secret over an insecure channel
         <ul>
           <li>DH-KEX (Key exchange) Underpins almost every aspect of our modern lives!</li>
           <li>DH security is based first on "very big numbers", with 4096 bits becoming more ussual.</li>
           <li>The DH-KEX generated shared-secret is usually called the "pre-master secret"</li>
           <li>It's used to derive session keys through hashing for example</li>
           <li>Ephemeral Mode. DH is used only for minutes/hours and not stored.</li>
         </ul>
       </li>RSA: 
         <ul>
           <li>provides encryption and/or authentication</li>
           <li>RSA provides us with Public (e,n) and Private (d)<br/>
               - e is usally a small number, <br/>
               - d is a much large number<br/>
               - n is avery large semi-prime number n=p.q <br/>
           </li>
           <li>Can be used for encription (using pub key) and signing (using the private key)</li>
           <li>It's compatible with integer prime number factorization, not with elliptic curves</li>
         </ul>
       <li>DSA: 
         <ul>
           <li>Can be used for signing (using the private key) only, NOT for encryption</li>
           <li>It's compatible with integer prime number factorization and  elliptic curves</li>
         </ul>
       </li>
     </ul>
  </td>  
  <td>
     <b>Hash Function primitives</b>
     <ul xxxsmall zoom>
       <li>takes message of any lenght, and returns a pseudoramdom hash of fixed length
<pre { >
┌─── Loop ←──┐
│            │
Block of   Current ──→ Final hash
message     Hash
└──────>─────┘
</pre } >
       </li>
       <li>HMAC: An attacker doesn't know the shared KEY so he can not add the correct HASH
<pre { >
PlainText -> |Symetric(KEY)| -> CipherText 

CipherText + HASH(KEY+CipherText)
</pre } >
       </li>
       <li>Digital Signatures: Hashing + Pub.Key
<pre>
Signer                   
Document -> hash -> sign 

Verifier
Document -> hash -> verify signature
</pre>
         <ul>
           <li>Prove authenticity of sender</li>
           <li>Used both in RSA and DSA</li>
         </ul>
       </li>
     </ul>
  </td>  
</tr }>
</table>

<table>
<tr {>
  <th colspan=3 header_delimit {   >OpenSSL Certificate Handling, 
    <span xsmall>See also: <a href="https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf">
         The Most Dangerous Code in the World: Validating SSL Certificates 
         in Non-Browser Software</a></span>
  </th>
</tr }>
<tr {>
  <td>
  Global Flow:
<pre xxxsmall zoom>
admin->admin: Create Private Key
admin->admin: Create CSR
alt
  admin->admin: Create self-certificate
else:
  admin->CA   : CSR
  CA->CA      : Create certificate
  CA->amdin   : certificate
</pre>
<br/>
Certificate Signing Request<span xxbig>(CSR)</span>:=
<pre xxxsmall zoom >
    PUBLIC KEY  
  + Distinguised Name (DN) :=
       + Common Name (CN)
         (SHOULD be the exact 
          Fully Qualified Domain Name (FQDN) 
          of the host)
       + "additional info
          about organization"
</pre>

  <li>useful ENV.VAR (DOMAIN/SUBJ):
<pre xxxsmall zoom { >
$ export DOMAIN="mydomain.com"
$ export SUBJ=""
$ export SUBJ="${SUBJ}/C=ES"
$ export SUBJ="${SUBJ}/ST=Aragon"
$ export SUBJ="${SUBJ}/L=Zaragoza"
$ export SUBJ="${SUBJ}/O=MyOrganization"
$ export SUBJ="${SUBJ}/CN=${DOMAIN}"
</pre }>
  Creating a CSR (<code>-new</code>)
<pre xxxsmall zoom { >
$ openssl req \
   -new \
   -nodes 
   -newkey rsa:2048 \
   -keyout ${DOMAIN}.key \
   -out ${DOMAIN}.csr -subj "${SUBJ}"

(replace <code>-newkey rsa:.... -keyout...</code> by
 <code>-key ${DOMAIN}.key</code>) to use already existing private key)
)
</pre }>
  </td>  

  <td>
  Create autogenerated Self-Signed-Certificate (<code>-x509</code>):<br/>
  Note: <code>-nodes</code> flag: *DO NOT* pass-phrase-encrypt Pub.Key
  <ul xxxsmall zoom>
  <li>
      From new priv.key:
<pre { >
$ openssl req \
    -nodes \
    -newkey rsa:2048 -keyout ${DOMAIN}.key \
    -x509 \    # <- self signed
    -days ${DAYS_TO_EXPIRE} \
    -out ${DOMAIN}.crt -subj "${SUBJ}"
</pre }>
  Note 1: replace <code>-newkey rsa:.... -keyout...</code> by
    <code>-key ${DOMAIN}.key</code>) to use already existing private key)<br/>
  Note 2: replace <code>-new</code> by
    <code>-in ${DOMAIN.csr}</code>) to use already existing CSR<br/>
  </li>
  </ul>
  Managing Private Keys
  <ul xxxsmall zoom>
  <li>CREATE A PRIVATE KEY:
<pre {>
$ openssl \
    genrsa -des3 \
    -out ${DOMAIN}.key 2048
(Enter password when prompted)
</pre }>
  </li>
  <li>Verify (-check) Private Key:
<pre {>
$ openssl rsa -check -in ${DOMAIN}.key
</pre }>
  </li>
  <li>Verify private key matches certificate and CSR:<br/>
   (If the output of each of the next command is identical there is an
    extremely high probability that the private key, certificate, and CSR are related)
<pre {>
$ openssl rsa  -noout -modulus -in ${DOMAIN}.key | openssl md5
$ openssl x509 -noout -modulus -in ${DOMAIN}.crt | openssl md5
$ openssl req  -noout -modulus -in ${DOMAIN}.csr | openssl md5
</pre }>
  </li>
  <li>Encrypt/Decrypt private key
<pre {>
$ openssl rsa -des3 -in unencrypted.key -out encrypted.key
$ openssl rsa       -in encrypted.key   -out decrypted.key
</pre }>
  </li>
  </ul>
  </td>  
  <td>
  CONVERTING certs FORMATS (Defaults to PEM):</span><br/>
<pre xxxsmall zoom{>
  (PKCS7 files, also known as P7B, are typically used in Java Keystores and 
  Microsoft IIS (Windows).  They are ASCII files which can contain certificates
  and CA certificates.)<br/>
   (PKCS12 ( also known as PFX files) are typically used for import/export 
  certs-chains in Micrsoft IIS)
# PEM   -> DER
$ openssl x509 -in ${DOMAIN}.crt -outform der -out ${DOMAIN}.der
# DER   -> PEM
$ openssl x509 -inform der -in ${DOMAIN}.der -out ${DOMAIN}.crt
# PEM   -> PKCS7
$ openssl crl2pkcs7 -nocrl -certfile ${DOMAIN}.crt
   -certfile ca-chain.crt -out ${DOMAIN}.p7b
# PKCS7 -> PEM
$ openssl pkcs7 -in ${DOMAIN}.p7b -print_certs -out ${DOMAIN}.crt
# PEM -> PKCS12
$ openssl pkcs12 -inkey ${DOMAIN}.key \
   -in ${DOMAIN}.crt -export -out ${DOMAIN}.pfx
# PKCS12 -> PEM 
$ openssl pkcs12 -in ${DOMAIN}.pfx -nodes -out ${DOMAIN}.combined.crt
</pre }>
  </td>  
  <td>
  <b>Recipes</b><br/>
  list openssl version and build options:
<pre>$ openssl version -a</pre>
  Download (first in chain) certificate from webpage and add to Java keystore:
<pre xxxsmall zoom {>
$ openssl s_client \
   -connect www.mywebsite.com:443 \  
   -showcerts </dev/null 2>/dev/null | \
  openssl x509 \
    -outform PEM > infura-morden.pem
$ ($JAVA_HOME/Contents/Home/jre/bin/)keytool \
    -import -noprompt -trustcacerts \
    -alias www.mywebsite.com -f
</pre }>
    View(-text) AND Verify (-verify) CSR:
<pre xxxsmall zom {>
$ openssl req \
  -text  \
  -noout \
  -verify -in ${DOMAIN}.csr
</pre }>
   Verify that cert. was signed by a CA:</span>
<pre xxxsmall zoom {>
$ openssl verify \
   -verbose \
   -CAFile ca.crt \
   ${DOMAIN}.crt
</pre }>
  </td>  
</tr }>
</table>
<!--
<tr {>
  <th colspan=3 header_delimit {   >Protocols</th>
</tr }>
  - Authenticated Encryption - AEAD
  - Handshake Phase Agree on a set of crypto. protocols AES 128, ECDH, RSA,...

Common protocol issues
 - ciphertext that aren't secured with a MAC
 - message taht don't include a time-stamp or counter
 - protocols that don't use PK for authenticity
 - Reuse of Nonces of IVs
 - ... many more
 => Don't do it yourself. => use well-established ones.
    (TLS, ...)

-->
<!--
<tr {>
  <th colspan=3 header_delimit } { >Dont's</th>
</tr }>
<tr {>
  <td col1 >
DONT'S:
- Don't Implement your own algorithms
- Don't Use hard-coded keys, 
- Implement your own algorithms
- Never use ECB mode. Prefer CBC, better yet CTR or GCM
- Don't use small public key sizes. At least 2048. 
  Elliptic curve preferable: p-256 or X25519

</tr }>
-->
</body>
<!--
NOTE: Ussually integrity (not being able to tamper the chiper text) is as important as confidentiality
   Python https://cryptography.io

    Recipes - Fernet
              X.509
    
    Hazardous
    Materials   Symmectric                             Quantum computer resiliant
                Asymmetric  -> (AES, ChaCha20, 3DES)   Quantum computer vulnerables
                Hashing
                MACs


   Public Key infraestructe:
     - A trusted CA (whose pub.key is known to browsers,...) signs confirming
   that another public key belongs to amazon,....
     - X.509 v3:
       - organised by PKI
       - standard for digital certificates hold info. on type,subject,issuer
       - Issuer will be a trusted third party (Verisign,Globalsign)
       Version#
       Serial Number
       Signature algorithm
       Issuere name
       Validity period
       Subject name
       Subject PK Info
       Issuer ID#
       Subject ID#
       Extensions
       __________
       CA Signature

___________________
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a>

________________
Block cipher mode of operation: A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block.[2] A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.[3][4][5].  Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key.[6] Block ciphers have one or more block size(s), but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be padded to a full block if it is smaller than the current block size.[2] There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher.
________________________
https://en.wikipedia.org/wiki/Security_token

https://en.wikipedia.org/wiki/Hash_chain

https://en.wikipedia.org/wiki/Linked_timestamping

https://en.wikipedia.org/wiki/Skip_list
________________________


<a href="https://en.wikipedia.org/wiki/PKCS">PKCS</a>: Set of "high-level" "Public Key Cryptography Standards". 
  PKCS #1  Defines math. properties and format of RSA pub/priv. keys,
           and basic algorithms and encoding/padding schemes for 
           RSA (de/en)cryption,  producing/verifying signatures.
  PKCS #3  Diffie–Hellman Key Agreement Standard
  PKCS #5  Password-based Encryption Standard
  PKCS #7  Cryptographic Message Syntax Standard. Used to sign and/or encrypt messages under a PKI
  PKCS #8  Used to carry private certificate keypairs
  PKCS #9  Defines selected attribute types for use in PKCS #6,#7,#8,#10
  PKCS #10 Certification Request Standard
  <a href="https://en.wikipedia.org/wiki/PKCS_11">PKCS #11</a> Cryptographic Token Interface 
           ("Cryptoki") API defining a
           generic interface to cryptographic tokens 
  PKCS #12 Personal Information Exchange Syntax Standard.
           Defines a file format commonly used to store private keys,
           protected with a password-based symmetric key. 
           - Usable as a format for the Java key store and 
             client authentication certificates in Firefox, Apache Tomcat
  PKCS #15 Defines a standard allowing users of cryptographic tokens
           to identify themselves to applications, independent of 
           the application's Cryptoki implementation (PKCS #11) or other API



The Key Management Interoperability Protocol (KMIP) defines a wire protocol that has similar functionality to the PKCS#11 API. The two standards were originally developed independently but are now both governed by an OASIS technical committee. It is the stated objective of both the PKCS#11 and KMIP committees to align the standards where practicable. For example, the PKCS#11 Sensitive and Extractable attributes are being added to KMIP version 1.4. There is considerable overlap between members of the two technical committees.

- PKCS: Pro. Conjunto de estándares "alto nivel" (RFCs)


    (petición firma, cifrado, acceso elementos criptográficos, generación ...)

   "similar a la JCE"


JCE: Sustituye a PKCS11 (


MSCAPI: ...


HSM: Módulo enrackable hardware


nCipher: ...

___________ 
Tree-signatures (Wuille): A way to express multisignature more "conciselly".
__________________________________
Delegation-(multi)signature: If Bob(and Alice) say YES, then YES.
 If any two of Both, Sandra or Sandy say YES, then YES
___________________
blinded signatures
___________________
-->

</html>
