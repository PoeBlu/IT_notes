<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Cryptography map(beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table style='width:100%'{>
<tr {>
  <th colspan=4 header_delimit >Building blocks <a href="https://www.crypto101.io/">REF: Crypto101</a></th>
  <td colsep></td>
  <th colspan=6 header_delimit >Advanced primitives</th>
</tr }>
<tr>
<td>
  <b>Symmetric primitives</b>
<pre xxxsmall zoom {>
Plain -> |Encrypt|-> C1 -> |Decrypt| -> Plain
             ^                  ^
             └─ KEY("Secret") ──┘
</pre>
     Symmetric cyrptography broadly splits into:
     <ul xxxsmall zoom>
       <li><def>Stream cipher</def>: inputs of "any lenght". Very difficult to implement properly<br/>
           Implementations: ChaCha, ...
           <pre { >
  INPUT     -> |Keystream | -> K0, K1, ...
(KEY, NONCE)   |Generator |           -> XOR -> C0, C1, ...
                               M0, M1, ... 
</pre } >
           "BUTS": Generate a safe (non predictive) KEY for the stream cipher is "difficult"
       <li><def>Block cipher</def>:  inputs must be divided into chunks of same size</li>
       <li>Hide plaintext transformation to ciphertext through:
          <ul>
            <li>*confusion*: mapping input to output hard to predict (not linear and parts of keys)</li>
            <li>*diffusion*: permutate bits</li>
          </ul>
       </li>
       <li><def>SP-Networks</def>:  Most block ciphers are based on SP-Networks composed of:
          <ul>
            <li>Subtitution box : "map<byte, byte>"   (replace bytes with bytes )</li>
            <li>Permutation box :  moves bits around</li>
            <li>Some substitution plus permutation are combined into a single round</li>
            <li>Rounds are then repeated enough times to ensure the algorithm is secure</li>
          </ul>
       </li>
       <li>SP-Networks alone are not enought. KEY secret is used like:
<pre>
                 ROUND1                  ROUND2
Plain -> XOR -> |Subsitution| -> XOR -> |Subsitution| -> C
         KEY    |Permutation|    KEY    |Permutation|
</pre>
       </li>
       <li><def>AES</def>: SP-Network based (Advanced Encryption Standard).
          <ul>
            <li>"Almost every block cipher uses AES". Supersedes DES (2002 Standard)</li>
            <li>Built around Rijndael (SP-Network with 128bit block size) and key length of 128,192, 256 bit</li>
            <li>Round count depends on key lenght: 10, 12 or 14 cycles</li>
            <li>Each Round: SubBytes, ShiftRows, MixColumns</li>
            <li>Modern CPUs have hardware instruccions to accelerate AES computation</li>
          </ul>
       </li>
       <li><def>Padding</def>: used when the message does exactly match a multiple of key size.</li>
       </ul>
  Modes of operation:
  

  <ul xxxsmall zoom >
  <li>
    A block cipher by itself is only suitable for the secure cryptographic 
    transformation (encryption or decryption) of one fixed-length group of bits
    called a block. A mode of operation describes how to repeatedly apply a 
    cipher's single-block operation to securely transform amounts of data larger
    than a block.</li>
  <li>Most modes require a unique binary sequence, often called 
    an initialization vector (IV), for each encryption operation. The IV has to
    be non-repeating and, for some modes, random as well. The initialization 
    vector is used to ensure distinct ciphertexts are produced even when the 
    same plaintext is encrypted multiple times independently with the same key.</li>
  <li>Block ciphers have one or more block size(s), but during transformation 
    the block size is always fixed.</li>
  <li>Block cipher modes operate on whole blocks and require that the last part
    of the data be padded to a full block if it is smaller than the current 
    block size.</li> 
  <li>There are, however, modes that do not require padding because they 
    effectively use a block cipher as a stream cipher.</li>
  <li>Electronic code block (ECB):<br/>
     (WARN: Don't use it, if different messages share same data information leaks cans rise)
<pre { >
M1 -> |E_k| -> C1
M2 -> |E_k| -> C2
M3 -> |E_k| -> C3
</pre } >
       </li>
       <li>Cipher block chaining (CBC):
<pre { >
IV: Initialization vector
M1 -> |XOR(IV)| -> |E_k| -> C1
   -> |XOR(M2)| -> |E_k| -> C2 
   -> |XOR(M3)| -> C3
</pre } >
    "BUTs": 
    <ul>
      <li>Not paralelizable , and can not seek randomnly</li>
      <li>Needs an IV (Difficult to generate)</li>
    </ul>
  </li>
  <li>Counter Mode (CT):(Can be paralellized)
<pre { >
            Nonce + 0 -> |E_k| -> XOR(M1) -> C1
            Nonce + 1 -> |E_k| -> XOR(M2) -> C2
            Nonce + 2 -> |E_k| -> XOR(M3) -> C3
</pre } >
  </li>
  <li>Noces are used *once* <br/>
      IVs must be *unpredictable*
  </li>
  </ul>
</td>  
<td>
  <b>Asymmetric private-public key primitives</b>
  <ul xxxsmall zoom>
  <li><def>public/private key</def> where Public Key can be computed easely from private key
      but the inverse in infeasible (intractable mathematical problem).<br/>
      WARN: Quantum computer will totally defeat it
  </li>
  <li><def>Signing</def> "==" Encrypt using private key<br/>
    Enyone can decrypt using pub.key.</br>
    Signing probides:</br>
    <ul zoom>
      <li>Non repudiability: Private key owner can not neglect having signed</li>
      <li>Non tampering:message can not be moddified by third parties without the priv.key</li>
    </ul>
  </li>
  <li><def>Encrypt</def>  "==" (one-directional) encrypt using public key<br/>
      One-directional: Only private key owner can de-encrypt. Priv.key owner can not encrypt, only sign
  </li>
  <li><def>Diffie-Hellman</def>: two non-local parties can jointly agree a shared secret over an insecure channel
    <ul zoom>
      <li>DH-KEX (Key exchange) Underpins almost every aspect of our modern lives!</li>
      <li>DH security is based first on "very big numbers", with 4096 bits becoming more ussual.</li>
      <li>The DH-KEX generated shared-secret is usually called the "pre-master secret"</li>
      <li>It's used to derive session keys through hashing for example</li>
      <li>Ephemeral Mode. DH is used only for minutes/hours and not stored.</li>
    </ul>
  </li><def>RSA</def>: 
    <ul zoom>
      <li>provides encryption and/or authentication</li>
      <li>RSA provides us with Public (e,n) and Private (d)<br/>
          - e is usally a small number, <br/>
          - d is a much large number<br/>
          - n is avery large semi-prime number n=p.q <br/>
      </li>
      <li>Can be used for encription (using pub key) and signing (using the private key)</li>
      <li>It's compatible with integer prime number factorization, not with elliptic curves</li>
    </ul>
  <li><def>DSA</def>: 
    <ul zoom>
      <li>Can be used for signing (using the private key) only, NOT for encryption</li>
      <li>It's compatible with integer prime number factorization and  elliptic curves</li>
    </ul>
  </li>
    </ul>
</td>  
<td>
  <b>Hash Function primitives</b>
  <ul xxxsmall zoom>
  <li>takes message of any lenght, and returns a pseudoramdom hash of fixed length
<pre { >
┌─── Loop ←──┐
│            │
Block of   Current ──→ Final hash
message     Hash
└──────>─────┘
</pre } >
  </li>
  <li>HMAC: An attacker doesn't know the shared KEY so he can not add the correct HASH
<pre { >
PlainText -> |Symetric(KEY)| -> CipherText 

CipherText + HASH(KEY+CipherText)
</pre } >
  </li>
  <li>Digital Signatures: Hashing + Pub.Key
<pre>
Signer                   
Document -> hash -> sign 

Verifier
Document -> hash -> verify signature
</pre>
    <ul>
      <li>Prove authenticity of sender</li>
      <li>Used both in RSA and DSA</li>
    </ul>
  </li>
  </ul>
  </td>  
  <td>
  <b>HMAC primitives</b><br/>
  ("Private key signature")
  <ul xxxsmall zoom>
  <li>HMAC = "MAC + symetric encryption"</li>
  <li>Message passes throuh a hash function twice, and is combined with
    the (secret key) key before each pass
<pre>
message 
    → sym.cypher(key inner)
        → hash 
            → sym.cypher(key outer) 
                → hash
                    → out 
</pre>
  </li>
  <li>An HMAC authenticates a message (principal == "owner of private key").
    If a message comes with a correct MAC attached, it means this message
    was seen by a holder of the secret key at some point.<br/>
    HMAC is a signature based on a secret key, providing similar 
    assurances to a signature scheme based on public-key cryptography
  </li>
  </ul>

  <b>Key derivation Function</b>
  <ul xxxsmall zoom>
  <li>Derive one or more secret keys from a first secret one</li>
  <li>Many key d.f. admits a salt to avoid returning the smae output keys from the same input secret</li>
  <li>Two main categories, depending on the entropy content of the secret value 
    which determines how many differnet possible values the secret value can take
    <ul>
    <li>input secret is user-supplied (low entropy): Key d.f will require lot of computing 
      resources to avoid attackers to just compute all possible convinations.(scrypt)</li>
    <li>input secret is random (high entropy): A trivial key derivation will suffice (HKDF)</li>
    </ul>
  </li>
  <li>HKDF (HMAC-based (Extract-and-Expand) Key Derivation Function, defined in RFC 5869, 
     (<a href="http://eprint.iacr.org/2010/264">paper</a>) requires high entropy initial input 
     key.
  </li>
  </ul>

  <b>Random number generators</b>
  <ul xxxsmall zoom>
  <li>True random number generators(quantum, thermanl, oscillators,...)</li>
  <li>Cryptographically secure pseudorandom generators (Unix /dev/urandom, Windows CryptGenRandom,...) </li>
  <li>Psuedorandom number generators</li>
  </li>
  </ul>
</td>
<td colsep>
</td>
<td TODO>
  Multisignature
  <ul xxxsmall>
  <li>Tree-signatures (Wuille):</li>
  <li>A way to express multisignature more "conciselly".</li>
  </ul>
</td>
<td TODO>
  <a href="http://en.wikipedia.org/wiki/Threshold_cryptosystem">Threshold cryptosystem</a>
  
</td>
<td>
  <a href="https://en.wikipedia.org/wiki/Blind_signature">blind signature</a>
  <ul xxxsmall zoom>
  <li>form of digital signature in which the content of a message is 
    disguised/blinded before being signed. The resulting blind signature can 
    be publicly verified against the original, unblinded message in the manner 
    of a regular digital signature. </li>
  <li>Blind signatures are typically employed in privacy-related
    protocols where the signer and message author are different parties. 
    Examples include cryptographic election systems and digital cash schemes.
<pre>
participant user # creates a message ("vote") and blinds it
participant signer # authenticates user and sign blinded message
signer → user: authenticate user
user   → user: +message
user   → user: message → blind → blinded_message
user   → signer: blinded_message
signer → signer: +signed_blinded_message
</pre>
  </li>
  <li>Blind signature schemes exist for many public key signing protocols
    (Blind RSA signatures, Blind ECDSA signatures,
  </li>
  <li><a href="https://archive.is/20130416090835/http://www.maniora.pl/?p=101&lang=en">java implementation</a></li>
  </ul>
<!--
-->
<td>
  <a href="https://en.wikipedia.org/wiki/Hash_chain">Hash chain</a>
<pre xxxsmall zoom>
non-repudiable probe of data chronology
doc1 → hash → has1 ─┬→ hash → has2 ─┬→ hash → has3 ─┬→ hash
               doc2─┘         doc3 ─┘         doc4 ─┘        
</pre>
  <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a></br>
  Allows to check if a leaf (data) is part of the tree with just a subset of the tree
  <ul>
  <li>In blockchain leafs are transactions and the tree is a block</li>
  </ul>
</td>
<td>
  <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">Authenticated Encryption (AE)<br/>AE with associated data(AEAD)</a><br/>
  <ul xxxsmall zoom>
  <li>The need for AE emerged from the observation that securely combining 
     separate confidentiality and authentication block cipher operation modes 
     could be error prone and difficult confirmed by a number of practical
     attacks introduced into production protocols and applications by 
     incorrect implementation, or lack, of authentication (including SSL/TLS)</li>
  <li>A typical programming interface for AE mode implementation would provide the following functions:
<pre>
Encryption
    Input : plaintext, key, and optionally a header in plaintext that will not 
            be encrypted, but will be covered by authenticity protection.
    Output: ciphertext and authentication tag (message authentication code).
Decryption
    Input : ciphertext, key, authentication tag, and optionally a header.
    Output: plaintext, or an error if the authentication tag does not match 
            the supplied ciphertext or header.
</pre>
  </li>
  <li>Approaches to authenticated encryption:
<pre>
Encrypt-then-MAC (EtM)
Encrypt-and-MAC (E&M)
MAC-then-Encrypt (MtE)
</pre>
  </li>
  </ul>
</td>

</tr }>
</table>
<table>
<tr {>
  <th colspan=5 header_delimit xsmall >OpenSSL Certificate Handling  <a href="https://www.openssl.org/docs/manmaster/man1/">(Man pages)</a> <br/>
  
    <span xsmall>See also: <a href="https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf">
         The Most Dangerous Code in the World: Validating SSL Certificates 
         in Non-Browser Software</a></span>
  </th>
  <td colsep></td>
  <th colspan=1 header_delimit xsmall >GPG Signature Handling<br/>
  <td colsep></td>
  <th colspan=2 header_delimit xsmall >Advanced Authentication<br/>
</tr }>
<tr {>
  <td>
  Global Flow:
<pre xxxsmall zoom>
admin->admin: Create Private Key
admin->admin: Create CSR
alt
  admin->admin: Create self-certificate
else:
  admin->CA   : CSR
  CA->CA      : Create certificate
  CA->amdin   : certificate
</pre>
<br/>
Certificate Signing Request<b>(CSR)</b>:=
<pre xxxsmall zoom >
    PUBLIC KEY  
  + Distinguised Name (DN) :=
       + Common Name (CN)
         (SHOULD be the exact 
          Fully Qualified Domain Name (FQDN) 
          of the host)
       + "additional info
          about organization"
</pre>

  <li>useful ENV.VAR (DOMAIN/SUBJ):
<pre xxxsmall zoom { >
$ export DOMAIN="mydomain.com"
$ export SUBJ=""
$ export SUBJ="${SUBJ}/C=ES"
$ export SUBJ="${SUBJ}/ST=Aragon"
$ export SUBJ="${SUBJ}/L=Zaragoza"
$ export SUBJ="${SUBJ}/O=MyOrganization"
$ export SUBJ="${SUBJ}/CN=${DOMAIN}"
</pre }>
  Creating a CSR (<code>-new</code>)
<pre xxxsmall zoom { >
$ openssl req \
   -new \
   -nodes 
   -newkey rsa:2048 \
   -keyout ${DOMAIN}.key \
   -out ${DOMAIN}.csr -subj "${SUBJ}"

(replace <code>-newkey rsa:.... -keyout...</code> by
 <code>-key ${DOMAIN}.key</code>) to use already existing private key)
)
</pre }>
  </td>  
  <td>
  Common opts:
<pre xxxsmall zoom>
-nodes: flag: *DO NOT* pass-phrase-encrypt Pub.Key
-noout: prevents output of encoded version of request
-text : Show human readable output (vs hex formated binary))
</pre>
  New Self-Signed-Certificate:<br/>
  <ul xxxsmall zoom>
  <li>
      From new priv.key:
<pre { >
$ openssl req \
    -nodes \
    -newkey rsa:2048 -keyout ${DOMAIN}.key \
    -x509 \    # <- self signed
    -days ${DAYS_TO_EXPIRE} \
    -out ${DOMAIN}.crt -subj "${SUBJ}"
</pre }>
  Note 1: replace <code>-newkey rsa:.... -keyout...</code> by
    <code>-key ${DOMAIN}.key</code>) to use already existing private key)<br/>
  Note 2: replace <code>-new</code> by
    <code>-in ${DOMAIN.csr}</code>) to use already existing CSR<br/>
  </li>
  </ul>
  Managing Private Keys
  <ul xxxsmall zoom>
  <li>CREATE A PRIVATE KEY:
<pre {>
$ openssl \
    genrsa -des3 \
    -out ${DOMAIN}.key 2048
(Enter password when prompted)
</pre }>
  </li>
  <li>Verify (-check) Private Key:
<pre {>
$ openssl rsa -check -in ${DOMAIN}.key
</pre }>
  </li>
  <li>Verify private key matches certificate and CSR:<br/>
   (If the output of each of the next command is identical there is an
    extremely high probability that the private key, certificate, and CSR are related)
<pre {>
$ openssl rsa  -noout -modulus -in ${DOMAIN}.key | openssl md5
$ openssl x509 -noout -modulus -in ${DOMAIN}.crt | openssl md5
$ openssl req  -noout -modulus -in ${DOMAIN}.csr | openssl md5
</pre }>
  </li>
  <li>Encrypt/Decrypt private key
<pre {>
$ openssl rsa -des3 -in unencrypted.key -out encrypted.key
$ openssl rsa       -in encrypted.key   -out decrypted.key
</pre }>
  </li>
  </ul>
  </td>  
  <td>
  <a href="https://en.wikipedia.org/wiki/X.509">X.509 Format (ITU_T standard)</a> containing: 
  <ul xxxsmall zoom>
  <li><def>public/private key certificates</def></li>
  <li><def>identity</def>: hostname + organization/individual</li>
  <li><def>certificate revocation lists</def>: certificates are no longer 
    valid,</li>
  <li><def>certification path validation algorithm</def> allowing for 
    certificates to be signed by intermediate CA certificates, which are in 
    turn signed by other certificates, eventually reaching a trust anchor.
  </li>
  <li>Used amongst others by Internet protocols like TLS/SSL</li>
  <li>X.509 v3:
<pre>
Version#
Serial Number
Signature algorithm
Issuer name
Validity period
Subject name
Subject PK Info
Issuer ID#
Subject ID#
Extensions
──────────────────
CA Signature 
</pre>
  </li>
  </ul>
  View x509 contents:
<pre xxxsmall zoom>
$ openssl x509 -text -in myCert.pem
</pre>

  </td>
  <td>
  Converting Formats
<pre xxxsmall zoom{>
-Defaults to PEM
-PKCS7 files, also known as P7B, are typically used in Java Keystores and 
 Microsoft IIS (Windows).  They are ASCII files which can contain certificates
 and CA certificates.
-PKCS12 ( also known as PFX files) are typically used for import/export 
  certs-chains in Micrsoft IIS
# PEM   → DER
$ openssl x509 -in ${DOMAIN}.crt -outform der -out ${DOMAIN}.der
# DER   → PEM
$ openssl x509 -inform der -in ${DOMAIN}.der -out ${DOMAIN}.crt
# PEM   → PKCS7
$ openssl crl2pkcs7 -nocrl -certfile ${DOMAIN}.crt
   -certfile ca-chain.crt -out ${DOMAIN}.p7b
# PKCS7 → PEM
$ openssl pkcs7 -in ${DOMAIN}.p7b -print_certs -out ${DOMAIN}.crt
# PEM → PKCS12
$ openssl pkcs12 -inkey ${DOMAIN}.key \
   -in ${DOMAIN}.crt -export -out ${DOMAIN}.pfx
# PKCS12 → PEM 
$ openssl pkcs12 -in ${DOMAIN}.pfx -nodes -out ${DOMAIN}.combined.crt
# x509 → PEM
$ openssl x509 -in ${DOMAIN}.cer -outform PEM -out ${DOMAIN}.pem
</pre }>

  Fingerprints
  <ul xxxsmall zoom>
  <li>Fingerprints are short sequences of bytes used to identify a longer public key,
      applying a cryptographic hash function to the public key</li>
  <li>Are used as "ids" to the longer public keys</li>
  <li>To generate a fingerprint from a TLS certificate, run:
<pre>
$ openssl x509 -in ${DOMAIN}.crt -noout -fingerprint -sha256
(output will be similar to
 fa:23:a4:48:............:56
</pre>

  </li>
  </ul>
  </td>  
  <td>
  <b>Recipes</b><br/>
  list openssl version/build
<pre>$ openssl version -a</pre>
  Download (first in chain) certificate from web, then  add to Java keystore:
<pre xxxsmall zoom {>
$ openssl s_client \
   -connect www.mywebsite.com:443 \  
   -showcerts </dev/null 2>/dev/null | \
  openssl x509 \
    -outform PEM > infura-morden.pem
$ ($JAVA_HOME/Contents/Home/jre/bin/)keytool \
    -import -noprompt -trustcacerts \
    -alias www.mywebsite.com -f
</pre }>
    View(-text) AND Verify (-verify) CSR:
<pre xxxsmall zom {>
$ openssl req \
  -text  \
  -noout \
  -verify -in ${DOMAIN}.csr
</pre }>
   Verify that cert. was signed by a CA:</span>
<pre xxxsmall zoom {>
$ openssl verify -verbose -CAFile ca.crt ${DOMAIN}.crt
</pre }>
</td>

<td colsep></td>
<td>
  <a href="http://central.sonatype.org/pages/working-with-pgp-signatures.html">REF:</a><br/>
  New KeyPair
<pre xxxsmall zoom>
$ gpg --gen-key # defaults to: RSA 2048bit, no-expire
# Provide name, email, and a comment for the key.

# Note: It's is commonly suggested to use an expire ofless than 2 years.
#    Once expired you can extend it, provided you own the key and
#    therefore know the passphrase.
</pre>

  Listing Keys
<pre xxxsmall zoom>
$ gpg2 --list-keys   # list <b>public</b> keys
/home/juven/.gnupg/pubring.gpg
------------------------------
pub   1024D/C6EED57A 2010-01-13
uid                  Juven Xu (Juven Xu works at Sonatype) <juven@sonatype.com>
sub   2048g/D704745C 2010-01-13
      ^        ^
    length   keyid

$ gpg2 --list-secret-keys # list <b>private</b> keys

/home/juven/.gnupg/secring.gpg
------------------------------
sec   1024D/C6EED57A 2010-01-13
uid                  Juven Xu (Juven Xu works at Sonatype)
ssb   2048g/D704745C 2010-01-13
</pre>

  Signing a File
<pre xxxsmall zoom>
$ gpg2 -ab temp.java # creates temp.java.asc
# -a create ASCII armored output,
# -b make detached signature

# Verify it's has been properly created
$ gpg2 --verify temp.java.asc
</pre>

  Distribute Pub.
<pre xxxsmall zoom>
$ gpg2 --keyserver hkp://pool.sks-keyservers.net --send-keys C6EED57A
# Now other people can import it from the key server using:
$ gpg2 --keyserver hkp://pool.sks-keyservers.net --recv-keys C6EED57A
</pre>

  Expire a Key
<pre xxxsmall TODO>
$ gpg2 --edit-key A6BAB25C
... Secret key is available.

pub  2048R/A6BAB25C  created: 2011-08-31  expires: 2012-02-27
                     trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created: 2011-08-31  expires: 2011-02-27 
...
gpg&gt; <b orange>1</b>  # only one key so choose it
pub  2048R/A6BAB25C  created: 2011-08-31  expires: 2012-02-27  usage: SC
                     trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created: 2011-08-31  expires: 2011-02-27  usage: E
(1)* Juven Xu (for testing) <test@juvenxu.com>

gpg&gt; <b orange>expire</b>
Changing expiration time for the primary key.
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      ...
gpg&gt; <b orange>save</b>

Finally, re-distribute your public key again:

$ gpg2 --keyserver hkp://pool.sks-keyservers.net --send-keys A6BAB25C
</pre>

  Delete SubKey
<pre xxxsmall>
- Some PGP tools by default generate a sub signing key and
  use it for signing instead of using the primary key (seed key).
- Maven and other only recognise the primary key, not subkeys.

- Delete sub-signing key like:

 To get an idea whether you have a sub signing key, run command below with your own key ID:

$ gpg2 --edit-key A6BAB25C
...
pub  2048R/A6BAB25C  created: 2011-08-31  expires: 2012-06-26  usage: SC
                     trust: ultimate      validity: ultimate
<b orange>sub</b>  2048R/DD289F64  created: 2011-08-31  expired: 2011-09-30  <b orange>usage: E  # E:Encryption</b>
<b orange>sub</b>  2048R/8738EC86  created: 2011-12-19  expires: 2012-06-16  <b orange>usage: S  # S: Signing  </b>


First select the sub key we want to delete, since its index is 2 (indices starts with 0), we run command:

gpg&gt; <b orange>key 2</b> (index start at 0)
...
gpg&gt; <b orange>delkey</b>
Do you really want to delete this key? (y/N) y

pub  2048R/A6BAB25C  created: 2011-08-31  expires: 2012-06-26  usage: SC
                     trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created: 2011-08-31  expired: 2011-09-30  usage: E

Tip: If Pub.key has already been distributed it's better to revoke the sub signing key instead of deleting it

gpg&gt; <b orange>save</b>

Signing now will show:
gpg: Signature made ************************* using *** key ID [YOUR-PRIMARY-KEY-ID]
</pre>

</td><td colsep></td>
  <!-- authentication -->
<td>
    <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">Multi-factor authentication (MFA)</a>
</td>  
<td TODO>
    OAuth2
<!--
    http://chuletario.blogspot.nl/2013/03/oauth2-summary.html
-->
</td>

</tr }>
</table>

<table>
<tr {>
  <th colspan=10 header_delimit >Standars / Complete Cryptosystems</th>
</tr }>
<tr>
<td>
  Common protocol issues
  <ul xxxsmall zoom>
  <li>ciphertext that aren't secured with a MAC</li>
  <li>message that don't include a time-stamp or counter</li>
  <li>protocols that don't use PK for authenticity</li>
  <li>Reuse of Nonces of IVs</li>
  <li>... many more</li>
  </ul>
  <b xxbig>Dont's</b>
  <ul xsmall zoom orange>
  <li>Don't Implement your own algorithms</li>
  <li>Don't Use hard-coded keys</li>
  <li>Never use ECB mode. Prefer CBC, better yet CTR or GCM</li>
  <li>Don't use small public key sizes. At least 2048</li>
  <li>Elliptic curve preferable: p-256 or X25519</li>
  <li>Don't use the same private key for encrypting and signing</li>
  </ul>
  </td>
  <td>
  SSL/TLS protocol for secure network communications (data "in motion")
  </td>
  <td>
  OpenPGP, open standard describin methods for encrypting and
  signing messages (data "at rest"), beeing GPG the most popular implementation.
  <br/>
  
  </td>
  <td>
  Off-The-Record Messaging (OTR) protocol for securing instant messaging 
  communication amongst people. Encrypts messages, prevents eavesdroppers,
  authenticates peers to each other, 

  </td>
  <td>
   <a href="https://en.wikipedia.org/wiki/PKCS">PKCS</a>: Set of "high-level" "Public Key Cryptography Standards"</a>
   <ul xxxsmall zoom>
   <li><def>PKCS #1 math. properties + format of RSA pub/priv</def> keys, and 
       basic algorithms and encoding/padding schemes for RSA
       (de/en)cryption,  producing/verifying signatures.</li>
   <li><def>PKCS #3 Diffie–Hellman</def> Key Agreement Standard</li>
   <li><def>PKCS #5 Password-based Encryption</def> Standard</li>
   <li><def>PKCS #7 Cryptographic Message Syntax</def> used to sign 
       and/or encrypt messages under a PKI</li>
   <li><def>PKCS #8 to carry private certificate keypairs</def></li>
   <li><def>PKCS #9 </def> Defines selected attribute types for use in PKCS #6,#7,#8,#10</li>
   <li><def>PKCS #10 Certification Request Standard </def></li>
   <li><def><a href="https://en.wikipedia.org/wiki/PKCS_11">PKCS #11</a></def> 
        Cryptographic (Athentication) Token Interface
        ("Cryptoki") API defining a generic interface to cryptographic tokens </li>
   <li><def>PKCS #12 Personal Information Exchange Syntax</def> defining file
       format commonly used to store private keys, protected with a password-based
       symmetric key. Used by <br/>
       - Java key store <br/>
       - client auth. certs in Firefox, Apache Tomcat</li>
   <li><def>PKCS #15 idetification through tokens </def> allowing users to identify 
        themselves to applications, independent of the application's Cryptoki
        implementation (PKCS #11) or other API</li>
  </ul>
  </td>
  <td>
  Key Management Interoperability Protocol (KMIP) wire protocol<br/>
  Similar functionality to the PKCS#11 API
  </td>
  <td TODO>
  [protocol] S/MIME: secure emails
  <ul xxxsmall zoom>
  <li>Uses session keys to encrypt the message</li>
  </ul>
  </td>
</tr>
</table>

<table>
<tr {>
  <th colspan=4 header_delimit >Hardware Vaults</a></th>
  <td colsep></td>
  <th colspan=1 header_delimit >Vault services</th>
</tr }>
<tr>
<td>
  <a href="https://en.wikipedia.org/wiki/Security_token">Security token</a> <br/>
  physical devices used to gain access to an electronically restricted resource 
  <ul xxxsmall>
  <li>used in addition to or in place of a password like a wireless keycard to open/unlock doors,... </li>
  <li>All tokens contain some secret information used to prove identity</li>
  <li>There are four ways in which this info. can be used:
    <ul> 
    <li><def>Static password</def> token containing a password transmitted for each authentication (vulnerable to replay attacks)</li>
    <li<def>>Syncrhonous dynamic password</def> token, using a timer to rotate through various combinations. Need time synchronization with server</li>
    <li<def>>Asyncrhonous password</def> token generating One-time password (no clock involved)</li>
    <li<def>>Challenge-response</def> token using pub.key cryptography.</li>
    </ul> 
  </li>
  </ul> 
</td>
<td>
  <a href="https://en.wikipedia.org/wiki/Smart_card">Smart card</a> <br/>
  can provide personal identification, authentication, data storage and app. processing.
  <ul xxxsmall>
  <li></li>
  </ul> 
</td>
<td>
  <a href="https://en.wikipedia.org/wiki/Software_Guard_Extensions">Intel SGX</a>
  CPU instruction set allowing user-level code to allocate private regions 
  of memory (enclaves) protected from processes running at higher privilege
  levels. (secure remote computation, secure web browsing, DRM).
  <ul xxxsmall zoom>
  <li>
SGX is a set of instruction set extensions for CPUs released in Fall 2015 and available on recent CPUs. The key ability SGX provides is the notion of confidential, private execution with integrity guarantees. In essence, the chip has a special construct called an enclave. An enclave is like an ordinary program, except that the memory contents of an enclave are encrypted whenever they are off-chip, and accessible only on-chip, and only while the special enclave code is running. Further, the decryption keys are available solely to code with a certain hash: if you or a hacker were to hack the enclave code and change its hash, that hacked code will no longer have access to the encryption keys, repelling attacks. As a result, this ingenious technology does not permit anyone, even the owner of the machine who can modify the code arbitrarily, to peek at the contents of the enclave or to modify execution within an enclave. Further, the SGX hardware enables remote attestation, that is, the ability to prove to a remote computer that a given enclave is running a particular software distribution. In essence, the chip is able to issue a statement that says "I guarantee to any remote party that I am running this code with this particular hash," which is a critical bootstrapping mechanism. Teechan is built on these two underlying features, which, together, provide a trusted execution environment (TEE).</li>
  </ul>
</td>
<td>
  <a href="https://en.wikipedia.org/wiki/Secure_cryptoprocessor">Secure cryptoprocessor</a>
  chip for carrying out cryptographic operations given degree of tamper resistance. 
  (vs cryptographic processors to speed-up crypto operations) 
</td>
<td colsep>
</td>
<td>
  <a href="https://www.vaultproject.io/">HashiCorp Vault Project</a>
  <ul>
  <li>
  </li>
  </ul>

</td>
</tr>
</table>

<table>
<tr>
<td>People
<pre xxxsmall>
Ron Rivest (the 'R' in RSA) 
Adi Shamir (the 'A' in RSA)
Whitfiled Diffie (Diffie-Hillman key exchange protocol)
Paul Kocher (SSLv3)
Moxie Marlinspike (founder of secure messaging organization Signal)
</pre>
</td>
<td>
  External Links:
  <ul>
  <li><a href="https://www.crypto101.io/">Crypto101</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Outline_of_cryptography">Outline of Cryptography at Wikipedia</a></li>
  <li><a href="https://www.bouncycastle.org/fips-java/BCFipsIn100.pdf">The Bouncy Castle FIPS Java API in 100 Examples </a></li>
<!--
  <li><a href="https://downloads.bouncycastle.org/fips-java/BC-FJA-SecurityPolicy-1.0.0.pdf">The Bouncy Castle FIPS Java API in 100 Examples </a></li>
-->
  </ul>
  
</td>
</tr>
</table>

</body>
<!--

TODO_start

___________________
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a>
________________


"similar a la JCE"


JCE: Sustituye a PKCS11 (


MSCAPI: ...


HSM: Módulo enrackable hardware


nCipher: ...

___________________
DSS: Use SHA 160 bits
________________
Asym. Key Distribution:
   - repeated use of key makes it easier to crack
__________________
Asym. ChaCha
__________
Derived (symetric) Keys:
_________
Fernet symmetric encryption
______
Salts: allows different outputs from same input .
   They must not be secret
______
Challenge-response:
 Authentication server encrypts a challenge (typically a random number) with a public key. 
 The device proves it possesses a copy of the matching private key by providing the decrypted challenge.
_____________
_________
https://en.wikipedia.org/wiki/Cryptographic_Service_Provider

JAVA Cryptographic Extension (JCE
http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html

__________
BitLocker full disk encryption:
https://en.wikipedia.org/wiki/BitLocker
____________
https://www.rsaconference.com/
______________________
Cryptographic accumulators: (Mou13)
________________
Ring signatures (vS13)
________________
Chaumian Blinding (Cha83)
________________
Patricia Tree:
________________

http://www.microsiervos.com/archivo/seguridad/segunda-ley-termodinamica-fuerza-bruta-256-bits.html


-->

</html>
