<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>changeme title</title>
<!--
 Q:Note what the attribute { and } do:
 A:Those attributes are ignored by the browser but are helpful to fold/unfold text in some
   editors (Vim, Emacs,...)
-->
<!--
ROW TEMPLATE
<tr {>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>
-->

<head>
<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 
function onTDDoubleClick()      { zoomDivDOM.innerHTML = 
     "('Esc' to close) Toggle "+
     "<span style='color:blue;' onClick=\"zoomDivFW  = !zoomDivFW ; zoomDivDOM.style.maxWidth  = zoomDivFW  ? '98%' : '30%'\">[Width]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivFH  = !zoomDivFH ; zoomDivDOM.style.maxHeight = zoomDivFH  ? '98%' : '30%'\">[Height]</span> " 
   + " Toggle " 
   + "<span style='color:blue;' onClick=\"zoomDivLft = !zoomDivLft; zoomDivDOM.style.left      = zoomDivLft ? '1%'  : '69%'\">[Horz]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivTop = !zoomDivTop; zoomDivDOM.style.top       = zoomDivTop ? '1%'  : '69%'\">[Vert]</span> " 
   + " <br/> " 
   + this.innerHTML; 
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
  removeToLeftMarginInPre();
}
</script>
<style>
pre { background-color:#EEEEEE; outline:1px dotted grey; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
* xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xbig  ]  { font-size:1.3rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

#zoomDiv [xxsmall]  , #zoomDiv * [xxsmall] , #zoomDiv * * [xxsmall] , #zoomDiv * * * [xxsmall] { font-size:1em; }
#zoomDiv [xsmall]   , #zoomDiv * [xsmall]  , #zoomDiv * * [xsmall]  , #zoomDiv * * * [xsmall]  { font-size:1em; }
#zoomDiv [small]    , #zoomDiv * [small]   , #zoomDiv * * [small]   , #zoomDiv * * * [small]   { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[col1] ,th[col1] {background-color:#FFFFFF; min-width:34%; max-width:34%; }
td[col2] ,th[col2] {background-color:#FAFAFA; min-width:33%; max-width:33%; }
td[col3] ,th[col3] {background-color:#FFFFFF; min-width:33%; max-width:33%; }
th[header_delimit]{background-color:#000000; color:#FFFFFF; font-size:2em; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

</style>
</head>
<body onLoad='onPageLoaded()'> <div id='zoomDiv'>Hint: double-click on cell to zoom!!</div> 
<table style='width:100%'{>
<tbody>

<tr {>
  <th colspan=3 header_delimit }   >Building blocks</th>
</tr }>
<tr {>
  <td col1 >
     <span xbig>Symmetric primitives</span>
         <pre>
Plain -> |Encrypt|-> C1 -> |Decrypt| -> Plain
             ^                  ^
             └─ KEY("Secret") ──┘
</pre>
     Symmetric cyrptography broadly splits into:
     <ul>
       <li>Stream cipher: inputs of "any lenght". Very difficult to implement properly<br/>
           Implementations: ChaCha, ...
           <pre { >
  INPUT     -> |Keystream | -> K0, K1, ...
(KEY, NONCE)   |Generator |           -> XOR -> C0, C1, ...
                               M0, M1, ... 
</pre } >
           "BUTS": Generate a safe (non predictive) KEY for the stream cipher is "difficult"
       <li>Block cipher:  inputs must be divided into chunks of same size</li>
       <li>Hide plaintext transformation to ciphertext through:
          <ul>
            <li>*confusion*: mapping input to output hard to predict (not linear and parts of keys)</li>
            <li>*diffusion*: permutate bits</li>
          </ul>
       </li>
       <li>SP-Networks:  Most block ciphers are based on SP-Networks composed of:
          <ul>
            <li>Subtitution box : "map<byte, byte>"   (replace bytes with bytes )</li>
            <li>Permutation box :  moves bits around</li>
            <li>Some substitution plus permutation are combined into a single round</li>
            <li>Rounds are then repeated enough times to ensure the algorithm is secure</li>
          </ul>
       </li>
       <li>SP-Networks alone are not enought. KEY secret is used like:
<pre>
                 ROUND1                  ROUND2
Plain -> XOR -> |Subsitution| -> XOR -> |Subsitution| -> C
         KEY    |Permutation|    KEY    |Permutation|
</pre>
       </li>
       <li>AES: SP-Network based (Advanced Encryption Standard).
          <ul>
            <li>"Almost every block cipher uses AES". Supersedes DES (2002 Standard)</li>
            <li>Built around Rijndael (SP-Network with 128bit block size) and key length of 128,192, 256 bit</li>
            <li>Round count depends on key lenght: 10, 12 or 14 cycles</li>
            <li>Each Round: SubBytes, ShiftRows, MixColumns</li>
          </ul>
       </li>
       <li>Padding: used when the message does exactly match a multiple of key size.</li>
       <li>Modes of operation:
          <ul>
            <li>Electronic code block (ECB):<br/>
             (WARN: Don't use it, if different messages share same data information leaks cans rise)
<pre { >
M1 -> |E_k| -> C1
M2 -> |E_k| -> C2
M3 -> |E_k| -> C3
</pre } >
            </li>
            <li>Cipher block chaining (CBC):
<pre { >
IV: Initialization vector
M1 -> |XOR(IV)| -> |E_k| -> C1
   -> |XOR(M2)| -> |E_k| -> C2 
   -> |XOR(M3)| -> C3
</pre } >
            "BUTs": 
              <ul>
                <li>Not paralelizable , and can not seek randomnly</li>
                <li>Needs an IV (Difficult to generate)</li>
              </ul>
            </li>
            <li>Counter Mode (CT):(Can be paralellized)
<pre { >
            Nonce + 0 -> |E_k| -> XOR(M1) -> C1
            Nonce + 1 -> |E_k| -> XOR(M2) -> C2
            Nonce + 2 -> |E_k| -> XOR(M3) -> C3
</pre } >
            </li>
       </li>
       <li>Noces are used *once* <br/>
           IVs must be *unpredictable*
       </li>
     </ul>
  </td>  
  <td col2 >
     <span xbig>Asymmetric private-public key primitives</span>
     <ul>
       <li>Two keys, public and private where Public Key can be computed easely from private key
           but the inverse in infeasible (intractable mathematical problem).<br/>
           WARN: Quantum computer will totally defeat it
       </li>
       <li>Diffie-Hellman: two non-local parties can jointly agree a shared secret over an insecure channel
         <ul>
           <li>DH-KEX (Key exchange) Underpins almost every aspect of our modern lives!</li>
           <li>DH security is based first on "very big numbers", with 4096 bits becoming more ussual.</li>
           <li>The DH-KEX generated shared-secret is usually called the "pre-master secret"</li>
           <li>It's used to derive session keys through hashing for example</li>
           <li>Ephemeral Mode. DH is used only for minutes/hours and not stored.</li>
         </ul>
       </li>RSA: 
         <ul>
           <li>provides encryption and/or authentication</li>
           <li>RSA provides us with Public (e,n) and Private (d)<br/>
               - e is usally a small number, <br/>
               - d is a much large number<br/>
               - n is avery large semi-prime number n=p.q <br/>
           </li>
           <li>Can be used for encription (using pub key) and signing (using the private key)</li>
           <li>It's compatible with integer prime number factorization, not with elliptic curves</li>
         </ul>
       <li>DSA: 
         <ul>
           <li>Can be used for signing (using the private key) only, NOT for encryption</li>
           <li>It's compatible with integer prime number factorization and  elliptic curves</li>
         </ul>
       </li>
     </ul>
  </td>  
  <td col3 >
     <span xbig>Hash Function primitives</span>
     <ul>
       <li>takes message of any lenght, and returns a pseudoramdom hash of fixed length
<pre { >
┌─── Loop ←──┐
│            │
Block of   Current ──→ Final hash
message     Hash
└──────>─────┘
</pre } >
       </li>
       <li>HMAC: An attacker doesn't know the shared KEY so he can not add the correct HASH
<pre { >
PlainText -> |Symetric(KEY)| -> CipherText 

CipherText + HASH(KEY+CipherText)
</pre } >
       </li>
       <li>Digital Signatures: Hashing + Pub.Key
<pre>
Signer                   
Document -> hash -> sign 

Verifier
Document -> hash -> verify signature
</pre>
         <ul>
           <li>Prove authenticity of sender</li>
           <li>Used both in RSA and DSA</li>
         </ul>
       </li>
     </ul>
  </td>  
</tr }>
<!--
<tr {>
  <th colspan=3 header_delimit {   >Protocols</th>
</tr }>
  - Authenticated Encryption - AEAD
  - Handshake Phase Agree on a set of crypto. protocols AES 128, ECDH, RSA,...

Common protocol issues
 - ciphertext that aren't secured with a MAC
 - message taht don't include a time-stamp or counter
 - protocols that don't use PK for authenticity
 - Reuse of Nonces of IVs
 - ... many more
 => Don't do it yourself. => use well-established ones.
    (TLS, ...)


<tr {>
  <td col1 >
     Building blocks need to be carefully assembled into protocols to be used safely.
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>
-->
<!--
<tr {>
  <th colspan=3 header_delimit } { >Dont's</th>
</tr }>
<tr {>
  <td col1 >
DONT'S:
- Don't Implement your own algorithms
- Don't Use hard-coded keys, 
- Implement your own algorithms
- Never use ECB mode. Prefer CBC, better yet CTR or GCM
- Don't use small public key sizes. At least 2048. 
  Elliptic curve preferable: p-256 or X25519


     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>
-->
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 

-->
<!--
NOTE: Ussually integrity (not being able to tamper the chiper text) is as important as confidentiality
   Python https://cryptography.io

    Recipes - Fernet
              X.509
    
    Hazardous
    Materials   Symmectric                             Quantum computer resiliant
                Asymmetric  -> (AES, ChaCha20, 3DES)   Quantum computer vulnerables
                Hashing
                MACs


   Public Key infraestructe:
     - A trusted CA (whose pub.key is known to browsers,...) signs confirming
   that another public key belongs to amazon,....
     - X.509 v3:
       - organised by PKI
       - standard for digital certificates hold info. on type,subject,issuer
       - Issuer will be a trusted third party (Verisign,Globalsign)
       Version#
       Serial Number
       Signature algorithm
       Issuere name
       Validity period
       Subject name
       Subject PK Info
       Issuer ID#
       Subject ID#
       Extensions
       __________
       CA Signature

___________________
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a>

________________
Block cipher mode of operation: A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block.[2] A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.[3][4][5].  Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key.[6] Block ciphers have one or more block size(s), but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be padded to a full block if it is smaller than the current block size.[2] There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher.

   
-->

</html>
