<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Cryptography map(v1.0)</title>
<head>
<script src="./map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="./map_v1.css" />
</head>

<body>

<div groupv>
<span title>Building blocks</span>

<pre zoom>
<span xsmall>Who is Who</span>
REFS:
-@[https://en.wikipedia.org/wiki/List_of_cryptographers] REF 1: Wikipedia list of Cryptographers
-@[http://pages.swcp.com/~mccurley/cryptographers/cryptographers.html] REF 2: Mc Curley list

-*Claude Shannon*                                                        | - Thomas Jakobsen
  Actually he was not a cryptographer,                                   | @[http://www.mat.dtu.dk/persons/Jakobsen_Thomas/]
  but the*founder of information theory*                                 | - Markus Jakobsson
  *on which everything is based*                                         | @[http://www.markus-jakobsson.com/]
@[https://en.wikipedia.org/wiki/Claude_Shannon]                          | - Stanislaw Jarecki
-*Charles Babbage*                                                       | @[http://theory.lcs.mit.edu/~stasio/]
@[https://en.wikipedia.org/wiki/Charles_Babbage]                         | - Antoine Joux
-*Ada Lovelace*                                                          | @[http://www.dmi.ens.fr/equipes/grecc/Membres/joux/pub.html]
@[https://en.wikipedia.org/wiki/Ada_Lovelace]                            | - Marc Joye
-*Ron Rivest*(the 'R' in the RSA)                                        | @[http://www.geocities.com/MarcJoye/]
@[http://theory.lcs.mit.edu:80/~rivest/]                                 | - Ari Juels
-*Adi Shamir*(the 'S' in the RSA)                                        | @[http://www.rsalabs.com/rsalabs/staff/ajuels/homepage.html]
@[http://www.wisdom.weizmann.ac.il/~shamir/]                             | - Mike Just
- Leonard Adleman (the 'A' in the RSA) @[]                               | @[http://www.scs.carleton.ca/~just/]
-*Whitfiled Diffie*                                                      | - Kwangjo Kim
  (Diffie-Hillman key exchange protocol)                                 | @[http://vega.icu.ac.kr/~kkj]
@[https://en.wikipedia.org/wiki/Whitfield_Diffie]                        | - Seung-Joo Kim
- Nick Szabo (Bitcoin "co?"inventor),                                    | @[http://dosan.skku.ac.kr/~sjkim]
@[https://en.wikipedia.org/wiki/Nick_Szabo]                              | - Andy Klapper
  came up with the idea of "bit gold" and developed                      | @[http://al.cs.engr.uky.edu/~klapper/andy.html]
  the idea of smart contract                                             | - Lars Knudsen
- @[http://www.weidai.com/] Wei Dai,                                     | @[http://www.ii.uib.no/~larsr/]
  create b-money, mentioned in the  second version                       | - François Koeune
  of the Bitcoin paper                                                   | @[http://www.dice.ucl.ac.be/~fkoeune/koeune.html]
-*Hal Finney*                                                            | - Kaoru Kurosawa
@[https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist)]         | @[http://kuro.cis.ibaraki.ac.jp/~kurosawa/]
 *PGP Developer* Bitcoin co?inventor                                     | - Markus Kuhn
- Paul Kocher                                                            | @[http://www.cl.cam.ac.uk/~mgk25/]
@[http://www.cryptography.com/about_pck.html]                            | - Eyal Kushilevitz
- Moxie Marlinspike                                                      | @[http://www.cs.technion.ac.il/~eyalk/]
  founder of secure messaging organization Signal                        | - Lam Kwok-Yan
- Ross Anderson                                                          | @[http://www.comp.nus.edu.sg/~lamky/]
  @[http://www.cl.cam.ac.uk/users/rja14/],                               | - Pil Joong Lee
  University of Cambridge, Computer Lab.                                 | @[http://wooly.postech.ac.kr/user/pjl/]
- Adam Back                                                              | - Reynald Lercier
@[https://en.wikipedia.org/wiki/Adam_Back]                               | @[http://lix.polytechnique.fr/~lercier/]
 *proof-of-work*system used by several anti-spam systems (and Bitcoin,..)| - Helger Lipmaa
- Don Beaver                                                             | @[http://home.cyber.ee/helger/]
- Mihir Bellare                                                          | - Mark Lomas
@[http://www-cse.ucsd.edu/users/mihir/] ,                                | @[http://www.cl.cam.ac.uk/users/tmal/]
  - professor at the University of California San Diego.                 | - Mike Luby
  - published several seminal papers in the cryp. field                  | @[http://www.icsi.berkeley.edu/~luby/]
    (notably in the area of provable security), many                     | - Philip MacKenzie
    of which were co-written with Phillip Rogaway.                       | @[http://cm.bell-labs.com/who/philmac/]
    and Format-Preserving Encryption.                                    | - Spyros Magliveras
-*Eran Tromer*@[http://www.cs.tau.ac.il/~tromer/] ,                      | @[http://zeus.math.fau.edu/spyros/]
  - ZCash Inventor and founding scientist                                | -
  @[https://z.cash]                                                      | @[http://www-ir.inf.ethz.ch/research/elek/signalverarbeitung/massey.proj_overview]
    privacy-preserving cryptocurrency which implements our               | - Gilles Brassard
    @[http://zerocash-project.org] Zerocash protocol.                    | @[http://www.iro.umontreal.ca/~brassard/]
   - RSA Key Extraction via Low-Bandwidth Acoustic Cryptanalysis         | - Lawrie Brown
  @[http://www.cs.tau.ac.il/~tromer/acoustic/]                           | @[http://mnementh.cs.adfa.oz.au/Lawrie_Brown.html]
    """particularly interested in what happens when cryptographic        | - Johannes Buchmann
     systems meet real world offaulty and leaky computation."""          | @[http://www.informatik.th-darmstadt.de/TI/Mitarbeiter/buchmann.html]
  -  heads the @[http://www.cs.tau.ac.il/~tromer/leisec] Laboratory      | - Mike Burmester
     for Experimental Information Security (LEISec) investigating side   | @[http://www.cs.fsu.edu/~burmester/]
     channel info leakage in computers through physical emanations       | - Christian Cachin
     electric and electromagnetic) and software (e.g.,                   | @[http://theory.lcs.mit.edu/~cc/]
   @[http://www.cs.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf]      | - Jan Camenisch
  -  cache contention in local and cloud computing                       | @[http://www.inf.ethz.ch/personal/camenisc/]
     @[http://www.cs.tau.ac.il/~tromer/cloudsec/]                        | - Ran Canetti
  -@[https://beautyburst.github.io]                                      | @[http://theory.lcs.mit.edu/~canetti/]
     Remote Identification of Encrypted Video Streams                    | - Anne Canteaut
  -  cofounded*SCIPR Lab*@[http://scipr-lab.org]</em>:                   | @[http://www-rocq.inria.fr/codes/Anne.Canteaut/]
     cryptographic zero -knowledge SNARK proof systems-                  | - Florent Chabaud
  -  Interested in blockchain-based cryptographic protocols,             | @[http://www.ens.fr/~chabaud/]
  -  Other research interests:                                           | - Che-Hao (Albert) Chang
     - tamper resilience, homomorphic encryption,                        | @[http://www.cl.cam.ac.uk/~chc1001/]
  -@[http://www.cs.tau.ac.il/~tromer/cryptodev]                          | - David Chaum
     special-purpose code-breaking hardware and various                  | @[http://www.digicash.com/digicash/people/david.html]
     aspects of network and systems security.                            | - Benny Chor
  -  Publications: @[http://www.cs.tau.ac.il/~tromer/publications]       | @[http://www.cs.technion.ac.il/~biham/cgi-bin/faculty.cgi?Chor.Benny]
     publications for more information.                                  | - Andy Clark
                                                                         | @[http://www.primarykey.co.uk/Andy/ajcmain.HTM]
- @[https://en.wikipedia.org/wiki/Steven_M._Bellovin] Steve Bellovin,    | - Lorrie Cranor
   a researcher on computer networking and security.                     | @[http://www.research.att.com/~lorrie/]
   Professor in the Computer Science department at Columbia              | - Claude Crépeau
   University,[1] having previously been a Fellow at AT&T Labs           | @[http://www.cs.mcgill.ca/~crepeau/]
   Research in Florham Park, New Jersey.[2][3]                           | - Ivan Damgård
   - In September 2012, Bellovin was appointed Chief                     | @[http://www.daimi.aau.dk/DAIMI/ScientificStaffProfiles/ivan.html]
   Technologist for the United States Federal Trade Commission,          | - George Davida
   replacing Edward W. Felten, who returned to Princeton University      | @[http://www.cs.uwm.edu/faculty/davida/]
- Philippe Béguin                                                        | - Alfredo de Santis
- Josh Benaloh(formerly Cohen)                                           | @[http://www.unisa.it/ads.dir/index.htm]
@[https://www.microsoft.com/en-us/research/people/benaloh/]              | - Giovanni Di Crescenzo
  - pioneered new technologies including:                                | @[http://www-cse.ucsd.edu/users/giovanni/]
    - "cast or spoil" paradigm that brings voters into                   | - Don Davis
      the verification process with minimal burden.                      | @[http://world.std.com/~dtd/]
- o*Daniel Julius Bernstein* (@[http://cr.yp.to/djb.html])               | - Dorothy Denning
 (@[https://en.wikipedia.org/wiki/Daniel_J._Bernstein] Wikipedia).       | @[http://www.cosc.georgetown.edu/~denning/]
  critic of the leading email and DNS packages of the time,              | - Yvo Desmedt
  Sendmail and BIND. Bernstein attempted to address the situation        | @[http://www.cs.fsu.edu/~desmedt/]
  by designing and implementing secure email and DNS services            | - Cunsheng Ding
  (qmail, ezmlm, djbdns, etc.)                                           | @[http://www.comp.nus.edu.sg/~dingcs]
  - sued the United States Government in 1995 (Bernstein                 | - Hans Dobbertin                                                                     
  v. United States).                                                     | @[http://www.ruhr-uni-bochum.de/itsc/englisch/index.html]                            
  - His software received significant attention and no bugs              | - Carl Ellison
    were found in it for eight years.                                    | @[http://www.clark.net/pub/cme/home.html]
  - Designer of the*Salsa20*stream cipher                                | - Paul Fahn
    in 2005 and submitted it to eSTREAM for                              | @[http://www-isl.stanford.edu/people/fahn/crypto.html]
    review and possible standardization.                                 | - Jean-François Dhem
  - In 2008 published a closely related stream cipher,                   | @[http://www.dice.ucl.ac.be/~dhem/]
    *ChaCha20*.                                                          | @[http://www.bell-labs.com/user/sgwetzel/]
  - He*also proposed the elliptic curve Curve25519*as a basis            | -  Ted Wobber
    for public-key schemes in 2005, and worked as the lead               | @[http://www.research.digital.com/SRC/staff/wobber/bib.html]
    researcher on the Ed25519 version of EdDSA.                          | -  Stefan Wolf
- @[http://www.nlsde.buaa.edu.cn/~kexu/]  Ke Xu                          | @[http://www.inf.ethz.ch/personal/wolf/]
- @[http://www.csie.ncu.edu.tw/~yensm/people/yensm/]  Sung-Ming Yen      | -  Dong-Ho Won
- @[http://www.cs.hut.fi/~ylo/]  Tatu Ylönen                             | @[http://dosan.skku.ac.kr/~dhwon/]
- @[http://www.cs.columbia.edu/~ayoung/]  Adam Young                     | -  Avishai Wool
- @[http://www.cs.columbia.edu/~moti/]  Moti Yung                        | @[http://research.lumeta.com/yash]                                
- @[http://pscit-www.fcit.monash.edu.au/~yuliang/]  Yulian Zheng         | -  Dongho Won                                                     
- @[http://www.cs.ucdavis.edu/~rogaway/]  Phil Rogaway                   | @[http://dosan.skku.ac.kr/~dhwon/]
- @[http://www.cs.nyu.edu/~rubin/]  Avi Rubin                            | -  Rebecca Wright
- Steven Rudich                                                          | @[http://www.research.att.com/info/rwright/]
@[http://www.cs.cmu.edu/afs/cs.cmu.edu/user/rudich/www/home.html]        | 
- @[http://tcslab.csce.kyushu-u.ac.jp/~sakurai/]  Kouichi Sakurai        | - Ueli Maurer
- @[http://tsk-www.ss.titech.ac.jp/~tsato/index-e.html]  Takashi Satoh   | @[http://www.inf.ethz.ch/personal/maurer/]
- @[http://www.mi.informatik.uni-frankfurt.de/]  Claus-Peter Schnorr     | - Kevin McCurley
- @[http://www.digicash.com/~berry/]  Berry Schoenmakers                 | @[http://www.swcp.com/~mccurley/index.html]
- @[http://www.cs.uow.edu.au/people/jennie/]  Jennifer Seberry           | - Robert J. McEliece
                                                                         | @[http://www.systems.caltech.edu/EE/Faculty/rjm/]
                                                                         | - Benny Pinkas
| - Joan Feigenbaum                                                      | @[http://www.wisdom.weizmann.ac.il/~bennyp/]
| @[http://www.cs.yale.edu/homes/jf/home.html]                           | - David Pointcheval
| - Niels Ferguson                                                       | @[http://www.dmi.ens.fr/~pointche/]
| @[http://niels.ferguson.net]                                           | - Thomas Pornin
| - Marc Fischlin                                                        | @[http://www.dmi.ens.fr/~pornin/index.html.en]
| @[http://www.mi.informatik.uni-frankfurt.de/people/marc/marc.html]     | - Guillaume Poupard
| - Yair Frankel                                                         | @[http://www.dmi.ens.fr/~poupard/]
| @[http://www.cs.sandia.gov/~yair]                                      | - Bart Preneel
| - Matt Franklin                                                        | @[http://www.esat.kuleuven.ac.be/~preneel/]
| @[http://www.cs.ucdavis.edu/~franklin/]                                | - Jean-Jacques Quisquater
| - Peter Gemmell                                                        | @[http://www.dice.ucl.ac.be/crypto/jjq.html]
| @[http://www.cs.sandia.gov/~psgemme]                                   | - Tal Rabin
| - Rosario Gennaro                                                      | @[http://theory.lcs.mit.edu/~talr/]
| @[http://www.research.ibm.com/people/r/rosario/]                       | -  Omer Reingold
| - Ian Goldberg                                                         | @[http://www.wisdom.weizmann.ac.il/~reingold/]
| @[http://www.cs.berkeley.edu/~iang/]                                   | -  Mike Reiter
| - Oded Goldreich                                                       | @[http://www.research.att.com/~reiter/]
| @[http://www.wisdom.weizmann.ac.il/~oded/]                             | -  Ali Aydin Selcuk
| - Shafi Goldwasser                                                     | @[http://www.csee.umbc.edu/~aselcu1/]
| @[http://theory.lcs.mit.edu/~shafi/]                                   | -  Alan Sherman
| - Li Gong                                                              | @[http://www.cs.umbc.edu/~sherman/]
| @[http://java.sun.com/people/gong/]                                    | -  English
| - <a hef='https://en.bitcoin.it/wiki/Wei_Dai'>Wei Dai (Crypto++)       | @[http://www.ecip.tohoku.ac.jp/Shizuya-Lab/index.html]
| - Mark Goresky                                                         | -  Adam Shostack
| @[http://www.math.ias.edu/~goresky/home.html]                          | @[http://www.homeport.org/~adam/]
| - Shai Halevi                                                          | -  Victor Shoup
| @[http://theory.lcs.mit.edu/~shaih/]                                   | @[http://www.cs.wisc.edu/~shoup/]
| - Helena Handschuh                                                     | -  Tom Shrimpton
| @[http://www-inf.enst.fr/~research/theses/handschuh.gb.html]           | @[http://www.ece.ucdavis.edu/~teshrim/]
| - Carlo Harpes                                                         | -  Alice Silverberg
| @[http://www.isi.ee.ethz.ch/~harpes/]                                  | @[http://www.math.ohio-state.edu/~silver/]
| - Martin Hellman (pubs only)                                           | -  Joseph H. Silverman
| @[ftp://isl.stanford.edu/pub/hellman/reports/]                         | @[http://www.math.brown.edu/~jhs]
| - Amir Herzberg                                                        |   by the NSA, who evidently knew about it as well.
| @[http://amir.herzberg.name/index.html]                                | - John R. Black
| - Frederic Huygens                                                     | @[http://www.cs.colorado.edu/~jrblack/papers.html]
| @[http://www.ulb.ac.be/di/scsi/defscsi.html]                           | - Simon Blackburn
| - Hideki Imai                                                          | @[http://www.cs.rhbnc.ac.uk/~simonb/]
| @[http://imailab-www.iis.u-tokyo.ac.jp/Members/imai-e.html]            | - Matt Blaze
| - Russell Impagliazzo                                                  | @[ftp://ftp.research.att.com/dist/mab/]
| @[http://www-cse.ucsd.edu/users/russell/]                              |   (corporate @[http://www.research.att.com/info/mab/] here)
| - David McGrew                                                         | - Daniel Bleichenbacher
| @[http://www.mindspring.com/~dmcgrew/dam.htm]                          | @[http://www.bell-labs.com/user/bleichen/]
| - Alfred Menezes                                                       | - Manuel Blum
| @[http://cacr.math.uwaterloo.ca/~ajmeneze/]                            | @[http://http.cs.berkeley.edu/~blum/]
| - Ralph Merkle                                                         | - Carlo Blundo
| @[http://merkle.com/merkle]                                            | @[http://www.unisa.it/carblu.dir/start.html]
| - Daniele Micciancio                                                   | - Dan Boneh
| @[http://theory.lcs.mit.edu/~miccianc/]                                | @[http://www.cs.princeton.edu/~dabo/]
| - Chris Mitchell                                                       | - Antoon Bosselaers
| @[http://isg.rhbnc.ac.uk/cjm/Chris_Mitchell.htm]                       | @[http://www.esat.kuleuven.ac.be/~bosselae/]
| - Shiho Moriai                                                         | - Joan F. Boyar (formerly Joan Plumstead)
| @[http://info.isl.ntt.co.jp/~shiho/]                                   | @[http://www.imada.sdu.dk/~joan/]
| - Sean Murphy                                                          | - Colid Boyd
| @[http://www.cs.rhbnc.ac.uk/~sean/]                                    | @[http://www.fit.qut.edu.au/~boyd/]
| - Clifford Neumann                                                     | - Stefan Brands,
| @[http://www.isi.edu/people/bcn/]                                      | @[https://en.wikipedia.org/wiki/Stefan_Brandr]
| - Mats Näslund                                                         |   - cryptographer specialized in electronic cash and digital identity.
| @[http://www.nada.kth.se/~matsn/matsn_homepage/research.html]          |   - best known for designing Microsoft's U-Prove protocols .
| - Moni Naor                                                            | -  Markus Stadler
| @[http://www.wisdom.weizmann.ac.il/people/homepages/naor/index.html]   | @[http://www.ubs.com/cgi-bin/framer.pl?/webclub/ubilab/e_index.htm/]
| - Harald Niederreiter                                                  | -  Frank Stajano
| @[http://www.iinform.oeaw.ac.at/Niederreiter.html]                     | @[http://www.cl.cam.ac.uk/~fms27/]
| - Valtteri Niemi                                                       | -  Jacques Stern
| @[http://www.uwasa.fi/~vni/]                                           | @[http://www.dmi.ens.fr/~stern/index.html]
| - Luke O'Connor                                                        | -  Anton Stiglic
| @[http://www.zurich.ibm.com/~oco/]                                     | @[http://crypto.cs.mcgill.ca/~stiglic]
| - Andrew Odlyzko                                                       | -  Doug Stinson
| @[http://www.research.att.com/~amo/]                                   | @[http://cacr.math.uwaterloo.ca/~dstinson/index.html]
| - Kazuo Ohta                                                           | -  Yuriy Tarannikov
| @[http://www.ohta.is.uec.ac.jp/k_ohta/]                                | @[http://liapunov.inria.msu.ru/PERSONAL/Taran/index.html]
| - Rafail Ostrovsky                                                     | -  Stafford Tavares
| @[http://www.cs.ucla.edu/~rafail/]                                     | @[http://http.ee.queensu.ca:8000/www/dept/facpages/set.html]
| - Christof Paar                                                        | -  Yiannis Tsiounis
| @[http://www.crypto.rub.de/en_paar.html]                               | @[http://www.ccs.neu.edu/home/yiannis/]
| - Torben Pryds Pedersen                                                | -  Jeroen van de Graaf
| @[http://cryptomathic.aau.dk/~tpp/]                                    | @[http://www.iro.umontreal.ca/people/jeroen/index.htm]
| - Rene Peralta                                                         | -  Joos Vandewalle
| @[http://www.cs.uwm.edu/faculty/peralta/index.html]                    | @[http://www.esat.kuleuven.ac.be/cosic/vdwalle.html]
| - Giuseppe Persiano                                                    | -  in English
| @[http://www.dia.unisa.it/~giuper]                                     | @[http://www.ens.fr/dmi/equipes_dmi/grecc/vaudenay/index_en.html]
| - Holger Petersen                                                      | -  David Wagner
| @[http://www.dmi.ens.fr/~petersen/]                                    | @[http://www.cs.berkeley.edu/~daw/]
| - Birgit Pfitzmann                                                     | -  Susanne Wetzel
| @[http://www.semper.org/sirene/people/birgit/info.birgit.html]         | - Thomas Beth
| - Josef Pieprzyk                                                       |   Albrecht Beutelspacher,
| @[http://www.cs.uow.edu.au/people/josef/homepage.html]                 | @[http://www.beutelspacher.info/]
| - Tom Berson, Advisory Board Member                                    |   mathematic "broadcaster"
| @[http://www.anagram.com/berson/]                                      | - Eli Biham: Biham
|   and Chief Security Advisor at Saleforce.com since 1999 foundation    | @[http://www.cs.technion.ac.il/~biham/]
                                                                         |   Ph.D. for inventing (publicly) differential cryptanalysis,
                                                                         |   while working under Adi Shamir. It had, it turned out, been invented
                                                                         |   at least twice before. A team at IBM discovered it during their work
                                                                         |   on DES, and was requested/required to keep their discovery secret
</pre>

<pre zoom>
<span xsmall>External Links</span>
@[https://en.wikipedia.org/wiki/Index_of_cryptography_articles]
@[https://www.crypto101.io/]
@[https://cryptography.io/en/latest/]
@[https://iancoleman.io/]
 Ian Coleman JS Tools for:
   - BIP39 Mnemonic Code Converter
   - Blockchain Blocksize/SAFE Network Attack/... 
   - Group Size Calculator
   -  Cost Benefit Calculator
   - Multisig Tool
   - ...
-@[https://keccak.team/index.html]
  information about our different cryptographic schemes and constructions,
  their specifications, cryptanalysis on them, the ongoing contests and the
  related scientific papers. 
- <a href="https://en.wikipedia.org/wiki/Outline_of_cryptography">Outline of Cryptography at Wikipedia</a>
- <a href="https://www.bouncycastle.org/fips-java/BCFipsIn100.pdf">The Bouncy Castle FIPS Java API in 100 Examples </a>
- <a href="http://eprint.iacr.org/">IACR Cryptology ePrint archives</a>
- <a href="http://people.csail.mit.edu/rivest/crypto-security.html">Ronald L.Rivest List of Links!!!</a>
- <a href="http://www.swcp.com/~mccurley/cryptographers/cryptographers.html">Kevin McCurley's links</a>
- <a href="http://nii.isi.edu/gost-group/">University of Southern California (Information Sciences Institute; Global Operating Systems Technology (GOST) Group)</a>
- <a href="http://https://blog.rootshell.be/">rootshell.be</a>: articles on exploits, security alerts, ...
- <a href="https://eccc.weizmann.ac.il/">Electronic Colloquium on Computational Complexity</a>
- <a href="http://www.sigsac.org/">ACM Special Interest Group on Security, Audit and Control (SIGSAC)</a>
- <a href="https://en.wikipedia.org/wiki/NSA_Playset">NSA Playset (OOSS ANT catalog)</a>

- SCIPR Lab:
@[http://www.scipr-lab.org/]
@[https://github.com/scipr-lab]
  is a multi-institutional academic collaboration of researchers
  seeking to bring to practice cryptographic proof systems that
  provide succinct integrity and privacy.

*Number Theory*
- NumberTheory.org Web
@[http://numbertheory.org]
- Number Theory and its History
@[https://archive.org/stream/NumberTheoryItsHistory/Ore-NumberTheoryItsHistory]
- The Prime Pages
@[http://primes.utm.edu]
- NTL: A Library for Doing Number Theory
@[http://www.shoup.net/ntl]

<span xsmall>Bibliography/Books</span>
- Crypto101
@[https://www.crypto101.io/]
- Encyclopedia of Cryptography and Security
@[https://www.springer.com/us/book/9781441959058]
- 
@[https://en.wikipedia.org/wiki/List_of_important_publications_in_cryptography]
- Handbook of Applied Cryptography, by Menezes, van Oorschot, and Vanstone.
@[http://www.cacr.math.uwaterloo.ca/hac/]
- Intro to Crypto.
@[https://www.cs.umd.edu/~waa/414-F11/IntroToCrypto.pdf]
- "Applied Cryptography", Bruce Schneier, ISBN 0-471-11709-9
</pre>

<pre zoom labels="learn_x_in_y_min">
<span xsmall>Concepts</span>
- *Doing encryption right is tough, managing secrets is even harder.*

- <a href="https://en.wikipedia.org/wiki/Information-theoretic_security">Perfect Secrecy</a>
  refers to a cryptosystem whose security derives purely from information theory.
  In other words, it cannot be broken even if the adversary had unlimited computing power.
   The adversary simply does not have enough information to break the encryption and so the
  cryptosystems are considered cryptanalytically-unbreakable. 
   
- <a href="https://en.wikipedia.org/wiki/Forward_secrecy">(Perfect) Forward Secrecy</a>
     gives assurances your session keys will not be compromised even if the private key
     of the server is compromised. Forward secrecy protects past sessions against future
     compromises of secret keys or passwords.
     WARN: Simple simetric encryption schemas are NOT forward secrecy compliant, and a 
     compromised keys can reveal past encrypted-communications.
  
- <a href="https://en.wikipedia.org/wiki/Secret_sharing">Secret_sharing</a> 
    refers to methods for distributing a secret amongst a group of participants,
    each of whom is allocated a share of the secret. The secret can be reconstructed
    only when a sufficient number, of possibly different types, of shares are combined
    together; individual shares are of no use on their own.
  
- <a href="https://en.wikipedia.org/wiki/Avalanche_effect">Avalanche_effect</a>:
  desirable property of cryptographic algorithms, typically block ciphers and cryptographic
  hash functions, wherein if an input is changed slightly (for example, flipping a single bit),
  the output changes significantly. 


- <a href="https://en.wikipedia.org/wiki/Malleability_(cryptography)">Malleability</a>
  - An (often) undesirable property of some cryptographic algorithms.
  - An encryption algorithm is "malleable" if it is possible to transform a ciphertext
    into another ciphertext which decrypts to a related plaintext. 

- <a href="https://en.wikipedia.org/wiki/Sponge_function">Sponge Function</a>
   In cryptography, a sponge function or sponge construction is any 
   of a class of algorithms with finite internal state that take an 
   input bit stream of any length and produce an output bit stream of 
   any desired length. Sponge functions have both theoretical and 
   practical uses. They can be used to model or implement many 
   cryptographic primitives, including cryptographic hashes, message 
   authentication codes, mask generation functions, stream ciphers, 
   pseudo-random number generators, and authenticated encryption.[1]
</pre>

<pre zoom labels="learn_x_in_y_min">
<span xsmall>brute force attacks</span>
@[https://twitter.com/fermatslibrary/status/969935429712666625]
According to the second law of thermodynamics,
the minimum amount of energy required to record a single
bit by changing the state of a system is:

  K x T  (Boltzman Constant "times" the temperature of the system)

Assuming our computer is ideal and running at 3.2 K (The temperature
of the cosmic background radiation), a bit change would consume
4.4 x 10^-16 erg.
Since the annual output of the Sun is 1.21 x 10^41 Erg, if we
used all its energy we could power 2.7 x 10^56 single bit changes,
which is enough to put a 187-bit counter through all its values.

To run through a 256-bit key we would need to build Dyson spheres
and capture the energy of:

*2^69 = 5.9 x 10^20 Suns during a year!!!*
</pre>

<pre zoom  labels="learn_x_in_y_min">
<span xsmall>Random number generators</span>
- True random number generators(quantum, thermanl, oscillators,...)
- Cryptographically secure pseudorandom generators (Unix /dev/urandom, Windows CryptGenRandom,...) 
- Psuedorandom number generators
</pre>
  
</div>

<div groupv>
<span title>Symmetric cryptography</span>
<pre zoom labels="learn_x_in_y_min,stream_cipher,block_cipher">
<span xsmall>Symmetric primitives</span>
Peer 1                              Peer 2
Plain → |Encrypt|→ C1 → |Decrypt| → Plain
            ^                ^
            └─ KEY("Secret") ┘
         Shared by peer 1 and 2 
NOTE: In symmetric crypto the key is often refered with
      the name of "password" to distinguish from the "private key"
      used in asymmetric crypto. schemas.

Symmetric cyrptography broadly splits into:
*Stream cipher*:
 - inputs of "any lenght". Very difficult to implement properly
   Implementations: ChaCha, ...
 
     INPUT     → |Keystream |→ K0, K1, ...
   (KEY, NONCE)  |Generator |         → XOR → C0, C1, ...
                               M0, M1, ... 
 
 - "BUTS": Generate a safe (non predictive) KEY for the stream cipher is "difficult"
*Block cipher*:
 - inputs must be divided into chunks of same size
 - Hide plaintext transformation to ciphertext through:
   - *confusion*: mapping input to output hard to predict (not linear and parts of keys)
   - *diffusion*: permutate bits
*SP-Networks*:
 - Most block ciphers are based on SP-Networks composed of:
   - Subtitution box : "map˂byte, byte˃"   (replace bytes with bytes )
   - Permutation box :  moves bits around
   - Some substitution plus permutation are combined into a single round
   - Rounds are then repeated enough times to ensure the algorithm is secure
   - SP-Networks alone are not enought. KEY secret is used like:
                  ROUND1                ROUND2
   Plain → XOR → |Subsitution| → XOR → |Subsitution| → C
           KEY   |Permutation|   KEY   |Permutation|

</pre>
<pre zoom TODO  labels="learn_x_in_y_min,block_cipher">
<span xsmall>Padding</span>:
@[https://en.wikipedia.org/wiki/Padding_(cryptography)]
- used when the message does exactly match a multiple of key size.
- Required by block padding cyphers. Streaming modes of operation 
  can encrypt and decrypt messages of any size and therefore do 
  not require padding.
</pre>

<pre zoom labels="learn_x_in_y_min,IV,block_cipher">
<span xsmall>Modes of operation</span>
- A block cipher by itself is only suitable for the secure cryptographic 
  transformation (encryption or decryption) of one fixed-length group of bits
  called a block. A mode of operation describes how to repeatedly apply a 
  cipher's single-block operation to securely transform amounts of data larger
  than a block.
- Most modes require a unique binary sequence, often called 
  an initialization vector (IV), for each encryption operation. The IV has to
  be non-repeating and, for some modes, random as well. The initialization 
  vector is used to ensure distinct ciphertexts are produced even when the 
  same plaintext is encrypted multiple times independently with the same key.
- Block ciphers have one or more block size(s), but during transformation
  the block size is always fixed.
- Block cipher modes operate on whole blocks and require that the last part
  of the data be padded to a full block if it is smaller than the current 
  block size.
- There are, however, modes that do not require padding because they 
  effectively use a block cipher as a stream cipher.
- Electronic code block (ECB):
  (WARN: Don't use it, if different messages share same data information leaks cans rise)
M1 → |E_k| → C1
M2 → |E_k| → C2
M3 → |E_k| → C3
- Cipher block chaining (CBC):
IV: Initialization vector
M1 → |XOR(IV)| → |E_k| → C1
   → |XOR(M2)| → |E_k| → C2 
   → |XOR(M3)| → C3
  "BUTs": 
   - Not paralelizable , and can not seek randomnly
   - Needs an IV (Difficult to generate)
- Counter Mode (CT):(Can be paralellized)
  Nonce + 0 → |E_k| → XOR(M1) → C1
  Nonce + 1 → |E_k| → XOR(M2) → C2
  Nonce + 2 → |E_k| → XOR(M3) → C3
  ^^^^^
 *Noces are used once*
 *IVs must be unpredictable*
</pre>
<pre zoom labels="learn_x_in_y_min,symmetric">
<span xsmall>AES</span>
-**: SP-Network based (Advanced Encryption Standard).
  - "Almost every block cipher uses AES". Supersedes DES (2002 Standard)
  - Built around Rijndael (SP-Network with 128bit block size) and key length of 128,192, 256 bit
  - Round count depends on key lenght: 10, 12 or 14 cycles
  - Each Round: SubBytes, ShiftRows, MixColumns
  - Modern CPUs have hardware instruccions to accelerate AES computation
  - AES-NI x86 acceleration:
  - REF: study of AES-NI acceleration using (Libre|Open)SSL
    @[https://calomel.org/aesni_ssl_performance.html] November 08, 2018
  - AES-NI x86-extension provides: 
    - improved the speed of cryptographic calcs. using AES standard (AES-128,AES-256,...).
    - Must be enabled through the BIOS.
    - Only supported by real CPU cores, NOT hyper-threaded/Virtual cores
    - Designed to provide 4x to 8x speed improvements.
    - Checking AES-NI enabled on linux:
      $ cat /proc/cpuinfo | grep flags
      flags           : fpu vme ...*aes* ... arat

  - Test benchmark:
    - TLS v1.2 and TLS v1.3 connections (typical connections in HTTP/2 , HTTPS clients)
    - Testing soft:
      LibreSSL 2.5.0 ( ~ OpenSSL 1.0.2d) ; FreeBSD 11 ; Clang LLVM compiler
      8192 byte blocks
       Script used for testing:
       $ openssl speed -elapsed -evp chacha
       $ openssl speed -elapsed -evp aes-128-gcm
       $ openssl speed -elapsed -evp aes-256-gcm
       $ openssl speed -elapsed -evp aes-128-cbc
       $ openssl speed -elapsed -evp aes-256-cbc

  *Results:*
  AES Performance per-CPU-core for TLS v1.2 Ciphers
  - MegaBytes-per-sec, Higher is Better
  - ChaCha20 (256 bit stream cipher, *NOT accelerated*) used as reference/baseline 
    (Note,*Google opts for ChaCha20 for low-powered devices*)
  
                    *ChaCha20  AES-128-GCM  AES-256-GCM  AES-128-CBC  AES-256-CBC  Total Score*
  AMD Ryzen 7 1800X   573       3006         2642         1513         1101        = 8835 
  Intel W-2125        565       2808         2426         1698         1235        = 8732
  Intel i7-6700       585       2607         2251         1561         1131        = 8135
  Intel i5-6500       410       1729         1520         1078          783        = 5520
  AMD FX 8350         367       1453         1278          716          514        = 4328
  AMD FX 8150         347       1441         1273          716          515        = 4292
  Intel E5-2650 v4    404       1479         1286          652          468        = 4289
  Intel i5-2500K      358       1274         1140          728          522        = 4022
  AMD Opteron 6380    293       1203         1063          589          423        = 3571
  Intel Xeon E5-2630  247        962          864          541          394        = 3008
  Intel Xeon L5630    225        701          610          626          450        = 2612
  Intel E5-2603 v4    236        866          754          382          274        = 2512
  Intel i7-950        401        256          218          358          257        = 1490
  Intel ATOM D525      98         51           43           28           20        =  240
  Snapdragon S4 Pro*1 131         41            -            -            -        =  172
  ARM Cortex A9    *1  73         24            -            -            -        =   97
  
  *1: Snapdragon and ARM Cortex values reported by Google Developers

  *How do I interpret the results ?*
  Let's suppose:
    - connection bandwidth: 10 Gbs (=1,250MBs)
    - Web server is able to concurrently encrypt|decrypt
      data to saturate the 10 gigabit connection.
    - Suppose 100% of our clients use AES-128-GCM cipher
  
  IDEALLY we would like the CPU could processes 10Gbs/1,250MBs of AES encrypted data per-cpu-core. 
  - Since we need to recieve (decrypt) and send (encrypt) the data we need at least two(2) CPU cores.
    -  each CPU must be able to sustain 1,250 MB/s.
  - From previous performance-table, just "AMD Opteron 6380" and  faster ones will be able to keep to pace.
    (Note: Opteron-6380 has 16 cores, so it leaves many other CPU cores for network I/O, firewall rules, ...)
  
  REAL-WORLD:
    - Clients connect with a variety of ciphers and the system is not dedicated to 
      just cipher processing.
    - It is also possible that the cipher processing of multiple cpu cores can be
      added together to reach the desired speed. 
      - "Intel Xeon L5630" four cores that can process up to 701 MB/s AES-128-GCM data.(2,804 MBs)
      (enough speed for encrypting and decrypting data on a 10 gigabit link using AES-128-GCM)
</pre>
</div>

<div groupv>
<span title>Asymmetric cryptography</span>
<pre zoom labels="learn_x_in_y_min,asymmetric,signature,authentication,PKI,session,rsa,dsa">
<span xsmall>Asymmetric primitives</span>

- 4 keys are need for bidirectional communication.
- Public  key (known to everyone) is used for encryption
- Private key (known to owner   ) is used for decryption

PEER 1                                                     PEER 2
            ENCRYPTION FROM PEER 1 TO PEER 2
            --------------------------------
        | Encrypt with |                | Decrypt with |
Plain → |    Peer 2    | → CypherText → |   Peer 2     | → Plain
text    | public  key  |                | private  key |   text


            ENCRYPTION FROM PEER 2 TO PEER 1
            --------------------------------

        | Decrypt with |                | Encrypt with |
Plain ← |    Peer 1    | ← CypherText ← |   Peer 1     | ← Plain
text    | private  key |                | private  key |   text


  - *public/private key* where Public Key can be computed easely from private key
      but the inverse in infeasible (intractable mathematical problem).
      WARN: Quantum computer will totally defeat it
  
  - *Signing* "==" message →Hash → PrivKey_encrypt → signature
    Everyone can decrypt using pub.key., probiding:
    
    - Non repudiability: Private key owner can not neglect having signed
    - Non tampering:message can not be moddified by third parties without the priv.key
    
  
  - *Encrypt*  "==" (one-directional) encrypt using public key
      One-directional: Only private key owner can de-encrypt. Priv.key owner can not encrypt, only sign
  

  - Asymmetric keys problems
    - Repeated use of key makes it easier to crack

</pre>
<pre zoom bgorange labels="learn_x_in_y_min,comparative,rsa,dsa,asymmetric,non_repudability">
<span xsmall>Digital Signature</span>
- Private key (known to owner   ) is used for signing.
- Public  key (known to everyone) is used for checking document signature.

-*THE TUPLE (SIGNING ALGORITHM, VERIFICATION ALGORITHM, KEY GENERATION ALGORITHM)   *
 *IS KNOWN AS THE DIGITAL SIGNATURE SCHEMA                                          *
 *(THE SET OF "ARROWS" IN THE NEXT SCHEMA PLUS THE NON-DISPLAYED PROCEDURE TO       *
 * GENERATE THE signer private key)                                                 *



                ─────────────                  ────────────── 
               │ INPUT       │                │    OUTPUT     │
───────────────┼─────────────┼                ┼───────────────┤
SIGNING:       |Doc          | → Doc Hash ─┐  |               |
               |             |            ─┼→ | Doc.Signature |
               |signer prv.K | ────────────┘  |               |
──────────────────────────────                ────────────────
VERIFYING      | Doc         | → Doc Hash ─┐  |               |
(Recursive     |signer pub.K ──────────────┼→ | TRUE | FALSE  |
               |Doc.Signature──────────────┘  |               |
──────────────────────────────                ────────────────

- Proves authenticity of sender: 
  No other but sender owning the priv.key could have created the signature

- Non-repudiable:
  Sender can NOT neglect the signature since no other has access to
  private key.

- <b>Authenticity + Non-repudiability = "Legal value"
  Signature probes the original intention of signer to sign/agree what
  is reflected in the document</b>
      
WARN: The key-generation algorithm is as important as the signing and verification
      algorithms. See for example:
      "How Perfect Offline Wallets Can Still Leak Bitcoin Private Keys"
    @[https://arxiv.org/abs/1501.00447]
      """... ECDSA has become a popular choice as lightweight alternative to RSA and 
      classic DL based signature algorithms in recent years. As standardized, the 
      signature produced by ECDSA for a pair of a message and a key is not 
      deterministic. This work shows how this non-deterministic choice can be 
      exploited by an attacker to leak private information through the signature 
      without any side channels, an attack first discovered by Young and Yung for 
      classic DL-based cryptosystems in 1997, and how this attack affects the 
      application of ECDSA in the Bitcoin protocol. """


- DSS/DSA:
r*WARN: SSH decided to drop DSS/DSA keys in favor of RSA due to "inherit weakness"*
@[https://www.gentoo.org/support/news-items/2015-08-13-openssh-weak-keys.html]
- See also critics to DSS @:
  @[http://groups.csail.mit.edu/mac/classes/6.805/articles/froomkin-metaphor/partIAB.html]
- United States government standard for authentication of electronic documents.
- DSS is a *document* describing the signing procedure and specifying certain standards.
  The original document is FIPS 186 and latest revision in 2013 is FIPS 186-4.
- DSA is a *cryptographic algorithm* that generates keys, signs data,
  and verifies signatures: 
  @[https://en.wikipedia.org/wiki/Digital_Signature_Algorithm]
  - based on the mathematical concept of modular exponentiation and the discrete logarithm problem.
  - DSA is a variant of the Schnorr and ElGamal signature schemes.
    (REF: "Applied Cryptography", Bruce Schneier, ISBN 0-471-11709-9)
- DSA, in itself, can use lot of "tunable switches" like the hash-funct, (L, N)-param-length,...
  DSS defines what those "tunnable switches" will be for the standard.
  - DSA should use hash-function: SHA-1 (recently SHA-2).
  - DSA should use specific length pairs: (2048,224), (3072,256), etc.
- 1994 Approbed by the USA National Institute of Standards and Technology (NIST), 
  - specified in Federal Information Processing Standard (FIPS) 186
    - Four versions exists:
      - FIPS 186-1 (1994)
      - FIPS 186-2 (????)
      - FIPS 186-3 (????)
      - FIPS 186-4 (2013)  @[https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf]
-  by:
  - DSA: Digital Signature Algorithm (standard)
  - RSA on the other hand refers to the initials of the people who created it. These are Ron Rivest, Adi Shamir, and Leonard Adleman. The DSA was designed as an encryption algorithm. The DSA was developed by the NSA to be used by the US government as a standard for digital signatures. This signature borrows heavily from the ElGamal Signature Algorithm from which most ideas were borrowed from. RSA, on the other hand, looks at the difficulty of factoring numbers as the main aspect of its development.
- RSA
- DSA
</pre>
<pre zoom labels="learn_x_in_y_min,">
<span xsmall>DSA/ECDSA/RSA</span>
<span xsmall>compared</span>
@[https://stackoverflow.com/questions/2841094/what-is-the-difference-between-dsa-and-rsa]
@[https://web.archive.org/web/20140212143556/http://courses.cs.tamu.edu:80/pooch/665_spring2008/Australian-sec-2006/less19.html]

 ____  ____    _                                                    ____  ____    _    
|  _ \/ ___|  / \                     __   _____                   |  _ \/ ___|  / \   
| |_) \___ \ / _ \                    \ \ / / __|                  | | | \___ \ / _ \  
|  _ < ___) / ___ \                    \ V /\__ \                  | |_| |___) / ___ \ 
|_| \_\____/_/   \_\                    \_/ |___/                  |____/|____/_/   \_\
                                                                                       
- RSA encryption and decryption are commutative                    (Digital Signature Algorithm)
  hence it may be used directly as a digital signature scheme      - variant of the ElGamal and Schnorr algorithms, but somewhat more complex,
- It's compatible with integer prime number factorization,           mostly because of the use of the secondary 160-bit modulus q used to help
  not with elliptic curves                                           speed up calculations and reduce the size of the resulting signature.
- It's computationally more expensive than DSA or ECDSA            - Can NOT be used for encryption
  but since it does not require a source of randomness is          - DSA Key Generation
  ussually prefered to alternatives in context like                  - firstly shared global public key values (p,q,g) are chosen:
  embedded systems/smartcards/....                                   - choose a large prime p = 2 power L
                                                                     - where L= 512 to 1024 bits and is a multiple of 64
- RSA provides us with Public (e,n) and Private (d)                  - choose q, a 160 bit prime factor of p-1
  - e is usally a small number,                                      - choose g = h power (p-1)/q
  - d is a much large number                                         - for any h1
  - n is avery large semi-prime number n=p.q                         - then each user chooses a private key and computes their public key:
                                                                     - choose x compute y = g power x(mod p)
  - given an RSA scheme {(e,R), (d,p,q)}                           
    to sign a message M, compute:                                   ┌────────────────────────────────────────────────────────────────────────────────────────┐
    S = M power d (mod R)                                           │                              DSA SCHEMA                                                │
    to verify a signature, compute:                                 │TO SIGN A MESSAGE M                            TO VERIFY A SIGNATURE, COMPUTE:          │
    M = S power e(mod R) = M power e.d(mod R) = M(mod R)            │generate random signature key k, k compute     w = s-1(mod q)                           │
                                                                    │r = (g power k(mod p))(mod q)                  u1= (SHA(M).w)(mod q)                    │
- RSA can be used both for encryption and digital signatures,       │s = k-1.SHA(M)+ x.r (mod q)                    u2= r.w(mod q)                           │
  simply by reversing the order in which the exponents are used.    │send signature (r,s) with message              v = (g power u1.y power u2(mod p))(mod q)│
  the secret exponent (d) to create the signature,                  │                                               if v=r then the signature is verified    │
  the public exponent (e) for anyone to verify the signature.       └^^^^^^^──────────────────────────────────────────────────────────────────────^^^^^^^^^^^┘
  Everything else is identical.                                      Signature creation is again similar to ElGamal                 Verification also consists of 
                                                                     with the use of a per message temporary signature key k,       comparing two computations, again being
                                                                     but doing calc first mod p, then mod q to reduce the           a bit more complex but related to El Gamal.
                                                                     size of the result.
                                                                     Note that the use of the hash function SHA is explicit here.
                                                                   
                                                                     NOTE: nearly all the calculations are mod q, and hence are much faster.



 ____  ____    _                                                    _____ ____ ____  ____    _    
|  _ \/ ___|  / \                     __   _____                   | ____/ ___|  _ \/ ___|  / \   
| |_) \___ \ / _ \                    \ \ / / __|                  |  _|| |   | | | \___ \ / _ \  
|  _ < ___) / ___ \                    \ V /\__ \                  | |__| |___| |_| |___) / ___ \ 
|_| \_\____/_/   \_\                    \_/ |___/                  |_____\____|____/|____/_/   \_\
@[https://www.ssl.com/article/comparing-ecdsa-vs-rsa/]
                                                                   Elliptic Curve DSA
                                                                   (TODO)
</pre>

<pre zoom labels="learn_x_in_y_min,">
<span xsmall>Dig.Sig.History</span>

1976: Whitfield Diffie and Marting Hellman describe
      the notion of digital Signature
      (previous work existed but was not disclosed
       in public)

1977: The RSA algorithm is invented 
      first version,"primitiv algorithm"
      RSA stays for:
      - (R)onal Rivest
      - Adi (S)hamir
      - Len (A)dleman
      - MIT was granted US patent 4.405.829 from 1983-2000

1978: Jacques Vélu, publish 
      "Courbes elliptiques munies d'un sous-group Z/nZxmu_n"
      Société Mathématique de France, 57, 1-152, Paris, 1978.
      @[http://archive.numdam.org/item/MSMF_1978__57__1_0/]

1985: ElGamal signature scheme by Taher Elgamal,
      later adopted by the DSS/DSA standard by
      US Guvernamental agencies.

1985: Neal Koblitz[7] and Victor S. Miller[8] suggest the use
      of elliptic curves in cryptography
      (We must wait until 2004/2005 to see broad ussage).
      1985 @[https://link.springer.com/chapter/10.1007%2F3-540-39799-X_31]
      1987 @[https://www.jstor.org/stable/2007884?seq=1] 1987

1988: Shafi Goldwasser, Silvio Micaly and Ronald Rivest
      rigorously define the security requirements of 
      digital signature schemes.
      Remember: in cryptography the scheme
      is the tuple of algorithm that define how to
      create the private key, distribute the public
      key, create a signature and verify it


1994: First DSA schema approved by DSS (FIPS 186-1)
      DSA is based on elGamal.

1995: Kocher described a new attack on RSA based on
      sufficient detail on hardware and time-measures
      to deduce the decryption key d quickly.
      Randomization of time output is needed to avoid it.

1995: FIPS 180-1, Secure Hash Standard

1998: ANSI X9.62-1998: Public Key Cryptography for the
      Financial Services Industry. The Elliptic Curve Digital
      Signature Algorithm. January 1999.

1999: NIST recommends 15 elliptic curves. 

2000: ESIGN Act makes online signatures legally binding

2013: Second DSA schema approved by DSS (FIPS 186-2).

2005: Elliptic Curve DSA 
    @[https://www.ietf.org/rfc/rfc4050.txt]


2009: PAdES: PDF Advanced Electronic Signatures
    @[https://en.wikipedia.org/wiki/PAdES]
    
2009: Benjamin Moody factored an RSA-512 bit key in 
      73 days using only public software (GGNFS) and
      a desktop computer with less than five gigabytes
      of disk storage and ~2.5 Gbytes RAM.
      - In 1999 it required the equivalent of 
        8_400MIPS years/seven months.
      - First exploits where reported in 2011
      (minimun 2048 bit is recomended)

2009: secg.org SEC 1: Elliptic Curve Cryptography
    @[http://www.secg.org/sec1-v2.pdf]
2010: secg.org SEC 2: Recommended Elliptic Curve Domain Parameters
    @[http://www.secg.org/sec2-v2.pdf]
2013: secg.org SEC 3: Elliptic Curve Qu-Vanstone Implicit Certificate
                      Scheme (ECQV)

2013: The New York Times stated that Dual Elliptic Curve Deterministic 
      Random Bit Generation (or Dual_EC_DRBG) had been included as a
      NIST national standard due to the influence of NSA, which had 
      included a r*deliberate weakness in the algorithm* and the 
      recommended elliptic curve. RSA Security in September 2013
      issued an advisory recommending that its customers discontinue using 
      any software based on Dual_EC_DRBG.
      - Cryptography experts have also expressed concern over the
        security of the NIST recommended elliptic curves, suggesting a
        return to encryption based on non-elliptic-curve groups. 

2013: Fourth DSA schema approved by DSS (FIPS 186-4).
2015: NSA announces plans to replace some ECDSA Suite B algorithms
      with a new cipher suite due to concerns about quantum-computing
      attacs on ECC.
</pre>

</div>

<div groupv>
<span title>Hash Primitives</span>
<pre zoom labels="learn_x_in_y_min,hash,integrity" >
<span xsmall>Hash primitives</span>
Plain  → | Hash | → Hash Result

- A single bit change in "Plain" input causes a completely 
  different Hash Result
- There are infinite plain inputs for each possible hash output,
  still given a single hash output, it's extremnly difficult to
  find any of the infinite plain inputs (without previous knowledge)
- Used to validate input integrity (input has not been modified).
- Frequently combined with symmetric/asymmetric primitives. 

- takes message of any lenght, and returns a pseudoramdom hash of fixed length
┌─── Loop ←──┐
│            │
Block of   Current ──→ Final hash
message     Hash
└──────→─────┘
- HMAC: An attacker doesn't know the shared KEY so he can not add the correct HASH
PlainText → |symmetric(KEY)| → CipherText 

CipherText + HASH(KEY+CipherText)
- Q: Why the "5381"/"33"/... constant in hash?:
@[https://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function]
  A: """ 5381 is just a number that, in testing, resulted in 
  fewer collisions (@[http://en.wikipedia.org/wiki/Collision_%28computer_science%29] and
  better avalanching(@[http://en.wikipedia.org/wiki/Avalanche_effect]).
  You'll find "magic constants" in just about every hash algo.
</pre>

<pre zoom labels="learn_x_in_y_min,symmetric,hash">
<span xsmall>HMAC primitives</span>
<span xsmall>"secret-shared signature"</span>

- HMAC = "MAC + symmetric encryption"
- Message passes throuh a hash function twice, and is combined with
  the (secret key) key before each pass

message 
    → sym.cypher(key inner)
        → hash 
            → sym.cypher(key outer) 
                → hash
                    → out 
  
  An HMAC authenticates a message (principal == "owner of private key").
    If a message comes with a correct MAC attached, it means this message
    was seen by a holder of the secret key at some point.
    HMAC is a signature based on a secret key, providing similar 
    assurances to a signature scheme based on public-key cryptography
</pre>  
<span xsmall>Diffie-Hellman</span>
<pre zoom labels="aaa,asymmetric,learn_x_in_y_min">
<span xsmall>Diffie-Hellman</span>
**: two non-local parties can jointly agree a shared secret over an insecure channel
    
    - DH-KEX (Key exchange) Underpins almost every aspect of our modern lives!
    - DH security is based first on "very big numbers", with 4096 bits becoming more ussual.
    - The DH-KEX generated shared-secret is usually called the "pre-master secret"
    - It's used to derive session keys through hashing for example
    - Ephemeral Mode. DH is used only for minutes/hours and not stored.
</pre>
    
 
</div>

<div groupv>
<pre zoom labels="learn_x_in_y_min,comparative">
<span title>Init Vector (IV)</span>
<span xsmall>(symmetric enc)</span>
@[https://en.wikipedia.org/wiki/Initialization_vector]
- in symmetric encryption is used to ensure distinct ciphertexts are produced even when the 
  same plaintext is encrypted multiple times with the same key.
  IV must not be repeated, and depending on the scheme used must also be UN-predictable 
  (cryptographically random)
  
<span title>Salt</span>
<span xsmall>(Hashing)</span>
@[https://en.wikipedia.org/wiki/Salt_(cryptography)]
- is random data that is used as an additional input to a one-way function 
  that "hashes" data, a password or passphrase. Salts are closely related to 
  the concept of nonce. The primary function of salts is to <b>defend against
  dictionary attacks</b> or against its hashed equivalent, a pre-computed rainbow table attack.
 *Nonce must not be repeated, but can be predictable. Salts must not be repeated, and*
 *also they must be cryptographically random to be secure.*

<span title>Nonce</span>
<span xsmall>(session establishment)</span>
@[https://en.wikipedia.org/wiki/Cryptographic_nonce]
- an arbitrary number that *can only be used once*. 
- Can be public or predictable but ussually it's a 
  pseudo-random number *issued in an authentication protocol*
 *to ensure that old communications cannot be reused in replay attacks:*
  - In this attack a cracked limits to replay the encrypted 
    session-establishment encrypted raw data between client and 
    server hopping to obtain a session token.
  - Since the nonce has already been used/wasted by the original
    client, the session establishment will fail.
- They can also be useful as IVs and in cryptographic hash functions.
</pre>
</div>

<div groupv>
<span title>Advanced Primitives</span>

<pre zoom labels="" TODO>
<span xsmall>Fernet sym. encrypt</span>
- Fernet guarantees that a message encrypted using it 
  cannot be manipulated or read without the key.
- Fernet also has support for implementing key rotation via MultiFernet.
</pre>

<pre zoom>
<span xsmall>Key Derivation,</span>
<span xsmall>Multi/Group/Ring</span>
<span xsmall>/Proxy/Threshold/Blind sig. </span>
┌─────────────────────────┬────────────────────────────────────────────────────┐┌────────────────┬───────────────────────────────────────────────────────────────┐
│*KEY DERIVATION FUNCTION*│                                                    ││*MULTISIGNATURE*│                                                               │
├─────────────────────────┘                                                    │├────────────────┘                                                               │
│- @[https://en.wikipedia.org/wiki/Key_derivation_function]                    ││@[https://en.wikipedia.org/wiki/Multisignature]                                 │
│- Derive one or more secret keys from a first secret one                      ││- Digital signature scheme which allows a group of users to                     │
│- Many key d.f. admits a salt to avoid returning the smae output keys from    ││  sign a single document. Usually, a multisignature algorithm produces          │
│  the same input secret                                                       ││  a joint signature that is more compact than a collection of distinct          │
│- Two main categories, depending on the entropy content of the secret value   ││  signatures from all users                                                     │
│  which determines how many differnet possible values the secret value can    ││- A tuple of N signatures is the simplest (non-compacted)                       │
│  take                                                                        ││  multisignature scheme                                                         │
│  - input secret is user-supplied (low entropy): Key d.f will require lot     ││- Multisignature can be considered as generalization of both group              │
│    of computing resources to avoid attackers to just compute all possible    ││  and ring signatures.                                                          │
│    (scrypt)                                                                  ││  - Used to add additional security for cryptocurrency transactions             │
│                                                                              ││  - The required number of signatures is agreed upfront                         │
│  - input secret is random (high entropy): A trivial key derivation will      ││  - Allows for the creation of N-of-M escrow services                           │
│    suffice (HKDF)                                                            ││  - Tree-signatures (Aug 24, 2015 by Pieter Wuille, Ph.D.):                     │
│- HKDF (HMAC-based (Extract-and-Expand) Key Derivation Function, defined in   ││    @[https://www.blockstream.com/2015/08/24/treesignatures/]                   │
│  RFC 5869, @[http://eprint.iacr.org/2010/264] requires high entropy initial  ││   """Imagine you want to create a 1-of-11 multisig (with 11 known public keys).│
│  input key.                                                                  ││   You compute the SHA256 hashes of the public keys involved and put them in    │
│- Argon2Id(@[https://en.wikipedia.org/wiki/Argon2] is a key der. func.,       ││   a Merkle tree. In the graph below, all symbol names represent 32-byte hashes,│
│  selected as winner of the Password Hashing Competition in July 2015.        ││   except the 1. The 1 is used as a simple constant instead of a right branch   │
│  - It maximizes resistance to GPU cracking attacks and time-memory-trade-off ││   when there is none."""                                                       │
│    (TMTO) attacks.                                                           ││                                 R                                              │
│  - It maximizes resistance to resist side-channel attacks.                   ││                              /     \                                           │
│  - It is an hybrid version (Recomended). The Internet draft[4] recommends    ││                           /           \                                        │
│    using Argon2id except when there are reasons to prefer one of the other   ││                       /                   \                                    │
│    two modes.                                                                ││                   Z1                          Z2                               │
└──────────────────────────────────────────────────────────────────────────────┘│                /      \                     /   \                              │
                                                                                │           Y1              Y2              Y3     1                             │
┌─────────────────┬───────────────────────────────────────────────────────────┐ │          /  \            /  \            /  \                                  │
│*GROUP SIGNATURE*│                                                           │ │       X1      X2      X3      X4      X5      X6                               │
├─────────────────┘                                                           │ │      / \     / \     / \     / \     / \     / \                               │
│@[https://en.wikipedia.org/wiki/Group_signature]                             │ │     K1 K2   K3 K4   K5 K6   K7 K8   K9 K10 K11  1                              │
│- A group signature scheme is a method for allowing a member of a group to   │ │                                                                                │
│  anonymously sign a message on behalf of the group.                         │ │   "" Using the script in our Alpha sidechain, we can build a script that takes │
│- For example, a group signature scheme could be used by an employee of      │ │   as input a public key, a signature, and a Merkle path. At verification time, │
│  a large company where it is sufficient for a verifier to know a message    │ │   it would use the Merkle path to prove that the public key belongs to a tree  │
│  was signed by an employee, but not which particular employee signed it.    │ │   with root R, and that the signature checks out with that public key."""      │
│- Essential to a group signature scheme is a group manager, who is in charge │ └────────────────────────────────────────────────────────────────────────────────┘
│  of adding group members and has the ability to reveal the original signer  │ ┌─────────────────┬───────────────────────────────────────────────────┐
│  in the event of disputes. In some systems the responsibilities of adding   │ │*PROXY SIGNATURE*│                                                   │
│  members and revoking signature anonymity are separated and given to a      │ ├─────────────────┘                                                   │
│  membership manager and revocation manager respectively.                    │ │ A proxy signature allows a delegator to give partial signing rights │
└─────────────────────────────────────────────────────────────────────────────┘ │ to other parties called proxy signers. Proxy signatures do not offer│
┌────────────────┬──────────────────────────────────────────────────────────┐   │ Anonymity                                                           │
│*RING SIGNATURE*│                                                          │   └─────────────────────────────────────────────────────────────────────┘
├────────────────┘                                                          │ ┌────────────────────────┬───────────────────────────────────────────────────┐
│@[https://en.wikipedia.org/wiki/Ring_signature]                            │ │*THRESHOLD CRYPTOSYSTEM*│                                                   │
│- Type of digital signature that can be performed by any member of         │ ├────────────────────────┘                                                   │
│  a group of users that each have keys.                                    │ │@[http://en.wikipedia.org/wiki/Threshold_cryptosystem] (TODO)               │
│  One of the security properties of a ring signature is                    │ │- In order to decrypt an encrypted message, several parties                 │
│  that it should be computationally infeasible to determine which of       │ │  (more than some threshold number) must cooperate in the decryption        │
│  the group members' keys was used to produce the signature                │ │  protocol. The message is encrypted using a public key and the             │
│- Ring signatures are similar to group signatures but differ in two key    │ │  corresponding private key is shared among the participating parties.      │
│  ways: first, there is no way to revoke the anonymity of an individual    │ │  Let "n" be the number of parties. Such a system is called (t,n)-threshold,│
│  signature, and second, any group of users can be used as a group without │ │  if at least t of these parties can efficiently decrypt the ciphertext,    │
│  additional setup.                                                        │ │  while less than t have no useful information.                             │
│- Invented by Ron Rivest, Adi Shamir, and Yael Tauman, and introduced      │ │- Similarly it is possible to define (t,n)-threshold signature scheme,      │
│  at ASIACRYPT in 2001                                                     │ │  where at least t parties are required for creating a signature.           │
│- Suppose that a group of entities each have public/private key pairs,     │ │- The most common application is in the storage of secrets in multiple      │
│  (Pub_1, Secret_1), ..., (Pn, Secret_n).                                  │ │  locations to prevent the capture of the ciphertext and the subsequent     │
│  Party i can compute a ring signature σ on a message "m", on input        │ │  cryptanalysis on that ciphertext. Most often the secrets that are         │
│  ("m", Secret_i, Pub_1, ..., Pub_n). Anyone can check the                 │ │  "split" are the secret key material of a public key cryptography key      │
│  validity of a ring signature given σ, m, and the public keys involved,   │ │  pair or the ciphertext of stored password hashes.                         │
│  P1, ..., Pn. If a ring signature is properly computed, it should pass    │ │- In October 2012 after a number of large public website password           │
│  the check. On the other hand, it should be hard for anyone to create a   │ │  ciphertext compromises, RSA Security announced that it would be           │
│  valid ring signature on any message for any group without knowing any    │ │  releasing software that makes the technology available to the general     │
│  of the private keys for that group.                                      │ │  public                                                                    │
└───────────────────────────────────────────────────────────────────────────┘ └────────────────────────────────────────────────────────────────────────────┘
┌─────────────────────────────┬──────────────────────────────────────────────┐ ┌─────────────────────────────────────┬──────────────────────────────┐
│*BLIND (CHAUMIAN) SIGNATURE**│                                              │ │*Identity-Based Aggregate Signatures*│                              │
├─────────────────────────────┘                                              │ ├─────────────────────────────────────┘                              │
│@[https://en.wikipedia.org/wiki/Blind_signature]                            │ │@[https://link.springer.com/chapter/10.1007/11745853_17]            │
│- Blind signature schemes exist for many public key signing protocols       │ │ An aggregate signature is a single short string that convinces any │
│  Blind RSA signatures, Blind ECDSA signatures,                             │ │ verifier that, for all 1 ≤ i ≤ n, signer S i signed message M i ,  │
│- Java implementation:                                                      │ │ where the n signers and n messages may all be distinct. The main   │
│  @[https://archive.is/20130416090835/http://www.maniora.pl/?p=101"]        │ │ motivation of aggregate signatures is compactness. However, while  │
│                                                                            │ │ the aggregate signature itself may be compact, aggregate signature │
│- form of digital signature in which the content of a message is            │ │ verification might require potentially lengthy additional          │
│  disguised/blinded before being signed. The resulting blind signature can  │ │ information – namely, the (at most) n distinct signer public keys  │
│  be publicly verified against the original, unblinded message in the manner│ │ and the (at most) n distinct messages being signed. If the verifier│
│  of a regular digital signature.                                           │ │ must obtain and/or store this additional information, the primary  │
│- Blind signatures are typically employed in privacy-related                │ │ benefit of aggregate signatures is largely negated.                │
│  protocols where the signer and message author are different parties.      │ └────────────────────────────────────────────────────────────────────┘
│  Examples include cryptographic election systems and digital cash schemes: │
│                                                                            │
│  ┌────────────────────────────────────────────────────────────────┐        │
│  │Seq. Diagram                                                    │        │
│  │participant user # creates a message ("vote") and blinds it     │        │
│  │participant signer # authenticates user and sign blinded message│        │
│  │signer → user: authenticate user                                │        │
│  │user   → user: +message                                         │        │
│  │user   → user: message → blind → blinded_message                │        │
│  │user   → signer: blinded_message                                │        │
│  │signer → signer: +signed_blinded_message                        │        │
│  └────────────────────────────────────────────────────────────────┘        │
└────────────────────────────────────────────────────────────────────────────┘
</pre>
<pre zoom labels="">
<span xsmall>Crypto accumulator</span>
A cryptographic accumulator is a one way membership function. It answers a 
query as to whether a potential candidate is a member of a set without 
revealing the individual members of the set. One example is how large 
composite numbers accumulate their prime factors, as it's currently 
impractical to factor a composite number, but relatively easy to divide a 
specific prime into another number to see if it is one of the factors and/or 
to factor it out. New members may be added or subtracted to the set of 
factors simply by multiplying or factoring out the number respectively. More 
practical accumulators use a quasi-commutative hash function where the size (
number of bits) of the accumulator does not grow with the number of members. 
</pre>

<pre zoom labels="" TODO>
<span xsmall>Zero Probe Knowledge</span>
@[https://blog.plan99.net/vntinyram-7b9d5b299097]
@[https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649]
- A zero-knowledge proof is a cryptographic method where one party (the prover)
  can prove toanother party (the verifier) that the prover knows a value x, 
  without conveying any informationapart from the fact that the prover knows 
  the value x
</pre>

<pre zoom>
<span xsmall>Homomorphic Encryption</span>
@[https://en.wikipedia.org/wiki/Homomorphic_encryption]
-http://enigma.media.mit.edu/
-http://www.xataka.com/privacidad/enigma-renace-el-cifrado-homomorfico-y-el-blockchain-como-base-de-una-internet-mas-privada
</pre>

</div>
<div groupv>
<span title>Data integrity</span>
<pre zoom labels="hash,">
<a xsmall href="https://en.wikipedia.org/wiki/Hash_chain">Hash chain</a>
non-repudiable probe of data chronology
doc1 → hash → has1 ─┬→ hash → has2 ─┬→ hash → has3 ─┬→ hash
               doc2─┘         doc3 ─┘         doc4 ─┘        
*Merkle tree*
@[https://en.wikipedia.org/wiki/Merkle_tree]
- Allows to check if a leaf (data) is part of the tree with just a
  subset of the tree
- NOTE: In blockchain leafs are transactions and the tree is a block


- TODO:
  *Patricia Tree* (Used by Ethereum,...)
</pre>
<pre zoom labels="learn_x_in_y_min,">
<span xsmall>Secret sharing</span>
@[https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing]
- provides a method of secret sharing, where a secret is divided into parts,
  giving each participant its own unique part, where some of the parts or all
  of them are needed in order to reconstruct the secret.
   Counting on all participants to combine the secret might be impractical, and
   therefore sometimes the threshold scheme is used where any "k" of the parts 
   are sufficient to reconstruct the original secret
  The essential idea of Adi Shamir's threshold scheme is that 2 points are 
   sufficient to define a line, 3 points are sufficient to define a parabola, 4
   points to define a cubic curve and so forth. That is, it takes k points to 
   define a polynomial of degree k − 1
</pre>

<span title>(Remote)Authentication</span>
<pre zoom labels="learn_x_in_y_min,">
<span xsmall>Challenge-response</span>
- cryptographic primitive
- Used mostly in communication protocols.
- Authentication server encrypts a challenge 
  (typically a random number) with a public key. 
  The device proves it possesses a copy of the
  matching private key by providing the decrypted 
  challenge.
</pre>


<pre zoom>
<span xsmall>Authenticated Encryption (AE)</span>
<span xsmall>AE with associated data(AEAD)</span>

<a xsmall href="https://en.wikipedia.org/wiki/Authenticated_encryption"></a>
- The need for AE emerged from the observation that securely combining 
   separate confidentiality and authentication block cipher operation modes 
   could be error prone and difficult confirmed by a number of practical
   attacks introduced into production protocols and applications by 
   incorrect implementation, or lack, of authentication (including SSL/TLS)
- A typical programming interface for AE mode implementation would provide the following functions:

 Encryption
     Input : plaintext, key, and optionally a header in plaintext that will not 
             be encrypted, but will be covered by authenticity protection.
     Output: ciphertext and authentication tag (message authentication code).
 Decryption
     Input : ciphertext, key, authentication tag, and optionally a header.
     Output: plaintext, or an error if the authentication tag does not match 
             the supplied ciphertext or header.

- Approaches to authenticated encryption:
  - Encrypt-then-MAC (EtM)
  - Encrypt-and-MAC (E-and-M)
  - MAC-then-Encrypt (MtE)
</pre>
</div>
<div groupv>
<span title>OAuth</span>
<pre zoom labels="aaa,jwt">
<span TODO xsmall>Summary</span>
TODO:
-@[https://oauth.net/2/]
-@[http://tutorials.jenkov.com/oauth2/authorization.html]
-@[https://oauth.net/1/grant-types/]

USE Cases:
- application that can read user data from another application 
- application that enables other applications to access its user data
  (e.g. Facebook in the example above). 

REF: @[http://www.youtube.com/watch?v=YLHyeSuBspI]
The idea is to obtain a temporal o*access_token* that expires in "N" hours.
This access_token is a secret shared between the OAuth2 client and the OAuth2 server (Client flow)

*INITIAL (ONCE-ONLY) SETUP (APP ADMIN):*
Register server app to OAuth2 Service provider:

Admin → "Google" Admin page. Request for:
        | OAuth2 g*client.id*
        | OAuth2 g*client.secret*


*CLIENT OAuth2 Login:*
 ───────────────────────────────────────────────┬─────────────────────────────────────────────────────
       CLIENT FLOW:                             │         SERVERSIDE FLOW:
                                                │
 ───────────────────────────────────────────────┼─────────────────────────────────────────────────────
                                                │ participant app_server
 participant Web Client as Client               │ participant Web Client as Client
 participant "Google"/...OAuthService           │ participant "Google"...OAuthService as OAuthSer
                                                │
 Client.UI →  Google Oauth: Redirect with       │ Client.UI  →  Google Oauth: Redirect with
                           input params:        │                           input params: 
   |scope                                       │   |scope
   | + 'https://www.googleapis.com/auth/tasks'  │   | + 'https://www.googleapis.com/auth/tasks'
   |authorizationURLBase:                       │   |authorizationURLBase:
   | 'https://accounts.google.com/o/oauth2/auth'│   | +'https://accounts.google.com/o/oauth2/auth'
   |redirect URI                                │   |redirect URI:
   | + b*'http://myapp.com/oauth2callback.html'*│   | + 'http://myapp.com/oauth2callback.html'
  *|response            : 'token'*              │  *|response            : 'code'*
                                                │  *|access_type         : 'offline'*
                                                │
 Google Popup → Client.UI: Show Popup           │Google Popup → Client.UI: Show Popup
                ╭────────────╮                  │               ╭────────────╮
                │Google      │                  │               │Google      │
                │   ╭───────╮│                  │               │   ╭───────╮│
                │   │ Allow ││                  │               │   │ Allow ││
                │   ╰───────╯│                  │               │   ╰───────╯│
                ╰────────────╯                  │               ╰────────────╯
 Client → Client.Popup: Click "Allow"           │ Client → Client.Popup: Click "Allow"     
 Popup.JS → UI: Redirect to client(JS)app       │ Popup.JS → UI: Redirect to 
b*http://myapp.com/oauth2callback.html?*        │b*http://myapp.com/oauth2callback.html*?*code=1234324afge*
        with o*#access_token:12345*!!!          │
                                                │
                                                │ Client.UI → app_server: oauth2callback(*code=1234324afge*)
                                                │ app_server → OAuthSer:  get token(
                                                │                           *code=1234324afge*,                                                   )
                                                │                          g*client.id*,
                                                │                          g*client.secret*)
                                                │ app_server ← OAuthSer :o*access_token* !!!
                                                │ ...
                                                │ app_server → OAuthSer: Request(... o*access_token*)
 ───────────────────────────────────────────────┴─────────────────────────────────────────────────────

<span TODO xsmall>OAuth 2 Grans</span>
- <a href="https://alexbilbie.com/guide-to-oauth-2-grants/">[REF]</a>

<span xsmall>JSON Web Token(JWT)</span>
@[https://jwt.io/introduction/]
@[https://en.wikipedia.org/wiki/JSON_Web_Token]
- open standard (RFC 7519) that *defines a compact and self-contained* way for
 *securely transmitting information between parties* as a JSON object.
- This information can be verified and trusted because it is *digitally signed*
- JWTs can be signed using a :
  - secret (HMAC algorithm) 
  - or a public/private key pair using RSA or ECDSA.
</pre>

<span title>OpenID</span>
<pre zoom>
<a xsmall TODO href="https://www.simpleorientedarchitecture.com/openid-connect-in-a-nutshell/">OpenID</a>
@[https://stackoverflow.com/questions/1087031/whats-the-difference-between-openid-and-oauth]
@[https://security.stackexchange.com/questions/44611/difference-between-oauth-openid-and-openid-connect-in-very-simple-term/130411#130411]
@[https://en.wikipedia.org/wiki/OpenID#OpenID_vs._pseudo-authentication_using_OAuth]
    """
    OpenID is about verifying a person's identity.
    OAuth is about accessing a person's stuff.
    OpenID Connect does both.
    """
OpenID Connect (2014) combines the features of OpenID 2.0, OpenID Attribute Exchange 1.0, and OAuth 2.0 in a single protocol.

<span xsmall>Dex</span>
@[https://github.com/dexidp/dex]
Dex is an identity service that uses OpenID Connect 
to drive authentication for other apps.
Dex acts as a portal to other identity providers through
"connectors." This lets dex defer authentication to 
LDAP servers, SAML providers, or established identity 
providers like GitHub, Google, and Active Directory.

 Clients write their authentication logic once to talk 
to Dex, then Dex handles the protocols for a given backend.
</pre>

<pre zoom labels="aaa,comparative">
<span xsmall>OpenID vs OAuth2 vs SAML</span>
REF:
@[https://spin.atomicobject.com/2016/05/30/openid-oauth-saml/]

- single sign-on (SSO) allows a user to enter sign once
  and "enter" multiple applications or web-sites.
  This means that some sort of "authentication token"
  must be provided to the user on first sign for later
  reuse.

- developers of the SSO applications don't have to
  store or request for passwords. Instead, they can
 *accept proof of identity or authorization*
 *from a trusted source*

- OpenID, OAuth2 and SAML are different security protocols
  for single sign-on

  the relying party.
*OpenID*
- open standard for authentication
- As of March 2016, there are over a billion 
  OpenID-enabled accounts on the internet.
- Google, WordPress, Yahoo, PayPal use OpenId
  to authenticate users.

OpenID FLOW:
user → id_provider01: request OpenID account
user ← id_provider01: OpenID account
                      ^^^^^^^^^^^^^^
                      technically it's a URL
                      (e.g. alice2016.myIDprovider.org)
       
user → web_site login_screen: Select "sign with id_provider01"
       (relying party)
web_site login_screen → id_provider01: request association handle
web_site login_screen ← id_provider01: association handle
user ← web_site login_screen: redirect to id_provider01 login page
user → id_provider01: enter OpenID account + credentials (pass,...)
user ← id_provider01: auth.token + url_redirect o web_site 
                      ^^^^^^^^^^
                      signed claim statying that id_provider01
                      believes user is actually user
user → web_site url : auth.token
web_site url → web_site url : Check auth.token is signed by trusted
                              id_provider01
web_site url → web_site url : Create session for user
user ←→ web_site url : --- app session ---

- 2014: Latest version (OpenID Connect) combines:
  - OpenID authentication  (user is who he claims to be)
  - OAuth2 authorization   (user is authorized a set of actions)

*OAuth2*
- Confusingly, OAuth2 is also the basis for OpenID Connect -2014-)
- Confusingly, authorization is also considered some time a form
 of pseudo-authentication and OAuth2 is claimed to be an 
 authentication standard. (An authorization signed token is a
 claim that the user is believed to be himself for the act of
 executing an action or accesing some resource). 

- open standard for authorization.
- OAuth2 provides secure delegated access:
  - application clients will use temporal tokens issued by
    the identity-provider to the user to access resources
    on another resource-server on behalf of the user.

*SAML*
- 2001: oldest standard of the three
- 2005: latest update.
- stands for Security Assertion Markup Language. 
- provides authentication + authorization.
- SAML defines:
  - principal (end user).
  - service provider (application web site)
  - identity provider:  server holding principal's ids + credentials.

user           → ser_rovider01: request service (action on a webapp)
ser_provider01 → id_provider  : XML message
                                -----------
                                required info
                                who_is_asking (ser_provider01) 
                                response_url
id_provider    → response_url : SAML signed response assertion
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                               (similar to a token in OpenID/OAuth2).
                                The assertion can contain statements
                                about authentication, authorization,
                                and/or attributes (emails, phones,...).

SAML 2.0 defines:
- assertions: 
- protocols : assertion requests and responses)
- bindings  : how requests/responses happen between the service provider and identity provider
              using communication methods like HTTP POST
- profile   : allowed combinations of (assertions, protocols, bindings)
              for various use cases, like SSO.

                    OAuth2             OpenId              SAML

Token format        JSON or SAML2      JSON                XML
(assertion)

Authorization?      Yes                No                  Yes

Authentication?     Pseudo-auth        Yes                 Yes

Year created        2005               2006                2001

Current version     OAuth2             OpenID              SAML 2.0
                                       Connect
    
Transport           HTTP               HTTP                - HTTP Redirect 
                                       GET/POST              (GET) binding
                                                           - SAML SOAP 
                                                             binding
                                                           - HTTP POST 
                                                             binding
                                                           - "others"


SECURITY RISKS      Phishing[1]        Phishing[1]         XML Signature
                                                           Wrapping to
                                                           impersonate 
                                                           any user



Best suited for     - API              - consumer apps     enterprise
                      authorization      Single sign-on    Single sign-on
                                         delegating SSO    
                                         to Google,...     

[1] OAuth 2.0 does not support signature,
    encryption, channel binding, or 
    client verification.  
    It relies completely on TLS for
    confidentiality.
    
    anyway, i have a question or maybe a misunderstanding about the term authorization in sso and i hope someone can solve it ^^.

    In the user context authorization means to give a user acces to a ressource. in server-based applications you could do this with in database-stored lists of rights and/or roles for example. same for hybrids but i don’t really know how to do it with real SPA’s. In my Opinon this has nothing to do with SSO.

    in the oauth (and maybe sso?) context authorization means giving a client (a website) access to resource an behalf of a user. For example the client has access to my facebook friendlist.

    Does authorization in sso stands for giving rights to a user or giving rights to a application? or… ehm both? does it depend? ^^

    best regards,
    andy
        R
        December 7, 2017    

        Giving rights to the user who’s browser signed into the SSO site. We are dealing with design issues in an app of ours because SAML assertions for authenticated users do not provide the information/security we need to *authorize* inter-application API requests made on behalf of the user. OAuth2 is definitely the solution for authorization when making app-to-app requests on behalf of users. Especially when transmitting username and password is not an option.
    Enda
    November 28, 2016   

    I love a good real world analogy and the border control example here is excellent.

    Thanks for putting this together Jaime – I found it incredibly useful.
    Billy Bao
    December 6, 2016    

    A very good knowledge share article, excellent!
    ee
    December 8, 2016    

    OAuth2 is for Delegation !! not authorization or authentification
    Willow9886
    December 12, 2016   

    Nice article! We also just posted a blog discussing the differences and similarities between these three protocols: http://www.gluu.co/oauth-saml-openid
    Naga
    January 11, 2017    

    Nice presentation, thanks
    Seif
    January 24, 2017    

    Hi Jaime, great description, thank you for that,
    I would like to ask if SAML can work for desktop applications as well ?
    thank you
        Junaid
        September 21, 2017  

        No SAML is for web only.
    Oliver G
    January 24, 2017    

    The best summary of the protocols I’ve yet read, many thanks!
    Srikanth GM
    January 24, 2017    

    Hi ,

    Great article, however I would like to get one thing clarified, as per my understanding

    Federated Identity management : – SAML, OAuth and OpenID
    Single-sign-on – Kerberos.

    I just think both were confused, however I may be wrong. Kindly enlighten me!
    Tulsi
    January 25, 2017    

    Great article. Helped me to get clarity on SAML and OAuth2.0

    Thanks
    Nick
    March 21, 2017  

    Very interesting blog and great introduction to these key technologies and concepts. So many people use these terms interchangeably and you helped clarify the distinction for me.
    Varun Vatsa
    March 22, 2017  

    Jaime, first of all great article, going to help me big time, but I am still confused with the role of JWT token and do see it been mentioned anywhere in your article, can you please help me understand that as well where does it fit in the picture and whats the diff between SAML Assertion and JWT assertion.
    Roncat
    March 30, 2017  

    Thanks for posting. It is very well explained. Congratulations!
    Jason
    April 2, 2017   

    Dear Jamie, this is wonderfully clear.
    I have one additional question: we want people to login to our family of websites by creating one central identity on our main website. What is the best way to become an identity provider ourselves? Or does one of the protocols above solve that?

    Yo continue your example, if you would create a second website, you would want people to create a central ID on your first one? Or alternatively, create a super ID that links I to all?

    Thanks!
    Binh Thanh Nguyen
    April 13, 2017  

    Thanks, nice post
    Sreedhar Balerao
    April 26, 2017  

    Jamie

    This is an Awesome article, with details on all 3 major authentication models.

    Thanks
    Sreedhar
    Bo Carlsson
    June 10, 2017   

    Great article! I mean Great. Thanks for this!
    Nicholas Noor
    July 31, 2017   

    Good article, will read this again as I’m still new to the OAuth and OpenID world. But your article sure spells out clearly. Just have to embed these in my mind.
    Claudio Licht
    August 7, 2017  

    Great article!
    Perhaps you can clear a related question since you are so good at explaining!
    In looking into OAUTH2 I see there are scopes and there are claims … It seems that scopes are more generic and claims give more granularity … Would you agree with this? Perhaps you can expand or explain when one would use each one?
    aTdHvAaNnKcSe !!!
    C
    (thanks IN advance)
    Junaid
    September 21, 2017  

    Very well written. Thank you
    Val Batchellor
    October 2, 2017 

    This is a brilliant summary Jaime. Thanks vey much for that.
    thanhvk
    October 19, 2017    

    Many thank you!
    It details and, well written and clear.
    Alfred
    November 14, 2017   

    Indeed a great article on SSO. Keep up with good work!
    Jean
    November 23, 2017   

    Awesome post, really easy to understand without being incomplete.
    Sushant
    December 6, 2017    

    Best article I’ve seen on the subject so far! The analogies really helped. Thanks!
    Subhayu
    January 18, 2018    

    Very well articulated. Thanks a lot!
    Janee
    February 24, 2018   

    Still reading and finding it useful in 2018! I especially like the examples on border control. I have one quesiton (same as another poster). You summarised that Open ID does not offer authorization. I assume this is no longer the case for OpenID Connect which is built on OAuth 2.

    Could you clarify?
    KS
    March 6, 2018   

    Yes, reading after tons of sites to get a clarity on protocol, framework, oauth, openid, SAML, I was getting no where and in fact more confused. Great and pretty clear write up! Keep up the great work.
    I see many examples for OpenID/OAuth, would you recommend any site with example for SAML implementation.
    Ashish
    March 9, 2018   

    This is really well written article providing overview and comparison of authentication & authorization protocols. You really know how to explain things.
    Ashish
    March 9, 2018   

    Though one question, is SAML token format and protocol both (unlike to JWT, which is just token format)?

Comments are closed.

We're hiring in Grand Rapids & Ann Arbor open positions >
x

Atomic does more than talk about software. We also make it — for clients large and small in all kinds of industries.
Check out our portfolio.

</pre>
</div>

<div groupv>
<span title>TLS protocol</span>
<pre zoom labels="protocol">
<span xsmall>External Links</span>
- <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Wikipedia</a>
- <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">Mozilla SSL config generator</a>
- <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla Server Side TLS</a>
- <a href="https://www.ssllabs.com/ssltest/">SSL Server Test</a>
</pre>
<pre zoom bgorange labels="protocol" >
<span xsmall>X.509 Format</span>
@[https://en.wikipedia.org/wiki/X.509]
(ITU_T standard)
containing: 
- *public/private key certificates*
- *identity*: hostname + organization/individual
- *certificate revocation lists*: certificates are no longer 
  valid,
- <def>certification path validation algorithm</def> allowing for 
  certificates to be signed by intermediate CA certificates, which are in 
  turn signed by other certificates, eventually reaching a trust anchor.
- Used amongst others by Internet protocols like TLS/SSL
- X.509 v3:
  Version#
  Serial Number
  Signature algorithm
  Issuer name
  Validity period
  Subject name
  Subject PK Info
  Issuer ID#
  Subject ID#
  Extensions
  ──────────────────
  CA Signature 

*View x509 contents:*
$ openssl x509 -text -in myCert.pem
</pre>

<pre zoom labels="tls,x509,fingerprint,web,java">
<span title>openSSL</span>
│*External Refs*
│@[https://www.openssl.org/docs/manmaster/man1/]
│@[https://www.ietf.org/rfc/rfc5280.txt] X.509 PKI
│- The Most Dangerous Code in the World: Validating SSL Certs ...:
│@[https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf] 


│*Common opts*
│-nodes: flag: *DO NOT* pass-phrase-encrypt Pub.Key
│-noout: prevents output of encoded version of request
│-text : Show human readable output (vs hex formated binary))


│*Global Flow*                             │*useful ENV.VAR (DOMAIN/SUBJ)*
│admin→admin: Create Private Key           │$ export DOMAIN="mydomain.com"
│admin→admin: Create CSR                   │$ export SUBJ=""
│alt                                       │$ export SUBJ="${SUBJ}/C=ES"
│  admin→admin: Create self-certificate    │$ export SUBJ="${SUBJ}/ST=Aragon"
│else:                                     │$ export SUBJ="${SUBJ}/L=Zaragoza"
│  admin→CA   : CSR                        │$ export SUBJ="${SUBJ}/O=MyOrganization"
│  CA→CA      : Create certificate         │$ export SUBJ="${SUBJ}/CN=${DOMAIN}"
│  CA→amdin   : certificate                │$ export NUM_OF_DAYS="999"
│
│
│Cert.Sign.Request*                        │*Creating a CSR*
│*CSR*                                     │$ openssl req \
│CSR :=                                    │  *-new*\
│    PUBLIC KEY                            │   -nodes 
│  + Distinguised Name (DN) :=             │   -newkey rsa:2048 \
│       + Common Name (CN)                 │   -keyout ${DOMAIN}.key \
│         (SHOULD be the exact             │   -out ${DOMAIN}.csr -subj "${SUBJ}"
│          Fully Qualified Dom Name(FQDN)  │
│          of the host)                    │(replace -newkey rsa:.... -keyout... by
│       + "additional info                 │            -key ${DOMAIN}.key to use 
│          about organization"             │            already existing private key)



│*Managing Private Keys*                   │*dump x509 info*
│*CREATE A PRIVATE KEY:*                   │$ openssl x509 -text -in myCert.pem
│$ openssl \
│    genrsa -des3 \
│    -out ${DOMAIN}.key 2048
│(Enter password when prompted)
│
│*VERIFY PRIVATE KEY:*
│$ openssl rsa*-check*-in ${DOMAIN}.key
│
│*Verify private key matches certificate and CSR*
│ (If the output of each of the next command is identical there is an
│  extremely high probability that the private key, certificate,
│  and CSR are related)
│  $ openssl rsa  -noout -modulus -in ${DOMAIN}.key | openssl md5
│  $ openssl x509 -noout -modulus -in ${DOMAIN}.crt | openssl md5
│  $ openssl req  -noout -modulus -in ${DOMAIN}.csr | openssl md5
│
│*Encrypt/Decrypt private key*
│$ openssl rsa -des3 -in unencrypted.key -out encrypted.key
│$ openssl rsa       -in encrypted.key   -out decrypted.key


│*Self-Signed-Cert*
│*working on Chrome/Java/...*
│REF:
│- chrome deprecates subject cn matching]
│@[https://textslashplain.com/2017/03/10/chrome-deprecates-subject-cn-matching/]
│- Fixing Fixing Chrome 58+ [missing_subjectAltName] with openssl&amp;S.S.certs</a>
│@[https://alexanderzeitler.com/articles/Fixing-Chrome-missing_subjectAltName-selfsigned-cert-openssl/]
│- getting-chrome-to-accept-self-signed-localhost-certificate
│@[https://stackoverflow.com/questions/7580508/getting-chrome-to-accept-self-signed-localhost-certificate/43666288#43666288]
│*create_root_cert_and_key.sh*
│ |#!/usr/bin/env bash
│ |openssl genrsa -out rootCA.key 2048
│ |openssl req -x509 -nodes \ 
│ |    -days $NUM_OF_DAYS \ 
│ |    -key rootCA.key -sha256 \
│ |    -out rootCA.pem
│ |    -new 
│      ^^^^ 
│      replace with -in $DOMAIN.csr to reuse crt

│*create_certificate_for_domain.sh*
│ |#!/usr/bin/env bash
│ |
│ |if [ -z "$1" ]; then
│ |  echo "Ussage: $0 myDomain.com"
│ |  echo "           ^^^^^^^^^^^^"
│ |  echo "    # alt1     wildcard"
│ |  echo "        $0 www.myDomain.com"
│ |  echo "           ^^^^^^^^^^^^^^^^"
│ |  echo "    # alt2 non-wildcard"
│ |  exit 1;
│ |fi
│ |if [ ! -f rootCA.pem ]; then echo 'no rootCA.pem detected. Please, run create_root_cert_and_key.sh first, and try again!' ; exit 1; fi
│ |if [ ! -f v3.ext     ]; then echo 'Please download the "v3.ext" file and try again!' ;  exit; fi
│ |
│ |if [ -f $DOMAIN.key ]; then KEY_OPT="-key" else KEY_OPT="-keyout" fi #  ← Create new Priv.Key || reuse existing one
│ |
│ |cat << EOF > /tmp/__v3.ext
│ |authorityKeyIdentifier=keyid,issuer
│ |basicConstraints=CA:FALSE
│ |keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
│ |subjectAltName = @alt_names
│ |
│ |[alt_names]
│ |DNS.1 = $COMMON_NAME
│ |EOF
│ |
│ |openssl req -new -newkey rsa:2048 \
│ |   -sha256 -nodes $KEY_OPT $DOMAIN.key \
│ |   -subj "$SUBJECT" -out $DOMAIN.csr
│ |openssl x509 -req -in $DOMAIN.csr \
│ |   -CA rootCA.pem -CAkey rootCA.key \
│ |   -CAcreateserial -out $DOMAIN.crt \
│ |   -days $NUM_OF_DAYS -sha256 \
│ |   -extfile /tmp/__v3.ext 
│
│*Ussage:*
│$ ./create_root_cert_and_key.sh        # ← STEP 01: create root Auth cert
│                                           
│$ ./create_certificate_for_domain.sh \ # ← STEP 02
│   mysite.com                          #   Alt 1
│   www.mysite.com www.mysite.com       #   Alt 2
│
│Note: You will also new to import the new cert. authority. 
│For example on Mac:
│    Open Keychain Access
│    Choose "System" in the "Keychains" list
│    Choose "Certificates" in the "Category" list
│    Choose "File | Import Items..."
│    Browse to the file created above, "rootCA.pem", select it, and click "Open"


│*Converting Formats*
│- X.509 DER ENCODING: Binary       encoding for X.509v3 certificates
│- X.509 PEM ENCODING: Base64-ASCII encoding for X.509v3 certificates, prefixed with a "—– BEGIN ..." line
│
│- NOTE common X.509 file extensions include:
│  - .CRT: certificates encoded as binary der or as ascii pem.
│  - .CER: certificates . Mostly similar to .CRT, recognized 
│          by some Microsoft products (IE, MS cryptoAPI commands, ...)
│  - .KEY: used for private PKCS#8 keys (and its corresponding public key)
│          encoded as binary DER or as ASCII PEM.
│
│- PKCS#7  Standard: Cryptographic Message Syntax used to sign and/or encrypt messages under PKI
│                    - ASCII files, also known as P7B, 
│                      which can contain (non-secret) certificates
│                      and CA certificates.
│
│- PKCS#12 Standard: file format commonly used for (private)keystores, protected with a password-based
│                    symmetric key. Used by:
│                    - Java key store
│                    - client auth. certs in Firefox, Apache Tomcat 
│                    - Files are also known as PFX files
│ (OpenSSL defaults to X.509 PEM format
│
│PER ←→ DER
│$ openssl x509 -inform pem -in ${DOMAIN}.crt -outform der -out ${DOMAIN}.der # PEM   → DER
│$ openssl x509 -inform der -in ${DOMAIN}.der -outform pem -out ${DOMAIN}.crt # DER   → PEM
│
│# PEM   → PKCS7
│$ openssl crl2pkcs7 -nocrl -certfile ${DOMAIN}.crt -certfile ca-chain.crt -out ${DOMAIN}.p7b
│# PKCS7 → PEM
│$ openssl pkcs7 -in ${DOMAIN}.p7b -print_certs -out ${DOMAIN}.crt
│
│# PEM → PKCS12
│$ openssl pkcs12 -inkey ${DOMAIN}.key \
│   -in ${DOMAIN}.crt -export -out ${DOMAIN}.pfx
│# PKCS12 → PEM 
│$ openssl pkcs12 -in ${DOMAIN}.pfx -nodes -out ${DOMAIN}.combined.crt
│# x509 → PEM
│$ openssl x509 -in ${DOMAIN}.cer -outform PEM -out ${DOMAIN}.pem


│*Fingerprints*
│- Fingerprints are short sequences of bytes used to identify a longer public key,
│  applying a cryptographic hash function to the public key
│- Are used as "ids" to the longer public keys
│- To generate a fingerprint from a TLS certificate, run:
│$ openssl x509 -in ${DOMAIN}.crt -noout -fingerprint -sha256
│(output will be similar to
│ fa:23:a4:48:............:56


│*fetch first-in-chain web cert.,*              │*list openssl version/build*
│*then add to Java.KeyStore:*                   │$ openssl version -a
│$ openssl s_client \
│   -connect www.mywebsite.com:443 \  
│   -showcerts ˂/dev/null 2˃/dev/null | \       │*View and Verify CSR*
│  openssl x509 \                               │$ openssl req \
│    -outform PEM ˃ infura-morden.pem           │  -text  \  # "view"
│$ ($JAVA_HOME/Contents/Home/jre/bin/)keytool \ │  -verify \ # "verify"
│    -import -noprompt -trustcacerts \          │  -noout \
│    -alias www.mywebsite.com -f                │-in ${DOMAIN}.csr


│*Verify that cert. was 
│ signed by a given CA:
│$ openssl verify -verbose
│    \ -CAFile ca.crt ${DOMAIN}.crt



│*Certificate revocation lists*
│r*WARN:* Some companies/applications have deprecated CRLs and are
│         instead using the *Online Certificate Status Protocol (OCSP)*
│
│- A CRL provides a list of certificates that have been revoked.<span title>other TLS projects</span>
│                                                              
│STEP 1: Prepare CLR config file                               
│$ vim .../intermediate/openssl.cnf                            
│ [ CA_default ]                                               
│ ...                                                          
│ default_crl_days = 30 ← STEP 2 must be periodically executed 
│ ...                     this delay                           
│ [ server_cert ]                                              
│ # ... snipped ...                                            
│*crlDistributionPoints = URI:http://example.com/intermediate.c
│ ^^^^^^^^^^^^^^^^^^^^^                                        
│ See man page for more crl options                            
│                                                              
│STEP 2: Create the CLR                                        
│(Repeat perioadically according to default_crl_days in config)
│$ cd ~/ca                                                     
│$ openssl ca \                                                
│  -config intermediate/openssl.cnf \                          
│ *-gencrl* \                                                  
│  -out intermediate/crl/intermediate.crl.pem                  
│                                                              
│STEP 3: Verify output of STEP 2:                              
│$ openssl crl \                                               
│  -in intermediate/crl/intermediate.crl.pem \                 
│  -noout -text                                                
│→ ... No Revoked Certificates                                 
│ (No certificates have been revoked yet)                      
│                                                              
│STEP 4: make intermediate.crl.pem accessible through          
│        the HTTP URL  indicated in STEP 1                     
│
│NOTE: For servers authenticating clients through              
│      X.509 certs, copy the generated crl file
│      to a path indicated by the server config                
│      ('SSLCARevocationPath' in Apache HTTP,                  
│      'crl-verify' in OpenVPN,...)                            
│                                                              
│REVOKE A CERTIFICATE:                                         
│$ cd ~/ca                                                     
│$ openssl ca -config intermediate/openssl.cnf \               
│ *-revoke* \
│  intermediate/certs/bob@example.com.cert.pem                 
│                                                              
│For a given X.509 certificate the CRL distribution            
│points are visible in the certificate X509v3 details.         
│                                                              
│# openssl x509 -in ${DOMAIN}.cert.pem -noout -text            
│→ ...
│→   X509v3 CRL Distribution Points:                   
│→                                                     
│→       Full Name:                                    
│→         URI:http://domain1.com/intermediate.crl.pem 
│→ ...                                                 

Related projects:
@[https://jamielinux.com/docs/openssl-certificate-authority/index.html]
</pre>
<pre zoom TODO>
<span xsmall>Certs Transparency</span>
@[https://www.certificate-transparency.org/]
(See also <a href="?query=Trillian">Trillian</a>
- G.C.T. project fixes several structural flaws in the SSL certificate system
matching- open framework for monitoring and auditing SSL certificates in nearly real time.
  detecting SSL certificates that have been mistakenly issued by a certificate authority 
  or maliciously acquired from an otherwise unimpeachable certificate authority.
  It also makes it possible to identify certificate authorities that have gone rogue
rl.pem*  and are maliciously issuing certificates. 
- <def>Certificate LOGS</def>:simple network services that maintain cryptographically 
assured, publicly auditable, append-only records of certificates. Anyone can 
submit certificates to a log, although certificate authorities will likely be 
the foremost submitters  
- <def>Monitors</def> are publicly run servers that periodically contact all of the log 
servers and watch for suspicious certificates. For example, monitors can tell 
if an illegitimate or unauthorized certificate has been issued for a domain, 
and they can watch for certificates that have unusual certificate extensions 
or strange permissions, such as certificates that have CA capabilities.
  
- <def>Auditors</def>: lightweight components performing two functions:
- verify that logs are behaving correctly and are cryptographically
consistent. If a log is not behaving properly, then the log will need to explain
itself or risk being shut down.
- verify that a particular certificate appears in a log. This is a particularly
important auditing function because the Certificate Transparency framework 
requires that all SSL certificates be registered in a log. If a certificate has 
not been registered in a log, it’s a sign that the certificate is suspect, and
TLS clients may refuse to connect to sites that have suspect certificates.
/pre>
                                                                                           
</div>
                                                                                           
<div groupv>
<span title>Cert.Authorities (CAs)</span>
<pre zoom labels="ca">
<span xsmall>Let's Encrypt</span>
@[https://letsencrypt.org/]
- free, automated, and open Certificate Authority.
</pre>
                                                                                           
<pre zoom labels="ca">
<span xsmall>cacert.org</span>
@[http://www.cacert.org]
- Mission Statement: create a Non-Profit Certificate Authority;
                     alternative to the commercial CAs.
</pre>

<pre zoom labels="">
 <span xsmall>make-ca</span>
<span xsmall>(KISS CA)</span>
@[https://github.com/djlucas/make-ca/blob/master/make-ca]
-  Simple scripts around OpenSSL to create a local certificat authority
</pre>

<span title>TLS Related</span>
<pre zoom labels="comparative">
<span xsmall>OCSP</span>
@[https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol]

- Internet protocol used for obtaining the revocation status of an X.509 digital certificate.
- Alternative to Certificate Revocation Lists to addressg problems associated with
  using CRLs in a public key infrastructure (PKI).
- Messages are encoded in ASN.1

- Architecture is "request/response" message based.
- Supported by different web browsers 

*Comparison to CRLs*
- OCSP response contains less data than a typical CRL file
- easier to parse by end client-side libraries
- OCSP discloses to the responder that """a particular
  network host used a particular certificate at a particular time"""

*Basic PKI implementation*
participant: Alice  with certificate issued by CA Carol
participant: Bob    with certificate issued by CA Carol
Carol      : CA

Alice wishes to perform a transaction with Bob.
Alice → Bob: Alice pub.key Certificate
Bob   → Bob:(concerned that Alice's priv.key is compromised)
             creates an 'OCSP-request' 
                        --------------
                        Alice_cert.serial_number
Bob   → Carol: OCSP-request
Carol → Carol: reads certificate serial number.
               Search if serial number is in revocation ddbb
Carol → Bob  : Signed OCSP-response with 
               'good'|'revoked'|'unknown'|'error code'
               key signing OCSP-response must be the
               original key signing the cert. originally 
               or another cert. issued by the original CA
               that is marked with a certain extension to
               flag it as OCSP signing authority.
rigi
 
              
Bob   → Bob  : verifies Carol's signed response.
               (it's supposed that Bob has stored Carol's 
                pub.key sometime before this transaction)

Bob   → Alice: ...

*Protocol details*
- OCSP request format supports additional extensions. 
- OCSP can be vulnerable to replay attacks,[5] where a signed,
  'good' response is captured by a malicious intermediary and 
  replayed to the client at a later date after the subject
  certificate may have been revoked.  A nonce can be included
  to avoid it.
  - Because of high load, most OCSP responders do not use the
    nonce extension to create a different response for each
    request, instead using presigned responses with a validity
    period of multiple days. 
   *Thus, the replay attack is a major threat to validation systems*

- OCSP can support more than one level of CA chaining/forwarding
  initial OCSP-requests to by delegated path validation (DPV) servers.

(See Criticisms in original wikipedia article)

Supported by 
Internet Explorer, Mozilla Firefox 3+, Safari-macOS.
r*Google Chrome disabled OCSP checks by default in 2012*
r*citing latency and privacy issues and instead uses their*
r*own update mechanism to retrieved revoked certificates*
</pre>

<pre zoom labels="signature,comparative">
<span xsmall>XML Signature</span>
@[https://en.wikipedia.org/wiki/XML_Signature]

- also called XMLDSig, XML-DSig, XML-Sig
- XML syntax for digital signatures 
- W3C recommendation
- it has much in common with PKCS#7 but is more extensible
- used by various XML related technologies like SOAP or SAML

- typically used toto sign XML documents, 
 *but anything that is accessible via a URL can be signed*

- An XML signature used to sign a resource outside its containing 
  XML document is called a detached signature;
- If used to sign some part of its containing document, it is
  called an enveloped signature;
- if it contains the signed data within itself it is called an
  enveloping signature.

- r*creation of XML Signatures is substantially more complex*
  r*than the creation of an ordinary digital signature because*
  r*a given XML Document may have more than one legal serialized*
  r*representation*
  - XML canonicalization transform is employed to alleviated some of
    those problems

(See detailed description in Wikipedia source)
</pre>
</div>


<div groupv>
<span title>Best Patterns</span>
<pre zoom>
<span xsmall>Common protocol issues</span>
- ciphertext that aren't secured with a MAC
- message that don't include a time-stamp or counter
- protocols that don't use PK for authenticity
- Reuse of Nonces of IVs
- ... many more
</pre>
<pre zoom bgorange labels="25519">
<span xsmall>###########</span>
<span xsmall># Dont's!!#</span>
<span xsmall>###########</span>
- Don't Implement your own algorithms
- Don't Use hard-coded keys, use a Vault service.
  Don't use a Vault when you can use wallet. (that will use an
  internal vault and never expose secrets outside)
- Never use ECB mode. Prefer CBC, better yet CTR or 
  GCM@[https://en.wikipedia.org/wiki/Galois/Counter_Mode]
- Don't use small public key sizes. At least 2048
- Elliptic curve preferable: p-256 or X25519
- Don't use the same private key for encrypting and signing
- Don't reuse the same nonce twice -it will no be a nonce-
</pre>
</div>


<div groupv>
<pre zoom labels="keystore,symmetric,asymmetric,signature">
<span title>GPG</span>
Gnu Privacy Guard 
<span xsmall bgorange>Sym file</span>
<span xsmall bgorange>encrypt</span>
*Encrypt/Decrypt from/to file*
$ gpg --symmetric plainTextFile --output myEncFile.gpg  # ← Encrypt 
$ gpg --decrypt -o -                                    # ← Decrypt to STDOUT
$ shred -n 2 -z -v plainTextFile                        # ← Safe delete

*Encrypt/Decrypt from/to STDIN/STDOUT*
$ echo "MySecret Text" | gpg -c --batch --passphrase 1234 | base64 -w 0                    # ← Encrypt from STDIN
jA0EBw...u+8ykK
$ echo "jA0EBw...u+8ykK" | base64 -d | gpg -d --batch --passphrase 1234 2˃/dev/null
MySecret Text


<span xsmall bgorange>- multi-level</span>
example script:
TMP_LEVEL1=/tmp/level1Ciphered.base64 ; DECODE_LEVEL1=decodedlevel1  ; PASS_LEVEL1=/tmp/myPassLevel1
TMP_LEVEL2=/tmp/level2Ciphered.base64 ; DECODE_LEVEL2=decodedlevel2  ; PASS_LEVEL2=/tmp/myPassLevel2
TMP_LEVEL3=/tmp/level3Ciphered.base64 ; DECODE_LEVEL3=decodedlevel3  ; PASS_LEVEL3=/tmp/myPassLevel3
(
cat ˂˂ EOF
 secrets level 1
EOF
) | gpg -c --batch  --passphrase ${PASS_LEVEL1} | base64 ˃ ${TMP_LEVEL1}


(
cat ${TMP_LEVEL1}

cat ˂˂ EOF
 secrets level 2
EOF
) | gpg -c --batch  --passphrase ${PASS_LEVEL2} | base64 ˃ ${TMP_LEVEL2}


(
cat ${TMP_LEVEL2}

cat ˂˂ EOF
 secrets level 3
EOF
) | gpg -c --batch  --passphrase ${PASS_LEVEL3} | base64 ˃ ${TMP_LEVEL3}

cat ${TMP_LEVEL3}  | base64 -d | gpg -d --batch --passphrase ${PASS_LEVEL3} ˃ $DECODE_LEVEL3
cat $DECODE_LEVEL3 | base64 -d | gpg -d --batch --passphrase ${PASS_LEVEL2} ˃ $DECODE_LEVEL2
cat $DECODE_LEVEL2 | base64 -d | gpg -d --batch --passphrase ${PASS_LEVEL1} ˃ $DECODE_LEVEL1

echo "---- DECODED LEVEL 3 ------"
cat $DECODE_LEVEL3 
echo "---- DECODED LEVEL 2 ------"
cat $DECODE_LEVEL2 
echo "---- DECODED LEVEL 1 ------"
cat $DECODE_LEVEL1 

<span xsmall>-Priv.key mng</span>
<a href="http://central.sonatype.org/pages/working-with-pgp-signatures.html">REF:</a>
<b>NEW KEYPAIR</b>
$ gpg --gen-key       # defs: RSA 2048bit, no-expire
# (enter name+email when prompted)         ^^^^^^^^^
                                           Recommended <=2 years
                                           Once expired it can be extended
                                           providing  key (and passphrase).

$ gpg2 --list-keys   #           ← *LIST PUBLIC KEYS*
/home/juven/.gnupg/pubring.gpg
------------------------------
pub   1024D/C6EED57A 2010-01-13
uid                  OldMcDonalds˂old.mcdonalds@farm.com˃
sub   2048g/D704745C 2010-01-13
      ^^^^  ^^^^^^^^
     length   keyid

$ gpg2 --list-secret-keys #      ← *LIST  KEYS*
/home/juven/.gnupg/secring.gpg
------------------------------
sec   1024D/C6EED57A 2010-01-13
uid                  OldMcDonalds<old.mcdonalds@farm.com>
ssb   2048g/D704745C 2010-01-13


$ gpg2 -ab temp.java #            ← <b>SIGNING A FILE</b>
           ^^^^^^^^^                -a create ASCII armored output
           output to temp.java.asc  -b make detached signature

$ gpg2 --verify temp.java.asc #   ← <b>Verify new signature</b> 


KEYSERVER="hkp://pool.sks-keyservers.net"
$ gpg2 --keyserver ${KEYSERVER}   ← <b>"PUSH" PUB.KEY</b>
  \ --send-keys C6EED57A
$ gpg2 --keyserver ${KEYSERVER}   ← <b>"PULL" PUB.KEY</b>
  \ --recv-keys C6EED57A

<b>EXPIRE A KEY</b>
$ gpg2 --edit-key A6BAB25C
... Secret key is available.
pub  2048R/A6BAB25C  created: ...  expires: ...
     trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created: ...  expires: ... 
     Juven Xu (for testing) <test@juvenxu.com>
...
gpg&gt; <b orange>1</b>  # ← Choose key
pub  2048R/A6BAB25C  created: ...  expires: ...  usage: SC
     trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created: ...  expires: ...  usage: E
(1)* Juven Xu (for testing) <test@juvenxu.com>

gpg&gt; <b orange>expire</b>
→ ...
→ Please specify how long the key should be valid.
        0 = key does not expire
      <n> = key expires in n days
     ...
gpg&gt; <b orange>save</b>
(push again to publick hkp serser)

<b>Maven problem with Signature SUBKEYs</b>
- Some PGP tools generate a sub-signing priv.key 
  splited from the primary key (seed key).
- Maven and other only recognise the primary key,
  not subkeys. Deleting Singing subkey will force
  GPG to use the primary key.
$ gpg2 --edit-key A6BAB25C
...
pub  2048R/A6BAB25C  created:... usage: SC
                   trust: ultimate      validity: ultimate
sub  2048R/DD289F64  created:... <b>usage: E  # E:Encryption</b>
sub  2048R/8738EC86  created:... <b>usage: S  # S: Signing  </b>

gpg&gt; <b orange>key 2</b> (index start at 0)
...
gpg&gt; <b orange>delkey</b>  # (or <b>revoke</b> if already published)
gpg&gt; <b orange>save</b>
</pre>
</div>

<div groupv>
<pre zoom labels="protocol">
<span xsmall TODO>S/MIME:</span>
- Uses Crypto.Message (PKCS#7) and pub.key infraestructure for encryption and signing
- <a href="https://www.infoq.com/news/2018/05/efail-pgp-smime-vulnerability">PGP/SMIME EFail vulneravility</a>
</pre>
<pre zoom labels="protocol" TODO>
<span xsmall>Off-The-Record</span>
<span xsmall> Messaging(OTR)</span>
@[https://en.wikipedia.org/wiki/Off-the-Record_Messaging]
- protocol for securing/authentication/encrypting instant messaging communication amongst people.
 Encrypts messages, prevents eavesdroppers, authenticates peers to each other.
 It also provides OTR provides forward secrecy and malleable encryption.

- OTR uses a combination of AES 128bits sym-key algorithm,  1536-bits group-size Diffie–Hellman 
  and the SHA-1 hash function.
- The primary motivation behind the protocol was providing deniable 
  authentication for the conversation participants while keeping 
  conversations confidential, like a private conversation in real life, or 
  off the record in journalism sourcing. This is in contrast with 
  cryptography tools that produce output which can be later used as a 
  verifiable record of the communication event and the identities of the 
  participants. The initial introductory paper was named "Off-the-Record 
  Communication, or, Why Not To Use PGP".[1]
- The OTR protocol was designed by cryptographers Ian Goldberg and Nikita 
  Borisov and released on 26 October 2004.[2] They provide a client library 
  to facilitate support for instant messaging client developers who want to 
  implement the protocol. A Pidgin and Kopete plugin exists that allows OTR 
  to be used over any IM protocol supported by Pidgin or Kopete, offering an 
  auto-detection feature that starts the OTR session with the buddies that 
  have it enabled, without interfering with regular, unencrypted
</pre>

<pre zoom labels="" TODO>
<span xsmall>Dmarc sec mail</span>
@[http://www.eweek.com/security/dmarc-email-security-adoption-soars-as-us-government-deadline-hits]]
DMARC is a protocol that helps protect the integrity and 
authenticity of email. DMARC is not a single technology but rather 
is a combination of several components, including the Sender Policy 
Framework (SPF) and Domain Keys Identified Email (DKIM), to help 
verify email authenticity. There are also different levels of DMARC 
policies. The "p=none" policy enables organizations to monitor 
their email systems for senders, while the "p=reject" policy will 
block non-compliant messages completely. BOD 18-01 mandates the use 
of the p=reject policy by Oct.16.
</pre>

</div>

<div groupv>
<span title>ECDSA Dig.Signature</span>
<pre zoom TODO>
<a xsmall href="http://www.freestd.us/soft/109819.htm" xsmall >ECDSA[X9.62] Dig.Sig</a>
Used, amongst others, by Bitcoin/Ethereum/... to sign TXs
</pre>

<pre TODO zoom>
<span xsmall>Deter.Dig.Sign.Gen.</span>
<span xsmall>RFC6979</span>
@[https://tools.ietf.org/html/rfc6979]
- Deterministic signature generation procedure for the usage
  of the Digital Signature Algorithm (DSA) and
  Elliptic Curve Digital Signature Algorithm (ECDSA)
  compatible (DSA) and (ECDSA)

- Deterministic signatures retain the cryptographic
  security features associated with DSA/ECDSA digital signatures 
  but can be more easily implemented in various environments,
  since they do not need access to a source of high-quality randomness
  (point of failure) for the "k" parameter
  It is possible to turn DSA and ECDSA into deterministic schemes by
  using a *deterministic process* for generating the "random" value "k"
  fulfilling some crypto. characteristics

- NOTE: key pair generation still requires a source of randomness.
 (system with poor randomness are supposed to initialize those keys
 in controlled conditions like factory initialization,...)
</pre>

<pre zoom labels="comparative,25519">
<span xsmall>Schnorr</span>
<span xsmall>"ECDSA++"</span>
@[http://ed25519.cr.yp.to/]
@[http://blog.siphos.be/2015/08/switching-openssh-to-ed25519-keys/]
@[http://chneukirchen.org/blog/archive/2014/02/the-road-to-openssh-bliss-ed25519-and-the-identitypersist-patch.html]
- designed by prominent cryptographer Daniel J. Bernstein
- cryptosystem powering Bitcoin, Ethereum, ...
- elliptic curve implementation
- more optimal and secure design schemes 
- Extracted from @[https://ripple.com/dev-blog/curves-with-a-twist/]
  ...  After months of analysis and testing, we’ve concluded 
  that a Schnorr-based cryptosystem will greatly enhance the
  security, flexibility, and performance of the Ripple protocol
  (when compared to Koblitz curves with secp256k1 parameters and
  ECDSA signatures as defined in :
  Standards for Efficient Cryptography
  @[http://www.secg.org/collateral/sec2_final.pdf]

- Summary of advantages versus secp256k1:

- Large absolute value</a> for the CM field discriminant 
 (large |D| )—although there is no evidence of security problems with small |D| 
@[http://safecurves.cr.yp.to/disc.html]
- Supports simple, fast, <a href="http://safecurves.cr.yp.to/complete.html">complete</a>
  constant-time single-scalar multiplication using 
  <a href="http://safecurves.cr.yp.to/ladder.html">a Montgomery ladder</a>.
- A random curve point can be represented in a way that's 
  <a href="http://safecurves.cr.yp.to/ind.html">indistinguishable from random data</a>.
- Faster performance
- ...  Our initial tests and analysis suggest ...
  Curve25519 halves verification time versus secp256k1 based on efficient implementations
  of both curves.
  - These results were achieved with lower variance, which point to the constant time
    properties of Curve25519.
  - the default signature format for Ed25519 allows batch signature verification,
    which&nbsp;promises twice the performance of DSA.
  Benchmarking:
  - <a href="http://justmoon.github.io/curvebench/benchmark.html">Raw test results</a>
  - <a href="https://github.com/justmoon/curvebench">Benchmark source code</a>

  - the new curve implementation is expected to quadruple performance versus secp256k1 
    based on our preliminary benchmarking.

- Extracted from @[https://www.mail-archive.com/cypherpunks@cpunks.org/msg02419.html]
  sums up the benefits of Schnorr as follows:
  "simple blinding, compact multi-sig, clearer security proofs, better security margin,
   less dependence on hash properties."

Summary of advantages versus ECDSA:
  - Simpler to securely implement
  - Composable threshold signatures without multi-party computation
  - Verification happens off-network allowing for sophisticated functionality without increasing network load or complexity
  - Conducive to highly distributed systems
  - Less constraints allows for more optimal and secure design schemes

  - DSA schemes are difficult to manage because the schemes are easy to get wrong.
    An improper implementations is trivial to break, and what might seem like a minor
    misstep can precipitate a system-wide vulnerability—as demonstrated by 
    @[http://nakedsecurity.sophos.com/2012/10/25/sony-ps3-hacked-for-good-master-keys-revealed/]
    ...  Hackers were able to access full control of the PS3 employing "simple algebra" after Sony
    set a constant in its custom DSA implementation instead of a randomly generated number. 
    The sensitivity of DSA signatures to human error allowed this single oversight to fully
    compromise the console's encryption protections, exposing the platform and Sony's partners
    to the perpetual threat of piracy.
  - Alternatively, Schnorr signatures are more forgiving and simpler to implement because its
    security is inherently more robust based on the scheme’s dynamic hash function
  @[http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&amp;arnumber=4908440]
    The ephemeral public value r is tightly bound to the message, which means that the security
    of the scheme is no longer dependent on the collision resistance of the hash function.
  @[http://www.cs.bris.ac.uk/Publications/pub_master.jsp?id=2001023]

  - Independent verification and combining:
    Another advantage of Schnorr is related to threshold signatures 
  - ECDSA can create threshold signatures, but requires multi-party computation
   @[http://en.wikipedia.org/wiki/Secure_multi-party_computation]
    This means that the number of participants required to generate a signature
    without revealing their secrets is twice the number of shares required to recover the key.
    - In contrast, Schnorr has no such restriction. Shares of a signature can be independently
      verified and then composed.

</pre>
</div>


<div groupv>
<pre zoom bgorange>
<a xsmall href="https://en.wikipedia.org/wiki/PKCS">PKCS</a>
PKCS: Set of "high-level" "Public Key Cryptography Standards":</a>
- <b>PKCS #1</b> math. properties + format of RSA pub/priv keys, and 
  basic algorithms and encoding/padding schemes for RSA
  (de/en)cryption,  producing/verifying signatures.
- <b>PKCS #3</b> Diffie–Hellman Key Agreement Standard
- <b>PKCS #5</b> Password-based Encryption Standard
- <b>PKCS #7</b> Cryptographic Message Syntax used to sign 
  and/or encrypt messages under a PKI
  See also (PKCS #7 derived)<a href="https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax">Cryptographyc Message Syntax</a>
- <b>PKCS #8 </b> to carry private certificate kye (and matching pub.key)
- <b>PKCS #9 </b> Defines selected attribute types for use in PKCS #6,#7,#8,#10
- <b>PKCS #10</b>  Certification Request Standard
- <a href="https://en.wikipedia.org/wiki/PKCS_11">PKCS #11</a>
  Cryptographic (Athentication) Token Interface
  ("Cryptoki") API defining a generic interface to cryptographic tokens
- <b>PKCS #12</b> Personal Information Exchange Syntax defining file
  format commonly used to store private keys, protected with a password-based
  symmetric key. Used by:
  - Java key store
  - client auth. certs in Firefox, Apache Tomcat
- <b>PKCS #15</b> idetification through tokens allowing users to identify 
  themselves to applications, independent of the application's Cryptoki
  implementation (PKCS #11) or other API

  See also:
  - ISO 7816 standard for electronic identification cards with contacts, especially smart cards.
    @[https://en.wikipedia.org/wiki/ISO/IEC_7816]
</pre>

<span title>OASIS STANDARDS</span>
<pre zoom labels="signature" TODO>
<span xsmall>XAdES</span>
@[https://www.w3.org/TR/XAdES/]
XML Advanced Electronic Signatures (XAdES)

</pre>

<pre zoom labels="signature,java" TODO>
<span xsmall>DSS</span>
OASIS Digital Signature Services (DSS)
@[https://ec.europa.eu/cefdigital/wiki/pages/viewpage.action?pageId=46992515]
DSS (Digital Signature Services) is an *open-source software library*
for *electronic signature creation and validation*. DSS supports the creation and 
verification of interoperable and secure electronic signatures in line with 
European legislation. In particular, DSS aims to follow the eIDAS Regulation 
and related standards closely.

DSS can be re-used in an IT solution for electronic signatures to ensure that 
signatures are created and verified in line with European legislation and 
standards. DSS allows re-use in a variety of different ways: in an applet, in 
a stand-alone application or in a server application. DSS can also be used as 
a reference implementation for IT solutions which do not directly re-use it. 
Demos are also available to assist the use of DSS as a reference implementation.

The library, *realised in Java*, is open-source, available to all Member States
, businesses and citizens for re-use in electronic signature solutions. It is 
continuously updated and maintained to anticipate and follow developments in 
regulations and standards. 

Anyone can integrate it and redistribute it under the terms of the Lesser 
General Public License (LGPL 2.1).

In accordance with ETSI standards, DSS supports various document and 
signature formats including PAdES, XAdES, CAdES and ASiC and is compliant 
with Implementing Decision 2015/1506/EU. A “cook-book” is also provided with 
documentation targeting implementers/developers and aiming at facilitating 
the integration and use of DSS in their applications.


<span xsmall>AES</span>
@[https://en.wikipedia.org/wiki/Advanced_electronic_signature]
-<span xsmall>- PAdES(PDF) format</span>
@[https://en.wikipedia.org/wiki/PAdES]
-<span xsmall>- XAdES(XML) format</span>
@[https://en.wikipedia.org/wiki/XAdES]
  The Cryptographic Message Syntax (CMS) is the IETF's standard 
  for cryptographically protected messages. It can be used to 
  digitally sign, digest, authenticate or encrypt any form of 
  digital data. 
-<span xsmall>- CAdES(CMS) format</span>
@[https://en.wikipedia.org/wiki/CAdES_(computing)]
@[https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax]
  Extensions to 'Cryptographic Message Syntax'
- <span xsmall>- ASiC format</span>
@[https://en.wikipedia.org/wiki/Advanced_electronic_signature]
  ASiC Baseline Profile. ASiC (Associated Signature Containers) 
  specifies the use of container structures to bind together one
  or more signed objects with either advanced electronic signatures 
  or time-stamp tokens into one single digital (zip) container.

</pre>

<pre zoom labels="hash,non_repudability,x509">
<span xsmall>X.509 TimeStamp Protocol</span>
@[https://tools.ietf.org/html/rfc3161]

- RFC describes format for request and responses sent to a
  Time Stamping Authority (TSA)
- It establishes several security-relevant requirements for TSA
   operation

- TSA service:
  - provides proof-of-existence:
    - Some data datum existed before a particular time.
      (only the hash representation is used by the protocol)
  - Can also be used as the base for Non-repudiation services [ISONR]
  - only time-stamp a hash representation of the datum, i.e., a
  - CAs will issue custom certificates for this service indicating
    that it is exclusively used for this TSA purpose 


2.2. TSA Transactions

A → TSA: request1
         --------
         type:TimeStampReq 

TSA → A: response1
         ---------
         TimeStampResp
           TimeStampToken(TST)

A →   A:- verify status error 
        - verify fields contained in the TimeStampToken 
        - verify validity of digital signature 
        - verify that what was time-stamped corresponds 
           to what was requested
        - verify that the TimeStampToken contains:
          - the correct certificate identifier of the TSA
          - the correct data imprint 
          - the correct hash algorithm OID.
        - verify time included in the response against
          local trusted time reference

See original RFC for extended details
</pre>
</div>
<div groupv>
<pre zoom labels="android,java,keystore">
<span title>Think lib</span>
<span xsmall>crypto for</span>
<span xsmall>non-experts</span>
@[https://www.infoq.com/news/2018/09/google-tink-cryto-ios-android]
- Crypto.libr for *non cryptographic experts
  cross-platform cryptographic library developed by a group of 
cryptographers and security engineers at Google to help developers implement 
cryptography correctly <b>without being cryptographic experts</b>.
version 1.2 adds support for Cloud, Android, and iOS platforms, and C++ and Objective-C.

aimed to stress cryptographic libraries against known attacks:
  - biased nonces
  - invalid curves
  - ...

ensure popular cryptographic algorithms behave as expected, including DSA, RSA, AES-EAX, ...

- Tink strives to make as explicit as possible what security guarantees each provided API gives:
  - For example, if a given operation is safe against chosen-ciphertext attacks, 
    this is displayed in the interface and that same guarantee has to be satisfied
    by each primitive used to implement it.

- currently four cryptographic operations are provided, implemented by specific primitives:

  - authenticated encryption with associated data (primitive: AEAD)
  - message authentication codes (primitive: MAC),
  - digital signatures (primitives: PublicKeySign and PublicKeyVerify)
  - hybrid encryption (primitives: HybridEncrypt and HybridDecrypt).

  Each operation has an associated set of minimal properties and a guarantee. 
  A primitive can have multiple implementations and the user chooses the actual
  implementation to use by instantiating a key of a corresponding type.

- Tink provides support for key management, 
  including key versioning/rotation/remote key management systems(KMS):

  -  Currently, the following KMSes are supported:
    Google Cloud KMS, Amazon KMS, Android Keystore, Apple iOS KeyChain (planned)

</pre>
</div>

<hr/>
<span title style="font-size:1.1em;">WARN: ☞ CRYPTOGRAPHY IS HARD, PROTECTING SECRETS IS (MUCH) HARDER!!!☜</span>
<br/> <br/>
<div groupv>
<span title>Wallets</span>
<pre zoom labels="learn_x_in_y_min," >
<span xsmall>Wallet vs Vault</span>
In Vaults, secrets are kept safe until needed by an application.

In wallets, the secrets (ideally) are never exposed outside the wallet.
Unsigned transactions come in, then signed transactions come out.
The wallet usually have aditional utility functions like "address agenda",
"browser of transactions", ...

A wallet makes use of a vault. (A vault is a "layer down the stack")

Vaults are generic for any type of app.

Wallets are mostly used for blockchain-like applications.
</pre>
<pre zoom>
<span xsmall>Wallet vs Smart-Cards</span>
  - Some types of Smart-Cards can be considered a type of wallet, in 
  the sense that they can be used to sign content using a hardware
  protected private-key. 
  - Still Smart-Cards are mostly designed with Authentication as
    primary use-case, to provide that the user accessing a website,
    a bank terminal, ... is the real authorized user.
  - Wallets is mostly a blockchain concept, while smart-card is
    a general device that can be used for many purposes 
    (Web TLS or SSH Client Authentication, PGP signature, ...)
  - Wallets are designed with TX signature in mind.
    A wallet protects the private key, signs the TXs and probably
    has a display that shows what's going to be signed and a 
    physical button that the user must "click" in order to confirm
    the transaction.
  - Stealing of the wallet can mean stealing of the money.
  - Stealing of the smart-card means money can be stealed until
    the smart-card is cancelled.
</pre>
<pre zoom>
<span xsmall><a href="https://en.bitcoin.it/wiki/Deterministic_wallet">Deterministic Wallet</a></span>
A deterministic wallet is a system of deriving keys from 
a single starting point known as a seed. The seed allows 
a user to easily back up and restore a wallet without 
needing any other information and can in some cases allow 
the creation of public addresses without the knowledge of 
the private key. Seeds are typically serialized into 
human -readable words in a Mnemonic phrase. 
</pre>
<pre zoom>
<span xsmall><a href="https://en.bitcoin.it/wiki/CarbonWallet">JS Carbon Wallet</a></span>
- No server side storage, <b>private keys are generated from 
  the passphrase and only exist in the memory of the browser</b>
- Deterministic key generation: Write down the passphrase 
  generated for you and it's all you need
- Transactions are signed locally in the browser: Your 
  private keys are not shared with the server. You do not 
  have to trust the server with your money
- Privacy: No need to register a passphrase is all that 
  is required
- Public code hosted on Github which anyone can audit
</pre>


<pre zoom labels="">
<span xsmall>Keepass</span>
@[https://keepass.info/]
- free, open source, light-weight and easy-to-use password manager in a ¿secure?
- All passwords are stored in a single database file (encrypted with AES/Twofish)
  locked with one master key or a key file.
              ^^^^^^^^^^^^^^ 
            (The only pass needed to remember)  


</pre>


<span xsmall>Hardware wallets</span>


<pre zoom labels="25519,hardware,signature" >
<span xsmall>Lattice 1</span>
@[https://blog.gridplus.io/lattice1-sdk-and-generalized-signatures-e17da7cf65d7]
Lattice 1:
  generalized "remote ("WiFi",...) signer" for 
  cryptocurrencies, digital identity, and more.
  (The priv.key is never transmited outside the hardware,
   unsigned docs come in and signed docs come out)

*REMOTE SIGNING*                                     | *SEPARATING THE SIGNER:*                              
wallet application technical components:             | STEP 1:
*USER INTERFACE*: It interfaces with both            | - let's consider moving TX signer to cloud machine.
  - persisted user data: addresses, TX history,...   |   => you have to store your private key on the cloud
  - network nodes: allow to display account info     | STEP 2:
*TX BUILDER*    : Applies the network protocol       | -Move TX builder in the cloud too
  to convert parameters (amount, recipient address   | 
  , ...) into one or more hashes that make up a TX.  | """In Lattice1 we have separated the protocol and
   Note: in Ethereum, each TX is represented by a    | cryptographic functionality away from the application
     single hash, whereas in Bitcoin each consumed   | layer ... Of course keys are in a secure chip within
     input has its own hash to sign,  there can be   | the Lattice1."""
     one or many inputs per Bitcoin transaction.
*TX SIGNER*     : sign TX hashes with private key.


*SECURING COMPONENTS AND SEPARATING CONCERNS*
- The Lattice1 introduces a more usable, robust, and
  secure connection between application ("wallet GUI")
  and TX builder/signer components.

 ┌────→ "GUI Apps in Cloud"
 │    
 ↓
Standard Chip ←─────────→ Secure Chip 1 ←────→ Secure Chip 2
    ↑                        ↑                    ↑
-connect to            - Build TX hashes      - Store priv.keys
 outside apps          - Placed on device     - Make signatures
- request signatures                          - Placed on device 
- Lattice1 addition:                            and each Safe Card
  - facilitates (wireless) communication app←→Sec.Chip

GUI App Connection:
STEP 1: App    generates EC25519 key pair (just once)
STEP 2: Chip 1 generates EC25519 key pair (for each new app pairing)
STEP 3: PAIRING: ECDH Key exchange is use to interchange 
               App.pub_key ←→ Chip1.pub_key_for_app1      


     _       _ _                                          
  __| | __ _(_) |_   _     _   _ ___ ___  __ _  __ _  ___ 
 / _` |/ _` | | | | | |   | | | / __/ __|/ _` |/ _` |/ _ \
| (_| | (_| | | | |_| |   | |_| \__ \__ \ (_| | (_| |  __/
 \__,_|\__,_|_|_|\__, |    \__,_|___/___/\__,_|\__, |\___|
                 |___/                         |___/      

""app wants to pair with a user’s Lattice1 device.""

*STEP 1*: Find device by serial number
- find the user's agent based on a serial number.
  (not needed if Lattice1 can connect with the app
   on a local area network). 

*STEP 2*: Transfer a Secret Code (Out of Band)
Once the app can talk (insecurely) to the Lattice1,
- app generates secret code, signs hash with that code
  using a secp256k1 private key (is different to the EC25519
  used for encryption/decription) 
- User presses "Pair" button: 
- Appt sends a message to Lattice1 device <b>requesting pairing</b> start
- Lattice1 displays a place for the user to enter
  the same code that is displayed on the application.

- With correct code lattice1 can recover secp256k1 public key
  used to sign the hash and stores both that and the curve25519 
  public key, which is also sent in the payload.

*STEP 3*: Establish a Read-Only Permission
(Pairing is done at this point)
- Lattice1 gives app permission to view addresses, 
  request signatures (that must be authorized on device screen)
  for one-off (vs automated) signatures,...

*FINAL STATE OF A PAIRING*

APP:                     LATTICE1 Dev:
32-byte priv.key 

Pairing registry:
- app1.pub_secp256k1 (used to  check future request signatures)
- app1.pub_EC25519   (sed to decrypt future request payloads  )

(App has now established a secure connection)

some complex details avoided (using 1-time keys for future requests,
  separate pairing code generated by the Lattice1). 

*REMOTE SIGNING*
Now app can be used as a generalized TX Signer, just like any other hardware wallet. Unlike other
hardware wallets, however, the paired application is capable of communicating with the device 
wirelessly.

We are now able to request a signature on some piece of data, which is of course parameterized
and built in the CHip 1 (TX  Builder)

*MANUAL REMOTE SIGNING*
As mentioned above, the pairing process also creates a minimal "permission". The application may request a 
signature using this permission in a way similar to existing hardware wallet TXs:

- the Lattice1 device displays transactional data to the user
  and must wait for the user to hit “accept” on the touch 
  screen.

However, there are a few technical differences that are worth noting:

- data must conform to a pre-defined "schema".
 (periodically released as use cases emerge, like
  ETH transfers and BTC transactions (P2SH|P2PKH)

AUTOMATIC REMOTE SIGNING: (Ex. ecurring payments, keep-alive messages)
- Use of "recurring permissions", which require a pre-defined schema
 (just like manual signatures) in addition to a set of "rules" on the
 data that will be signed in the future. Such a permission might look like this:

{
  schemaIndex: 0,     ← published "schema" for Eth TX (0)
  typeIndex: 0,       ← ETh TX type.  0: standard TX (empty data)
  rules: [
    null    , null                                        , null,
    null    , null                                        , null,
    null    , null                                        , null,
    'equals', '0x39765400baa16dbcd1d7b473bac4d55dd5a7cffb', null,  ←  recipient
    'equals', 1000                                        , null,  ←  wei ammount
    'equals', ''                                          , null,
       ^                        ^                            ^
    typeOfRule             value1                           value2
  ],
  timeLimit: 10000                                                ← seconds elapsed between requests
}

specific rules [ nonce, gas, gasPrice, to, value, data ]

. In this case, the requester can only send a request once every 10,000 seconds. One second (or more) too early and the request will be denied.
Application SDK

All of the previously discussed functionality is made possible through a Grid
+ Software Development Kit (SDK); this SDK will be released as an open source 
node.js module. We hope that developers wanting to build applications with a 
separated, internet-connected, secure signing service will experiment with 
the SDK and integrate with the Lattice1 device. Although Grid+ is building a 
mobile wallet application, this too will be open sourced as an example of how 
to leverage the Grid+ SDK.

Although the API is not finalized yet, the below Javascript snippet is an 
example of what using the SDK may look like:

const Sdk = require('gridplus-sdk');
const sdk = new Sdk({ btcNode: 'localhost:48332', ethNode: 'localhost:8545' });


const req = {
  type: 'eth-transfer',
  rules: {
    value: { 'equals': 1000 },
    to: { 'equals': '0x39765400baa16dbcd1d7b473bac4d55dd5a7cffb' }
  },
  interval: 10000
}

sdk.createAutomaticPermission(req, (err, res) => {
  ... do stuff ...
})

Keeping it General

Although this article mostly discusses the Lattice1 remote signing 
functionality in the context of cryptocurrency transfers, it is important to 
highlight that using an abstracted “signer” allows applications to request 
signatures on any data that is parametrizable. One can imagine, for example, 
a data schema that represents parameters of a legal contract:
</pre>

<pre zoom>
<a xsmall href="https://en.bitcoin.it/wiki/TREZOR">Trezor Wallet</a>
BIP 0032 Deterministic hardware wallet.

TREZOR is basically a small computer. It is designed to 
protect your private keys from possible online and 
offline risks. In order to do this, TREZOR keeps the 
private keys away from the Internet and confirms the 
transactions in-device. That way you can always check the 
screen for the right address, amount and transaction fee 
before sending your bitcoins. 
</pre>
</div>

<div groupv>
<span title>
Hardware Security Module(HSM)</br>
(Vaults, encrypt modules,...)
</span>
<pre zoom labels="hardware">
<span xsmall>PROTOCOL/APIs SCHEMA</span>
        ┃  COMMUNICATION          ┃
        ┃ APIs/PROTOCOLS          ┃
        ┃                         ┃
        ┃ Standard Cross-Platform ┃
        ┃   -<b>PKCS#10</b>              ┃ 
        ┃   -OpenSSL              ┃ HARDWARE
        ┃   -<a href="https://en.wikipedia.org/wiki/Key_Management_Interoperability_Protocol_(KMIP)">KMIP</a>                 ┃ SECURITY
APPLICATION ┃                         ┃  MODULE
        ┃ Non-Standard and/or     ┃
        ┃ Non-Cross-Platform      ┃
        ┃   -Java JCE             ┃
        ┃   -MS/CAPI              ┃
        ┃   -"others"             ┃


                        <b>PKCS#11 flow</b>
──────────────────────────────────────────────────────────────────────────────────
     SOFTWARE                 ┇            HARDWARE
______________________________    ┃   ____________________________________________
                              ┃   ╭─────────────╮  ╭───╮  ╭──────────────────╮
App ←→ Driver PKCS#11 ←→ OpenSC → ┃ ←→│Crypto OpenSC│←→│Phy│←→│SmartCard ISOXXXX │ 
                              ┃   ╰─────────────╯  ╰───╯  ╰──────────────────╯
</pre>
<pre zoom labels="hardware" TODO>
<span xsmall>Arch.considerations</span>
<span xsmall>for cryptanalytic hardware</span>
@[https://people.eecs.berkeley.edu/~daw/papers/hwkeysearch96-www/chap-10_local.html]
</pre>

<pre zoom labels="aaa,hardware" TODO>
<span xsmall>yubikey</span>
@[https://www.yubico.com/products/yubikey-hardware/]
@[https://github.com/drduh/YubiKey-Guide]
""the industry's #1 security key, enabling strong
two-factor, multi-factor and passwordless authentication."""

- Works with hundreds of services incluing Windows/Mac login,
  Gmail, Dropbox, Facebook, Salesforce, Duo, ... 

- Multi-protocol support: FIDO2, U2F, Smart card, OTP
</pre>

<pre zoom labels="hardware,signature,aaa,java,keystore">
<span xsmall>USB Armory</span>
@[https://inversepath.com/usbarmory]
The following example security application ideas 
illustrate the flexibility of the USB armory concept:

- Hardware Security Module (HSM)
- encrypted file storage with malware scanning,
  host authentication and data self-destruct
- USB firewall, bridging built-in receptacle and plug ports
- OpenSSH client and agent for untrusted hosts (kiosk)
- router for end-to-end VPN tunnelling, Tor
- password manager with integrated web server
- electronic wallet (e.g. pocket Bitcoin wallet)
- authentication, provisioning or licensing token
- portable penetration testing platform
- low level USB security testing
</pre>

<pre zoom labels="aaa,hardware,signature,keystore">
<span xsmall>Enterprise HSM</span>
@[https://safenet.gemalto.com/data-encryption/hardware-security-modules-hsms/protectserver-security-module/]

             SECP256K1                      Crytographic APIs
           |              /----------+----------------+---------------------+--------\
           |              | PKCS#11  | Java (JCA/JCE) | Microsoft CAPI  CNG | OpenSSL|
-----------|--------------+----------+----------------+---------------------+--------{
nChiper    |              |          |                |                     |        |
           |              |          |                |                     |        |
Gemalto    |              |          |                |                     |        |
(LunaHSM)  |              |          |                |                     |        |
           |              |          |                |                     |        |
....                 
</pre>

</div>
<div groupv>
<span xsmall>MultiFacto authentication</span>
</pre>

<pre zoom  labels="learn_x_in_y_min,aaa" TODO>
<span xsmall>Universal </span>
<span xsmall>Second Factor</span>
<span xsmall>(U2F)</span>
- See also:
@[https://en.wikipedia.org/wiki/Multi-factor_authentication]

@[https://www.yubico.com/solutions/fido-u2f/]
internet open auth. enabling users to securely access services
*with one single sec.key and with no drivers or client software needed*

<a href="https://github.com/google?utf8=%E2%9C%93&q=u2f&type=&language=">u2f at github.com/google</a>
See also: <a href="???">Universal Authentication Framework (UAF) protocol</a>
- vision: "take strong public key crypto to the mass market"
- Successfully deployed by Facebook, Gmail, Dropbox, GitHub, Salesforce.com, the UK government,
and many more.
</pre>
</div>
<div groupv>
<span title>Smart Cards</span>
<pre zoom labels="hardware">
<span xsmall>GNUPGP SC</span>
-@[https://www.commoncriteriaportal.org/cc/]
   Supporting Documents related to Smart Cards and similar devices
   Document number     Document title  Class
   2006-06-001         Rationale for Smart cards and similar devices   
   CCDB-2010-03-001    Guidance for smartcard evaluation v2.0  Guidance
   CCDB-2014-04-001    Security Architecture requirements (ADV_ARC) for
                       smart cards and similar devices (Mandatory)
   CCDB-2009-03-002    Application of CC to Integrated Circuits v3.0  (Mandatory)
   CCDB-2012-04-001    Composite product evaluation for Smartcards    (Mandatory)
                       and similar devices
   CCDB-2007-09-02     ETR-template lite for composition Guidance
   CCDB-2012-04-004    Security Architecture requirements (ADV_ARC)   (Guidance)
                       for smart cards and similar devices - Appendix 1 
   CCDB-2013-05-001    Minimum ITSEF Requirements for Security  (Mandatory)
                       Evaluations of Smart cards and similar devices  
   CCDB-2013-05-002    Application of Attack Potential to Smartcards  (Mandatory)

- GNUPGP Smart Card specs
@[https://gnupg.org/ftp/specs/]
@[http://cardwerk.com/iso-7816-smart-card-standard/]

- Extracted from @[https://en.wikipedia.org/wiki/Smart_card]
  """PGP SmartCard is the most widely used
  Crypto Commands include:
    - PSO: COMPUTE DIGITAL SIGNATURE
    - HASH ALGORITHMS
    - DigestInfo for RSA
    - PSO: DECIPHER
    - PSO: ENCIPHER
    - INTERNAL AUTHENTICATE
      + Client/Server Authentication
    - GENERATE ASYMMETRIC KEY PAIR
    - GET CHALLENGE
    - TERMINATE DF
  """

Related:
- GPG SmartCard for SSH Authentication
@[https://www.grepular.com/Smart_Cards_and_SSH_Authentication]
  *SSH KEY SETUP*
  ────────────────────┬──────────────────────────────────────
  STANDARD(SOFTWARE)  │ PGP (HARDWARE)
  SSH KEYGEN          │ SMART-CARD: 
  ────────────────────┼──────────────────────────────────────
            GENERATING THE KEYS
  ────────────────────┼──────────────────────────────────────
  $ ssh-keygen ...    │ (Install GnuPG 2 first)
                      │   $ gpg –gen-key  # Generate a keypair:
                      │   $ gpg –edit-key # ← Add <b>authentication subkey</b>
                      │   > addkey        # ←
                      │   > keytocard     # ← transfer private part of subkey to smart-card 
                      │                   #   A stub referencing the subkey is left behind
                      │                   #   with your on disk keypair. 
                      │ 
                      │ - Whenever you try to use that subkey, the system
                      │   will request that you insert the smart card.
                      │
  ────────────────────┼──────────────────────────────────────
            ADDING AUTH.SUBKEY TO SSH LIST OF AUTHORIZED KEYS
  ────────────────────┼──────────────────────────────────────
  $ ssh-copy-id ...   │  ("gpgkey2ssh" utility is provided by the gnupg-agent package )
                      │  Alt 1:
                      │    $ gpgkey2ssh $gpgSubkeyID_for_sshAuth \
                      │      → output_ssh_formated_pubkey  
                      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^
                      │    C+P to remote "~/ssh/authorized_keys" file
                      │  
                      │  Alt 2: (If the auth.subkey is on public gpg keyservers):
                      │    $ gpg --recv-key 0018461F
                      │    $ gpgkey2ssh 13990B29 >> ~/.ssh/authorized_keys
  ────────────────────┴──────────────────────────────────────
   
  AUTHENTICATING USING THE SMART CARD
  (how do we get the OpenSSH client to use the smart card)
  
  ────────────────────┬──────────────────────────────────────
  STANDARD(SOFTWARE)  │ PGP (HARDWARE)
  SSH KEYGEN          │ SMART-CARD: 
  ────────────────────┼──────────────────────────────────────
  (setup ssh-agent)   │ gpg-agent has been designed to speak 
                      │ the same protocol as ssh-agent 
                      │ 
                      │ - STEP 01:
                      │   stop ssh-agent process
                      │ - STEP 02:
                      │   add "enable-ssh-support" to
                      │   ~/.gnupg/gpg-agent.conf
                      │ 
                      │ ( OpenSSH client should start talking
                      │   to gpg-agent now )
                      │ 
                      │ - STEP 03:
                      │   $ ssh-add -l
                      │ ( You should see that the key you
                      │   generated previously is mentioned 
                      │   only when the S.C. is inserted!!! )
                      │ 
                      │ you’re done!!
                      │ ssh'ing to a remote machine with your pubkey
                      │ will ask to type your pin on the smart-card
                      │ reader.

  (See original ref for Windows/Putty setup)


- List of Implementations of the OpenPGP application for smart cards
@[https://incenp.org/notes/2016/openpgp-card-implementations.html]

- @[https://g10code.com/]
  """Founded by the principal author of GnuPG ...
     we provide custom development, enhancements
     and audits of cryptographic software.
     An ongoing effort of ours is the development 
     and maintenance of GnuPG and related software."""
  - OpenPGP (Smart)Card Specs:
  @[https://g10code.com/p-card.html]

  - @[https://openpgpcard.net/]
  r*WARN: Does not include display*
  - Hardware cryptocurrency wallet
  - OpenPGP smart card
  - U2F authenticator
  - One-time password generator
</pre>

<pre zoom labels="comparative">
<span xsmall>OpenCryptoJC.org</span>
@[http://opencryptojc.org/]
(Speed Up JavaCard Dev)
- <a href="https://www.youtube.com/watch?v=vd0-Uhx2OoQ">[Video] Unchaining the JavaCard Ecosystem (2018-02-22)</a>
Project providing convinient libraries for JavaCard development
including Integers, Big Numbers, Elliptic Curves and Profilers.

<a TODO href="https://www.fi.muni.cz/~xsvenda/jcalgtest/index.html">Java Card Comparision</a>
</pre>

<pre zoom labels="aaa,hardware">
<span xsmall>Security token</span>
@[https://en.wikipedia.org/wiki/Security_token]
- Physical devices used to gain access to an 
  electronically restricted resource
- Used in addition to or in place of a password like a 
  wireless keycard to open/unlock doors,... 
- All tokens contain some secret information used to 
  prove identity
- There are four ways in which this info. can be used:
  - Static password: token containing a password 
    transmitted for each authentication (vulnerable to 
    replay attacks)
  - Syncrhonous dynamic password</def> token, using a 
    timer to rotate through various combinations. Need 
    time synchronization with server
  - Asyncrhonous password</def> token generating One-time 
    password (no clock involved)
  - Challenge-response</def> token using pub.key 
    cryptography
</pre>

<pre zoom>
<span xsmall>Trusted Exec Env</span>
@[https://en.wikipedia.org/wiki/Trusted_execution_environment]
@[https://en.wikipedia.org/wiki/Trusted_Platform_Module]

<a xsmall href="https://en.wikipedia.org/wiki/Software_Guard_Extensions">Intel SGX</a>
@[https://software.intel.com/en-us/blogs/2013/09/26/protecting-application-secrets-with-intel-sgx]
r*WARN: SGX was vulnerable to Meltdown and Spectre hardware bugs*
CPU instruction set allowing user-level code to allocate 
private regions of memory (enclaves) protected from 
processes running at higher privilege levels. (secure 
remote computation, secure web browsing, DRM).

SGX is a set of instruction set extensions for CPUs 
released in Fall 2015 and available on recent CPUs. The 
key ability SGX provides is the notion of confidential, 
private execution with integrity guarantees. In essence, 
the chip has a special construct called an enclave. An 
enclave is like an ordinary program, except that the 
memory contents of an enclave are encrypted whenever they 
are off-chip, and accessible only on-chip, and only while 
the special enclave code is running. Further, the 
decryption keys are available solely to code with a 
certain hash: if you or a hacker were to hack the enclave 
code and change its hash, that hacked code will no longer 
have access to the encryption keys, repelling attacks. As 
a result, this ingenious technology does not permit anyone
, even the owner of the machine who can modify the code 
arbitrarily, to peek at the contents of the enclave or to 
modify execution within an enclave. Further, the SGX 
hardware enables remote attestation, that is, the ability 
to prove to a remote computer that a given enclave is 
running a particular software distribution. In essence, 
the chip is able to issue a statement that says "I 
guarantee to any remote party that I am running this code 
with this particular hash," which is a critical 
bootstrapping mechanism. Teechan is built on these two 
underlying features, which, together, provide a trusted 
execution environment (TEE).
</pre>
</div>

<div groupv>
<span title>Vault services&amp;KMS</span>
<pre zoom>
<a TODO xsmall href="https://www.vaultproject.io/">HashiCorp Vault Project</a>
"""HashiCorp Vault secures, stores, and tightly controls 
  access to tokens, passwords, certificates, API keys, and 
  other secrets in modern computing. Vault handles leasing, 
  key revocation, key rolling, and auditing. Through a 
  unified API, users can access an encrypted Key/Value 
  store and network encryption-as-a-service, or generate 
  AWS IAM/STS credentials, SQL/NoSQL databases, X.509 
  certificates, SSH credentials, and more. "

  <a href="https://github.com/hashicorp/vault">Vault@Github</a>

<span xsmall>Keywhiz</span>
@[https://square.github.io/keywhiz/]

<span xsmall>Crypt</span>
@[https://xordataexchange.github.io/crypt/]
(in combination with with etcd or consul)
</pre>

<pre zoom labels="keystore">
<span TODO xsmall>Key Mng.Serv.(KMS)</span>
- Google Cloud KMS
- Amazon KMS
- Android Keysotre
- Apple iOS KeyChain
- ...?
</pre>
</div>
<br/>
<hr/>

<div groupv>
<span title>Technology Radar</span>
<pre zoom>
<span xsmall TODO><a href="https://github.com/google/trillian">Trillian "Big"MerkleTree</a></span>
Trillian is an implementation of the concepts described in the
<a href="/google/trillian/blob/master/docs/VerifiableDataStructures.pdf">Verifiable Data Structures</a> white paper, which in turn is an extension and
generalisation of the ideas which underpin <a href="https://certificate-transparency.org" rel="nofollow">Certificate Transparency</a>
</pre>
<pre zoom>
<a xsmall TODO href="https://en.wikipedia.org/wiki/BitLocker">BitLocker full disk encryption</a>
</pre>
<pre zoom>
<a xsmall TODO href="https://www.rsaconference.com/">RSA Conference</a>
</pre>
<pre zoom labels="signature">
<span xsmall>Lamport signatures</span>
- quantum-proof cryptographic signatures
- Quantum Safe Ethereum proxy with
  Winternitz One-Time signatures
  @[https://github.com/tjade273/QEth]
</pre>
<pre zoom labels="keystore,hardware">
<span xsmall>Azure Sphere Pluton</span>
@[https://azure.microsoft.com/en-us/services/azure-sphere/]
Azure Sphere is solution for creating highly secured,
connected MCU-powered devices.

- The Pluton security subsystem creates a hardware root of trust,
  stores private keys, and executes complex cryptographic operations. 
</pre>

<pre zoom labels="">
<span xsmall>Elliptic Curves</span>
- ¿Safe?Curves: 
@[http://safecurves.cr.yp.to/]
- Browser support
@[https://security.stackexchange.com/questions/31772/what-elliptic-curves-are-supported-by-browsers]

- TLS-RSA cert. with elliptic curve
@[https://crypto.stackexchange.com/questions/30503/tls-rsa-certificate-with-elliptic-curve-negotiation]
</pre>

<pre zoom labels="">
<span xsmall>Pairing primitives</span>
@[https://www.math.uwaterloo.ca/~ajmeneze/publications/pairings.pdf]
</pre>

<pre zoom labels="ca,x509,comparative">
<span xsmall>RFC 8555</span>
@[https://tools.ietf.org/html/rfc8555]
Published on 2015-05-22 according to
@[https://datatracker.ietf.org/doc/rfc8555/]
Public Key Infrastructure using X.509 (PKIX) certificates are used
for a number of purposes, the most significant of which is the
authentication of domain names.  Thus, certification authorities
(CAs) in the Web PKI are trusted to verify that an applicant for a
certificate legitimately represents the domain name(s) in the
certificate.  As of this writing, this verification is done through a
collection of ad hoc mechanisms.  This document describes a protocol
that a CA and an applicant can use to automate the process of
verification and certificate issuance.  The protocol also provides
facilities for other certificate management functions, such as
certificate revocation.
</pre>
</div>
</body>
</html>
<!--
https://www.nucypher.com/
nuCypher. Privacy Infrastructure for the Decentralized Web

- Alice has sensitive data that she wants to store and share.
- Alice encrypts her data using her public key and uploads it to storage.
- Alice delegates access to Bob. The data is rekeyed to Bob's key using proxy re-encryption
- Bob downloads the data and decrypts it with his own private key.


Proxy Re-encryption (PRE)

NuCypher's PRE network provides cryptographic access controls for distributed apps and protocols.


Fully Homomorphic Encryption (FHE)

NuCypher's NuFHE library enables secure, private computation on encrypted data by outsourced nodes.

See also:
https://blog.nucypher.com/numerology-fast-ecc-arithmetic-on-chain-5eb438a735d4
____________________
https://cryptonaute.fr/portefeuilles-hardware-crypto-monnaie-bitcoins/

_________________________
https://journalducoin.com/altcoins/ethereum-eth-bientot-resistant-aux-asic-grace-a-progpow/
_______________________
Key Shadowing: patents:
https://patents.google.com/patent/US9634836
____________________________
Comparisions of secp256r1-vs-secp256k1 Elliptic Curves:
https://crypto.stackexchange.com/questions/18965/is-secp256r1-more-secure-than-secp256k1

__________________________
Linux Oauth 2factor authentication from CLI:
https://www.cyberciti.biz/faq/use-oathtool-linux-command-line-for-2-step-verification-2fa/
_____________________
__________________

______________________
______________________________
https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer
________________________
https://firmaelectronica.gob.es/Home/Ciudadanos/Formatos-Firma.html
CADES/PADES/XADES
__________________________
Comparative:
Multi-signature schemes require the network to verify each signature, increasing load with the number of participants. Conversely, threshold signatures are generated offline and result in a single signature regardless of total number of parties participating.
____________________
Keccak
https://en.wikipedia.org/wiki/SHA-3
SHA-3 is a subset of the broader cryptographic primitive family Keccak
____________________
@[http://www-math.ucdenver.edu/~wcherowi/courses/m5410/dss.pdf]
El-Gamal
https://en.wikipedia.org/wiki/ElGamal_encryption

In cryptography, the ElGamal encryption system is an asymmetric key 
encryption algorithm for public-key cryptography which is based on the Diffie–
Hellman key exchange. The system provides an additional layer of security by 
asymmetrically encrypting keys previously used for symmetric message 
encryption. It was described by Taher Elgamal in 1985.[1] ElGamal encryption 
is used in the free GNU Privacy Guard software, recent versions of PGP, and 
other cryptosystems. The Digital Signature Algorithm (DSA) is a variant of 
the ElGamal signature scheme, which should not be confused with ElGamal encryption.
_________________
_________________
What's the signature recovery key?
_________________
Asym. ChaCha
___________________________
https://en.wikipedia.org/wiki/RSA_(cryptosystem)
__________________
https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language
__________________
https://en.wikipedia.org/wiki/Kerberos_(protocol)
- computer-network authentication protocol that works on
  the basis of tickets to allow nodes communicating over 
  a non-secure network to prove their identity to one
  another in a secure manner.

__________________
Comparative: OpenID vs OAuth2 vs SAML
@[https://spin.atomicobject.com/2016/05/30/openid-oauth-saml/]
_________________
https://standards.globalspec.com/std/1167872/DS/EN%2014890-1

Part 1 of this series specifies the application interface to Smart Cards during the usage phase, used as Secure Signature Creation Devices (SSCD) according to the Terms of the European Directive on Electronic Signature 1999/93 to enable interoperability and usage as SSCD on a national or European level. This document describes the mandatory services for the usage of Smart Cards as SSCDs based on CEN CWA 14890. This covers the signing function, storage of certificates, the related user verification, establishment and use of trusted path and channel, requirements for key generation and the allocation and format of resources required for the execution of those functions and related cryptographic token information. Thereby the functionality of CWA 14890-1 is enhanced in the following areas: - Device authentication with Elliptic Curves (ELC) for existing asymmetric authentication protocols (RSA Transport, Privacy Protocol), - Enhancement of existing asymmetric authentication protocols due to privacy and non-traceability constraints, - Card Verifiable (CV) Certificate Formats (self descriptive) with ELC for all types of authentication and authorization protocols, - Secure Messaging Tags and use of commands with Odd-INS Code in compliance to the actual ISO/IEC 7816-4, - Further hash algorithms (SHA2-family) with corresponding Object identifier and Algorithm references, - Use of AES in authentication protocols, - Use of AES for secure messaging. The following items are out of scope: 1) The physical, electrical and transport protocol characteristics of the card, 2) The external signature creation process and signature environment, 3) The elements required to verify an electronic signature produced by a card used as a SCCD, 4) The error handling process.
-->

