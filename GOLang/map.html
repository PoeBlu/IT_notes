<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Go Lang. Summary(beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->
<table style='width:100%'{>
<tbody>
<tr {>
<td>
     <a href="https://golang.org/doc/install">Install (GOPATH)</a><br/>
<pre xxxsmall zoom>
GOPATH ENV.VAR: (default: $HOME/go) location of working workspace
$ go env GOPATH # prints the effective current GOPATH
</pre>
<hr/>
  Hello World
<pre xxxsmall zoom>
# setup Environement
$ export GOPATH=$(go env GOPATH)
$ export PATH=$PATH:${GOPATH}/bin
$ mkdir -p ${GOPATH}\
  /src/github.com/"myUser"/hello

$ vim ${GOPATH}/src/github.com/"myUser"/hello
  | package main 
  | // ^ must be always the first statement
  | 
  | import (
  |   "fmt"
  |   "time"
  |   "math/rand"
  |   m "golang-book/chapter11/math"
  | )
  | func f(n int) {
  |   for i := 0; i < 10; i++ {
  |     fmt.Println(n, ":", i)
  |     amt := time.Duration(rand.Intn(250))
  |     time.Sleep(time.Millisecond * amt)
  |   }
  |   ... m.Average(...)
  | }
  | 
  | func main() {
  |     const (
  |        HELLO = "Hello"
  |        WORLD = "World"
  |     )
  |     
  |     var x string = HELLO + " " + WORLD +"\n"
  |         x       := HELLO + " " + WORLD +"\n"  // alt 2
  |     fmt.Printf(x) // alt 1
  |     fmt.Println("1 + 1 = ", 1.0 + 1.0) // alt 2
  |     var input float64 
  |     go f(1) // go-routine
  |     fmt.Printf(fmt.Scanf("%f", &amp;input))
  | }

$ <def>go run  </def> hello.go     # alt 1
$ <def>go build</def>  &amp;&amp; ./hello # alt 2

</pre>
</td>
<td>
  <ul xsmall zoom>
  <li><a href="https://golang.org/doc/">Golang Doc</a></li>
  <li><a href="https://golang.org/doc/diagnostics.html">Diagnostics</a></li>
  <li><a href="https://golang.org/pkg/">Standard lib</a></li>
  <li><a href="https://golang.org/pkg/builtin/">Builtin library</a>
<pre xxxsmall zoom>
functions:
    append(slice []Type, elems ...Type) []Type
    cap(v Type) int
    close(c chan<- Type)
    complex(r, i FloatType) ComplexType
    copy(dst, src []Type) int
    delete(m map[Type]Type1, key Type)
    imag(c ComplexType) FloatType
    len(v Type) int
    make(t Type, size ...IntegerType) Type
    new(Type) *Type
    panic(v interface{})
    print(args ...Type)
    println(args ...Type)
    real(c ComplexType) FloatType
    recover() interface{}

types
   ComplexType FloatType IntegerType Type Type1 bool byte complex128 complex64 error float32
   float64 int int16 int32 int64 int8 rune string uint uint16 uint32 uint64 uint8 uintptr
</pre>
  </li>
  <li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
  </ul>
  <hr/>
  Install to $GOPATH/bin:
  <ul xxxsmall zoom>
  <li><pre xxxsmall zoom>$ go install github.com/"myUser"/hello</pre></li>
  <li>A workspace contains many version control repositories (Git, ...).</li>
  <li>Each repository contains one or more packages</li>
  <li>Each package consists of one or more Go src files in a single directory</li>
  <li>The directory file path to a package determines <code>import path</code></li>
  </ul>

  Building a library<br/>
  <ol xxxsmall zoom>
  <li>
<pre>$ mkdir $GOPATH/src/github.com/"myUser"/stringutil</pre>
  </li>
  <li>
Edit $GOPATH/src/github.com/"myUser"/stringutil/reverse.go
<pre xxxsmall zoom>
// utility functs for strings
package stringutil

func Reverse(s string) string {
    r := []rune(s)
    for i, j := 0, <b blue>len</b>(r)-1;
        i < <b blue>len</b>(r)/2;
        i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
</pre>
  </li>
  <li>
Test build:
<pre xxxsmall zoom>
$ go build github.com/"myUser"/stringutil</pre>
  </li>
  <li>
Install:
<pre xxxsmall zoom>
$ go install github.com/"myUser"/stringutil</pre>
  </li>
  <li>
Use it in hello.go:
<pre xxxsmall zoom>
package main
import ("fmt"
        "github.com/myUser/stringutil"
)
...
   fmt.Printf(stringutil.Reverse("!oG, olleH"))
</pre>
  </li>
  </ol>
</td>  
<td>
  Code organization (workspace):<br/>
<pre xxxsmall zoom>
  typically keep all Go code in a single workspace ("GOPATH")
workspace
 | bin/
 |   hello
 |   outyet
 | pkg/
 |   linux_amd64/
 |     github.com/golang/example/
 |       stringutil.a
 | src/
 |   github.com/golang/example/
 |       .git/
 |   golang.org/x/image/
 |       .git/
 |   hello/
 |       hello.go
 |   ...
</pre>
<br/>
<pre xxxsmall zoom>
# "go get" is similar to "go install" but also downloads
# from git if the specified packages is not in workspace
$ go get \
   github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go examples!
</pre>
  Testing <a xxsmall href="https://golang.org/cmd/go/#hdr-Test_packages"><br/>
  <code>go test help</code></a>, <a xxsmall href="https://golang.org/pkg/testing/">testing package</a>
  <ol xxxsmall zoom>
  <li>edit <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code> (same folder than standar source code)
<pre xxxsmall zoom>
package stringutil

import "testing"

func TestReverse(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {"Hello, world", "dlrow ,olleH"},
  }
  for _, c := range cases {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf(
        "Reverse(%q) == %q, want %q",
        c.in, got, c.want)
    }
  }
}
</pre>
  </li>
  <li>Run tests:
<pre xxxsmall zoom>
$ go test \
  github.com/user/stringutil
ok github.com/user/stringutil 0.165s
</pre>
  </li>
  </ol>
</td>  
<td>
  Types<br/>
<pre xxxsmall zoom>
(u)int8/16/32/64
float32/64
complex64/128
NaN
positive/negative inifinity
Strings:
   "asdf" + `asdf`/* newline allowed */
   <b blue>len</b>("asdf")
   "asdf"[0] // a
Booleans: true / false (&amp;&amp; , || ,  !)

float64(<b blue>len</b>(x)) // Type conversion

val1 := 1
xPtr *int = &amp;val1 // Pointer
ptr1 := new(int)      // Pointer
</pre>

  Structs and Embedded Type<br/>
<pre xxxsmall zoom>
<b orange>type</b> Circle <b orange>struct</b> {
  x, y, r float64
  color   string 
}
circle1 := Circle{0,0,4,"blue"}

// <b orange>"friend"</b> function
func <b orange>(c *Circle)</b> area() float64 {
  return math.Pi * c.r*c.r
}
circle1.area
</pre>

  Type composition:
<pre xxxsmall zoom>
type Wheel struct {
   <b orange>Circle</b> // embedded (composed) type
   material string
}
wheel1 := Wheel1{circle1, "iron"}
wheel1<b orange>.area</b> // calls wheel1<b orange>.circle1.area</b>
</pre>


  For loops<br/>
<pre xxxsmall zoom>
i := 1
for i<=10 { ...
  i = i + 1
}
</pre>
  if-else , switch<br/>
<pre xxxsmall zoom>
if i % 2 == 0 {       | switch i {
    // divisible by 2 |   case  0: ...
} else if i % 3 == 0 {|   case  1: ...
    // divisible by 3 |   default: ...
} else  {             | }
    // ...
} 
</pre>
</td>
<td>
  arrays<br/>
<pre xxxsmall zoom>
var x [5]int // 0-initialized
x[4] = 100 // [ 0 0 0 0 100]
<b blue>len</b>(x)
x := [3]float64 { 1.0, 2.0, 3.0}
</pre>
  slices (segments of arrays)<br/>
<pre xxxsmall zoom>
slice1 := <b orange>make</b>(<b orange>[]</b>float64, 5 ,  10)
//                        ^    ^
//                       len capacity 
                          
array1 :=[]int{1,2,3,4,5}
slice2 :=array1[0:5]
slice3 :=append(mySlice2,4)
copy(slice3,slice2) 
     ^copy of slice2 up to len   
</pre>
  Walk over array
<pre xxxsmall zoom>
for idx, element := <b orange>range</b> array1 {
  // do something
}
</pre>
  Maps<br/>
<pre xxxsmall zoom>
map1 := <b orange>make</b>(<b orange>map</b>[string]int)
map1["key"] = 10
delete(map1, "key")
map1["no_key"] // = "zero type value"
if value1, ok := map1["no_key"]; ok {
   ...
}
map2 := map[string]map[string]string{
  "H": map[string]string{
    "name":"Hydrogen", 
    "state":"gas",
  },
  ...
}

</pre>
  Walk over a map
<pre xxxsmall zoom>
// Iterate over map key/value pairs
for key, value := <b orange>range</b> map1 {
    fmt.Println("Key:", key, "Value:", value)
}
</pre>


  List<br/>
<pre xxxsmall zoom>
import ("container/list")
var x list.List
x.PushBack(1)
x.PushBack(2)
...

---------------

import ("sort")
type ByOrder1 []MyType
func (this ByOrder1) Len() int {
  return <b blue>len</b>(this)
}
func (this ByOrder1) Less(i, j int) bool {
  return this[i].Name < this[j].Name
}
func (this ByOrder1) Swap(i, j int) {
  this[i], this[j] = this[j], this[i]
}
...
sort.Sort(ByName(kids))
</pre>
  Walk over a list
<pre xxxsmall zoom>
//  To iterate over a list (where l is a *List):
for e := l.Front(); e != nil; e = e.Next() {
    // do something with e.Value
}

</pre>
</td>
</tr>
</table>
<table>
<tr {>
<td>
  Functions and Closures<br/>
<pre xxxsmall zoom>
func                       |func 
  funcName(                |  makeEvenGenerator() 
    param1 []int,          |   func() uint {
    param2 string          | //^returns function that
    ...int                 | // returns uint
  )                        |  i := uint(0)
  (int,int) /*return type*/|  return func() (ret uint) 
  {                        |  {      ^closure
    ...                    |    ret = i
    if !ok {               |    i += 2
      panic("RuntimeError")|    return
    }                      |  }
    return 1,2             |}
}
</pre>
  defer, panic, recover<br/>
<pre xxxsmall zoom>
f, _ := os.Open(filename)
func main() {
  defer f.Close()
  defer func() {
     fmt.Println(recover())
  }
  ...
  if ... { panic("RuntimeException") }
}
</pre>
</td>  
 
<td>
  Interfaces<br/>
<pre xxxsmall zoom>
type Shape interface {
  area() float64
}

func totalArea(shapes ...Shape) 
  float64 {
  var result float64
  for _, s := range shapes {
     result += s.area() 
  }
  return result
}
</pre>
</td>  
<td>
  Goroutines and Channels<br/>
<pre xxxsmall zoom>
// call functName in micro-thread
go functName(param1,param2,..)

/*
 * Init non-buffered channel (sync)
 * c1 "sides" will wait 
 * until the other is ready
 */
var c1 chan string \
   = <b orange>make</b>(<b orange>chan</b> string)
/*
 * Init    buffered channel (async)
 * c1 "sides" will wait until the other
 * is ready
 */

var c2 chan string \
   = <b orange>make</b>(<b orange>chan</b> string, 1/*capacity*/)

c1 <- "a"    // Write to channel
msg := <- c1 // Read from chnanel

// func1 can read/write to channel
func func1(c chan string) ...

// func2 can write to channel
func func2(c chan<- string) ...

// func3 can read from channel
func func3(c <-chan string) ...
</pre>
 Select<br/>
<pre xxxsmall zoom>
pick the first channel ready and receives from it (or sends to it)
select {
  case msg1 := <- c1:
    fmt.Println(msg1)
  case msg2 := <- c2:
    fmt.Println(msg2)
  case <- time.After(time.Second):
    fmt.Println("timeout")
  default:
    fmt.Println("nothing ready")
}
</pre>
</td>  
<td>
  strings package<br/>
<pre xxxsmall zoom>
strings.Contains("test", "es")  // true
strings.Count("test", "t")      // 2
strings.HasPrefix("test", "te") // true
strings.HasSuffix("test", "st") // true
strings.Index("test", "e")    // 1
strings.Join([]string{"a","b"}, "-")  // "a-b"
strings.Repeat("a", 3)        // == "aaa"
strings.Replace("aa","a","b",1)  // "ba"
strings.Split("a-b-c", "-")   // []string
                              // {"a","b","c"}
strings.ToLower("TEST")       // "test"
strings.ToUpper("test")       // "TEST"

arr := []byte("test")
str := string([]byte{'t','e','s','t'}
</pre>
</td>  
</tr>
</table>

<table>
<tr {>
<td>
  Input/Output<br/>
<!--
@ma https://www.golang-book.com/public/pdf/gobook.0.pdf pag 138
--> 
  Many fuctions in Go take Readers and Writers as arguments
  (io:Copy, ...)
<pre xxxsmall zoom>
func Copy(dst Writer, src Reader) 
    (written int64, err error)
</pre>
  Buffers<br/>
<pre xxxsmall zoom>
// No need to init (make)
var buf bytes.Buffer
buf.Write([]byte("test"))

// Convert string to Reader
strings.NewReader
</pre>
</td>  
  
<td>
  Parsing cmd line args<br/>
<pre xxxsmall zoom>
package main
import ("fmt";"flag";"math/rand")
func main() {
  // Define flags
  maxp := flag.Int("max", 6, "the max value")
  flag.Parse() // Parse
  // Generate number between 0 and max
  fmt.Println(rand.Intn(*maxp))
}
</pre>
</td>  
<td>  
  <a href="https://golang.org/pkg/time/">time</a>
<pre xxxsmall zoom>
start   := time<b orange>.Now()</b>
// time diff
elapsed := time.Now()<b orange>.Sub</b>(start)

<a href="https://golang.org/pkg/time/#After">func After(d Duration) &lt;-chan Time</a>
<a href="https://golang.org/pkg/time/#Sleep">func Sleep(d Duration)</a>
<a href="https://golang.org/pkg/time/#Tick">func Tick(d Duration) &lt;-chan Time</a>
<a href="https://golang.org/pkg/time/#Duration">type Duration</a>
    <a href="https://golang.org/pkg/time/#ParseDuration">func ParseDuration(s string) (Duration, error)</a>
    <a href="https://golang.org/pkg/time/#Since">func Since(t Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Until">func Until(t Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Duration.Hours">func (d Duration) Hours() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.Minutes">func (d Duration) Minutes() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.Nanoseconds">func (d Duration) Nanoseconds() int64</a>
    <a href="https://golang.org/pkg/time/#Duration.Round">func (d Duration) Round(m Duration) Duration</a>
    <a href="https://golang.org/pkg/time/#Duration.Seconds">func (d Duration) Seconds() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.String">func (d Duration) String() string</a>
    <a href="https://golang.org/pkg/time/#Duration.Truncate">func (d Duration) Truncate(m Duration) Duration</a>
<a href="https://golang.org/pkg/time/#Location">type Location</a>
    <a href="https://golang.org/pkg/time/#FixedZone">func FixedZone(name string, offset int) *Location</a>
    <a href="https://golang.org/pkg/time/#LoadLocation">func LoadLocation(name string) (*Location, error)</a>
    <a href="https://golang.org/pkg/time/#LoadLocationFromTZData">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</a>
    <a href="https://golang.org/pkg/time/#Location.String">func (l *Location) String() string</a>
<a href="https://golang.org/pkg/time/#Month">type Month</a>
    <a href="https://golang.org/pkg/time/#Month.String">func (m Month) String() string</a>
<a href="https://golang.org/pkg/time/#ParseError">type ParseError</a>
    <a href="https://golang.org/pkg/time/#ParseError.Error">func (e *ParseError) Error() string</a>
<a href="https://golang.org/pkg/time/#Ticker">type Ticker</a>
    <a href="https://golang.org/pkg/time/#NewTicker">func NewTicker(d Duration) *Ticker</a>
    <a href="https://golang.org/pkg/time/#Ticker.Stop">func (t *Ticker) Stop()</a>
<a href="https://golang.org/pkg/time/#Time">type Time</a>
    <a href="https://golang.org/pkg/time/#Date">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a>
    <a href="https://golang.org/pkg/time/#Now">func Now() Time</a>
    <a href="https://golang.org/pkg/time/#Parse">func Parse(layout, value string) (Time, error)</a>
    <a href="https://golang.org/pkg/time/#ParseInLocation">func ParseInLocation(layout, value string, loc *Location) (Time, error)</a>
    <a href="https://golang.org/pkg/time/#Unix">func Unix(sec int64, nsec int64) Time</a>
    <a href="https://golang.org/pkg/time/#Time.Add">func (t Time) Add(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.AddDate">func (t Time) AddDate(years int, months int, days int) Time</a>
    <a href="https://golang.org/pkg/time/#Time.After">func (t Time) After(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.AppendFormat">func (t Time) AppendFormat(b []byte, layout string) []byte</a>
    <a href="https://golang.org/pkg/time/#Time.Before">func (t Time) Before(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.Clock">func (t Time) Clock() (hour, min, sec int)</a>
    <a href="https://golang.org/pkg/time/#Time.Date">func (t Time) Date() (year int, month Month, day int)</a>
    <a href="https://golang.org/pkg/time/#Time.Day">func (t Time) Day() int</a>
    <a href="https://golang.org/pkg/time/#Time.Equal">func (t Time) Equal(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.Format">func (t Time) Format(layout string) string</a>
    <a href="https://golang.org/pkg/time/#Time.GobDecode">func (t *Time) GobDecode(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.GobEncode">func (t Time) GobEncode() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.Hour">func (t Time) Hour() int</a>
    <a href="https://golang.org/pkg/time/#Time.ISOWeek">func (t Time) ISOWeek() (year, week int)</a>
    <a href="https://golang.org/pkg/time/#Time.In">func (t Time) In(loc *Location) Time</a>
    <a href="https://golang.org/pkg/time/#Time.IsZero">func (t Time) IsZero() bool</a>
    <a href="https://golang.org/pkg/time/#Time.Local">func (t Time) Local() Time</a>
    <a href="https://golang.org/pkg/time/#Time.Location">func (t Time) Location() *Location</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalBinary">func (t Time) MarshalBinary() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalJSON">func (t Time) MarshalJSON() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalText">func (t Time) MarshalText() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.Minute">func (t Time) Minute() int</a>
    <a href="https://golang.org/pkg/time/#Time.Month">func (t Time) Month() Month</a>
    <a href="https://golang.org/pkg/time/#Time.Nanosecond">func (t Time) Nanosecond() int</a>
    <a href="https://golang.org/pkg/time/#Time.Round">func (t Time) Round(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.Second">func (t Time) Second() int</a>
    <a href="https://golang.org/pkg/time/#Time.String">func (t Time) String() string</a>
    <a href="https://golang.org/pkg/time/#Time.Sub">func (t Time) Sub(u Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Time.Truncate">func (t Time) Truncate(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.UTC">func (t Time) UTC() Time</a>
    <a href="https://golang.org/pkg/time/#Time.Unix">func (t Time) Unix() int64</a>
    <a href="https://golang.org/pkg/time/#Time.UnixNano">func (t Time) UnixNano() int64</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalBinary">func (t *Time) UnmarshalBinary(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON">func (t *Time) UnmarshalJSON(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalText">func (t *Time) UnmarshalText(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.Weekday">func (t Time) Weekday() Weekday</a>
    <a href="https://golang.org/pkg/time/#Time.Year">func (t Time) Year() int</a>
    <a href="https://golang.org/pkg/time/#Time.YearDay">func (t Time) YearDay() int</a>
    <a href="https://golang.org/pkg/time/#Time.Zone">func (t Time) Zone() (name string, offset int)</a>
<a href="https://golang.org/pkg/time/#Timer">type Timer</a>
    <a href="https://golang.org/pkg/time/#AfterFunc">func AfterFunc(d Duration, f func()) *Timer</a>
    <a href="https://golang.org/pkg/time/#NewTimer">func NewTimer(d Duration) *Timer</a>
    <a href="https://golang.org/pkg/time/#Timer.Reset">func (t *Timer) Reset(d Duration) bool</a>
    <a href="https://golang.org/pkg/time/#Timer.Stop">func (t *Timer) Stop() bool</a>
<a href="https://golang.org/pkg/time/#Weekday">type Weekday</a>
    <a href="https://golang.org/pkg/time/#Weekday.String">func (d Weekday) String() string</a>

</pre>
</td>  
</tr>
</table>

</body>
<!--
error handling
files
networking
runtime
________________
A Brief tour of Practical Crypto in GoLang: https://cyberspy.io/articles/crypto101/
    AES encryption (also known as FIPS 197)
    Block Ciphers
    DES and TDEA (also known as FIPS 46-3)
    Digital Signature Algorithms (DSA FIPS 186-3)
    Hashed Message Authentication Code (HMAC FIPS-198)
    Hashing: MD5 Hashing Algorithm (RFC 1321), SHA1 (RFC 3174), SHA256/SHA512 (FIPS 180-4)
    RSA: RSA PKCS#1 encryption implementation
    X509/TLS Certificate and Key based comms and general certificates/key manipulation
-->

</html>
