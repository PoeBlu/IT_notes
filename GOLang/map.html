<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Go Lang. Summary</title>
<!--
 Q:Note what the attribute { and } do:
 A:Those attributes are ignored by the browser but are helpful to fold/unfold text in some
   editors (Vim, Emacs,...)
-->
<!--
ROW TEMPLATE
<tr {>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>
-->

<head>
<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 
function onTDDoubleClick()      { zoomDivDOM.innerHTML = 
     "('Esc' to close) Toggle "+
     "<span style='color:blue;' onClick=\"zoomDivFW  = !zoomDivFW ; zoomDivDOM.style.maxWidth  = zoomDivFW  ? '98%' : '30%'\">[Width]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivFH  = !zoomDivFH ; zoomDivDOM.style.maxHeight = zoomDivFH  ? '98%' : '30%'\">[Height]</span> " 
   + " Toggle " 
   + "<span style='color:blue;' onClick=\"zoomDivLft = !zoomDivLft; zoomDivDOM.style.left      = zoomDivLft ? '1%'  : '69%'\">[Horz]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivTop = !zoomDivTop; zoomDivDOM.style.top       = zoomDivTop ? '1%'  : '69%'\">[Vert]</span> " 
   + " <br/> " 
   + this.innerHTML; 
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
  removeToLeftMarginInPre();
}
</script>
<style>
pre { background-color:#EEFFEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
* xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xbig  ]  { font-size:1.3rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

#zoomDiv [xxsmall]  , #zoomDiv * [xxsmall] , #zoomDiv * * [xxsmall] , #zoomDiv * * * [xxsmall] { font-size:1em; }
#zoomDiv [xsmall]   , #zoomDiv * [xsmall]  , #zoomDiv * * [xsmall]  , #zoomDiv * * * [xsmall]  { font-size:1em; }
#zoomDiv [small]    , #zoomDiv * [small]   , #zoomDiv * * [small]   , #zoomDiv * * * [small]   { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[col1] ,th[col1] {background-color:#FFFFFF; min-width:34%; max-width:34%; }
td[col2] ,th[col2] {background-color:#FAFAFA; min-width:33%; max-width:33%; }
td[col3] ,th[col3] {background-color:#FFFFFF; min-width:33%; max-width:33%; }
th[header_delimit]{background-color:#000000; color:#FFFFFF; font-size:2em; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

</style>
</head>
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>

<table style='width:100%'{>
<tbody>
<tr {>
  <th colspan=3 header_delimit {   >Go Lang</th>
</tr }>
<tr {>
  <td col1 >
     <a xbig href="https://golang.org/doc/install">Install</a><br/>
     <span xbig>GOPATH ENV.VAR</span><br/>
     GOPATH : localtion of working workspace. (defaults to $HOME/go)<br/>
     <code> $ go env GOPATH</code> prints the effective current GOPATH<br/>
<hr/>
     <span xbig>Hello World:</span><br/>
<pre>
export GOPATH=$(go env GOPATH)
export PATH=$PATH:${GOPATH}/bin
$ mkdir -p ${GOPATH}\
  /src/github.com/"myUser"/hello
</pre>
edit ${GOPATH}/src/github.com/"myUser"/hello
<pre {>
package main 
// ^ must be always the first statement

import (
  "fmt"
  "time"
  "math/rand"
  m "golang-book/chapter11/math"
)
func f(n int) {
  for i := 0; i < 10; i++ {
    fmt.Println(n, ":", i)
    amt := time.Duration(rand.Intn(250))
    time.Sleep(time.Millisecond * amt)
  }
  ... m.Average(...)
}

func main() {
    const (
       HELLO = "Hello"
       WORLD = "World"
    )
    
    var x string = HELLO + " " + WORLD +"\n"
 // alt x       := HELLO + " " + WORLD +"\n" 
    fmt.Printf(x) // alt 1
    fmt.Println("1 + 1 = ", 1.0 + 1.0) // alt 2
    var input float64 
    go f(1) // go-routine
    fmt.Printf(fmt.Scanf("%f", &input))
}
</pre }>
       </td>  
  <td col2 >
   <span xbig>Run/test</span><br/>
   <ul>
<pre {>
$ go run hello.go     # alt 1
$ go build && ./hello # alt 2
</pre }>
Install to $GOPATH/bin:
<pre {>$ go install github.com/"myUser"/hello</pre }>
       <li>A workspace contains many version control repositories (Git, ...).</li>
       <li>Each repository contains one or more packages</li>
       <li>Each package consists of one or more Go src files in a single directory</li>
       <li>The directory file path to a package determines <code>import path</code></li>
   </ul>
   <span xbig>Building a library</span><br/>
   <ol>
     <li>
<pre>
$ mkdir $GOPATH/src/github.com/"myUser"/stringutil
</pre>
     </li>
     <li>
Edit $GOPATH/src/github.com/"myUser"/stringutil/reverse.go
<pre>
// utility functs for strings
package stringutil

func Reverse(s string) string {
    r := []rune(s)
    for i, j := 0, len(r)-1;
        i < len(r)/2;
        i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
</pre>
     </li>
     <li>
Test build:
<pre>$ go build github.com/"myUser"/stringutil</pre>
     </li>
     <li>
Install:
<pre>$ go install github.com/"myUser"/stringutil</pre>
     </li>
     <li>
Use it in hello.go:
<pre>
package main
import ("fmt"
        "github.com/myUser/stringutil"
)
...
   fmt.Printf(stringutil.Reverse("!oG, olleH"))
</pre>
     </li>
   </ol>
  </td>  
  <td col3 >
    <span xbig>Code organization (workspace):</span><br/>
    typically keep all Go code in a single workspace ("GOPATH")
<pre {>
workspace
 | bin/
 |   hello
 |   outyet
 | pkg/
 |   linux_amd64/
 |     github.com/golang/example/
 |       stringutil.a
 | src/
 |   github.com/golang/example/
 |       .git/
 |   golang.org/x/image/
 |       .git/
 |   hello/
 |       hello.go
 |   ...
</pre }>
<br/>

"go get" is similar to "go install" but also download from git if the specified packages is not in workspace
<pre>
$ go get \
   github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go examples!
</pre>
  </td>  
</tr }>
<tr {>
  <td col1 >
    <span xbig>Testing</span><br/>
    See also: <a href="https://golang.org/cmd/go/#hdr-Test_packages"><code>go test help</code></a>,
    <a href="https://golang.org/pkg/testing/">testing package</a>
    <ol>
      <li>edit <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code> (same folder than standar source code)
<pre>
package stringutil

import "testing"

func TestReverse(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {"Hello, world", "dlrow ,olleH"},
  }
  for _, c := range cases {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf(
        "Reverse(%q) == %q, want %q",
        c.in, got, c.want)
    }
  }
}
</pre>
      </li>
      <li>Run tests:
<pre>
$ go test \
  github.com/user/stringutil
ok github.com/user/stringutil 0.165s
</pre>
      </li>
    </ol>
  </td>  
  <td col2 >
    <span xbig>Types</span><br/>
<pre>
(u)int8/16/32/64
float32/64
complex64/128
NaN
positive/negative inifinity
Strings:
   "asdf" + `asdf`/* newline allowed */
   len("asdf")
   "asdf"[0] // a
Booleans: true / false (&amp;&amp; , || ,  !)

float64(len(x)) // Type conversion

val1 := 1
xPtr *int = &amp;val1 // Pointer
ptr1 := new(int)      // Pointer
</pre>
    <span xbig>For loops</span><br/>
<pre>
i := 1
for i<=10 { ...
  i = i + 1
}
</pre>
    <span xbig>if-else , switch</span><br/>
<pre>
if i % 2 == 0 {       | switch i {
    // divisible by 2 |   case  0: ...
} else if i % 3 == 0 {|   case  1: ...
    // divisible by 3 |   default: ...
} else  {             | }
    // ...
} 
</pre>
  </td>  
  <td col3 >
    <span xbig>arrays</span><br/>
<pre>
var x [5]int // 0-initialized
x[4] = 100 // [ 0 0 0 0 100]
len(x)
x := [3]float64 { 1.0, 2.0, 3.0}
</pre>
    <span xbig>slices (segments of arrays)</span><br/>
<pre>
slice1 := make([]float64, 5 ,  10)
//                        ^    ^
//                       len capacity 
                          
array1 :=[]int{1,2,3,4,5}
slice2 :=array1[0:5]
slice3 :=append(mySlice2,4)
copy(slice3,slice2) 
     ^copy of slice2 up to len   
</pre>
    <span xbig>Maps</span><br/>
<pre>
map1 := make(map[string]int)
map1["key"] = 10
delete(map1, "key")
map1["no_key"] // = "zero type value"
if value1, ok := map1["no_key"]; ok {
   ...
}
map2 := map[string]map[string]string{
  "H": map[string]string{
    "name":"Hydrogen", 
    "state":"gas",
  },
  ...
}
</pre>
  </td>  
</tr }>
<tr {>
  <td col1 >
    <span xbig>Functions and Closures</span><br/>
<pre>
func                       |func 
  funcName(                |  makeEvenGenerator() 
    param1 []int,          |   func() uint {
    param2 string          | //^returns function that
    ...int                 | // returns uint
  )                        |  i := uint(0)
  (int,int) /*return type*/|  return func() (ret uint) 
  {                        |  {      ^closure
    ...                    |    ret = i
    if !ok {               |    i += 2
      panic("RuntimeError")|    return
    }                      |  }
    return 1,2             |}
}
</pre>
    <span xbig>defer, panic, recover</span><br/>
<pre>
f, _ := os.Open(filename)
func main() {
  defer f.Close()
  defer func() {
     fmt.Println(recover())
  }
  ...
  if ... { panic("RuntimeException") }
}
</pre>

  </td>  
  <td col2 >
    <span xbig>Structs and Embedded Type</span><br/>
<pre>
type Circle struct {
  x, y, r float64
  color   string 
}
circle1 := Circle{0,0,4,"blue"}

// "friend" function
func (c *Circle) area() float64 {
  return math.Pi * c.r*c.r
}
circle1.area

type Wheel struct {
   Circle // embedded
   material string
}
wheel1 := Wheel1{circle1, "iron"}
wheel1.area // calls wheel1.circle1.area
</pre>

  </td>  
  <td col3 >
    <span xbig>Interfaces</span><br/>
<pre>
type Shape interface {
  area() float64
}

func totalArea(shapes ...Shape) 
  float64 {
  var result float64
  for _, s := range shapes {
     result += s.area() 
  }
  return result
}
</pre>
  </td>  
</tr }>
<tr {>
  <td col1 >
    <span xbig>Goroutines and Channels</span><br/>
<pre>
// call functName in micro-thread
go functName(param1,param2,..)

/*
 * Init non-buffered channel (sync)
 * c1 "sides" will wait 
 * until the other is ready
 */
var c1 chan string \
   = make(chan string)
/*
 * Init    buffered channel (async)
 * c1 "sides" will wait until the other
 * is ready
 */

var c2 chan string \
   = make(chan string, 1/*capacity*/)


c1 <- "a"    // Write to channel
msg := <- c1 // Read from chnanel

// func1 can read/write to channel
func func1(c chan string) ...

// func2 can write to channel
func func2(c chan<- string) ...

// func3 can read from channel
func func3(c <-chan string) ...
</pre>
  </td>  
  <td col2 >
    <span xbig>Select</span><br/>
    <code>select</code> picks the first channel ready and
    receives from it (or sends to it)
<pre>
select {
  case msg1 := <- c1:
    fmt.Println(msg1)
  case msg2 := <- c2:
    fmt.Println(msg2)
  case <- time.After(time.Second):
    fmt.Println("timeout")
  default:
    fmt.Println("nothing ready")
}
</pre>
  </td>  
  <td col3 >
    <span xbig>strings package</span><br/>
<pre>
strings.Contains("test", "es")  // true
strings.Count("test", "t")      // 2
strings.HasPrefix("test", "te") // true
strings.HasSuffix("test", "st") // true
strings.Index("test", "e")    // 1
strings.Join([]string{"a","b"}, "-")  // "a-b"
strings.Repeat("a", 3)        // == "aaa"
strings.Replace("aa","a","b",1)  // "ba"
strings.Split("a-b-c", "-")   // []string
                              // {"a","b","c"}
strings.ToLower("TEST")       // "test"
strings.ToUpper("test")       // "TEST"

arr := []byte("test")
str := string([]byte{'t','e','s','t'}
</pre>
  </td>  
</tr }>

<tr {>
  <td col1 >
    <span xbig>Input/Output</span><br/>
<!--
@ma https://www.golang-book.com/public/pdf/gobook.0.pdf pag 138
--> 
    Many fuctions in Go take Readers and Writers as arguments
    (io:Copy, ...)
<pre>
func Copy(dst Writer, src Reader) 
    (written int64, err error)
</pre>
    <span xbig>Buffers</span><br/>
<pre>
// No need to init (make)
var buf bytes.Buffer
buf.Write([]byte("test"))

// Convert string to Reader
strings.NewReader
</pre>
  </td>  
  <td col2 >
    <span xbig>List</span><br/>
<pre>
import ("container/list")
var x list.List
x.PushBack(1)
x.PushBack(2)
...
</pre>
    <span xbig>List</span><br/>
<pre>
import ("sort")
type ByOrder1 []MyType
func (this ByOrder1) Len() int {
  return len(this)
}
func (this ByOrder1) Less(i, j int) bool {
  return this[i].Name < this[j].Name
}
func (this ByOrder1) Swap(i, j int) {
  this[i], this[j] = this[j], this[i]
}
...
sort.Sort(ByName(kids))
</pre>
  </td>  
  <td col3 >
    <span xbig>Parsing cmd line args</span><br/>
<pre>
package main
import ("fmt";"flag";"math/rand")
func main() {
  // Define flags
  maxp := flag.Int("max", 6, "the max value")
  flag.Parse() // Parse
  // Generate number between 0 and max
  fmt.Println(rand.Intn(*maxp))
}
</pre>
  </td>  
</tr }>

<tr {>
  <td col1 >
  </td>  
  <td col2 >
  </td>  
  <td col3 >
  </td>  
</tr }>

</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 


strings
collections
arrays
error handling
goroutines
slices
maps
channels
numbers
dates
times
files
networking
runtime
web apps

Effective Go:
https://golang.org/doc/effective_go.html


https://golang.org/doc/

https://golang.org/doc/editors.html

Diagnostics:
https://golang.org/doc/diagnostics.html

________________
A Brief tour of Practical Crypto in GoLang: https://cyberspy.io/articles/crypto101/
    AES encryption (also known as FIPS 197)
    Block Ciphers
    DES and TDEA (also known as FIPS 46-3)
    Digital Signature Algorithms (DSA FIPS 186-3)
    Hashed Message Authentication Code (HMAC FIPS-198)
    Hashing: MD5 Hashing Algorithm (RFC 1321), SHA1 (RFC 3174), SHA256/SHA512 (FIPS 180-4)
    RSA: RSA PKCS#1 encryption implementation
    X509/TLS Certificate and Key based comms and general certificates/key manipulation

-->

</html>
