<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Go Lang. Summary(beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<span small>
<a href="https://golang.org/doc/">Doc</a>,
<a href="https://golang.org/ref/spec">Spec</a>,
<a href="https://golang.org/doc/effective_go.html">Effective Go</a>,
<a href="https://golang.org/pkg/">StdLib</a>,
<a href="https://golang.org/doc/cmd">cli</a>,
<a href="https://golang.org/doc/diagnostics.html">Diagnos.</a>
</span small>
<table style='width:100%'{>
<tbody>
<tr {>
<td>
  <a href="https://golang.org/doc/install">Workspace/packages/GOPATH</a>
<pre xxxsmall zoom>
                  |  SCM     |        
|workspace|1 ←→ N |repository| 1 ←→ N |package| 
   ^                                      ^   
 $GOPATH                               path to package
 |bin/                                 determines its 
 |  hello                              import path
 |  outyet                           
 |src/                               
 |  github.com/golang/example/   ←  repository 1
 |      .git/  
 |      hello/hello.go           ← package 1.
 |                               import github.com/golang/example/hello/...
 |      outyet/                  ← package 2
 |          main.go
 |          main_test.go
 |  golang.org/x/image/          ← repository 2
 |      .git/
 |  github.com/"myUser"/...
           
<p>GOPATH</p>: (default: $HOME/go) working workspace location 
$ go env GOPATH # prints the effective current GOPATH
# setup Environement
$ export GOPATH=$(go env GOPATH)  # can fix some problems
$ export PATH=$PATH:${GOPATH}/bin
</pre>
<hr/>
  Hello World run&amp;build
<pre xxxsmall zoom>
(${GOPATH}/src/github.com/"myUser"/hello/hello.go)
| package main 
| // ^ must be always the first statement
| //   Go's convention is that package name is the last element of 
| //   the import path:
| //   package importaed as "crypto/rot13" should be named rot13
| import (
|   "fmt"
|   "time"
|   "math/rand"
|   m "golang-book/chapter11/math"
| )
| func f(n int) {
|   for i := 0; i < 10; i++ {
|     fmt.Println(n, ":", i)
|     amt := time.Duration(rand.Intn(250))
|     time.Sleep(time.Millisecond * amt)
|   }
|   ... m.Average(...)
| }
| 
| func main() {
|     const (
|        HELLO = "Hello"
|        WORLD = "World"
|     )
|     
|     var x string = HELLO + " " + WORLD +"\n"
|  //     x       := HELLO + " " + WORLD +"\n"  // alt 2. (Type inference)
|     fmt.Printf(x) // alt 1
|     fmt.Println("1 + 1 = ", 1.0 + 1.0) // alt 2
|     <b>go</b> f(1) // go-routine
|     var inputFromSTDIN float64 
|     fmt.Scanf ("%f", &amp;inputFromSTDIN) // formated input
|     fmt.Printf("%f", inputFromSTDIN)      // formated output
| }

$ go <b>run  </b> hello.go                # alt 1.
→ ...
$ go <b>build</b>  &amp;&amp; ./hello     # alt 2.


# INSTALL:
# "go get" will also install downloading first any missing packages
$ go install github.com/"myUser"/hello
Exec like:
$ $GOPATH/bin/hello
→ ...
</pre>

  Testing
  <a xsmall href="https://golang.org/cmd/go/#hdr-Test_packages"><code>go test help</code></a>,
  <a xsmall href="https://golang.org/pkg/testing/">test package</a>
<pre xxxsmall zoom>
(vim $GOPATH/src/github.com/user/stringutil/reverse_test.go)
| package stringutil
| 
| import "testing"
| 
| func TestReverse(t *testing.T) {
|   cases := []struct {
|     in, want string
|   }{
|     {"Hello, world", "dlrow ,olleH"},
|   }
|   for _, c := range cases {
|     got := Reverse(c.in)
|     if got != c.want {
|       t.Errorf(
|         "Reverse(%q) == %q, want %q",
|         c.in, got, c.want)
|     }
|   }
| }
  
<b>Running tests:</b>
$ go test github.com/user/stringutil
→ ok github.com/user/stringutil 0.165s
</pre>

  <a href="https://golang.org/pkg/builtin/">Builtin library</a>,
<a href="https://golang.org/ref/spec#Built-in_functions">Spec</a>
<pre xxxsmall bgorange zoom>
functions:
  append(slice []Type, elems ...Type) []Type
    - appends elements to the end of a slice.
      WARN: returns the updated slice.  It is therefore necessary 
            to store the result of append, often in the variable
            holding the slice itself.
       
      <b>sliceRefInFunc</b> = append(<b>sliceRefInFunc</b>, elem1, elem2)
      <b>sliceRefInFunc</b> = append(<b>sliceRefInFunc</b>, anotherSlice...)

      It is legal to append a string to a byte slice, like this:
      slice = append([]byte("hello "), "world"...)

  cap(v Type) int
   - returns the capacity of v, according to its type

  close(c chan<- Type)
   - closes a channel, which must be either bidirectional or send-only.
   WARN: It should be executed only by the sender, never the receiver, 
        and has the effect of shutting down the channel after the last sent
        value is received. 
   WARN: After the last value has been received from a closed channel c,
        any receive from c will succeed without blocking, returning the
        zero value for the channel element. 
   WARN: "x, ok := <-c" will also set ok to false for a closed channel.

  copy(dst, src []Type) int
   - copies elements from a source slice into a destination slice.
   -returns number of elements copied, which will be the minimum of len(src) and len(dst).
   WARN: source and destination may overlap.

  delete(m map[Type]Type1, key Type)
   - deletes the element with the specified key (m[key]) from the map.
   If m is nil or there is no such element, delete is a no-op.
          
  len(v Type) int
   - returns the length of v, according to its type:

  make(t Type, size ...IntegerType) Type
   - allocates and initializes an object of type slice, map, or chan (only).
   - Like new, the first argument is a type, not a value.
   - (Unlike "new") return type is the same as the type of its argument, not pointer 

  new(Type) *Type
   - allocates memory. 
   - returns pointer to a newly allocated zero value of that type

  panic(v interface{})
   - stops normal execution of the current goroutine
   - termination sequence can be controlled by the built-in function recover.

  recover() interface{}
   - allows a program to manage behavior of a panicking goroutine.
     Executing a call to recover inside a deferred function (but not any function called by it)
     stops the panicking sequence by restoring normal execution and retrieves the error
     value passed to the call of panic.
   - If recover is called outside the deferred function it will not stop a panicking sequence.

   ...

types
   ComplexType FloatType IntegerType Type Type1 bool byte complex128 complex64 error float32
   float64 int int16 int32 int64 int8 rune string uint uint16 uint32 uint64 uint8 uintptr
</pre>


  <hr/>
  Building a library<br/>
<pre xxxsmall zoom>
(edit $GOPATH/src/github.com/"myUser"/stringutil/reverse.go)
| // utility functs for strings
| package stringutil
| 
| func Reverse(s string) string {
|     r := []rune(s)
|     for i, j := 0, <b blue>len</b>(r)-1;
|         i &lt; <b blue>len</b>(r)/2;
|         i, j = i+1, j-1 {
|         r[i], r[j] = r[j], r[i]
|     }
|     return string(r)
| }

<b>BUILD:</b>
$ go build github.com/"myUser"/stringutil

<b>INSTALL:</b>
$ go install github.com/"myUser"/stringutil

<b>IMPORT AND USE INTO CODE:</b>
(..../hello.go)

| package main
| import ("fmt"
|         "github.com/myUser/stringutil"
| )
| ...
|    fmt.Printf(stringutil.Reverse("!oG, olleH"))
</pre>
</td>  
  
<td>
  Types<br/>
<pre xxxsmall zoom>
(u)int8/16/32/64
float32/64
complex64/128
NaN
positive/negative inifinity
Strings:
   "asdf" + `asdf`/* newline allowed */
   <b blue>len</b>("asdf")
   "asdf"[0] // a
Booleans: true / false (&amp;&amp; , || ,  !)

float64(<b blue>len</b>(x)) // Type conversion

val1 := 1
xPtr *int = &amp;val1 // Pointer
ptr1 := new(int)      // Pointer
</pre>

  Structs and Embedded Type<br/>
<pre xxxsmall zoom>
<b orange>type</b> Circle <b orange>struct</b> {
  x, y, r float64
  color   string 
}
circle1 := Circle{0,0,4,"blue"}

// <b orange>"friend"</b> function
func <b orange>(c *Circle)</b> area() float64 {
  return math.Pi * c.r*c.r
}
circle1.area
</pre>

  Type composition:
<pre xxxsmall zoom>
type Wheel struct {
   <b orange>Circle</b> // embedded (composed) type
   material string
}
wheel1 := Wheel1{circle1, "iron"}
wheel1<b orange>.area</b> // calls wheel1<b orange>.circle1.area</b>
</pre>


  For loops<br/>
<pre xxxsmall zoom>
i := 1
for i<=10 { ...
  i = i + 1
}
</pre>
  if-else , switch<br/>
<pre xxxsmall zoom>
if i % 2 == 0 {       | switch i {
    // divisible by 2 |   case  0: ...
} else if i % 3 == 0 {|   case  1: ...
    // divisible by 3 |   default: ...
} else  {             | }
    // ...
} 
</pre>
</td>
<td>
  arrays<br/>
<pre xxxsmall zoom>
var x [5]int // 0-initialized
x[4] = 100 // [ 0 0 0 0 100]
<b blue>len</b>(x)
x := [3]float64 { 1.0, 2.0, 3.0}
</pre>
  slices (segments of arrays)<br/>
<pre xxxsmall zoom>
slice1 := <b orange>make</b>(<b orange>[]</b>float64, 5 ,  10)
//                        ^    ^
//                       len capacity 
                          
array1 :=[]int{1,2,3,4,5}
slice2 :=array1[0:5]
slice3 :=append(mySlice2,4)
copy(slice3,slice2) 
     ^copy of slice2 up to len   
</pre>
  Walk over array
<pre xxxsmall zoom>
for idx, element := <b orange>range</b> array1 {
  // do something
}
</pre>
  <a href="https://golang.org/ref/spec#Map_types">Maps</a>
<pre xxxsmall zoom>
map1 := <b orange>make</b>(<b orange>map</b>[string]int)
map1["key"] = 10
delete(map1, "key")
map1["no_key"] // = "zero type value"
if value1, ok := map1["no_key"]; ok {
   ...
}
map2 := map[string]map[string]string{
  "H": map[string]string{
    "name":"Hydrogen", 
    "state":"gas",
  },
  ...
}

</pre>
  Walk over a map
<pre xxxsmall zoom>
// Iterate over map key/value pairs
for key, value := <b orange>range</b> map1 {
    fmt.Println("Key:", key, "Value:", value)
}
</pre>


  List<br/>
<pre xxxsmall zoom>
import ("container/list")
var x list.List
x.PushBack(1)
x.PushBack(2)
...

---------------

import ("sort")
type ByOrder1 []MyType
func (this ByOrder1) Len() int {
  return <b blue>len</b>(this)
}
func (this ByOrder1) Less(i, j int) bool {
  return this[i].Name < this[j].Name
}
func (this ByOrder1) Swap(i, j int) {
  this[i], this[j] = this[j], this[i]
}
...
sort.Sort(ByName(kids))
</pre>
  Walk over a list
<pre xxxsmall zoom>
//  To iterate over a list (where l is a *List):
for e := l.Front(); e != nil; e = e.Next() {
    // do something with e.Value
}
</pre>
</td>
<td>
  <a href="https://golang.org/ref/spec#Errors">Contemplated Error Handling</a>
<pre xxxsmall zoom>
The predeclared type error is defined as

  type error interface {
      Error() string
  }

It is the conventional interface for representing an error condition,
with the nil value representing no error.

For instance, a function to read data from a file might be defined:

  func Read(f *File, b []byte) (n int, err error)

Ex.1:

  f, err := os.Open("/test.txt")
  if err != nil {
     // Fix contemplated error
     // (otherwise panic...)
  }
</pre>

  <a href="https://blog.golang.org/defer-panic-and-recover">Non contemplated errors</a>paniq/recover("try"/"catch")
<pre xxxsmall zoom>
func goRutine1() (i int) {
  f, _ := os.Open(filename)
  <b blue>defer</b> f.Close()   //pushes function call onto a list *1
  <b blue>defer</b> func() {
     fmt.Println(<b orange>recover</b>())
  }
  <b blue>defer</b> func() {
      if r := <b orange>recover</b>(); r != nil {
          fmt.Println("Recovered in f", r)
      }
  }()
  ...
  if "nonContemplatedError" { panic("RuntimeException") }
  i = 0;
  <b blue>defer</b> func() { fmt.Prinlnt(i); }() // Will print 0: i evaluated at this line
  <b blue>defer</b> func() { i++ }() // goRutine1 caller will receive 2
  i++ 
  return i;
}

*1: The list of saved calls is executed 
    <b>after</b> the surrounding function returns
    <b>Deferred functions execute even when panicking.</b>

Ex: deferred func increments return value i on return: 
    This is convenient for modifying the error return value 

"<b orange>recover</b>" can regain control and stop paniq propagation.
It's only useful inside deferred functions. 
Here's an example program that demonstrates the mechanics of panic and <b blue>defer</b>:
</pre>
<br/>
<b xsmall blue>THE CONVENTION IN THE GO LIBRARIES IS THAT EVEN WHEN A PACKAGE
  USES PANIC INTERNALLY, ITS EXTERNAL API STILL PRESENTS EXPLICIT ERROR
  RETURN VALUES.</b>

</td>
</tr>
</table>
<table>
<tr {>
<td>
  Functions and Closures<br/>
<pre xxxsmall zoom>
func                       |func 
  funcName(                |  makeEvenGenerator() 
    param1 []int,          |   func() uint {
    param2 string          | //^returns function that
    ...int                 | // returns uint
  )                        |  i := uint(0)
  (int,int) /*return type*/|  return func() (ret uint) 
  {                        |  {      ^closure
    ...                    |    ret = i
    if !ok {               |    i += 2
      panic("RuntimeError")|    return
    }                      |  }
    return 1,2             |}
}
</pre>

</td>  
 
<td>
  <a href="https://golang.org/ref/spec#Interface_types">Interfaces</a>
<pre xxxsmall zoom>
type Shape interface {
  area() float64
}

func totalArea(shapes ...Shape) 
  float64 {
  var result float64
  for _, s := range shapes {
     result += s.area() 
  }
  return result
}
</pre>
</td>  
<td>
  Goroutines and Channels<br/>
<pre xxxsmall zoom>
// call functName in micro-thread
go functName(param1,param2,..)

/*
 * Init non-buffered channel (sync)
 * c1 "sides" will wait 
 * until the other is ready
 */
var c1 chan string \
   = <b orange>make</b>(<b orange>chan</b> string)
/*
 * Init    buffered channel (async)
 * c1 "sides" will wait until the other
 * is ready
 */

var c2 chan string \
   = <b orange>make</b>(<b orange>chan</b> string, 1/*capacity*/)

c1 <- "a"    // Write to channel
msg := <- c1 // Read from chnanel

// func1 can read/write to channel
func func1(c chan string) ...

// func2 can write to channel
func func2(c chan<- string) ...

// func3 can read from channel
func func3(c <-chan string) ...
</pre>
 Select<br/>
<pre xxxsmall zoom>
pick the first channel ready and receives from it (or sends to it)
select {
  case msg1 := <- c1:
    fmt.Println(msg1)
  case msg2 := <- c2:
    fmt.Println(msg2)
  case <- time.After(time.Second):
    fmt.Println("timeout")
  default:
    fmt.Println("nothing ready")
}
</pre>
</td>  
<td>
  strings package<br/>
<pre xxxsmall zoom>
strings.Contains("test", "es")  // true
strings.Count("test", "t")      // 2
strings.HasPrefix("test", "te") // true
strings.HasSuffix("test", "st") // true
strings.Index("test", "e")    // 1
strings.Join([]string{"a","b"}, "-")  // "a-b"
strings.Repeat("a", 3)        // == "aaa"
strings.Replace("aa","a","b",1)  // "ba"
strings.Split("a-b-c", "-")   // []string
                              // {"a","b","c"}
strings.ToLower("TEST")       // "test"
strings.ToUpper("test")       // "TEST"

arr := []byte("test")
str := string([]byte{'t','e','s','t'}
</pre>
</td>  
</tr>
</table>

<table>
<tr {>
<td>
  Input/Output<br/>
<!--
@ma https://www.golang-book.com/public/pdf/gobook.0.pdf pag 138
--> 
  Many fuctions in Go take Readers and Writers as arguments
  (io:Copy, ...)
<pre xxxsmall zoom>
func Copy(dst Writer, src Reader) 
    (written int64, err error)
</pre>
  Buffers<br/>
<pre xxxsmall zoom>
// No need to init (make)
var buf bytes.Buffer
buf.Write([]byte("test"))

// Convert string to Reader
strings.NewReader
</pre>
</td>  
  
<td>
  Parsing cmd line args<br/>
<pre xxxsmall zoom>
package main
import ("fmt";"flag";"math/rand")
func main() {
  // Define flags
  maxp := flag.Int("max", 6, "the max value")
  flag.Parse() // Parse
  // Generate number between 0 and max
  fmt.Println(rand.Intn(*maxp))
}
</pre>
</td>  
<td>  
  <a href="https://golang.org/pkg/time/">time</a>
<pre xxxsmall zoom>
start   := time<b orange>.Now()</b>
// time diff
elapsed := time.Now()<b orange>.Sub</b>(start)

<a href="https://golang.org/pkg/time/#After">func After(d Duration) &lt;-chan Time</a>
<a href="https://golang.org/pkg/time/#Sleep">func Sleep(d Duration)</a>
<a href="https://golang.org/pkg/time/#Tick">func Tick(d Duration) &lt;-chan Time</a>
<a href="https://golang.org/pkg/time/#Duration">type Duration</a>
    <a href="https://golang.org/pkg/time/#ParseDuration">func ParseDuration(s string) (Duration, error)</a>
    <a href="https://golang.org/pkg/time/#Since">func Since(t Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Until">func Until(t Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Duration.Hours">func (d Duration) Hours() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.Minutes">func (d Duration) Minutes() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.Nanoseconds">func (d Duration) Nanoseconds() int64</a>
    <a href="https://golang.org/pkg/time/#Duration.Round">func (d Duration) Round(m Duration) Duration</a>
    <a href="https://golang.org/pkg/time/#Duration.Seconds">func (d Duration) Seconds() float64</a>
    <a href="https://golang.org/pkg/time/#Duration.String">func (d Duration) String() string</a>
    <a href="https://golang.org/pkg/time/#Duration.Truncate">func (d Duration) Truncate(m Duration) Duration</a>
<a href="https://golang.org/pkg/time/#Location">type Location</a>
    <a href="https://golang.org/pkg/time/#FixedZone">func FixedZone(name string, offset int) *Location</a>
    <a href="https://golang.org/pkg/time/#LoadLocation">func LoadLocation(name string) (*Location, error)</a>
    <a href="https://golang.org/pkg/time/#LoadLocationFromTZData">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</a>
    <a href="https://golang.org/pkg/time/#Location.String">func (l *Location) String() string</a>
<a href="https://golang.org/pkg/time/#Month">type Month</a>
    <a href="https://golang.org/pkg/time/#Month.String">func (m Month) String() string</a>
<a href="https://golang.org/pkg/time/#ParseError">type ParseError</a>
    <a href="https://golang.org/pkg/time/#ParseError.Error">func (e *ParseError) Error() string</a>
<a href="https://golang.org/pkg/time/#Ticker">type Ticker</a>
    <a href="https://golang.org/pkg/time/#NewTicker">func NewTicker(d Duration) *Ticker</a>
    <a href="https://golang.org/pkg/time/#Ticker.Stop">func (t *Ticker) Stop()</a>
<a href="https://golang.org/pkg/time/#Time">type Time</a>
    <a href="https://golang.org/pkg/time/#Date">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a>
    <a href="https://golang.org/pkg/time/#Now">func Now() Time</a>
    <a href="https://golang.org/pkg/time/#Parse">func Parse(layout, value string) (Time, error)</a>
    <a href="https://golang.org/pkg/time/#ParseInLocation">func ParseInLocation(layout, value string, loc *Location) (Time, error)</a>
    <a href="https://golang.org/pkg/time/#Unix">func Unix(sec int64, nsec int64) Time</a>
    <a href="https://golang.org/pkg/time/#Time.Add">func (t Time) Add(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.AddDate">func (t Time) AddDate(years int, months int, days int) Time</a>
    <a href="https://golang.org/pkg/time/#Time.After">func (t Time) After(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.AppendFormat">func (t Time) AppendFormat(b []byte, layout string) []byte</a>
    <a href="https://golang.org/pkg/time/#Time.Before">func (t Time) Before(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.Clock">func (t Time) Clock() (hour, min, sec int)</a>
    <a href="https://golang.org/pkg/time/#Time.Date">func (t Time) Date() (year int, month Month, day int)</a>
    <a href="https://golang.org/pkg/time/#Time.Day">func (t Time) Day() int</a>
    <a href="https://golang.org/pkg/time/#Time.Equal">func (t Time) Equal(u Time) bool</a>
    <a href="https://golang.org/pkg/time/#Time.Format">func (t Time) Format(layout string) string</a>
    <a href="https://golang.org/pkg/time/#Time.GobDecode">func (t *Time) GobDecode(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.GobEncode">func (t Time) GobEncode() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.Hour">func (t Time) Hour() int</a>
    <a href="https://golang.org/pkg/time/#Time.ISOWeek">func (t Time) ISOWeek() (year, week int)</a>
    <a href="https://golang.org/pkg/time/#Time.In">func (t Time) In(loc *Location) Time</a>
    <a href="https://golang.org/pkg/time/#Time.IsZero">func (t Time) IsZero() bool</a>
    <a href="https://golang.org/pkg/time/#Time.Local">func (t Time) Local() Time</a>
    <a href="https://golang.org/pkg/time/#Time.Location">func (t Time) Location() *Location</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalBinary">func (t Time) MarshalBinary() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalJSON">func (t Time) MarshalJSON() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.MarshalText">func (t Time) MarshalText() ([]byte, error)</a>
    <a href="https://golang.org/pkg/time/#Time.Minute">func (t Time) Minute() int</a>
    <a href="https://golang.org/pkg/time/#Time.Month">func (t Time) Month() Month</a>
    <a href="https://golang.org/pkg/time/#Time.Nanosecond">func (t Time) Nanosecond() int</a>
    <a href="https://golang.org/pkg/time/#Time.Round">func (t Time) Round(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.Second">func (t Time) Second() int</a>
    <a href="https://golang.org/pkg/time/#Time.String">func (t Time) String() string</a>
    <a href="https://golang.org/pkg/time/#Time.Sub">func (t Time) Sub(u Time) Duration</a>
    <a href="https://golang.org/pkg/time/#Time.Truncate">func (t Time) Truncate(d Duration) Time</a>
    <a href="https://golang.org/pkg/time/#Time.UTC">func (t Time) UTC() Time</a>
    <a href="https://golang.org/pkg/time/#Time.Unix">func (t Time) Unix() int64</a>
    <a href="https://golang.org/pkg/time/#Time.UnixNano">func (t Time) UnixNano() int64</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalBinary">func (t *Time) UnmarshalBinary(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON">func (t *Time) UnmarshalJSON(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.UnmarshalText">func (t *Time) UnmarshalText(data []byte) error</a>
    <a href="https://golang.org/pkg/time/#Time.Weekday">func (t Time) Weekday() Weekday</a>
    <a href="https://golang.org/pkg/time/#Time.Year">func (t Time) Year() int</a>
    <a href="https://golang.org/pkg/time/#Time.YearDay">func (t Time) YearDay() int</a>
    <a href="https://golang.org/pkg/time/#Time.Zone">func (t Time) Zone() (name string, offset int)</a>
<a href="https://golang.org/pkg/time/#Timer">type Timer</a>
    <a href="https://golang.org/pkg/time/#AfterFunc">func AfterFunc(d Duration, f func()) *Timer</a>
    <a href="https://golang.org/pkg/time/#NewTimer">func NewTimer(d Duration) *Timer</a>
    <a href="https://golang.org/pkg/time/#Timer.Reset">func (t *Timer) Reset(d Duration) bool</a>
    <a href="https://golang.org/pkg/time/#Timer.Stop">func (t *Timer) Stop() bool</a>
<a href="https://golang.org/pkg/time/#Weekday">type Weekday</a>
    <a href="https://golang.org/pkg/time/#Weekday.String">func (d Weekday) String() string</a>

</pre>
</td>  
</tr>
</table>

</body>
<!--
error handling
files
networking
runtime
________________
A Brief tour of Practical Crypto in GoLang: https://cyberspy.io/articles/crypto101/
    AES encryption (also known as FIPS 197)
    Block Ciphers
    DES and TDEA (also known as FIPS 46-3)
    Digital Signature Algorithms (DSA FIPS 186-3)
    Hashed Message Authentication Code (HMAC FIPS-198)
    Hashing: MD5 Hashing Algorithm (RFC 1321), SHA1 (RFC 3174), SHA256/SHA512 (FIPS 180-4)
    RSA: RSA PKCS#1 encryption implementation
    X509/TLS Certificate and Key based comms and general certificates/key manipulation
___________________________________
https://blog.gopheracademy.com/ "The Best Go Content on the Internet"

  https://blog.gopheracademy.com/advent-2017/messaging-framework/
________________________
https://blog.gopheracademy.com/advent-2015/vendor-folder/
____________________________
Go 1.11 Add WebAssembly, Experimental Module Support,...
https://www.infoq.com/news/2018/08/golang-1.11-modules-we
https://golang.org/doc/go1.11
"""You can compile a Go program for the Web running:
$ GOARCH=wasm GOOS=js go build -o test.wasm main.go
this will produce three files:
   - wasm_exec.html
   - wasm_exec.js
   - test.wasm
that you can deploy to your HTTP server or load directly into a browser.
The js package can be used for DOM manipulation.
______________________
   "if val, ok := map["key"]; ok { .... }" construct must be used to
   check for key existence
____________________________
https://github.com/spf13/cobra
Cobra (kubernetes, etcd, ...) is a library providing a simple interface to create powerful modern CLI interfaces similar to git & go tools.

Cobra is also an application that will generate your application scaffolding to rapidly develop a Cobra-based application.

Cobra provides:

    Easy subcommand-based CLIs: app server, app fetch, etc.
    Fully POSIX-compliant flags (including short & long versions)
    Nested subcommands
    Global, local and cascading flags
    Easy generation of applications & commands with cobra init appname & cobra add cmdname
    Intelligent suggestions (app srver... did you mean app server?)
    Automatic help generation for commands and flags
    Automatic help flag recognition of -h, --help, etc.
    Automatically generated bash autocomplete for your application
    Automatically generated man pages for your application
    Command aliases so you can change things without breaking them
    The flexibility to define your own help, usage, etc.
    Optional tight integration with viper for 12-factor apps
_________________________
Check Golang Builders and Visitors decorators pattern
_________________________
visitor construct: used to iterate across all the resources.

-->

</html>
