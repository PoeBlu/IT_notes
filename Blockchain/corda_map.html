<html>
<head>
   <meta charset="UTF-8">
   <title>Corda Map</title>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[ xxsmall], #zoomDiv > * > *[ xxsmall], #zoomDiv > * > * > *[ xxsmall]{ font-size:1rem; }
#zoomDiv > *[  xsmall], #zoomDiv > * > *[  xsmall], #zoomDiv > * > * > *[  xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:20%; max-width:30%; }
td[col1]  {background-color:#FFFFFF; min-width:20%; max-width:30%; }
td[col2]  {background-color:#FAFAFA; min-width:20%; max-width:30%; }
td[col3]  {background-color:#FFFFFF; min-width:20%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "<span xsmall>('Esc' to close)</span><br/>" + this.innerHTML; }

function onPageLoaded() {
   /* Notes:
    * The name (and number) of columns 'topic', 'summa', 'col1', 'col2' is arbitrary.
    * Change at will. For example for development projects there could be a column for each 
    * software life-cycle similar to:  
    * topic -> summary -> documentation -> development -> testing/CI -> deployment -> QA
    * WARN: Don't forget to change the css too.
   */

  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  Ex.1:
     <pre xxsmall>
     ...
     </pre>
  </td>
  <td >
     <table subtable1>
     <tr subtable1>
       <td subtable1></td>
       <td subtable1></td>
       <td subtable1></td>
     </tr>
     </table>
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <th topic >topic</th>
  <th summa >summary</th>
  <th col1  ></th>
  <th col2  ></th>
  <th col3  ></th>
</tr>
<!-- ************************************** -->
<tr {>
  <td topic >Corda M14.0</td>
  <td summa >
     <ul>
       <li><a href='https://github.com/corda/corda/tree/master/core/src/main/kotlin/net/corda/core'>Corda Core@Github</a></li>
       <li><a href='https://docs.corda.net/key-concepts.html'>REF: Key Concepts</a></li>
       <li>
           <a href='https://github.com/corda/cordapp-tutorial' >Corda Tutorial (<a href='https://corda.net'>https://corda.net</a>)</a><br/>

           <a href='https://docs.corda.net/running-the-demos.html#irs-demo' >Asset Trading(irs-demo)</a><br/>
           <a href='https://docs.corda.net/running-the-demos.html#simm-demo'>SIMM and Portfolio Demo(aka the Initial Margin Agreement Demo)</a><br/>
       </li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href='https://docs.corda.net/api-core-types.html'>API Core Types</a>
         <pre>
- SecureHash.SHA256 and utility methods to create/parse/... them
- mathematical utilities (interpolators and classes for working with splines)
- NamedByHash and UniqueIdentifier( == 128 bit Java UUID random number + arbitrary string)
- (Anonymous)Party classes represent participating network entities containing (set of) keys
- AuthenticatedObject: represents an object (like a command) and the list of associated signers
- CompositeKey: tree data structure to provide Multi-signature support
- Date support: interfaces and classes for use by contracts which deal with dates 
     (especially in the context of deadlines).  and terms such as "overnight", "T+3", etc.
  Tenor models the interval before a deadline, such as 3 days, etc.
  DateRollConvention describes how deadlines are modified to take into account bank holidays
  ...modifying normal working days
  -  BusinessCalendar class models these calendars of business holidays 
         </pre>
       </li>
     </ul>
  </td>
  <td col2  >
  </td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >CORDAPP LAYOUT</td>
  <td summa >
     <ul>
 
       <li>CorDapps are installed at the level of the individual node, rather than on the network itself.</li>
       <li>Each CorDapp allows a node to handle new business processes by defining new
           flows on the node (started by the node owner) conduct the process of negotiating
           a specific ledger update with other nodes on the network
       </li>
       <li>CorDapp developers will usually define:
         <pre>
         - States     

         - Contracts  implementing <a href='https://docs.corda.net/api-contracts.html'>&lt;&lt;Contract>></a>
         - Flows      implementing <a href='https://docs.corda.net/api-flows.html'>&lt;&lt;FlowLogic>></a>
         - Web APIs
         - Services
         </pre>
       </li>
       <li>Your CorDapp may need to define two types of plugins:
         <pre>
         - CordaPluginRegistry subclasses that can overwrite:
             - customizeSerialization: set of the classes       to be whitelisted for object serialisation
             - requiredSchemas       : set of the MappedSchemas to use for persistence and vault queries
           - must be added also to resources/META-INF/services/net.corda.core.node.CordaPluginRegistry
         - WebServerPluginRegistry subclasses, that can overwrite:
         - webApis        : list of JAX-RS annotated REST access classes.
         - staticServeDirs: map of static web content to virtual paths 
           (The static web content itself should be placed inside src/main/resources)
           must be added also to resources/META-INF/services/net.corda.webserver.services.WebServerPluginRegistry
         </pre>
       </li>
     </ul>
  </td>
  <td col1  >
    - <a href="https://github.com/corda/cordapp-template-java"  >JAVA   TEMPLATE</a> <br/>
    - <a href="https://github.com/corda/cordapp-template-kotlin">KOTLIN TEMPLATE</a>
  </td>
  
  <td col2  >Code layout:
  <pre xxsmall>
     src
     ├── main
     │   ├── java
     │   │   └── com
     │   │       └── template
     │   │           ├── Main.java
     │   │           ├── api
     │   │           │   └── TemplateApi.java
     │   │           ├── client
     │   │           │   └── TemplateClientRPC.java
     │   │           ├── contract
     │   │           │   └── TemplateContract.java
     │   │           ├── flow
     │   │           │   └── TemplateFlow.java
     │   │           ├── plugin
     │   │           │   └── TemplatePlugin.java
     │   │           ├── service
     │   │           │   └── TemplateService.java
     │   │           └── state
     │   │               └── TemplateState.java
     │   └── resources
     │       ├── META-INF
     │       │   └── services
     │       │       ├── net.corda.core.node.CordaPluginRegistry
     │       │       └── net.corda.webserver.services.WebServerPluginRegistry
     │       ├── certificates
     │       │   ├── sslkeystore.jks
     │       │   └── truststore.jks
     │       └──templateWeb
     │           ├── index.html
     │           └── js
     │               └── template-js.js
     └── test
         └── java
             └── com
                 └── template
                     └── contract
                         └── TemplateTests.java
  </pre>
  </td>
  <td col3  ></td>
</tr }>

<!-- ************************************** -->


<tr {>
  <td topic >THE NETWORK</td>
  <td summa >
     <ul>
       <li>A Corda network is made up of nodes running (JVM) Corda Services (Notary+,Oracle*, ...) and CorDapps</li>
       <li>The network is permissioned, with access controlled by a doorman: Enforces rules regarding the infor. that nodes must provide and the KYC processes that they must complete before being admitted to the network.</li>
       <li>Communication between nodes is point-to-point, instead of relying on global broadcasts with TLS-encrypted messages sent over AMQP/1.0.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>



<!-- ************************************** -->

<tr {>
  <td topic >THE LEDGER</td>
  <td summa >
     <ul>
       <li>The ledger is subjective from each peer's perspective. Each peer only sees a subset of facts on the ledger</li>
       <li>Two peers are always guaranteed to see the exact same version of any on-ledger facts they share</li>
     </ul>
  </td>

  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>


<!-- ************************************** -->
<tr {>
  <td topic >CONTRACT STATES</td>
  <td summa >
    <ul>
      <li>Can contain arbitrary data, allowing them to represent facts of any kind (stocks, bonds, loans, KYC data, identity information...).</li>
       <li>Represent on-ledger facts</li>
       <li>Evolve by marking the current state as historic and creating an updated state</li>
       <li>Each node has a vault where it stores any relevant states to itself</li>
       <li>Each node on the network maintains a vault: a database where it tracks all the current and historic states that it is aware of, and which it considers to be relevant to itself</li>
     </ul>
  </td>
  <td col1  >Implement <a href='https://docs.corda.net/api-states.html'>&lt;&lt;ContractState>></a> or (optimal) sub-interfaces:<br/>
    <a href='https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/Structures.kt'>contracts/Structures.kt</a>

    <pre xsmall  >
@CordaSerializable
interface ContractState {
    val contract: Contract
    val participants: List<AbstractParty>
}
          ----------------------------------------
          object with constant identity over time 
          (facts evolving over time)
          interface LinearState : ContractState {
              val linearId: UniqueIdentifier
          }
          ----------------------------------------
          fungible asset with an owner
          interface OwnableState : ContractState {
              val owner: AbstractParty
              fun withNewOwner(newOwner: AbstractParty): CommandAndState
          }
          ----------------------------------------
              &lt;&lt;FungibleAsset>> (TODO: Inherits from OwnableState?)
              represent assets that are fungible, countable and issued by a specific party
              (eg. Cash.State and CommodityContract.State in the Corda finance module)
    </pre>
    <br/>
</td>
  <td col2  >Every ContractState can implement the QueryableState interface if 
     it wishes to be inserted into the node’s local database and accessible using SQL.
    <pre xsmall  >
interface QueryableState : ContractState {
    fun supportedSchemas(): Iterable<MappedSchema>
    fun generateMappedObject(schema: MappedSchema): PersistentState
}
    </pre>
  </td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >STATE PERSISTENCE (VAULTS)</td> 
  <td summa >
     <ul>

     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href="https://docs.corda.net/api-vault-query.html">API VAULT Query</a></li>
       <li>The majority of query requirements can be satisfied by using the Vault Query API,
           which is exposed via the VaultQueryService for use directly by flows. (See also helper methods)
           <pre  xsmall>
    Vault.Page, use for returning results, object contains:
     *  1. states as a List of <StateAndRef> (page number and size defined by [PageSpecification])
     *  2. states metadata as a List of [Vault.StateMetadata] held in the Vault States table.
     *  3. total number of results available if [PageSpecification] supplied (otherwise returns -1)
     *  4. status types used in this query: UNCONSUMED, CONSUMED, ALL
     *  5. other results (aggregate functions with/without using value groups)
    
    One-time-query                             |  Stream (snapshot + Observable stream) query
    -------------------------------------------+---------------------------------------------
    fun &lt;T : ContractState> _queryBy(          |  fun &lt;T : ContractState> _trackBy(
        criteria: QueryCriteria /*filters*/,   |      criteria: QueryCriteria /* filters */,
        paging: PageSpecification,             |      paging: PageSpecification,
        sorting: Sort,                         |      sorting: Sort,
        contractType: Class&lt;out T>):           |      contractType: Class&lt;out T>): 
      Vault.Page&lt;T>                            |        DataFeed&lt;
                                               |            Vault.Page&lt;T> /*"snapshot"*/,
                                               |             Vault.Update /* Observable */>
              </pre>
       </li>
       <li>&lt;&lt;QueryCriteria>> provides mechanisms for specifying filtering,
           including (AND, OR), (LESS|GREATER)_(THAN|THAN_OR_EQUAL), (NOT_)EQUAL,
           (NOT_)LIKE, (IS_|NOT_)NULL,  (NOT_)IN,  Standard SQL-92 aggregate functs
           (SUM, AVG, MIN, MAX, COUNT)
       </li>
       <li>There are four implementations of this interface which CAN BE CHAINED TOGETHER to define advanced filters.
        <pre xsmall>
VaultQueryCriteria: filter on attributes within the Vault states table:
   - status (UNCONSUMED, CONSUMED)
   - state reference(s)
   - contract state type(s)
   - notaries
   - soft locked states
   - timestamps (RECORDED, CONSUMED)

FungibleAssetQueryCriteria: filter on    |  LinearStateQueryCriteria: filter on attributes 
attributes defined in FungibleAsset      |  defined in &lt;&lt;LinearState>> and &lt;&lt;DealState>>
contract state:                          |  contract state
   - participants(s)                     |     - participant(s)
   - owner(s)                            |     - linearId(s)
   - quantity                            |     - dealRef(s)
   - issuer party(s) and/or reference(s) |

VaultCustomQueryCriteria:  provides the means to specify one or many arbitrary expressions on attributes 
   defined by a custom contract state that implements its own schema. 
   See the Builder object in QueryCriteriaUtils for a complete specification of the DSL.
         </pre>
       </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li>custom query example:
       <pre>
val generalCriteria = VaultQueryCriteria(Vault.StateStatus.ALL)

val results = builder {
    val currencyIndex = PersistentCashState::currency.equal(USD.currencyCode)
    val quantityIndex = PersistentCashState::pennies.greaterThanOrEqual(10L)

    val customCriteria1 = VaultCustomQueryCriteria(currencyIndex)
    val customCriteria2 = VaultCustomQueryCriteria(quantityIndex)

    val criteria = generalCriteria.and(customCriteria1.and(customCriteria2))
    vaultQuerySvc.queryBy<Cash.State>(criteria)
}
       </pre>
       <li>Example 2. Query for all unconsumed states (simplest query possible):
       <pre xxsmall>
(UNCOSUMED STATE BY DEFAULT)
----------------------------------------------------------------
val sortAttribute = SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF_TXN_ID)
----------------------------------------------------------------
// recorded in time interval:
val timeIntervalFilter = TimeCondition(
        QueryCriteria.TimeInstantType.RECORDED,
        ColumnPredicate.Between(TODAY, TODAY.plus(30, ChronoUnit.DAYS)) )
----------------------------------------------------------------
VaultQueryCriteria FILTER:
  // state reference list:          | // set of contract state:              | // by notary:                             | // by recorded time  interval
  val criteria = VaultQueryCriteria | val criteria = VaultQueryCriteria      | val criteria = VaultQueryCriteria         | val criteria = VaultQueryCriteria
      (                             |    (                                   |    (                                      |     (
       stateRefs = listOf(          |     contractStateTypes = setOf(        |     notaryName = listOf(CASH_NOTARY.name) |      timeCondition = timeIntervalFilter
               stateRefs.first(),   |                Cash.State::class.java, |    )                                      |     )
               stateRefs.last()  )  |                DealState::class.java)
      )                             |    )

----------------------------------------------------------------
LinearStateQueryCriteria FILTER:
// (unconsumed states) + set of participants:
val criteria = LinearStateQueryCriteria
    (
      participants = listOf(MEGA_CORP, MINI_CORP)
    )
----------------------------------------------------------------
Reading query results:
   val results = vaultQuerySvc.queryBy<DummyLinearContract.State> (
                 criteria, 
                 Sort(setOf(
                            Sort.SortColumn(sortAttribute, Sort.Direction.ASC)
                      ) ),
                 paging = PageSpecification(DEFAULT_PAGE_NUM, 10)
               )
   val states   = result.states
   val metadata = result.statesMetadata
       </pre>
       </li>
       <li>LinearState and DealState queries using LinearStateQueryCriteria example:
       <pre>
val linearIds = issuedStates.states.map
        { it.state.data.linearId }.toList()
val       vaultCriteria = VaultQueryCriteria(status = Vault.StateStatus.ALL)
val linearStateCriteria = LinearStateQueryCriteria
    (
     status = Vault.StateStatus.ALL,  // CONSUMED & UNCOSUMED
     linearId = listOf(linearIds.first(), linearIds.last())
     dealRef = listOf("456", "789"), // by deals references:
     participants = parties,
    )
val results = vaultQuerySvc.queryBy<LinearState>(
         linearStateCriteria and vaultCriteria  )
       </pre>
       </li>
       <li>
       <pre xxsmall>
FungibleAssetQueryCriteria

val fungibleAssetCriteria = FungibleAssetQueryCriteria(
    quantity = builder { greaterThan(2500L) }, // filter by minimum quantity
    issuerPartyName = listOf(BOC),
)
// Cash.State inherits from <FungibleAsset<*>>
val results = vaultQuerySvc.queryBy<Cash.State>(fungibleAssetCriteria)
----------------------------------------------------------------------
AGGREGATE FUNCTION

  AGGREGATIONS ON CASH USING VARIOUS FUNCTIONS                              | AGGREGATIONS ON CASH GROUPED BY CURRENCY FOR VARIOUS FUNCTIONS:
  --------------------------------------------------------------------------+----------------------------------------------------------------
  val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum() }     | val sum = builder { CashSchemaV1.PersistentCashState::
  val sumCriteria = VaultCustomQueryCriteria(sum)                           |     pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val sumCriteria = VaultCustomQueryCriteria(sum)
  val count = builder { CashSchemaV1.PersistentCashState::pennies.count() } | 
  val countCriteria = VaultCustomQueryCriteria(count)                       | val max = builder { CashSchemaV1.PersistentCashState::
                                                                            |     pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val max = builder { CashSchemaV1.PersistentCashState::pennies.max() }     | val maxCriteria = VaultCustomQueryCriteria(max)
  val maxCriteria = VaultCustomQueryCriteria(max)                           | 
                                                                            | val min = builder { CashSchemaV1.PersistentCashState::
  val min = builder { CashSchemaV1.PersistentCashState::pennies.min() }     |     pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val minCriteria = VaultCustomQueryCriteria(min)                           | val minCriteria = VaultCustomQueryCriteria(min)
                                                                            | 
  val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg() }     | val avg = builder { CashSchemaV1.PersistentCashState::
  val avgCriteria = VaultCustomQueryCriteria(avg)                           |     pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val avgCriteria = VaultCustomQueryCriteria(avg)
  val results = vaultQuerySvc.queryBy<FungibleAsset<*>>(
                             sumCriteria .and(countCriteria) .and(maxCriteria) .and(minCriteria) .and(avgCriteria) )
  val (snapshot, updates)  = vaultQuerySvc.trackBy/* stream/observable queries */<FungibleAsset>(...) 
       </pre>
       </li>
     </ul>
  </td>
  <td >
  </td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >PERSISTENCE (TODO)</td> 
  <td summa >
     <ul>
       <li>Corda offers developers the option to expose all or some part of a 
           contract state to an Object Relational Mapping (ORM) tool to be persisted
           in a RDBMS. The purpose of this is to assist vault development by effectively
           indexing persisted contract states held in the vault for the purpose of running
           queries over them and to allow relational joins between Corda data and private
           data local to the organisation owning a node.
       </li>
       <li>Nodes have an internal SchemaService which decides what to persist and
           what not by selecting the MappedSchema to use.
          <pre xxxsmall>
interface SchemaService {
    data class SchemaOptions(val databaseSchema: String? = null, val tablePrefix: String? = null)    
    val schemaOptions: Map&lt;MappedSchema, SchemaOptions>
    fun selectSchemas(state: ContractState): Iterable&lt;MappedSchema>
    fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState
}

open class MappedSchema(schemaFamily: Class&lt;*>,
                        val version: Int,
                        val mappedTypes: Iterable&lt;Class&lt;*>>) {
    val name: String = schemaFamily.name
    override fun toString(): String = "${this.javaClass.simpleName}(name=$name, version=$version)"
}
          </pre>
      </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://docs.corda.net/api-persistence.html'>API</a></li>
     </ul>
  </td>  
  <td col2  > </td>
  <td >
  </td>
</tr }>
<!-- ************************************** -->

<tr {>
  <td topic >CONTRACTS</td>
  <td summa >
     <ul>
       <li>A valid transaction must be accepted by the contract of each of its input and output states</li>
       <li>Contracts are written in a JVM programming language (e.g. Java or Kotlin)</li>
       <li>Contract execution is deterministic and its acceptance of a transaction is based on the transaction's contents alone. A contract should either always accept or always reject a given transaction. Can not depend on the validation date or other contextual info.</li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href='https://docs.corda.net/api-contracts.html'>API</a></li>
       <li>All Corda contracts are JVM classes th implement the next interface:
         <pre xsmall>
<b>package net.corda.core.contracts.Contract</b>
@CordaSerializable
interface Contract {
    @Throws(IllegalArgumentException::class)
    fun verify(tx: LedgerTransaction <a href='https://docs.corda.net/api-transactions.html'>/*TX with all signatures*/</a>)   

    val legalContractReference: SecureHash
}
         </pre>
       </li>
     </ul>
</td>
  <td col2  >Example contract using requireSingleCommand() helper method to extract commands:
     <pre xxsmall>
class XContract : Contract {
   interface Commands : CommandData {
       class Issue : TypeOnlyCommandData(), Commands
       class Transfer : TypeOnlyCommandData(), Commands
   }

   override fun verify(tx: LedgerTransaction) {
       val command = tx.commands.<b>requireSingleCommand</b><Commands>()

       when (command.value) {
           is Commands.Issue -> {
               // Issuance verification logic.
           }
           is Commands.Transfer -> {
               // Transfer verification logic.
           }
       }
   }
   override val legalContractReference: SecureHash = 
       SecureHash.sha256("X contract hash")
}
     </pre>


 </td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >TRANSACTIONS</td>
  <td summa >
     <ul>
       <li>Transactions are proposals to update the ledger</li>
       <li>A transaction proposal will only be committed if: 
          <pre>
      - It doesn't contain double-spends
      - It is contractually valid
        {
         - Each state points to a contract
         - A contract takes a transaction as input, and states 
           whether the transaction is considered valid based on the contract’s rules
         - A transaction is only valid if the contract of every
           input state and every output state considers it to be valid
        }

      - It is signed by the required parties
         </pre>
       </li>
       <li>A transaction can contain any number of inputs and outputs of any type:<br/>
     - They can include many different state types (e.g. both cash and bonds)<br/>
     - They can be issuances (have zero inputs) or exits (have zero outputs)<br/>
     - They can merge or split fungible assets (e.g. combining a $2 state and a $5 state into a $7 cash state)
       </li>
       <li>There are two basic types of transactions:<br/>
     - Notary-change transactions (used to change a state’s notary - see Notaries)<br/>
     - General transactions (used for everything else)
       </li>
       <li>TX input states references are a combination of:<br/>
     - The hash of the transaction that created the input<br/>
     - The input’s index in the outputs of the previous transaction</li>
       <li>
       - Initially, a transaction is just a proposal to update the ledger.
       representing the future state of the ledger desired by the 
       transaction builder(s): <br/>
       - To become reality, the transaction must receive signatures from 
         all of the required signers.<br/>
       - Once all the required signatures are gathered, the transaction 
         becomes committed meaning:<br/>
         - TX’s inputs are marked as historic, and cannot be used anymore<br/>
         - TX’s outputs become part of the current state of the ledger</li>
       <li>TX commands: Including a command in a transaction allows us to
      indicate the transaction’s intent, affecting how we check the
      validity of the transaction.<br/>
     - Each command is also associated with a list of one or more signers.
       By taking the union of all the public keys listed in the commands, 
       we get the list of the transaction’s required signers.</li>
       <li>ATTACHMENTS: Each TX can refer to zero or more attachments by hash.
         These attachments are ZIP/JAR files containing arbitrary content.</li>
       <li>TIME-WINDOWS: specify the time window during which the transaction 
         can be committed</li>
       <li>
         There are four states the transaction can occupy:<br/>
           - TransactionBuilder, a builder for a transaction in construction<br/>
           - WireTransaction, an immutable transaction<br/>
           - SignedTransaction, an immutable transaction with 1+ associated signatures<br/>
           - LedgerTransaction, a transaction that can be checked for validity
       </li>
       <li>Building a new transaction:
         <pre xxsmall>
// Create a TransactionBuilder
val txBuilder: TransactionBuilder = TransactionBuilder(General, specificNotary)
// Creating the inputs (Refs. to previous outputs)
val ourStateAndRef: StateAndRef<DummyState> = serviceHub.toStateAndRef<DummyState>(ourStateRef)
val ourStateRef: StateRef = StateRef(SecureHash.sha256("DummyTransactionHash"), 0)
// Creating the Outputs
val ourOutput: DummyState = DummyState()
val ourOtherOutput: DummyState = ourOutput.copy(magicNumber = 77)

// Creating the command
val ourPubKey: PublicKey = serviceHub.legalIdentityKey
val counterpartyPubKey: PublicKey = counterparty.owningKey
val commandData: DummyContract.Commands.Create = DummyContract.Commands.Create()
val requiredSigners: List<PublicKey> = listOf(ourPubKey, counterpartyPubKey)
val ourCommand: Command<DummyContract.Commands.Create> = Command(commandData, requiredSigners)

// Adding attachements
val ourAttachment: SecureHash = SecureHash.sha256("DummyAttachment")

// Specifying TimeWindow
val ourTimeWindow: TimeWindow = TimeWindow.between(Instant.MIN, Instant.MAX)
val ourAfter: TimeWindow = TimeWindow.fromOnly(Instant.MIN)
val ourBefore: TimeWindow = TimeWindow.untilOnly(Instant.MAX)

txBuilder.withItems( ourStateAndRef, ourOutput, ourCommand, ourTimeWindow)

// Finally sign the transaction with legar identity key. :
val onceSignedTx: SignedTransaction = serviceHub.signInitialTransaction(txBuilder) 
// Alternatively choose other key:
val otherKey: PublicKey = serviceHub.keyManagementService.freshKey()
val onceSignedTx2: SignedTransaction = serviceHub.signInitialTransaction(txBuilder, otherKey)

         </pre>
       </li>
     </ul>
  </td>
  <td col1  >
     <ul>
     <li> <a href='https://docs.corda.net/api-transactions.html'>Transaction API</a> </li>
     <li> LedgerTransaction sent to Contract::verify(...):
     <pre xxsmall>
@CordaSerializable
class LedgerTransaction(
     override val inputs: List&lt;StateAndRef&lt;*>>,
     outputs: List&lt;TransactionState&lt;ContractState>>,
     /** Arbitrary data passed to the program of each input state. */
     // NOTE: AuthenticatedObject pairs a command with a list of signers. 
     val commands: List&lt;AuthenticatedObject&lt;CommandData>>,
     val attachments: List&lt;Attachment>,
     override val id: SecureHash, // for original serialised-Wire-TX
     notary: Party?,
     signers: List&lt;PublicKey>,
     timeWindow: TimeWindow?,
     type: TransactionType
) : BaseTransaction(inputs, outputs, notary, signers, type, timeWindow) {
    ...
}
     </pre>
     </li>
     </ul>
</td>
  <td col2  >requireThat-DSL Example (replacing throw IllegalArgumentException...):<br/>
     <pre xxsmall>
requireThat {
    "No inputs should be consumed @ Issue" using (tx.inputs.isEmpty())
    "Only one output state permitted"      using (tx.outputs.size == 1)
    val out = tx.outputs.single() as XState
    "sender == recipient not allowed"      using (out.sender != out.recipient)
    "All participants must be signers"     using (command.signers.containsAll(out.participants))
    "X's value must be >0 "                using (out.x.value > 0)
}
     </pre>



</td>
  <td col3  ></td>
</tr }>

<!-- ************************************** -->
<tr {>
  <td topic >FLOWS</td>
  <td summa >
     <ul>
       <li>Flows automate the process of agreeing ledger updates</li>
       <li>Communication between nodes only occurs in the context of these flows,
      and is point-to-point</li>
       <li>Built-in flows are provided to automate common tasks</li>
       <li>Represents a sequence of steps that tells a node how to 
      achieve a specific ledger update, such as issuing an asset
      or settling a trade</li>
       <li>Once a given business process has been encapsulated in a flow 
      and installed on the node as part of a CorDapp, the node's
      owner can instruct the node to kick off this business process 
      at any time using an RPC call. The flow abstracts all the
      networking, I/O and concurrency issues away from the node owner.</li>
       <li>Flows may last days, across node restarts and even upgrades.</li>
       <li>Flow Initiator: Builds new TX (choose notary), signs,
           verify (run its contract), gather counterparty's signature, finalize TX:<br/>
           Finalize: -> Send TX to notary -> Wait for notarised TX -> Record locally ->
           Store states in the vault -> Send TX to counterparty for recording
       </li>
       <li>Responder:<br/>
         Verify signatures and contract -> Signs -> send signature back ->
         wait for notarised TX -> record locally -> store states in vault
       </li>

     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://docs.corda.net/api-flows.html'>Flows API</a></li>
       <li><a href='https://docs.corda.net/api-service-hub.html'>Service Hub API</a>(Accesible inside the FlowLogic::call())
         <pre xxsmall>
networkMapCache      : Provides information on other nodes on the network
identityService      : Allows to resolve anonymous identities 
                       to well-known identities
attachments          : Gives access to the node's attachments
validatedTransactions: Gives access to the TX stored in the node
vaultService         : Stores node's current and historic states
keyManagementService : Manages signing TXs and generating public keys
myInfo               : Other information about the node
clock                : Provides access to node's internal time+date
  
Additional, ServiceHub exposes the following properties:
  
loadState             : resolve a StateRef into a TransactionState
toStateAndRef         : resolve a StateRef into a StateAndRef
signInitialTransaction: signs TransactionBuilder -> SignedTransaction
createSignature       : create signature to a SignedTransaction
addSignature          : add signatures   to a SignedTransaction

legalIdentityKey      : node's legal identity key
notaryIdentityKey     : notary identity key
         </pre>
</li>

       <li>
       <pre xxsmall>
Additionally, any flow that is started by a SchedulableState must be annotated with the  annotation.
-----------------------------------------------+----------------------------------
@SchedulableFlow   &lt;- If started by an      |
                         SchedulableState      |
@InitiatingFlow    &lt;- Indicates that can be | @InitiatedBy &lt;- Indicates that responds to messages
                         started "manually"    |
@StartableByRPC    &lt;- Add RPC control.      | 
class Initiator(val arg1: Boolean,             | class Responder(val otherParty: Party):
                val arg2: Int,                 |     FlowLogic<Unit>() { ... }
                val counterparty: Party):      |
    FlowLogic<SignedTransaction>() {           |
                                               |
      @Suspendable &lt;- serializable+restart.
      override fun call() {
        val NMC = serviceHub.networkMapCache
        val x500Name = X500Name("CN=NodeA,O=NodeA,L=London,C=UK")
        // Retrieve counterparties legal identities {
        val namedCounterparty: Party? = NMC.getNodeByLegalName       (x500Name   )?.legalIdentity
        val keyedCounterparty: Party? = NMC.getNodeByLegalIdentityKey(dummyPubKey)?.legalIdentity
        val firstCounterparty: Party  = NMC.partyNodes[0]                          .legalIdentity
        // }
        // find nodes providing a specific service (regulator, oracle, ...)
        val regulator: Party = NMC.getNodesWithService(ServiceType.regulator)[0].legalIdentity
        
        val packet2: UntrustworthyData<Boolean> = 
                   sendAndReceive<Boolean>(regulator /*counterparty*/, "payload")
        val boolean: Boolean = packet2.unwrap { untrustedData -> ...  return checkedAndTrustedData }
      }
    }
-----------------------------------------------+----------------------------------
       </pre>
       </li>
       <li>BUILT-IN SUBFLOWS ("BUILDING BLOCKS"):
         <pre xxsmall>
  | SubFlow                  | should be used to 
  +--------------------------+-------------------
  | CollectSignaturesFlow    | collect TXs required signatures
  | SignTransactionFlow      | 
  | FinalityFlow             | notarise and record a transaction
  | ResolveTransactionsFlow  | verify inputs chain to TX 
  | ContractUpgradeFlow      | change a state's contract
  | NotaryChangeFlow         | change a state's notary
         </pre>
         Example ussage:
         <pre xxsmall>
(Initiator)Party starts CollectSignatures Subflow   | Counterparty
----------------------------------------------------+--------------------------------------------------------------------------------
val fullySignedTx: SignedTransaction =              | 
    subFlow(                                        | val counterParty_SignTransactionFlow: SignTransactionFlow = 
      CollectSignaturesFlow(                        |     object : SignTransactionFlow(counterparty) {
        twiceSignedTx,                              |     override 
        SIGS_GATHERING.childProgressTracker()       |     fun checkTransaction(stx: SignedTransaction) = requireThat {
      )                                             |       ... checking ...
    )                                               |       if (stx_has_dependencies)
                                                    |         subFlow(ResolveTransactionsFlow(twiceSignedTx, counterparty))
                                                    | 
                                                    |       subFlow(ResolveTransactionsFlow(setOf(ourStateRef.txhash), counterparty))
                                                    | 
                                                    |       val outputState = stx.tx.outputsOfType<DummyState>().single()
                                                    |       assert(outputState.magicNumber == 777)
                                                    |     }
                                                    | }
                                                    | subFlow(counterParty_SignTransactionFlow)
----------------------------------------------------+--------------------------------------------------------------------------------

val additionalParties: Set<Party> = setOf(regulator) 
val notarisedTx1: SignedTransaction = 
    subFlow(
      FinalityFlow(               // &lt;- Finalizing Flow
        listOf(fullySignedTx),
        additionalParties /*optional*/,
        FINALISATION.childProgressTracker())
    ).single()
         <pre xxsmall>
       </li>
       <li>ProgressTracker :allows to see the flow's progress visually in our node's CRaSH shell.
           ID_OTHER_NODES->SENDING_AND_RECEIVING_DATA->EXTRACTING_VAULT_STATES->OTHER_TX_COMPONENTS
           ->TX_BUILDING->TX_SIGNING->TX_VERIFICATION->SIGS_GATHERING->VERIFYING_SIGS->FINALISATION
         <pre>
         progressTracker.currentStep = ...
         </pre>
       </li>
     </ul>
  </td>  
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >CONSENSUS</td>
  <td summa >
     <ul>
       <li>To be committed, transactions must achieve both validity and uniqueness consensus</li>
       <li>Validity consensus requires contractual validity of the 
      transaction and all its dependencies</li>
       <li>Uniqueness consensus prevents double-spends. 
           This consensus is provided by notaries.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->

<tr {>
  <td topic >NOTARIES</td>
  <td summa >
     <ul>
       <li>Notaries prevent "double-spends"</li>
       <li>Notaries may optionally also validate transactions</li>
       <li>A network can have several notaries, each running a different
         consensus algorithm</li>
       <li>notaries may differ in terms of <br/>
      - Structure: a notary may be a single network node,
        a cluster of mutually-trusting nodes, or a cluster of mutually-distrusting nodes<br/>
      - Consensus algorithm: a notary service may choose to run a high-speed, high-trust
        algorithm such as RAFT, a low-speed, low-trust algorithm such as BFT, or any other
        consensus algorithm it chooses
       </li>
       <li>A notary also act as the timestamping authority,</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->


<tr {>
  <td topic >TIME-WINDOWS</td>
  <td summa >
     <ul>
       <li>If a transaction includes a time-window, it can only be committed during that window</li>

       <li>The notary is the timestamping authority, refusing to commit transactions outside of that windowli>
       <li>Time-windows can have a start and end time, or be open at either 
     end allowing all of the following situations to be modelled:<br/>
     -A TX occurring at some point after the given time (e.g. after a maturity event)<br/>
     -A TX occurring at any time before the given time (e.g. before a bankruptcy event)<br/>
     -A TX occurring at some point roughly around the given time (e.g. on a specific day)</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >ORACLES</td>
  <td summa >
     <ul>
       <li>A fact can be included in a TX as part of a command</li>
       <li>An oracle is a (network) service that will only sign the TX if the included fact is true</li>
       <li> Upon request, an oracle provide commands that encapsulate a specific fact
           (e.g, the exchange rate at time x) and list the oracle as a required signer.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>

<!-- ************************************** -->
<tr {>
  <td topic >NODES</td>
  <td summa >
 
     <ul>
       <li>A node is JVM run-time with a unique network identity running the Corda software</li>

       <li>The node has two interfaces with the outside world:<br/>
    - A network layer, for interacting with other nodes<br/>
    - RPC, for interacting with the node's owner</li>
       <li>The node's functionality is extended by installing CorDapps in the plugin registry</li>
       <li>The core elements of the architecture are <br/>
         <ul sublist>
         <li>
         - A persistence layer for storing data It has two parts:<br/>
           - The vault, where the node stores any relevant current and historic states<br/>
           - The storage service, where it stores transactions, attachments and flow checkpoints
         </li>
         <li>
         - A network interface for interacting with other nodes (as part of a running flow).<br/>
           Node's owner doesn't interact with other network nodes directly.<br/>
         - An RPC interface for interacting with the node's owner
         </li>
         <li>
         - A service hub for allowing the node's flows to call upon the node's other services<br/>
           - Information on other nodes on the network and the services they offer<br/>
           - Access to the contents of the vault and the storage service<br/>
           - Access to, and generation of, the node’s public-private keypairs<br/>
           - Information about the node itself<br/>
           - The current time, as tracked by the node
         </li>
         <li>
         - A plugin registry for extending the node by installing CorDapps<br/>
           The node also has several plugins installed by default to handle common tasks such as:<br/>
           - Retrieving transactions and attachments from counterparties<br/>
           - Upgrading contracts<br/>
           - Broadcasting agreed ledger updates for recording by counterparties
         </li>
         </ul>
       </li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->

</table>
</body>
<!--
TODO: Identity Services

TODO: RPC HowTo {  
   Example VaultQueryBy by RPC: (https://docs.corda.net/api-vault-query.html)

   @RPCReturnsObservables
   fun <T : ContractState> vaultQueryBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractType: Class<out T>): Vault.Page<T>

   @RPCReturnsObservables
   fun <T : ContractState> vaultTrackBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort,
       contractType: Class<out T>): DataFeed<Vault.Page<T>, Vault.Update>
}
 
-->

</html>
