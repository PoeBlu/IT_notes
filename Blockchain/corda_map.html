<html>
<head>
   <meta charset="UTF-8">
   <title>Corda Map</title>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[ xxsmall], #zoomDiv > * > *[ xxsmall], #zoomDiv > * > * > *[ xxsmall]{ font-size:1rem; }
#zoomDiv > *[  xsmall], #zoomDiv > * > *[  xsmall], #zoomDiv > * > * > *[  xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:20%; max-width:30%; }
td[col1]  {background-color:#FFFFFF; min-width:20%; max-width:30%; }
td[col2]  {background-color:#FAFAFA; min-width:20%; max-width:30%; }
td[col3]  {background-color:#FFFFFF; min-width:20%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "<span xsmall>('Esc' to close)</span><br/>" + this.innerHTML; }

function onPageLoaded() {
   /* Notes:
    * The name (and number) of columns 'topic', 'summa', 'col1', 'col2' is arbitrary.
    * Change at will. For example for development projects there could be a column for each 
    * software life-cycle similar to:  
    * topic -> summary -> documentation -> development -> testing/CI -> deployment -> QA
    * WARN: Don't forget to change the css too.
   */

  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
&lt;tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  Ex.1:
     <pre xxsmall>
     ...
     </pre>
  </td>
  <td >
     <table subtable1>
     <tr subtable1>
       <td subtable1></td>
       <td subtable1></td>
       <td subtable1></td>
     </tr>
     </table>
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <th topic >topic</th>
  <th summa >summary</th>
  <th col1  ></th>
  <th col2  ></th>
  <th col3  ></th>
</tr>
<!-- ************************************** -->
<tr {>
  <td topic >Corda M14.0</td>
  <td summa >
     <ul>
       <li><a href='https://github.com/corda/corda/tree/master/core/src/main/kotlin/net/corda/core'>Corda Core@Github</a></li>
       <li><a href='https://docs.corda.net/key-concepts.html'>REF: Key Concepts</a></li>
       <li>
           <a href='https://docs.corda.net/running-the-demos.html#irs-demo' >Asset Trading(irs-demo)</a><br/>
           <a href='https://docs.corda.net/running-the-demos.html#simm-demo'>SIMM and Portfolio Demo(aka the Initial Margin Agreement Demo)</a><br/>
       </li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href='https://docs.corda.net/api-core-types.html'>API Core Types</a>
         <pre>
- SecureHash.SHA256 and utility methods to create/parse/... them
- mathematical utilities (interpolators and classes for working with splines)
- NamedByHash and UniqueIdentifier( == 128 bit Java UUID random number + arbitrary string)
- (Anonymous)Party classes represent participating network entities containing (set of) keys
- AuthenticatedObject: represents an object (like a command) and the list of associated signers
- CompositeKey: tree data structure to provide Multi-signature support
- Date support: interfaces and classes for use by contracts which deal with dates 
     (especially in the context of deadlines).  and terms such as "overnight", "T+3", etc.
  Tenor models the interval before a deadline, such as 3 days, etc.
  DateRollConvention describes how deadlines are modified to take into account bank holidays
  ...modifying normal working days
  -  BusinessCalendar class models these calendars of business holidays 
         </pre>
       </li>
     </ul>
  </td>
  <td col2  >
  </td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >CORDAPP LAYOUT</td>
  <td summa >
     <ul>
 
       <li>CorDapps are installed at the level of the individual node, rather than on the network itself.</li>
       <li>Each CorDapp allows a node to handle new business processes by defining new
           flows on the node (started by the node owner) conduct the process of negotiating
           a specific ledger update with other nodes on the network
       </li>
       <li>CorDapp developers will usually define:
         <pre>
         - States     

         - Contracts  implementing <a href='https://docs.corda.net/api-contracts.html'>&lt;&lt;Contract>></a>
         - Flows      implementing <a href='https://docs.corda.net/api-flows.html'>&lt;&lt;FlowLogic>></a>
         - Web APIs
         - Services
         </pre>
       </li>
       <li>Your CorDapp may need to define two types of plugins:
         <pre>
         - CordaPluginRegistry subclasses that can overwrite:
             - customizeSerialization: set of the classes       to be whitelisted for object serialisation
             - requiredSchemas       : set of the MappedSchemas to use for persistence and vault queries
           - must be added also to resources/META-INF/services/net.corda.core.node.CordaPluginRegistry
         - WebServerPluginRegistry subclasses, that can overwrite:
         - webApis        : list of JAX-RS annotated REST access classes.
         - staticServeDirs: map of static web content to virtual paths 
           (The static web content itself should be placed inside src/main/resources)
           must be added also to resources/META-INF/services/net.corda.webserver.services.WebServerPluginRegistry
         </pre>
       </li>
     </ul>
  </td>
  <td col1  >
    - <a href="https://github.com/corda/cordapp-template-java"  >JAVA   TEMPLATE</a> <br/>
    - <a href="https://github.com/corda/cordapp-template-kotlin">KOTLIN TEMPLATE</a>
  </td>
  
  <td col2  >Code layout:
  <pre xxsmall>
     src
     ├── main
     │   ├── java
     │   │   └── com
     │   │       └── template
     │   │           ├── Main.java
     │   │           ├── api
     │   │           │   └── TemplateApi.java
     │   │           ├── client
     │   │           │   └── TemplateClientRPC.java
     │   │           ├── contract
     │   │           │   └── TemplateContract.java
     │   │           ├── flow
     │   │           │   └── TemplateFlow.java
     │   │           ├── plugin
     │   │           │   └── TemplatePlugin.java
     │   │           ├── service
     │   │           │   └── TemplateService.java
     │   │           └── state
     │   │               └── TemplateState.java
     │   └── resources
     │       ├── META-INF
     │       │   └── services
     │       │       ├── net.corda.core.node.CordaPluginRegistry
     │       │       └── net.corda.webserver.services.WebServerPluginRegistry
     │       ├── certificates
     │       │   ├── sslkeystore.jks
     │       │   └── truststore.jks
     │       └──templateWeb
     │           ├── index.html
     │           └── js
     │               └── template-js.js
     └── test
         └── java
             └── com
                 └── template
                     └── contract
                         └── TemplateTests.java
  </pre>
  </td>
  <td col3  ></td>
</tr }>

<!-- ************************************** -->


<tr {>
  <td topic >THE NETWORK</td>
  <td summa >
     <ul>
       <li>A Corda network is made up of nodes running (JVM) Corda Services (Notary+,Oracle*, ...) and CorDapps</li>
       <li>The network is permissioned, with access controlled by a doorman: Enforces rules regarding the infor. that nodes must provide and the KYC processes that they must complete before being admitted to the network.</li>
       <li>Communication between nodes is point-to-point, instead of relying on global broadcasts with TLS-encrypted messages sent over AMQP/1.0.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>



<!-- ************************************** -->

<tr {>
  <td topic >THE LEDGER</td>
  <td summa >
     <ul>
       <li>The ledger is subjective from each peer's perspective. Each peer only sees a subset of facts on the ledger</li>
       <li>Two peers are always guaranteed to see the exact same version of any on-ledger facts they share</li>
     </ul>
  </td>

  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>


<!-- ************************************** -->
<tr {>
  <td topic >CONTRACT STATES</td>
  <td summa >
    <ul>
      <li>Can contain arbitrary data, allowing them to represent facts of any kind (stocks, bonds, loans, KYC data, identity information...).</li>
       <li>Represent on-ledger facts</li>
       <li>Evolve by marking the current state as historic and creating an updated state</li>
       <li>Each node has a vault where it stores any relevant states to itself</li>
       <li>Each node on the network maintains a vault: a database where it tracks all the current and historic states that it is aware of, and which it considers to be relevant to itself</li>
     </ul>
  </td>
  <td col1  >Implement <a href='https://docs.corda.net/api-states.html'>&lt;&lt;ContractState>></a> or (optimal) sub-interfaces:<br/>
    <a href='https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/Structures.kt'>contracts/Structures.kt</a>

    <pre xsmall  >
@CordaSerializable
interface ContractState {
    val contract: Contract
    val participants: List<AbstractParty>
}
          ----------------------------------------
          object with constant identity over time 
          (facts evolving over time)
          interface LinearState : ContractState {
              val linearId: UniqueIdentifier
          }
          ----------------------------------------
          fungible asset with an owner
          interface OwnableState : ContractState {
              val owner: AbstractParty
              fun withNewOwner(newOwner: AbstractParty): CommandAndState
          }
          ----------------------------------------
              &lt;&lt;FungibleAsset>> (TODO: Inherits from OwnableState?)
              represent assets that are fungible, countable and issued by a specific party
              (eg. Cash.State and CommodityContract.State in the Corda finance module)
    </pre>
    <br/>
</td>
  <td col2  >Every ContractState can implement the QueryableState interface if 
     it wishes to be inserted into the node’s local database and accessible using SQL.
    <pre xsmall  >
interface QueryableState : ContractState {
    fun supportedSchemas(): Iterable<MappedSchema>
    fun generateMappedObject(schema: MappedSchema): PersistentState
}
    </pre>
  </td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >STATE PERSISTENCE (VAULTS)</td> 
  <td summa >

     <ul>
       <li>Nodes have an internal SchemaService which decides what to persist and what not by selecting the MappedSchema to use.
          <pre xxxsmall>
interface SchemaService {
    data class SchemaOptions(val databaseSchema: String? = null, val tablePrefix: String? = null)    
    val schemaOptions: Map<MappedSchema, SchemaOptions>
    fun selectSchemas(state: ContractState): Iterable<MappedSchema>
    fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState
}

open class MappedSchema(schemaFamily: Class<*>,
                        val version: Int,
                        val mappedTypes: Iterable<Class<*>>) {
    val name: String = schemaFamily.name
    override fun toString(): String = "${this.javaClass.simpleName}(name=$name, version=$version)"
}
          </pre>
</li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href="https://docs.corda.net/api-vault-query.html">API VAULT Query</a></li>
       <li>The majority of query requirements can be satisfied by using the Vault Query API,
           which is exposed via the VaultQueryService for use directly by flows. (See also helper methods)
           <pre  xsmall>
    Vault.Page, use for returning results, object contains:
     *  1. states as a List of <StateAndRef> (page number and size defined by [PageSpecification])
     *  2. states metadata as a List of [Vault.StateMetadata] held in the Vault States table.
     *  3. total number of results available if [PageSpecification] supplied (otherwise returns -1)
     *  4. status types used in this query: UNCONSUMED, CONSUMED, ALL
     *  5. other results (aggregate functions with/without using value groups)
     */
    One-time-query                             |  Stream (snapshot + Observable stream) query
    -------------------------------------------+---------------------------------------------
    fun <T : ContractState> _queryBy(          |  fun <T : ContractState> _trackBy(
        criteria: QueryCriteria /*filters*/,   |      criteria: QueryCriteria /* filters */,
        paging: PageSpecification,             |      paging: PageSpecification,
        sorting: Sort,                         |      sorting: Sort,
        contractType: Class<out T>):           |      contractType: Class<out T>): 
      Vault.Page<T>                            |        DataFeed<
                                               |            Vault.Page<T> /*"snapshot"*/,
                                               |             Vault.Update /* Observable */>
              </pre>
       </li>
       <li>&lt;&lt;QueryCriteria>> provides mechanisms for specifying filtering,
           including (AND, OR), (LESS|GREATER)_(THAN|THAN_OR_EQUAL), (NOT_)EQUAL,
           (NOT_)LIKE, (IS_|NOT_)NULL,  (NOT_)IN,  Standard SQL-92 aggregate functs
           (SUM, AVG, MIN, MAX, COUNT)
       </li>
       <li>There are four implementations of this interface which CAN BE CHAINED TOGETHER to define advanced filters.
        <pre xsmall>
VaultQueryCriteria: filter on attributes within the Vault states table:
   - status (UNCONSUMED, CONSUMED)
   - state reference(s)
   - contract state type(s)
   - notaries
   - soft locked states
   - timestamps (RECORDED, CONSUMED)

FungibleAssetQueryCriteria: filter on    |  LinearStateQueryCriteria: filter on attributes 
attributes defined in FungibleAsset      |  defined in &lt;&lt;LinearState>> and &lt;&lt;DealState>>
contract state:                          |  contract state
   - participants(s)                     |     - participant(s)
   - owner(s)                            |     - linearId(s)
   - quantity                            |     - dealRef(s)
   - issuer party(s) and/or reference(s) |

VaultCustomQueryCriteria:  provides the means to specify one or many arbitrary expressions on attributes 
   defined by a custom contract state that implements its own schema. 
   See the Builder object in QueryCriteriaUtils for a complete specification of the DSL.
         </pre>
       </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li>custom query example:
       <pre>
val generalCriteria = VaultQueryCriteria(Vault.StateStatus.ALL)

val results = builder {
    val currencyIndex = PersistentCashState::currency.equal(USD.currencyCode)
    val quantityIndex = PersistentCashState::pennies.greaterThanOrEqual(10L)

    val customCriteria1 = VaultCustomQueryCriteria(currencyIndex)
    val customCriteria2 = VaultCustomQueryCriteria(quantityIndex)

    val criteria = generalCriteria.and(customCriteria1.and(customCriteria2))
    vaultQuerySvc.queryBy<Cash.State>(criteria)
}
       </pre>
       </li>
     </ul>
  </td>
  <td >
  </td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >CONTRACTS</td>
  <td summa >
     <ul>
       <li>A valid transaction must be accepted by the contract of each of its input and output states</li>
       <li>Contracts are written in a JVM programming language (e.g. Java or Kotlin)</li>
       <li>Contract execution is deterministic and its acceptance of a transaction is based on the transaction's contents alone. A contract should either always accept or always reject a given transaction. Can not depend on the validation date or other contextual info.</li>
     </ul>
  </td>
  <td col1  >All Corda contracts are JVM classes th implement the next interface:
    <pre xsmall>
<b>package net.corda.core.contracts.Contract</b>
@CordaSerializable
interface Contract {
    @Throws(IllegalArgumentException::class)
    fun verify(tx: LedgerTransaction)

    val legalContractReference: SecureHash
}
    </pre>
</td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >TRANSACTIONS</td>
  <td summa >
     <ul>
       <li>Transactions are proposals to update the ledger</li>
       <li>A transaction proposal will only be committed if: 
          <pre>
      - It doesn't contain double-spends
      - It is contractually valid
        {
         - Each state points to a contract
         - A contract takes a transaction as input, and states 
           whether the transaction is considered valid based on the contract’s rules
         - A transaction is only valid if the contract of every
           input state and every output state considers it to be valid
        }

      - It is signed by the required parties
         </pre>
       </li>
       <li>A transaction can contain any number of inputs and outputs of any type:<br/>
     - They can include many different state types (e.g. both cash and bonds)<br/>
     - They can be issuances (have zero inputs) or exits (have zero outputs)<br/>
     - They can merge or split fungible assets (e.g. combining a $2 state and a $5 state into a $7 cash state)
       </li>
       <li>There are two basic types of transactions:<br/>
     - Notary-change transactions (used to change a state’s notary - see Notaries)<br/>
     - General transactions (used for everything else)
       </li>
       <li>TX input states references are a combination of:<br/>
     - The hash of the transaction that created the input<br/>
     - The input’s index in the outputs of the previous transaction</li>
       <li>
       - Initially, a transaction is just a proposal to update the ledger.
       representing the future state of the ledger desired by the 
       transaction builder(s): <br/>
       - To become reality, the transaction must receive signatures from 
         all of the required signers.<br/>
       - Once all the required signatures are gathered, the transaction 
         becomes committed meaning:<br/>
         - TX’s inputs are marked as historic, and cannot be used anymore<br/>
         - TX’s outputs become part of the current state of the ledger</li>
       <li>TX commands: Including a command in a transaction allows us to
      indicate the transaction’s intent, affecting how we check the
      validity of the transaction.<br/>
     - Each command is also associated with a list of one or more signers.
       By taking the union of all the public keys listed in the commands, 
       we get the list of the transaction’s required signers.</li>
       <li>ATTACHMENTS: Each TX can refer to zero or more attachments by hash.
         These attachments are ZIP/JAR files containing arbitrary content.</li>
       <li>TIME-WINDOWS: specify the time window during which the transaction 
         can be committed</li>
       <li>
         There are four states the transaction can occupy:<br/>
           - TransactionBuilder, a builder for a transaction in construction<br/>
           - WireTransaction, an immutable transaction<br/>
           - SignedTransaction, an immutable transaction with 1+ associated signatures<br/>
           - LedgerTransaction, a transaction that can be checked for validity
         <pre>
         val txBuilder: TransactionBuilder = TransactionBuilder(General, specificNotary)
         <pre>
       </li>
     </ul>
  </td>
  <td col1  >
     <ul>
     <li> <a href='https://docs.corda.net/api-transactions.html'>Transaction API</a> </li>
     <li> LedgerTransaction example:
     <pre xxsmall>
@CordaSerializable
class LedgerTransaction(
     override val inputs: List&lt;StateAndRef&lt;*>>,
     outputs: List&lt;TransactionState&lt;ContractState>>,
     /** Arbitrary data passed to the program of each input state. */
     // NOTE: AuthenticatedObject pairs a command with a list of signers. 
     val commands: List&lt;AuthenticatedObject&lt;CommandData>>,
     val attachments: List&lt;Attachment>,
     override val id: SecureHash, // for original serialised-Wire-TX
     notary: Party?,
     signers: List&lt;PublicKey>,
     timeWindow: TimeWindow?,
     type: TransactionType
) : BaseTransaction(inputs, outputs, notary, signers, type, timeWindow) {
    ...
}
     </pre>
     </li>
     </ul>
</td>
  <td col2  >requireThat-DSL Example (replacing throw IllegalArgumentException...):<br/>
     <pre xxsmall>
requireThat {
    "No inputs should be consumed @ Issue" using (tx.inputs.isEmpty())
    "Only one output state permitted"      using (tx.outputs.size == 1)
    val out = tx.outputs.single() as XState
    "sender == recipient not allowed"      using (out.sender != out.recipient)
    "All participants must be signers"     using (command.signers.containsAll(out.participants))
    "X's value must be >0 "                using (out.x.value > 0)
}
     </pre>



</td>
  <td col3  >requireSingleCommand() helper method to extract commands:
     <pre xxsmall>
class XContract : Contract {
   interface Commands : CommandData {
       class Issue : TypeOnlyCommandData(), Commands
       class Transfer : TypeOnlyCommandData(), Commands
   }

   override fun verify(tx: LedgerTransaction) {
       val command = tx.commands.<b>requireSingleCommand</b><Commands>()

       when (command.value) {
           is Commands.Issue -> {
               // Issuance verification logic.
           }
           is Commands.Transfer -> {
               // Transfer verification logic.
           }
       }
   }
   override val legalContractReference: SecureHash = 
       SecureHash.sha256("X contract hash")
}
     </pre>


 </td>
</tr }>

<!-- ************************************** -->
<tr {>
  <td topic >FLOWS</td>
  <td summa >
     <ul>
       <li>Flows automate the process of agreeing ledger updates</li>
       <li>Communication between nodes only occurs in the context of these flows,
      and is point-to-point</li>
       <li>Built-in flows are provided to automate common tasks</li>
       <li>Represents a sequence of steps that tells a node how to 
      achieve a specific ledger update, such as issuing an asset
      or settling a trade</li>
       <li>Once a given business process has been encapsulated in a flow 
      and installed on the node as part of a CorDapp, the node's
      owner can instruct the node to kick off this business process 
      at any time using an RPC call. The flow abstracts all the
      networking, I/O and concurrency issues away from the node owner.</li>
       <li>Flows may last days, across node restarts and even upgrades.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >CONSENSUS</td>
  <td summa >
     <ul>
       <li>To be committed, transactions must achieve both validity and uniqueness consensus</li>
       <li>Validity consensus requires contractual validity of the 
      transaction and all its dependencies</li>
       <li>Uniqueness consensus prevents double-spends. 
           This consensus is provided by notaries.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->

<tr {>
  <td topic >NOTARIES</td>
    * 
    * 
  <td summa >
     <ul>
       <li>Notaries prevent "double-spends"</li>
       <li>Notaries may optionally also validate transactions</li>
       <li>A network can have several notaries, each running a different
         consensus algorithm</li>
       <li>notaries may differ in terms of <br/>
      - Structure: a notary may be a single network node,
        a cluster of mutually-trusting nodes, or a cluster of mutually-distrusting nodes<br/>
      - Consensus algorithm: a notary service may choose to run a high-speed, high-trust
        algorithm such as RAFT, a low-speed, low-trust algorithm such as BFT, or any other
        consensus algorithm it chooses
       </li>
       <li>A notary also act as the timestamping authority,</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->


<tr {>
  <td topic >TIME-WINDOWS</td>
  <td summa >
     <ul>
       <li>If a transaction includes a time-window, it can only be committed during that window</li>

       <li>The notary is the timestamping authority, refusing to commit transactions outside of that windowli>
       <li>Time-windows can have a start and end time, or be open at either 
     end allowing all of the following situations to be modelled:<br/>
     -A TX occurring at some point after the given time (e.g. after a maturity event)<br/>
     -A TX occurring at any time before the given time (e.g. before a bankruptcy event)<br/>
     -A TX occurring at some point roughly around the given time (e.g. on a specific day)</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td topic >ORACLES</td>
  <td summa >
     <ul>
       <li>A fact can be included in a TX as part of a command</li>
       <li>An oracle is a (network) service that will only sign the TX if the included fact is true</li>
       <li> Upon request, an oracle provide commands that encapsulate a specific fact
           (e.g, the exchange rate at time x) and list the oracle as a required signer.</li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->

<tr {>
  <td topic >NODES</td>
  <td summa >
 
     <ul>
       <li>A node is JVM run-time with a unique network identity running the Corda software</li>

       <li>The node has two interfaces with the outside world:<br/>
    - A network layer, for interacting with other nodes<br/>
    - RPC, for interacting with the node's owner</li>
       <li>The node's functionality is extended by installing CorDapps in the plugin registry</li>
       <li>The core elements of the architecture are <br/>
         <ul sublist>
         <li>
         - A persistence layer for storing data It has two parts:<br/>
           - The vault, where the node stores any relevant current and historic states<br/>
           - The storage service, where it stores transactions, attachments and flow checkpoints
         </li>
         <li>
         - A network interface for interacting with other nodes (as part of a running flow).<br/>
           Node's owner doesn't interact with other network nodes directly.<br/>
         - An RPC interface for interacting with the node's owner
         </li>
         <li>
         - A service hub for allowing the node's flows to call upon the node's other services<br/>
           - Information on other nodes on the network and the services they offer<br/>
           - Access to the contents of the vault and the storage service<br/>
           - Access to, and generation of, the node’s public-private keypairs<br/>
           - Information about the node itself<br/>
           - The current time, as tracked by the node
         </li>
         <li>
         - A plugin registry for extending the node by installing CorDapps<br/>
           The node also has several plugins installed by default to handle common tasks such as:<br/>
           - Retrieving transactions and attachments from counterparties<br/>
           - Upgrading contracts<br/>
           - Broadcasting agreed ledger updates for recording by counterparties
         </li>
         </ul>
       </li>
     </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr }>
<!-- ************************************** -->

</table>
</body>
<!--
TODO: Identity Services

TODO: RPC HowTo {  
   Example VaultQueryBy by RPC: (https://docs.corda.net/api-vault-query.html)

   @RPCReturnsObservables
   fun <T : ContractState> vaultQueryBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractType: Class<out T>): Vault.Page<T>

   @RPCReturnsObservables
   fun <T : ContractState> vaultTrackBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort,
       contractType: Class<out T>): DataFeed<Vault.Page<T>, Vault.Update>
}
 
-->

</html>
