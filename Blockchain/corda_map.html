<html>
<head>
   <meta charset="UTF-8">
   <title>Corda Map</title>
<style>
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xbig]  { font-size:1.3rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[ xxsmall], #zoomDiv > * > *[ xxsmall], #zoomDiv > * > * > *[ xxsmall]{ font-size:1rem; }
#zoomDiv > *[  xsmall], #zoomDiv > * > *[  xsmall], #zoomDiv > * > * > *[  xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[col0] {background-color:#FAFAFA; min-width:20%; max-width:30%; }
td[col1]  {background-color:#FFFFFF; min-width:20%; max-width:30%; }
td[col2]  {background-color:#FAFAFA; min-width:20%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "<span xsmall>('Esc' to close)</span><br/>" + this.innerHTML; }

function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td col0 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  Ex.1:
     <pre xxsmall>
     ...
     </pre>
  </td>
  <td >
     <table subtable1>
     <tr subtable1>
       <td subtable1></td>
       <td subtable1></td>
       <td subtable1></td>
     </tr>
     </table>
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <th colspan=3>Corda M14.0</th>
</tr>
<!-- ************************************** -->
<tr {>
  <td col0 >
     <ul>
       <li><a href='https://github.com/corda/corda/tree/master/core/src/main/kotlin/net/corda/core'>Corda Core@Github</a></li>
       <li><a href='https://docs.corda.net/key-concepts.html'>
           REF: Key Concepts (The network, The ledger, Identity, States, Contracts, TXs, Flows, 
                Consensus, Notaries, Time-windows, Oracles, Nodes, Tradeoffs)</a>
       </li>
       <li mono><a href='https://docs.corda.net/key-concepts-tradeoffs.html'>Tradeoffs</a>:
Permissioned   vs. permissionless
Point-to-point vs. global broadcasts
UTXO           vs. account model
Code-is-law    vs. existing legal systems
Build          vs. re-use
       </li>
       <li>
           <a href='https://github.com/corda/cordapp-tutorial' >Corda Tutorial (<a href='https://corda.net'>https://corda.net</a>)</a><br/>

           <a href='https://docs.corda.net/running-the-demos.html#irs-demo' >Asset Trading(irs-demo)</a><br/>
           <a href='https://docs.corda.net/running-the-demos.html#simm-demo'>SIMM and Portfolio Demo(aka the Initial Margin Agreement Demo)</a><br/>
       </li>
     </ul>
     Release Notes:
     <ul>
       <li ><a class="reference internal" href="https://docs.corda.net/release-notes.html">Release notes</a></li>
       <li ><a class="reference internal" href="https://docs.corda.net/changelog.html">Changelog</a></li>
       <li ><a class="reference internal" href="https://docs.corda.net/codestyle.html">Code style guide</a></li>
       <li ><a class="reference internal" href="https://docs.corda.net/testing.html">Testing Corda</a></li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href='https://docs.corda.net/api-core-types.html'>API Core Types</a>
         <ul>
           <li>SecureHash.SHA256 and utility methods to create/parse/... them</li>
           <li>mathematical utilities (interpolators and classes for working with splines)</li>
           <li>NamedByHash and UniqueIdentifier( == 128 bit Java UUID random number + arbitrary string)</li>
           <li>(Anonymous)Party classes represent participating network entities containing (set of) keys</li>
           <li>AuthenticatedObject: represents an object (like a command) and the list of associated signers</li>
           <li>CompositeKey: tree data structure to provide Multi-signature support</li>
           <li>Date support: interfaces and classes for use by contracts which deal with dates 
               (especially in the context of deadlines).  and terms such as "overnight", "T+3", etc.</li>
           <li>Tenor models the interval before a deadline, such as 3 days, etc.
               DateRollConvention describes how deadlines are modified to take into account bank holidays
               ...modifying normal working days
           </li>
           <li>BusinessCalendar class models these calendars of business holidays </li>
       </li>
     </ul>
  </td>
  <td col2  ><span xbig>Getting Set Up</span>
     <ul>
       <li><a href="https://docs.corda.net/getting-set-up.html">Getting Set Up</a></li>
      <li>
         <span xbig>CordApp Example</span>
<pre { >
     $ git clone <a href='https://github.com/corda/cordapp-example'>https://github.com/corda/cordapp-example</a>  
     $ cd cordapp-example
     $ gradlew deployNodes
     $ ./kotlin-source/build/nodes/runnodes.sh
</pre } >
         (Wait until all the terminal windows display either 
          "Webserver started up in XX.X sec" or "Node for "NodeC"
          started up and registered in XX.XX sec")<br/>
         Test front end at <a href='http://localhost:10007/web/example/'>http://localhost:10007/web/example/</a>
        </li>
     </ul>
  </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>CorDapps</th>
</tr>
<tr {>
  <td col0 >
     <ul>
       <li>CorDapps are installed at the level of the individual node, rather than on the network itself.</li>
       <li>Each CorDapp allows a node to handle new business processes by defining new
           flows on the node (started by the node owner) conduct the process of negotiating
           a specific ledger update with other nodes on the network
       </li>
       <li>CorDapp developers will usually define:
         <ul>
            <li mono>Flows       subclassing <a href='https://docs.corda.net/api-flows.html'>&lt;&lt;FlowLogic>></a></li>
            <li mono>States     implementing ContractState</li>
            <li mono>Contracts  implementing <a href='https://docs.corda.net/api-contracts.html'>&lt;&lt;Contract>></a></li>
            <li mono>Services    subclassing SingletonSerializationToken</li>
            <li mono>Serialisation whitelist implementing SerializationWhitelist</li>
            <li mono>Web APIs</li>
       </li>
       <li>Your CorDapp may need to define two types of plugins:
         <ul>
           <li>CordaPluginRegistry subclasses that can overwrite:<br/>
             <ul>
               <li>customizeSerialization: set of the classes       to be whitelisted for object serialisation</li>
               <li>requiredSchemas       : set of the MappedSchemas to use for persistence and vault queries</li>
             </ul>
           * must be added also to resources/META-INF/services/net.corda.core.node.CordaPluginRegistry
           </li>
           <li>WebServerPluginRegistry subclasses, that can overwrite:
             <ul>
               <li>webApis        : list of JAX-RS annotated REST access classes.</li>
               <li>staticServeDirs: map of static web content to virtual paths <br/>
                   (The static web content itself should be placed inside src/main/resources)
                   must be added also to 
                   resources/META-INF/services/net.corda.webserver.services.WebServerPluginRegistry</li>
             </ul>
           </li>
         </ul>
       </li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href="https://github.com/corda/cordapp-template-java"  >JAVA   TEMPLATE</a></li>
       <li><a href="https://github.com/corda/cordapp-template-kotlin">KOTLIN TEMPLATE</a></li>
       <li><hr/></li>
       <li><a href='https://docs.corda.net/tutorial-cordapp.html'>Hello, World! tutorial</a></li>
       <li><a href="https://docs.corda.net/cordapp-build-systems.html">>Building a CorDapp</a> to build and run your CorDapp</li>
       <li><a href="https://docs.corda.net/api-index.html">>API docs</a></li>
       <li><a href="https://docs.corda.net/cheat-sheet.html">>cheatsheet</a></li>
       <li><hr/></li>
       <li><a href="https://docs.corda.net/flow-cookbook.html">>Flow cookbook</a>: how to perform common flow tasks</li>
       <li><a href="https://www.corda.net/samples/">Sample CorDapps</a></li>
     </ul>
  </td>
  <td col2  ><span xbig>Code layout:</span>
    project should be split into two modules:
    <ul>
      <li>cordapp-contracts-states module/CorDapp: contracts , states sent over the wire
<pre { >
main
└── java
    └── com
        └── template
            ├── TemplateContract.java 
            └── TemplateState.java
</pre } >
      </li>
      <li>cordapp module/CorDapp: remaining classes
<pre { >
main ─ java ─ com.template
│             TemplateFlow.java (inherits FlowLogic)
│             TemplateSerializationWhitelist.java
│             (testing env)TemplateApi.java
│             (testing env)TemplateClient.java
│             (testing env)TemplateWebPlugin.java
└── resources
    ├── META-INF ─ services
    │              net.corda.core.serialization.SerializationWhitelist
    │              net.corda.webserver.services.WebServerPluginRegistry
    ├── certificates
    └── templateWeb
test ─ java ─ com.template
               ContractTests.java
               FlowTests.java
               NodeDriver.java
integrationTest
└── java ─ com.template
               DriverBasedTest.java
</pre } >
      </li>
  </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>BUILDING BLOCKS</th>
</tr>
<tr {>
  <td col0 >
     <span xbig>NODES</span>
     <ul>
       <li>Definition:unique network identity running the Corda software
<pre>
        NODE
┌──────────────────┐
│   TLS            ├── Net iface interacting 
│certificate       │   with "other nodes" in
│                  │   a running flow
│                  │
│                  ├── RPC ... node owner
│                  │
│ ┌────────────────┤
│ │PLUGIN REGISTRY │←CorDapps extending node functionality
│ ├────────────────┤
│ │    VAULT       │←stores relevant current/historic states sequences 
│ ├────────────────┤
│ │ STORAGE SRV    │←stores [TXs, attachments, flow checkpoints]
└─┴────────────────┘

The service hub (not show in schema) allows the node's flows
    to call upon the node's other services
</pre>
       </li>
       <li>several plugins are installed by default for common tasks like:
         <ul>
           <li>Retrieving TXs and attachments from counterparties</li>
           <li>Upgrading contracts</li>
           <li>Broadcasting agreed ledger updates for recording by counterparties</li>
         </ul>
       </li>

       <li>A node must be authenticated to the network as pre-setup step.<br/>
           Authenticating to the network means to install a valid signed TLS certificate.<br/>
           The flow diagram to retrieve such TLS certificate is as follow:
<pre>
node    -> node   :   generates key pair 
                    + certificate signing request
node    -> doorman: Certificate signing request
doorman -> doorman: signs cert *1
doorman -> node   : (root-authority-signed) certificate CERT1
node    -> node   : creates and signs (using CERT1) two more certs:
                    - TLS certificate 
                    - Signing-certificate *2
                    (node’s well-known-identity)
node    -> node   : builds node-info-record
                          address
                          well-known-identity
node    -> network: register node-info-record
           map srv


...
node    -> ??? : establish TLS session using certificate

  * CERT: X.509 certificate 
  * 1: or forwards to well known signing authority
  * 2: an organisation can further use the 
       Signing-certificate to create both 
       well-known and confidential identities. 
</pre>
       </li>
       <li>
         Other Core elements:
         <ul>
           <li>service hub for allowing the node's flows to call upon the node's other services</li>
           <li>Information on other nodes on the network and the services they offer</li>
           <li>The current time, as tracked by the node</li>
           <li>Information about the node itself</li>
           <li>...</li>
         <ul>
       </li>
     </ul>
  </td>
  <td col1 >
     <span xbig>THE NETWORK</span>
     <ul>
       <li>made up of authenticated peer-to-peer nodes runing CorDapps and or Notary+,Oracle*, ...services</li>
       <li><span xbig>doorman service</span>: controls network access: 
         <p>
           Enforces rules regarding the information that nodes must
           provide and the KYC processes that they must complete
           Before being admitted to the network
         </p>
       <li>node-to-node communication uses TLS + AMQP/1.0</li>
     </ul>
     <hr/>
     <span xbig>IDENTITIES</span>
     <ul>
       <li>Well known identities are published in the network map</li>
       <li><span xbig>Confidential identities</span> are only shared on a need to know basis:<br/>
           Although there are several elements to the Corda transaction privacy model,
           including ensuring that transactions are only shared with those who need to see them,
           and planned use of <span xbig><a href='https://software.intel.com/en-us/blogs/2013/09/26/protecting-application-secrets-with-intel-sgx'>Intel SGX</a></span>,
           it is important to provide defense in depth against privacy breaches.
           Confidential identities are used to ensure that even if a third party gets access
           to an unencrypted transaction, they cannot identify the participants without
           additional information.
       </li>
       <li>Identities in Corda can represent:
         <ul>
           <li>Legal identity of an organisation</li>
           <li>Service identity of a network service</li>

         </ul>
       </li>
     </ul>
    

  </td>
  <td col2  ><span xbig>THE LEDGER</span>
     <ul>
       <li>The ledger is subjective from each peer's perspective:<br/>
           Each peer only sees a subset of facts on the ledger</li>
       <li>Two peers are always guaranteed to see the exact same version
           of any on-ledger facts they share</li>
       <li>We can think of the ledger from each node's point of view
           as the set of all the current (i.e. non-historic) states
           that it is aware of.</li>
     </ul>
  </td>

</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3><a href='https://docs.corda.net/key-concepts-states.html'>(CONTRACT) STATES</a></th>
</tr>
<tr {>
  <td col0 >
    <ul>
      <li>Immutable object representing a fact known by one or more Corda nodes at a specific point in time</li>
      <li>Can contain arbitrary data, allowing them to represent facts of any kind (stocks, bonds, loans, KYC data, identity information...).<br/>
      Ex. I owe you state:
<pre>
  - IOU.contract.ref
  - participants=[Alice,Bob]
  - IOU.state.props
      From: Alice
      To  : Bob
      Amount: 10$
      Due : 2017-03-01
      Paid:   5$
      Penalty: 20%
</pre>
      </li>
       <li>Represent on-ledger facts</li>
       <li>The <span xbig>lifecycle of a shared fact</span> over time is represented by a state squence.<br/>
           Evolve by marking the current state as historic and creating an updated state</li>
     </ul>
  </td>
  <td col1  >Implement <a href='https://docs.corda.net/api-states.html'>&lt;&lt;ContractState>></a> or (optimal) sub-interfaces:<br/>
    <a href='https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/Structures.kt'>contracts/Structures.kt</a>
<pre xsmall { >
@CordaSerializable
interface ContractState {
    val contract: Contract
    val participants: List<AbstractParty>
}
</pre } >
          &lt;&lt;LinearState>>: object with constant identity over time (facts evolving over time)
<pre xsmall { >
interface LinearState : ContractState {
    val linearId: UniqueIdentifier
}
</pre } >
          &lt;&lt;FungibleAsset>>:  with an owner (TODO: Inherits from OwnableState?)
          represent assets that are fungible, countable and issued by a specific party
          (eg. Cash.State and CommodityContract.State in the Corda finance module)
<pre xsmall { >
interface OwnableState : ContractState {
    val owner: AbstractParty
    fun withNewOwner(newOwner: AbstractParty): CommandAndState
}
</pre } >
</td>
  <td col2  >Every ContractState can implement the QueryableState interface if 
     it wishes to be inserted into the node’s local database and accessible using SQL.
    <pre xsmall  >
interface QueryableState : ContractState {
    fun supportedSchemas(): Iterable<MappedSchema>
    fun generateMappedObject(schema: MappedSchema): PersistentState
}
    </pre>
  </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>STATE PERSISTENCE (VAULTS)</th>
</tr>
<tr {>
  <td col0 >
<pre>
NODE VAULT:
────────────────────────────────────
      CONSUMED          │   *NON* 
 HISTORICAL STATES      │  CONSUMED
────────────────────────┴───────────
            B0 -> B1  --│-> B_head
  A0 -> A1 -A2 -> A3  --│-> A_head
                        │   C_head
</pre>
  </td>
  <td col1 >
     <ul>
       <li><a href="https://docs.corda.net/api-vault-query.html">API VAULT Query</a></li>
       <li>The majority of query requirements can be satisfied by using the Vault Query API,
           which is exposed via the VaultQueryService for use directly by flows. (See also helper methods).<br/>
           Vault.Page, use for returning results, object contains:
         <ol>
           <li>states as a List of <StateAndRef> (page number and size defined by [PageSpecification])</li>
           <li>states metadata as a List of [Vault.StateMetadata] held in the Vault States table.</li>
           <li>total number of results available if [PageSpecification] supplied (otherwise returns -1)</li>
           <li>status types used in this query: UNCONSUMED, CONSUMED, ALL</li>
           <li>other results (aggregate functions with/without using value groups)</li>
         </ol>
         <pre xsmall>
One-time-query                             |  Stream (snapshot + Observable stream) query
-------------------------------------------+---------------------------------------------
fun &lt;T : ContractState> _queryBy(          |  fun &lt;T : ContractState> _trackBy(
    criteria: QueryCriteria /*filters*/,   |      criteria: QueryCriteria /* filters */,
    paging: PageSpecification,             |      paging: PageSpecification,
    sorting: Sort,                         |      sorting: Sort,
    contractType: Class&lt;out T>):           |      contractType: Class&lt;out T>): 
  Vault.Page&lt;T>                            |        DataFeed&lt;
                                           |            Vault.Page&lt;T> /*"snapshot"*/,
                                           |             Vault.Update /* Observable */>
              </pre>
       </li>
       <li>&lt;&lt;QueryCriteria>> provides mechanisms for specifying filtering,
           including (AND, OR), (LESS|GREATER)_(THAN|THAN_OR_EQUAL), (NOT_)EQUAL,
           (NOT_)LIKE, (IS_|NOT_)NULL,  (NOT_)IN,  Standard SQL-92 aggregate functs
           (SUM, AVG, MIN, MAX, COUNT)
       </li>
       <li>There are four implementations of this interface which CAN BE CHAINED TOGETHER to define advanced filters.
        <pre xsmall>
VaultQueryCriteria: filter on attributes within the Vault states table:
   - status (UNCONSUMED, CONSUMED)
   - state reference(s)
   - contract state type(s)
   - notaries
   - soft locked states
   - timestamps (RECORDED, CONSUMED)

FungibleAssetQueryCriteria: filter on    |  LinearStateQueryCriteria: filter on attributes 
attributes defined in FungibleAsset      |  defined in &lt;&lt;LinearState>> and &lt;&lt;DealState>>
contract state:                          |  contract state
   - participants(s)                     |     - participant(s)
   - owner(s)                            |     - linearId(s)
   - quantity                            |     - dealRef(s)
   - issuer party(s) and/or reference(s) |
</pre>
VaultCustomQueryCriteria:  provides the means to specify one or many arbitrary expressions on attributes 
   defined by a custom contract state that implements its own schema. 
   See the Builder object in QueryCriteriaUtils for a complete specification of the DSL.
       </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li>custom query example:
       <pre>
val generalCriteria = VaultQueryCriteria(Vault.StateStatus.ALL)

val results = builder {
    val currencyIndex = PersistentCashState::currency.equal(USD.currencyCode)
    val quantityIndex = PersistentCashState::pennies.greaterThanOrEqual(10L)

    val customCriteria1 = VaultCustomQueryCriteria(currencyIndex)
    val customCriteria2 = VaultCustomQueryCriteria(quantityIndex)

    val criteria = generalCriteria.and(customCriteria1.and(customCriteria2))
    vaultQuerySvc.queryBy<Cash.State>(criteria)
}
       </pre>
       <li>Example 2. Query for all unconsumed states (simplest query possible):
       <pre xxsmall>
(UNCOSUMED STATE BY DEFAULT)
----------------------------------------------------------------
val sortAttribute = SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF_TXN_ID)
----------------------------------------------------------------
// recorded in time interval:
val timeIntervalFilter = TimeCondition(
        QueryCriteria.TimeInstantType.RECORDED,
        ColumnPredicate.Between(TODAY, TODAY.plus(30, ChronoUnit.DAYS)) )
----------------------------------------------------------------
VaultQueryCriteria FILTER:
  // state reference list:          | // set of contract state:              | // by notary:                             | // by recorded time  interval
  val criteria = VaultQueryCriteria | val criteria = VaultQueryCriteria      | val criteria = VaultQueryCriteria         | val criteria = VaultQueryCriteria
      (                             |    (                                   |    (                                      |     (
       stateRefs = listOf(          |     contractStateTypes = setOf(        |     notaryName = listOf(CASH_NOTARY.name) |      timeCondition = timeIntervalFilter
               stateRefs.first(),   |                Cash.State::class.java, |    )                                      |     )
               stateRefs.last()  )  |                DealState::class.java)
      )                             |    )

----------------------------------------------------------------
LinearStateQueryCriteria FILTER:
// (unconsumed states) + set of participants:
val criteria = LinearStateQueryCriteria
    (
      participants = listOf(MEGA_CORP, MINI_CORP)
    )
----------------------------------------------------------------
Reading query results:
   val results = vaultQuerySvc.queryBy<DummyLinearContract.State> (
                 criteria, 
                 Sort(setOf(
                            Sort.SortColumn(sortAttribute, Sort.Direction.ASC)
                      ) ),
                 paging = PageSpecification(DEFAULT_PAGE_NUM, 10)
               )
   val states   = result.states
   val metadata = result.statesMetadata
       </pre>
       </li>
       <li>LinearState and DealState queries using LinearStateQueryCriteria example:
       <pre>
val linearIds = issuedStates.states.map
        { it.state.data.linearId }.toList()
val       vaultCriteria = VaultQueryCriteria(status = Vault.StateStatus.ALL)
val linearStateCriteria = LinearStateQueryCriteria
    (
     status = Vault.StateStatus.ALL,  // CONSUMED & UNCOSUMED
     linearId = listOf(linearIds.first(), linearIds.last())
     dealRef = listOf("456", "789"), // by deals references:
     participants = parties,
    )
val results = vaultQuerySvc.queryBy<LinearState>(
         linearStateCriteria and vaultCriteria  )
       </pre>
       </li>
       <li>
       <pre xxsmall>
FungibleAssetQueryCriteria

val fungibleAssetCriteria = FungibleAssetQueryCriteria(
    quantity = builder { greaterThan(2500L) }, // filter by minimum quantity
    issuerPartyName = listOf(BOC),
)
// Cash.State inherits from <FungibleAsset<*>>
val results = vaultQuerySvc.queryBy<Cash.State>(fungibleAssetCriteria)
----------------------------------------------------------------------
AGGREGATE FUNCTION

  AGGREGATIONS ON CASH USING VARIOUS FUNCTIONS                              | AGGREGATIONS ON CASH GROUPED BY CURRENCY FOR VARIOUS FUNCTIONS:
  --------------------------------------------------------------------------+----------------------------------------------------------------
  val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum() }     | val sum = builder { CashSchemaV1.PersistentCashState::
  val sumCriteria = VaultCustomQueryCriteria(sum)                           |     pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val sumCriteria = VaultCustomQueryCriteria(sum)
  val count = builder { CashSchemaV1.PersistentCashState::pennies.count() } | 
  val countCriteria = VaultCustomQueryCriteria(count)                       | val max = builder { CashSchemaV1.PersistentCashState::
                                                                            |     pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val max = builder { CashSchemaV1.PersistentCashState::pennies.max() }     | val maxCriteria = VaultCustomQueryCriteria(max)
  val maxCriteria = VaultCustomQueryCriteria(max)                           | 
                                                                            | val min = builder { CashSchemaV1.PersistentCashState::
  val min = builder { CashSchemaV1.PersistentCashState::pennies.min() }     |     pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val minCriteria = VaultCustomQueryCriteria(min)                           | val minCriteria = VaultCustomQueryCriteria(min)
                                                                            | 
  val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg() }     | val avg = builder { CashSchemaV1.PersistentCashState::
  val avgCriteria = VaultCustomQueryCriteria(avg)                           |     pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val avgCriteria = VaultCustomQueryCriteria(avg)
  val results = vaultQuerySvc.queryBy<FungibleAsset<*>>(
                             sumCriteria .and(countCriteria) .and(maxCriteria) .and(minCriteria) .and(avgCriteria) )
  val (snapshot, updates)  = vaultQuerySvc.trackBy/* stream/observable queries */<FungibleAsset>(...) 
       </pre>
       </li>
     </ul>
  </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>PERSISTENCE (TODO)</th>
</tr>
<tr {>
  <td col0 >
     <ul>
       <li>Corda offers developers the option to expose all or some part of a 
           contract state to an Object Relational Mapping (ORM) tool to be persisted
           in a RDBMS. The purpose of this is to assist vault development by effectively
           indexing persisted contract states held in the vault for the purpose of running
           queries over them and to allow relational joins between Corda data and private
           data local to the organisation owning a node.
       </li>
       <li>Nodes have an internal SchemaService which decides what to persist and
           what not by selecting the MappedSchema to use.
          <pre xxxsmall>
interface SchemaService {
    data class SchemaOptions(val databaseSchema: String? = null, val tablePrefix: String? = null)    
    val schemaOptions: Map&lt;MappedSchema, SchemaOptions>
    fun selectSchemas(state: ContractState): Iterable&lt;MappedSchema>
    fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState
}

open class MappedSchema(schemaFamily: Class&lt;*>,
                        val version: Int,
                        val mappedTypes: Iterable&lt;Class&lt;*>>) {
    val name: String = schemaFamily.name
    override fun toString(): String = "${this.javaClass.simpleName}(name=$name, version=$version)"
}
          </pre>
      </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://docs.corda.net/api-persistence.html'>API</a></li>
     </ul>
  </td>  
  <td col2  > </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>CONTRACTS</th>
</tr>
<tr {>
  <td col0 >
     <ul>
       <li>A valid transaction must be accepted by the contract of each of its input and output states</li>
       <li>Contracts are written in a JVM programming language (e.g. Java or Kotlin)</li>
       <li>Contract execution is deterministic and its acceptance of a transaction is based on
           the transaction's contents alone. A contract should either always accept or always reject 
           a given transaction. Can not depend on the validation date or other contextual info.</li>
       <li><a href='https://docs.corda.net/contract-catalogue.html' xbig>Contract catalogue</a>  provides
           a number of contracts supplied with Corda, which cover both core functionality 
           and provide examples of how to model complex contracts (such as interest rate swaps):
           Cash, Commodity, Commercial paper, Interest rate swap, Obligation</li>
     </ul>
  </td>
  <td col1  >
     <ul>
       <li><a href='https://docs.corda.net/api-contracts.html'>API</a></li>
       <li>All Corda contracts are JVM classes th implement the next interface:
         <pre xsmall>
<b>package net.corda.core.contracts.Contract</b>
@CordaSerializable
interface Contract {
    @Throws(IllegalArgumentException::class)
    fun verify(tx: LedgerTransaction <a href='https://docs.corda.net/api-transactions.html'>/*TX with all signatures*/</a>)   

    val legalContractReference: SecureHash
}
         </pre>
       </li>
     </ul>
</td>
  <td col2  >Example contract using requireSingleCommand() helper method to extract commands:
     <pre xxsmall>
class XContract : Contract {
   interface Commands : CommandData {
       class Issue : TypeOnlyCommandData(), Commands
       class Transfer : TypeOnlyCommandData(), Commands
   }

   override fun verify(tx: LedgerTransaction) {
       val command = tx.commands.<b>requireSingleCommand</b><Commands>()

       when (command.value) {
           is Commands.Issue -> {
               // Issuance verification logic.
           }
           is Commands.Transfer -> {
               // Transfer verification logic.
           }
       }
   }
   override val legalContractReference: SecureHash = 
       SecureHash.sha256("X contract hash")
}
     </pre>
 </td>
</tr }>
<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3>TRANSACTIONS</th>
</tr>
<tr {>
  <td col0 >
     <ul>
       <li><span xbig>Transactions are proposals to update the ledger</span><br/>
           When creating a new transaction, the output states that the transaction will propose
           do NOT exist yet, and must therefore be created by the proposer(s) of the transaction.
       </li>
       <li><a href='https://docs.corda.net/api-transactions.html'>API</a></li>
       <li>A transaction proposal will only be committed if: 
         <ul>
           <li>It doesn't contain double-spends</li>
           <li>It is contractually valid:
             <ol>
               <li>Each state points to a contract</li>
               <li>every input state and every output state considers it to be valid</li>
             </ol>
             Notice that peers can still reject a TX even when it's contractually valid by
             NOT signing it.
           </li>
           <li>It is signed by the required parties</li>
         </ul>
       </li>
       <li>A transaction can contain any number of inputs and outputs of any type:<br/>
     - They can include many different state types (e.g. both cash and bonds)<br/>
     - They can be issuances (have zero inputs) or exits (have zero outputs)<br/>
     - They can merge or split fungible assets (e.g. combining a $2 state and a $5 state into a $7 cash state)
       </li>
       <li>There are two basic types of transactions:<br/>
     - Notary-change transactions (used to change a state’s notary - see Notaries)<br/>
     - General transactions (used for everything else)
       </li>
       <li>TX input states references are a combination of:<br/>
     - The hash of the transaction that created the input<br/>
     - The input’s index in the outputs of the previous transaction</li>
       <li>Once all the required signatures are gathered, the transaction 
         becomes committed meaning:<br/>
         - TX’s inputs are marked as historic, and cannot be used anymore<br/>
         - TX’s outputs become part of the current state of the ledger
       </li>
       <li>TX commands: Including a command in a transaction allows us to
         indicate the transaction’s intent, affecting how we check the
         validity of the transaction.<br/>
     - Each command is also associated with a list of one or more signers.
       By taking the union of all the public keys listed in the commands, 
       we get the list of the transaction’s required signers.</li>
       <li>ATTACHMENTS: Each TX can refer to zero or more attachments by hash.
         These attachments are ZIP/JAR files containing arbitrary content.</li>
       <li>TIME-WINDOWS: specify the time window during which the transaction 
         can be committed</li>
       <li>
         There are four states the transaction can occupy:<br/>
           - TransactionBuilder, a builder for a transaction in construction<br/>
           - WireTransaction, an immutable transaction<br/>
           - SignedTransaction, an immutable transaction with 1+ associated signatures<br/>
           - LedgerTransaction, a transaction that can be checked for validity
       </li>

     </ul>
  </td>
  <td col1  >
     <ul>
       <li> <a href='https://docs.corda.net/api-transactions.html'>Transaction API</a> </li>
       <li>Building a new transaction:
         <pre xsmall>
// Create a TransactionBuilder
val txBuilder: TransactionBuilder = TransactionBuilder(General, specificNotary)
// Creating the inputs (Refs. to previous outputs)
val ourStateAndRef: StateAndRef<DummyState> = serviceHub.toStateAndRef<DummyState>(ourStateRef)
val ourStateRef: StateRef = StateRef(SecureHash.sha256("DummyTransactionHash"), 0)
// Creating the Outputs
val ourOutput: DummyState = DummyState()
val ourOtherOutput: DummyState = ourOutput.copy(magicNumber = 77)

// Creating the command
val ourPubKey: PublicKey = serviceHub.legalIdentityKey
val counterpartyPubKey: PublicKey = counterparty.owningKey
val commandData: DummyContract.Commands.Create = DummyContract.Commands.Create()
val requiredSigners: List<PublicKey> = listOf(ourPubKey, counterpartyPubKey)
val ourCommand: Command<DummyContract.Commands.Create> = Command(commandData, requiredSigners)

// Adding attachements
val ourAttachment: SecureHash = SecureHash.sha256("DummyAttachment")

// Specifying TimeWindow
val ourTimeWindow: TimeWindow = TimeWindow.between(Instant.MIN, Instant.MAX)
val ourAfter: TimeWindow = TimeWindow.fromOnly(Instant.MIN)
val ourBefore: TimeWindow = TimeWindow.untilOnly(Instant.MAX)

txBuilder.withItems( ourStateAndRef, ourOutput, ourCommand, ourTimeWindow)

// Finally sign the transaction with legar identity key. :
val onceSignedTx: SignedTransaction = serviceHub.signInitialTransaction(txBuilder) 
// Alternatively choose other key:
val otherKey: PublicKey = serviceHub.keyManagementService.freshKey()
val onceSignedTx2: SignedTransaction = serviceHub.signInitialTransaction(txBuilder, otherKey)

       </pre>
       </li>
       <li>LedgerTransaction sent to Contract::verify(...):
<pre xsmall>
@CordaSerializable
class LedgerTransaction(
     override val inputs: List&lt;StateAndRef&lt;*>>,
     outputs: List&lt;TransactionState&lt;ContractState>>,
     /** Arbitrary data passed to the program of each input state. */
     // NOTE: AuthenticatedObject pairs a command with a list of signers. 
     val commands: List&lt;AuthenticatedObject&lt;CommandData>>,
     val attachments: List&lt;Attachment>,
     override val id: SecureHash, // for original serialised-Wire-TX
     notary: Party?,
     signers: List&lt;PublicKey>,
     timeWindow: TimeWindow?,
     type: TransactionType
) : BaseTransaction(inputs, outputs, notary, signers, type, timeWindow) {
    ...
}
</pre>
       </li>
     </ul>
  </td>
  <td col2  >requireThat-DSL Example (replacing throw IllegalArgumentException...):<br/>
     <pre xsmall>
requireThat {
    "No inputs should be consumed @ Issue" using (tx.inputs.isEmpty())
    "Only one output state permitted"      using (tx.outputs.size == 1)
    val out = tx.outputs.single() as XState
    "sender == recipient not allowed"      using (out.sender != out.recipient)
    "All participants must be signers"     using (command.signers.containsAll(out.participants))
    "X's value must be >0 "                using (out.x.value > 0)
}
     </pre>



</td>
</tr }>

<!-- ************************************** -->
<tr header_delimit {>
  <th colspan=3><a href='https://docs.corda.net/key-concepts-flows.html'>FLOWS</a></th>

</tr>
<tr {>
  <td col0 >
     <ul>
       <li>Flows automate the process of agreeing ledger updates</li>
       <li>Communication between nodes only occurs in the context of these flows,
      and is point-to-point</li>
       <li>Built-in flows are provided to automate common tasks</li>
       <li>Represents a sequence of steps that tells a node how to 
           achieve a specific ledger update, such as issuing an asset
           or settling a trade</li>
       <li>Unlike contracts, flows do not execute in a 
           sandbox (access to net, disk, time, ...)
       <li>Once a given business process has been encapsulated in a flow 
           and installed on the node as part of a CorDapp, the node's
           owner can instruct the node to kick off this business process 
           at any time using an RPC call. The flow abstracts all the
           networking, I/O and concurrency issues away from the node owner.</li>
       <li>Flows may last days, across node restarts and even upgrades.</li>
       <li>Flow Initiator: Builds new TX (choose notary), signs,
           verify (run its contract), gather counterparty's signature, finalize TX:<br/>
<span mono>
Finalize: 
    → Send TX to notary
        → Wait for notarised TX
             → Record locally 
                → Store states in the vault
                    → Send TX to counterparty for recording
</span>
       </li>
       <li>Responder side:
<span mono>
Verify signatures and contract 
  → Signs
    → send signature back 
      → wait for notarised TX
        → record locally
          → store states in vault
</span>
       </li>
       <li><a href='https://docs.corda.net/flow-library.html' xbig>Flow library</a>
           provides a number of built-int flows supplied with Corda, covering some core
           functionality:
           - FinalityFlow to verify TXs<br/>
           - CollectSignaturesFlow<br/>
           - SendTransactionFlow/ReceiveTransactionFlow
       </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://docs.corda.net/api-flows.html'>Flows API</a></li>
       <li><a href='https://docs.corda.net/api-service-hub.html'>Service Hub API</a>(Accesible inside the FlowLogic::call())
         <ul>
           <li mono>networkMapCache      : Provides information on other nodes on the network</li>
           <li mono>identityService      : Allows to resolve anonymous identities to well-known identities</li>
           <li mono>attachments          : Gives access to the node's attachments</li>
           <li mono>validatedTransactions: Gives access to the TX stored in the node</li>
           <li mono>vaultService         : Stores node's current and historic states</li>
           <li mono>keyManagementService : Manages signing TXs and generating public keys</li>
           <li mono>myInfo               : Other information about the node</li>
           <li mono>clock                : Provides access to node's internal time+date</li>
         </ul>
         Additional, ServiceHub exposes the following properties:
         <ul>
           <li mono>loadState             : resolve a StateRef into a TransactionState</li>
           <li mono>toStateAndRef         : resolve a StateRef into a StateAndRef</li>
           <li mono>signInitialTransaction: signs TransactionBuilder -> SignedTransaction</li>
           <li mono>createSignature       : create signature to a SignedTransaction</li>
           <li mono>addSignature          : add signatures   to a SignedTransaction</li>
           <li mono>legalIdentityKey      : node's legal identity key</li>
           <li mono>notaryIdentityKey     : notary identity key</li>
         </ul>
       </li>
       <li>Additionally, any flow that is started by a SchedulableState must be annotated with the  annotation.
         <ul>
           <li mono>@SchedulableFlow   :If started by an SchedulableState</li>
           <li mono>@InitiatedBy       :Indicates that responds to messages</li>
           <li mono>@InitiatingFlow    :Indicates that can be started "manually"</li>
           <li mono>@StartableByRPC    : Add RPC control</li>
         </ul>
       </li>
       <li>
<pre { >
class Initiator(val arg1: Boolean,
                val arg2: Int,
                val counterparty: Party):
  FlowLogic<SignedTransaction>() {

    @Suspendable &lt;- serializable+restart.
    override fun call() {
      val NMC = serviceHub.networkMapCache
      val x500Name = X500Name("CN=NodeA,O=NodeA,L=London,C=UK")
      // Retrieve counterparties legal identities {
      val namedCounterparty: Party? =
          NMC.getNodeByLegalName       (x500Name   )?.legalIdentity
      val keyedCounterparty: Party? =
          NMC.getNodeByLegalIdentityKey(dummyPubKey)?.legalIdentity
      val firstCounterparty: Party  = 
          NMC.partyNodes[0]                          .legalIdentity
      // }
      // find nodes providing a specific service 
      val regulator: Party = // could be a regulator, oracle,...
          NMC.getNodesWithService(ServiceType.regulator)[0]
                                                     .legalIdentity

      val packet2: UntrustworthyData<Boolean> =
          sendAndReceive<Boolean>(regulator /*counterparty*/, "payload")
      val boolean: Boolean = packet2.unwrap 
          { untrustedData -> ...  return checkedAndTrustedData }
    }
  }
</pre } >
<pre { >
class Responder(val otherParty: Party):
    FlowLogic<Unit>() { ... }
</pre } >
       </li>
       <li>BUILT-IN SUBFLOWS ("BUILDING BLOCKS"):
         <pre >
| SubFlow                  | should be used to 
+--------------------------+-------------------
| CollectSignaturesFlow    | collect TXs required signatures
| SignTransactionFlow      | 
| FinalityFlow             | notarise and record a transaction
| ResolveTransactionsFlow  | verify inputs chain to TX 
| ContractUpgradeFlow      | change a state's contract
| NotaryChangeFlow         | change a state's notary
         </pre>
         Example ussage:
         <pre xxsmall>
(Initiator)Party starts CollectSignatures Subflow | Counterparty
--------------------------------------------------+--------------------------------------------------------------------------------
val fullySignedTx: SignedTransaction =            | 
    subFlow(                                      | val counterParty_SignTransactionFlow: SignTransactionFlow = 
      CollectSignaturesFlow(                      |     object : SignTransactionFlow(counterparty) {
        twiceSignedTx,                            |     override 
        SIGS_GATHERING.childProgressTracker()     |     fun checkTransaction(stx: SignedTransaction) = requireThat {
      )                                           |       ... checking ...
    )                                             |       if (stx_has_dependencies)
                                                  |         subFlow(ResolveTransactionsFlow(twiceSignedTx, counterparty))
                                                  | 
                                                  |       subFlow(ResolveTransactionsFlow(setOf(ourStateRef.txhash), counterparty))
                                                  | 
                                                  |       val outputState = stx.tx.outputsOfType<DummyState>().single()
                                                  |       assert(outputState.magicNumber == 777)
                                                  |     }
                                                  | }
                                                  | subFlow(counterParty_SignTransactionFlow)
--------------------------------------------------+--------------------------------------------------------------------------------

val additionalParties: Set<Party> = setOf(regulator) 
val notarisedTx1: SignedTransaction = 
    subFlow(
      FinalityFlow(               // &lt;- Finalizing Flow
        listOf(fullySignedTx),
        additionalParties /*optional*/,
        FINALISATION.childProgressTracker())
    ).single()
         <pre xxsmall>
       </li>
       <li>ProgressTracker :allows to see the flow's progress visually in our node's CRaSH shell.
           ID_OTHER_NODES->SENDING_AND_RECEIVING_DATA->EXTRACTING_VAULT_STATES->OTHER_TX_COMPONENTS
           ->TX_BUILDING->TX_SIGNING->TX_VERIFICATION->SIGS_GATHERING->VERIFYING_SIGS->FINALISATION
         <pre>
         progressTracker.currentStep = ...
         </pre>
       </li>
     </ul>
  </td>  
  <td col2  ></td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td col0 >
    <span xbig>Node service hub</span> key services provided are:
    <ul>
      <li>Information on other nodes on the network and the services they offer</li>
      <li>Access to the contents of the vault and the storage service</li>
      <li>Access to, and generation of, the node's public-private keypairs</li>
      <li>Information about the node itself</li>
      <li>The current time, as tracked by the node</li>
    </ul>
  </td>
  <td col1  ><span xbig>TRANSACTION TIME-WINDOWS</span> <ul>
       <li>If a transaction includes a time-window, it can only be committed during that window</li>
       <li>The notary is the timestamping authority, refusing to commit transactions outside of that window</li>
       <li>Time-windows can have a start and end time, or be open at either 
     end allowing all of the following situations to be modelled:<br/>
     -A TX occurring at some point after the given time (e.g. after a maturity event)<br/>
     -A TX occurring at any time before the given time (e.g. before a bankruptcy event)<br/>
     -A TX occurring at some point roughly around the given time (e.g. on a specific day)</li>
     </ul>
  </td>
  <td col2  ><span xbig>CONSENSUS</span>
     <ul>
       <li>To be committed, transactions must achieve both validity and uniqueness consensus</li>
       <li>Validity consensus requires contractual validity of the 
      transaction and all its dependencies</li>
       <li>Uniqueness consensus prevents double-spends. 
           This consensus is provided by notaries.</li>
     </ul>
     
  </td>
</tr }>
<!-- ************************************** -->
<tr {>
  <td col0 >
     
  </td>
  <td col1  ><span xbig >(NODE) ORACLES SERVICES</span>
     <ul>
       <li>A fact can be included in a TX as part of a command</li>
       <li>An oracle is a (network) service that will only sign the TX if the included fact is true</li>
       <li> Upon request, an oracle provide commands that encapsulate a specific fact
           (e.g, the exchange rate at time x) and list the oracle as a required signer.</li>
       <li> To sign a transaction, the only information the oracle needs to see is their
           embedded command. Providing any additional transaction data to the oracle would
           constitute a privacy leak. Similarly, a non-validating notary only needs to see
           a transaction's input states.  <br/>
            To combat this, the transaction proposer(s) uses a Merkle tree to "tear off" 
           any parts of the transaction that the oracle/notary doesn't need to see before
           presenting it to them for signing. A Merkle tree is a well-known cryptographic
           scheme that is commonly used to provide proofs of inclusion and data integrity.<br/>
            The advantage of a Merkle tree is that the parts of the transaction that were
           torn off when presenting the transaction to the oracle cannot later be changed 
           without also invalidating the oracle's digital signature.
        </li>
     </ul>
  </td>
  <td col2  ><span xbig>NOTARY SERVICE</span>
     <ul>
       <li>("orderer" in hyperledger or "miner" in bitcoin)</li>
       <li>Notaries prevent "double-spends"</li>
       <li>Notaries may optionally also validate transactions</li>
       <li>A network can have several notaries, each running a different
         consensus algorithm</li>
       <li>notaries may differ in terms of <br/>
      - Structure: a notary may be a single network node,
        a cluster of mutually-trusting nodes, or a cluster of mutually-distrusting nodes<br/>
      - Consensus algorithm: a notary service may choose to run a high-speed, high-trust
        algorithm such as RAFT, a low-speed, low-trust algorithm such as BFT, or any other
        consensus algorithm it chooses
       </li>
       <li>A notary also act as the timestamping authority,</li>
     </ul>
</td>
</tr }>
<!-- ************************************** -->

</table>
</body>
<!--
TODO: Identity Services

TODO: RPC HowTo {  
   Example VaultQueryBy by RPC: (https://docs.corda.net/api-vault-query.html)

   @RPCReturnsObservables
   fun <T : ContractState> vaultQueryBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractType: Class<out T>): Vault.Page<T>

   @RPCReturnsObservables
   fun <T : ContractState> vaultTrackBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort,
       contractType: Class<out T>): DataFeed<Vault.Page<T>, Vault.Update>
}



─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓


- https://docs.corda.net/financial-model.html
  Corda provides a large standard library of data types used in
  financial applications and contract state objects. 
  These provide a common language for states and contracts.
  Amount<Currency>
  Financial states (LinearState, DealState, FungibleAsset)

- Interest rate swaps contract: https://docs.corda.net/contract-irs.html
  
- Node detailed
  NODE
┌──────────────────┐
│TLS       Corda ┬─┼── Net iface interacting 
│cert      RPCOps│ │   with "other nodes" in
│                │ │   a running flow
│                │ │
│                └─┼── RPC node owner
│ ┌────────────┐   │                 User-defined CordApp
│ │ServiceHub  ┼───┼──────────┬──────────────────────────────────────────┐
│ └────────────┘   │          │┌─────────┬──────────┬─────────┐ ┌───────┐│
│ ┌────────────────┤          ││Services │ Contracts│  States │ │Default││
│ │Messaging   ────┼─── Other │├─────────┼──────────┼─────────┤ │Flows  ││
│ ├────────────────┤    Nodes ││Web APIs │ Whitelist│  Flows  │ └───────┘│
│ │Notary?         │          │└─────────┴──────────┴─────────┘          │
│ ├────────────────┤          └──────────────────────────────────────────┘
│ │Network Map?    │
│ ├────────────────┤
│ │Key Management  │
│ ├────────────────┤
│ │Flow SMM        │
│ ├────────────────┤
│ │PLUGIN REGISTRY │←CorDapps extending node functionality
│ ├────────────────┤
│ │    VAULT       │←stores relevant current/historic states sequences 
│ ├────────────────┤
│ │ STORAGE SRV    │←stores [TXs, attachments, flow checkpoints]
└─┴────────────────┘


-->

</html>

