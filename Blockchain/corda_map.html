<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Corda Map (beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>
    <table>
<tr>
<td>
<pre zoom>
<span small>External Refs:</span>
&lt;&lt;aa&gt;&gt;
-*Key Concepts*
@[https://docs.corda.net/key-concepts.html]
 (network, ledger, Identity,
  States, Contracts, TXs, Flows, Consensus,
  Notaries, Time-windows, Oracles, Nodes,..
-*Tradeoffs*
 @[https://docs.corda.net/key-concepts-tradeoffs.html]:
 Permissioned   vs. permissionless
 Point-to-point vs. global broadcasts
 UTXO           vs. account model
 Code-is-law    vs. existing legal systems
 Build          vs. re-use
- Corda sample (tutorial refs):
@[https://github.com/corda/samples]
- Asset Trading(irs-demo):
@[https://docs.corda.net/running-the-demos.html#irs-demo]
- SIMM and Portfolio Demo(aka the Initial Margin Agreement Demo)
@[https://docs.corda.net/running-the-demos.html#simm-demo]

- JAVA   TEMPLATE    :@[https://github.com/corda/cordapp-template-java]
- KOTLIN TEMPLATE    :@[https://github.com/corda/cordapp-template-kotlin]
- Hello World!       :@[tutorial https://docs.corda.net/tutorial-cordapp.html]
- Building a CorDapp :@[https://docs.corda.net/cordapp-build-systems.html]
- API Docs           :@[https://docs.corda.net/api-index.html]
- Official Cheatsheet:@[https://docs.corda.net/cheat-sheet.html]
- Flow cookbook      :@[https://docs.corda.net/flow-cookbook.html]
                      @[how to perform common flow tasks]
- Sample CorDapps    :@[https://www.corda.net/samples/]
</pre>
</td>
<td>
<pre zoom>
<span small>Who is Who</span>
Richard Gendal Brown, current CTO @[https://gendal.me/"]
Mike Hearn,                       @[https://github.com/mikehearn]
Clinton Alexander
Andras Slemmer
Ross Nicoll
Shams Asari
Chris Rankin
Matthew Nesbit
Andrius Dagys
josecoll
Katelyn Baker
Rick Parker
Joel Dudley
Andrzej Cichocki
Michele Sollecito
Patrick Kuo
Viktor Kolomeyko
Tudor Malene
Konstantinos Chalkias
szymonsztuka
...
</pre>
</td>
<td>
<pre zoom>
<span small>Release Notes:</span>
  @[https://docs.corda.net/release-notes.html] Release notes
  @[https://docs.corda.net/changelog.html]     Changelog
  @[https://docs.corda.net/codestyle.html]     Code style guide
  @[https://docs.corda.net/testing.html]       Testing Corda
</pre>
</td>
<td>
<pre zoom>
<span small>Project Code layout:</span>
                            SHOULD BE SPLIT INTO TWO MODULES:
───────────────────────────────────────────┬──────────────────────────────────────────────
1*cordapp─contracts─states*module/CorDapp: │  2*cordapp module/CorDapp: remaining classes*
contracts and states sent over the wire    │  main ─ java ─ com.template
main ─ java ─ com.template                 │  │             TemplateFlow.java (inherits FlowLogic)
              ├── TemplateContract.java    │  │             TemplateSerializationWhitelist.java
              └── TemplateState.java       │  │             (testing env)TemplateApi.java
                                           │  │             (testing env)TemplateClient.java
                                           │  │             (testing env)TemplateWebPlugin.java
                                           │  └─ resources
                                           │     ├─ META─INF ─ services
                                           │     │             net.corda.core.serialization.SerializationWhitelist
                                           │     │             net.corda.webserver.services.WebServerPluginRegistry
                                           │     ├─ certificates
                                           │     └─ templateWeb
                                           │  test ─ java ─ com.template
                                           │                 ContractTests.java
                                           │                 FlowTests.java
                                           │                 NodeDriver.java
                                           │  integrationTest
                                           │  └─ java ─ com.template
                                           │                DriverBasedTest.java
───────────────────────────────────────────┴──────────────────────────────────────────────
</pre>
</td>
</tr>
</table>
<br/>
<span bgorange>BUILDING BLOCKS</span>
<table>
<tr>
<td>
<pre zoom >
<span small>API Core Types</span>
-@[https://docs.corda.net/api-core-types.html]
*SecureHash*:
 - Any object that needs to be identified by its hash
   should implement the NamedByHash interface (TXs, attachments,..)
*interface NamedByHash*{  ← only defines a single sealed subclass:
    val id: SecureHash      SecureHash.SHA256
 }                          (and utility methods to instantiate/parse it)

*CompositeKey*:
 - Allows for complex signature scenarios.
 - Uses public-key composition to organise
   the various public keys into a tree data
   structure, storing the cryptographic
   pub.key primitives in its leaves and the
   composition logic in the intermediary
   nodes.
 - Every intermediary node specifies a
   threshold of how many child signatures
   it requires.
   OR(1)
   ├── Charlie
   └── (2)AND
          │
          ├── Alice (w:2)
          ├── Bob   (w:1)
          └── Mike  (w:1)

│*Signature verification is performed in two stages:
│  Given a list of signatures, each signature is verified against the expected content.
│- public keys corresponding to the signatures are matched against
│  the leaves of the composite key tree in question, and the total combined
│  weight of all children is calculated for every intermediary node.
│- If all thresholds are satisfied, the composite key requirement is considered
│  to be met.
</pre>
</td>

<td>
<pre zoom >
A Corda network is a peer-to-peer network of nodes.

<span small bgorange>NODE SCHEMA:</span>
               Net interface with         RPC        ┌──────────────┬────────────┐  ┌───────────────────────┬───┐
               other nodes in a           with       │*Service hub *│            │  │*permissioning service*│   │
               running flow            node owner    ├──────────────┘            │  ├───────────────────────┘   │
                    ↕                      ↕         │─ allows the node's flows  │  │                           │
┌────────┬──────────╨──────────────────────╨────┐    │  to call upon             │  │                           │
│CORDA   │─ TLS                                 │    │  the node's other services│  │                           │
│SOFTWARE│  certificate                         │    └───────────────────────────┘  └───────────────────────────┘
├────────┘  @"workspace"/certificates/node─TLS ←── represents the node in TXs. The network map service
│         - IP                                  │  maps each well-known node-TLS identity to its IP address
│         - Current time as tracked by node     │
│         - Information on other nodes on the   │
│           network                             │
│       ┌───────────────────────────────────────┤   VAULT SCHEMA:              ┌─ *(Contract) State:*
│       │*STORAGE SRV*                          │   ┌──────────────────────┐   │   @[https://docs.corda.net/key-concepts-states.html]
│       │─ stores [TXs, attachements,           │   │  CONSUMED │  *NON*   │   │   ─ *1: ContractState.kt@Github
│       │  flow─checkpoints]                    │   │ HISTORICAL│ CONSUMED │   │   ─ fact known by one or more Corda nodes at
│       ├───────────────────────────────────────┤   │  STATES   │          │   │     a specific point in time
│       │*VAULT*                                │   │───────────┼──────────│   │   ─ Can contain arbitrary data, allowing them to
│       │─stores relevant current/histor        │  ←│      B0→B1│→ B_head  ←───┘     represent facts of any kind (stocks, bonds,
│       │ state sequences                       │   │A0→A1→A2→A3│→ A_head  │         KYC data, identity information, loans,...).
│       │                                       │   │      C0→C1│→ C_head  │         Ex.o*I owe you*state:
│       ├───────────────────────────────────────┤   └──────────────────────┘         - IOU.contract.ref
│       │*PLUGIN REGISTRY*                      │  - Vault-queries are used to       - participants=[Alice,Bob]
│       │ of installed o*CorDapps*              │    query current/historical        - IOU.state.props
│       │- Preinstaled plugins exists for:      │    states (state "life-cicle")         (From,To)    : (Alice     ,Bob)
│       │  - Retrieving TXs/attachments from    │  - Complex sign.schemas can be         (Amount,Paid): (10$       , 5$)
│       │    counterparties.                    │    used to change the state            (Due,Penalty): (2017-03-01,20%)
│       │  - Upgrading contracts                │  - States are inmutable. The
│       │  - Boradcasting agreed ledger updates │    notary (vs consensus) warrants        ┌─→  Bond  ←─┐
│       │    for recording counterparties       │    no double-spent of states.            │  Contract  │
└───────┴────────↑──────────────────────────────┘  - State change (A0→A1,...) occurs       │     │g*OK* │
                 │                                   after valid TXs:                 ┌────│─────↓──────│────┐
                 │                                   - signature-tree fulfilled       │Bond1 ────────→  Bond2│
                 │                                   - contract of every              │     (afterg*OK*)     │
                 │                                     input/output state is valid.   │Cash1 ────────→  Cash2│
                 │                                   - do*NOT*contains double-spends. └────│─────↑──────│────┘
                 │                                                                         │     │g*OK* │
                 │                                                                         │    Cash    │
                 │                                                                         └─→Contract←─┘
┌────────────────┴───────────────────────────────────────┐┌────────────────────────────────────────────────────────────┐
│o*CorDapp*                                              ││─ Ao*CorDapp*may also need to define two types of plugins:  │
│─ installed at the level of the individual node         ││  ─*CordaPluginRegistry*subclasses overwriting:             │
│  (rather than on the network itself)                   ││    ─ customizeSerialization: set of the classes            │
│─ provide the node with new business processes          ││                              to be whitelisted for         │
│  by defining new flows on the node                     ││                              object serialisation          │
│  (started by the node owner).                          ││    ─ requiredSchemas *1    : set of the MappedSchemas      │
│─ Drives the process of negotiating a specific          ││                              to use for persistence and    │
│┌──────────────────────────────────────────────────────┐││                              vault queries                 │
││developers will usually define:                       │││  ─*WebServerPluginRegistry*subclasses, that can overwrite: │
││─*Flows*    subclassing*FlowLogic*                    │││      ─ webApis          :JAX─RS annotated REST             │
││          @[https://docs.corda.net/api─flows.html]    │││                          access classes list.              │
││                                                      │││      ─ staticServeDirs*2: map of static web content to     │
││─*States*   implementing*ContractState*               │││                           virtual paths                    │
││            States can change through aprobed         │││                        (static web content itself should   │
││            signature trees                           │││                        be placed inside src/main/resources)│
││                                                      │││                                                            │
││─*Contracts*implementing*Contract* logic              │││*1 must be added also to (resources/META─INF/services/)     │
││          @[https://docs.corda.net/api─contracts.html]│││   net.corda.core.node.CordaPluginRegistry                  │
││                                                      │││*2 must be added also to (resources/META─INF/services/)     │
││─*Services* subclassing*SingletonSerializationToken*  │││   net.corda.webserver.services.WebServerPluginRegistry     │
││                                                      ││└────────────────────────────────────────────────────────────┘
││─*Serialisation*implementing*SerializationWhitelist*  ││
││ *whitelist    *                                      ││
│└──────────────────────────────────────────────────────┘│
└────────────────────────────────────────────────────────┘
*1: @[https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/ContractState.kt]
</pre>
</td>
<td>
<pre zoom >
<span small>THE NETWORK</span>
- node-to-node communication uses encrypted TLS + AMQP/1.0
  in a point-to-point approach (vs broadcasts or gossip)
</pre>
</td>
<td>
<pre zoom >
<span small>IDENTITIES</span>
- Well known identities are published in the network map
-*Confidential identities* are only shared on a need to know basis:
  Although there are several elements to the Corda transaction
  privacy model, including ensuring that transactions are only
  shared with those who need to see them, and planned use of
  Intel SGX TEE, it is important to provide defense in depth
  against privacy breaches.
  Confidential identities are used to ensure that even if a
  third party gets access to an unencrypted transaction, they
  cannot identify the participants without additional information.
- Identities in Corda can represent:
  - Legal identity of an organisation
  - Service identity of a network service
</pre>
</td>
<td>
<pre zoom >
<span small>THE LEDGER</span>
@[https://docs.corda.net/key-concepts-ledger.html]
- The ledger is subjective from each peer's perspective:
  Each peer only sees a subset of facts on the ledger
- Two peers are always guaranteed to see the exact same version
  of any on-ledger facts they share
- We can think of the ledger from each node's point of view
  as the set of all the current (i.e. non-historic) states
  that it is aware of.
</pre>
</td>
<td>
<pre zoom>
<span small>(CONTRACT) STATE API</span>AAa
@[https://docs.corda.net/api-states.html]
- interface ContractState { //  or (optimal) sub-interfaces
      val contract: Contract
      val participants: List<AbstractParty>
  }

- @[https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/Structures.kt]
 *interface NamedByHash*
 *interface OwnableState*: ContractState
 *interface Scheduled*
 *interface LinearState*: ContractState      ← object with constant identity over time (facts evolving over time)
 *interface SchedulableState*: ContractState ← allows to schedule future actions for the state (payment on date) (see Event scheduling)
 *interface CommandData*
 *interface MoveCommand*: CommandData
 *interface Contract*
 *interface UpgradedContract*˂in OldState : ContractState, out NewState : ContractState˃ : Contract
 *interface UpgradedContractWithLegacyConstraint˂in OldState... , out NewState˃: UpgradedContract˂OldState, NewState˃

-*interface FungibleAsset*
@[https://github.com/corda/corda/blob/master/core/src/main/kotlin/net/corda/core/contracts/FungibleAsset.kt]
- represent assets that are fungible, countable and issued by a
  specific party (eg. Cash.State and CommodityContract.State in
  the Corda finance module)


-*interface QueryableState*
  - allows to query the state in the node's database using custom attributes (see Persistence)
</pre>
</td>
<td>
<pre zoom>
<span small>VAULTS QUERIES API</span>
- @[https://docs.corda.net/api-vault-query.html]
  The majority of query requirements can be satisfied by using the Vault Query API,
  which is exposed via the VaultQueryService for use directly by flows.
  (See also helper methods).
-*Vault.Page*: use for returning results, object contains:
  - states as a List of «StateAndRef» (page number and size defined by [PageSpecification])
  - states metadata as a List of [Vault.StateMetadata] held in the Vault States table.
  - total number of results available if [PageSpecification] supplied (otherwise returns -1)
  - status types used in this query: UNCONSUMED, CONSUMED, ALL
  - other results (aggregate functions with/without using value groups)

- «QueryCriteria» provides mechanisms for specifying filtering,
  including (AND, OR), (LESS|GREATER)_(THAN|THAN_OR_EQUAL), (NOT_)EQUAL,
  (NOT_)LIKE, (IS_|NOT_)NULL,  (NOT_)IN,  Standard SQL-92 aggregate functs
  (SUM, AVG, MIN, MAX, COUNT)

                              *ONE-TIME VS STREAM QUERY*
┌────────────────────────────────────────┐  ┌───────────────────────────────────────────┐
│ONE─TIME─QUERY                          │  │STREAM (snapshot + Observable stream) QUERY│
├────────────────────────────────────────┤  ├───────────────────────────────────────────┤
│fun ˂T : ContractState ˃ _queryBy(      │  │fun ˂T : ContractState ˃ _trackBy(/        │
│    criteria: QueryCriteria /*filters*/,│  │    criteria: QueryCriteria /* filters */, │
│    paging: PageSpecification,          │  │    paging: PageSpecification,             │
│    sorting: Sort,                      │  │    sorting: Sort,                         │
│    contractType: Class˂out T ˃):       │  │    contractType: Class˂out T ˃):          │
│  Vault.Page˂T ˃                        │  │      DataFeed˂                            │
│                                        │  │          Vault.Page˂T ˃ /*"snapshot"*/,   │
│                                        │  │           Vault.Update /* Observable */ ˃ │
└────────────────────────────────────────┘  └───────────────────────────────────────────┘

4 implementations of QueryCriteria exists which CAN BE CHAINED TOGETHER to define advanced filters
VaultQueryCriteria: filter on attributes within the Vault states table:
   - status (UNCONSUMED, CONSUMED)
   - state reference(s)
   - contract state type(s)
   - notaries
   - soft locked states
   - timestamps (RECORDED, CONSUMED)

FungibleAssetQueryCriteria: filter on    |  LinearStateQueryCriteria: filter on attributes
attributes defined in FungibleAsset      |  defined in «LinearState» and «DealState»
contract state:                          |  contract state
   - participants(s)                     |     - participant(s)
   - owner(s)                            |     - linearId(s)
   - quantity                            |     - dealRef(s)
   - issuer party(s) and/or reference(s) |

VaultCustomQueryCriteria:
   provides the means to specify one or many arbitrary expressions on attributes
   defined by a custom contract state that implements its own schema.
   See the Builder object in QueryCriteriaUtils for a complete specification of the DSL.
</pre>
</td>
<td>
<pre zoom>
<span small>STATE PERSISTENCE (VAULTS) Examples:</span>
Ex.1:*custom query*
  val generalCriteria = VaultQueryCriteria(Vault.StateStatus.ALL)

  val results = builder {
      val currencyIndex = PersistentCashState::currency.equal(USD.currencyCode)
      val quantityIndex = PersistentCashState::pennies.greaterThanOrEqual(10L)

      val customCriteria1 = VaultCustomQueryCriteria(currencyIndex)
      val customCriteria2 = VaultCustomQueryCriteria(quantityIndex)

      val criteria = generalCriteria.and(customCriteria1.and(customCriteria2))
      vaultQuerySvc.queryBy<Cash.State>(criteria)
  }
Ex.2:*Query for all unconsumed states (simplest query possible)*
(UNCOSUMED STATE BY DEFAULT)
----------------------------------------------------------------
val sortAttribute = SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF_TXN_ID)
----------------------------------------------------------------
// recorded in time interval:
val timeIntervalFilter = TimeCondition(
        QueryCriteria.TimeInstantType.RECORDED,
        ColumnPredicate.Between(TODAY, TODAY.plus(30, ChronoUnit.DAYS)) )
----------------------------------------------------------------
VaultQueryCriteria FILTER:
  // state reference list:          | // set of contract state:              | // by notary:                             | // by recorded time  interval
  val criteria = VaultQueryCriteria | val criteria = VaultQueryCriteria      | val criteria = VaultQueryCriteria         | val criteria = VaultQueryCriteria
      (                             |    (                                   |    (                                      |     (
       stateRefs = listOf(          |     contractStateTypes = setOf(        |     notaryName = listOf(CASH_NOTARY.name) |      timeCondition = timeIntervalFilter
               stateRefs.first(),   |                Cash.State::class.java, |    )                                      |     )
               stateRefs.last()  )  |                DealState::class.java)
      )                             |    )

----------------------------------------------------------------
LinearStateQueryCriteria FILTER:
// (unconsumed states) + set of participants:
val criteria = LinearStateQueryCriteria
    (
      participants = listOf(MEGA_CORP, MINI_CORP)
    )
----------------------------------------------------------------
Reading query results:
   val results = vaultQuerySvc.queryBy<DummyLinearContract.State> (
                 criteria,
                 Sort(setOf(
                            Sort.SortColumn(sortAttribute, Sort.Direction.ASC)
                      ) ),
                 paging = PageSpecification(DEFAULT_PAGE_NUM, 10)
               )
   val states   = result.states
   val metadata = result.statesMetadata

Ex.3:*LinearState and DealState queries using LinearStateQueryCriteria*
val linearIds = issuedStates.states.map
        { it.state.data.linearId }.toList()
val       vaultCriteria = VaultQueryCriteria(status = Vault.StateStatus.ALL)
val linearStateCriteria = LinearStateQueryCriteria
    (
     status = Vault.StateStatus.ALL,  // CONSUMED and UNCOSUMED
     linearId = listOf(linearIds.first(), linearIds.last())
     dealRef = listOf("456", "789"), // by deals references:
     participants = parties,
    )
val results = vaultQuerySvc.queryBy<LinearState>(
         linearStateCriteria and vaultCriteria  )

Ex.4:*FungibleAssetQueryCriteria*
val fungibleAssetCriteria = FungibleAssetQueryCriteria(
    quantity = builder { greaterThan(2500L) }, // filter by minimum quantity
    issuerPartyName = listOf(BOC),
)
// Cash.State inherits from ˂FungibleAsset˂*˃˃
val results = vaultQuerySvc.queryBy˂Cash.State˃(fungibleAssetCriteria)
----------------------------------------------------------------------
AGGREGATE FUNCTION

  AGGREGATIONS ON CASH USING VARIOUS FUNCTIONS                              | AGGREGATIONS ON CASH GROUPED BY CURRENCY FOR VARIOUS FUNCTIONS:
  --------------------------------------------------------------------------+----------------------------------------------------------------
  val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum() }     | val sum = builder { CashSchemaV1.PersistentCashState::
  val sumCriteria = VaultCustomQueryCriteria(sum)                           |     pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val sumCriteria = VaultCustomQueryCriteria(sum)
  val count = builder { CashSchemaV1.PersistentCashState::pennies.count() } |
  val countCriteria = VaultCustomQueryCriteria(count)                       | val max = builder { CashSchemaV1.PersistentCashState::
                                                                            |     pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val max = builder { CashSchemaV1.PersistentCashState::pennies.max() }     | val maxCriteria = VaultCustomQueryCriteria(max)
  val maxCriteria = VaultCustomQueryCriteria(max)                           |
                                                                            | val min = builder { CashSchemaV1.PersistentCashState::
  val min = builder { CashSchemaV1.PersistentCashState::pennies.min() }     |     pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
  val minCriteria = VaultCustomQueryCriteria(min)                           | val minCriteria = VaultCustomQueryCriteria(min)
                                                                            |
  val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg() }     | val avg = builder { CashSchemaV1.PersistentCashState::
  val avgCriteria = VaultCustomQueryCriteria(avg)                           |     pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }
                                                                            | val avgCriteria = VaultCustomQueryCriteria(avg)
  val results = vaultQuerySvc.queryBy<FungibleAsset<*>>(
                             sumCriteria .and(countCriteria) .and(maxCriteria) .and(minCriteria) .and(avgCriteria) )
  val (snapshot, updates)  = vaultQuerySvc.trackBy/* stream/observable queries */<FungibleAsset>(...)
</pre>
</td>
</tr>
</table>
<br/>
<table>
<tr>
<td>
<pre zoom>
<span small TODO>PERSISTENCE</span>
- @[https://docs.corda.net/api-persistence.html]
- Corda offers developers the option to expose all or some part of a
  contract state to an Object Relational Mapping (ORM) tool to be persisted
  in a RDBMS. The purpose of this is to assist vault development by effectively
  indexing persisted contract states held in the vault for the purpose of running
  queries over them and to allow relational joins between Corda data and private
  data local to the organisation owning a node.

- Nodes have an internal*«SchemaService»*which decides what to persist and
  what not by selecting the MappedSchema to use.

interface SchemaService {
    data class SchemaOptions(
                 val databaseSchema: String? = null,
                 val tablePrefix   : String? = null)
    val schemaOptions: Map˂MappedSchema, SchemaOptions˃
    fun selectSchemas(state: ContractState): Iterable˂MappedSchema˃
    fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState
}

open class MappedSchema(schemaFamily: Class˂*˃,
                        val version: Int,
                        val mappedTypes: Iterable˂Class˂*˃˃) {
    val name: String = schemaFamily.name
    override fun toString(): String = "${this.javaClass.simpleName}(name=$name, version=$version)"
}
</pre>
</td>
<td>
<pre zoom >
  <span small>CONTRACTS</span>
- @[https://docs.corda.net/api-contracts.html]
- A valid transaction must be accepted by the contract of each of its
  input and output states.
- Written in a JVM programming language (Kotlin,...).
-*Execution is deterministic:*
  - TX acceptance is based on the transaction's contents alone.
  - A contract should either always accept or always reject
    a given transaction. Can not depend on the validation date
    or other contextual info.
-*Contract catalogue* @[https://docs.corda.net/contract-catalogue.html]
  provides a number of contracts supplied with Corda, covering:
  - core functionality
  - examples modeling complex contracts like:
    - Cash
    - Commodity
    - Commercial paper
    - Interest rate swap
    - Obligation
- Can contain legral prose text
-*All Corda contracts implement the next interface*:
 │ *package net.corda.core.contracts.Contract*
 │ @CordaSerializable
 │*interface Contract*{
 │     @Throws(IllegalArgumentException::class)
 │     fun verify(tx: LedgerTransaction )
 │                    ^^^^^^^^^^^^^^^^^
 │                    TX with all signatures
 │                  @[https://docs.corda.net/api─transactions.html]
 │     val legalContractReference: SecureHash
 │ }

*Ex.1: contract using requireSingleCommand() helper method to extract commands*
class XContract : Contract {
  interface Commands : CommandData {
    class Issue : TypeOnlyCommandData(), Commands
    class Transfer : TypeOnlyCommandData(), Commands
  }

  override fun verify(tx: LedgerTransaction) {
    val command = tx.commands.<b>requireSingleCommand</b><Commands>()

    when (command.value) {
      is Commands.Issue -> {
        // Issuance verification logic.
      }
      is Commands.Transfer -> {
        // Transfer verification logic.
      }
    }
  }
  override val legalContractReference: SecureHash =
    SecureHash.sha256("X contract hash")
}
</pre>
<pre zoom>
<span small>requireThat-DSL Example</span>
<span small>(replacing throw IllegalArgumentException...)</span>
requireThat {
    "No inputs should be consumed @ Issue" using (tx.inputs.isEmpty())
    "Only one output state permitted"      using (tx.outputs.size == 1)
    val out = tx.outputs.single() as XState
    "sender == recipient not allowed"      using (out.sender != out.recipient)
    "All participants must be signers"     using (command.signers.containsAll(out.participants))
    "X's value must be ˃0 "                using (out.x.value ˃ 0)
}
</pre>
</td>
<td>
<pre zoom >
<span small>TRANSACTIONS</span>
<span small>(proposals to update ledgers)</span>
- @[https://docs.corda.net/api-transactions.html]
- When creating a new transaction, the output states that the transaction will propose
  do NOT exist yet, and must therefore be created by the proposer(s) of the transaction.
  A transaction proposal will only be committed if:
  - It doesn't contain double-spends
  - It is contractually valid:
    - Each state points to a contract
    - every input state and every output state considers it to be valid
        Notice that peers can still reject a TX even when it's contractually valid by
        NOT signing it.
  - It is signed by the required parties
  - A transaction can contain any number of inputs and outputs of any type:
  - They can include many different state types (e.g. both cash and bonds)
  - They can be issuances (have zero inputs) or exits (have zero outputs)
  - They can merge or split fungible assets
    (e.g. combining a $2 state and a $5 state into a $7 cash state)
  - There are*two basic types of transactions*:
    - Notary-change transactions (used to change a state’s notary - see Notaries)
    - General transactions (used for everything else)
  - TX input states references are a combination of:
    - The hash of the transaction that created the input
    - The input’s index in the outputs of the previous transaction
  - Once all the required signatures are gathered, the transaction
    becomes committed meaning:
    - TX’s inputs are marked as historic, and cannot be used anymore
    - TX’s outputs become part of the current state of the ledger
  - TX commands: Including a command in a transaction allows us to
    indicate the transaction’s intent, affecting how we check the
    validity of the transaction.
  - Each command is also associated with a list of one or more signers.
    By taking the union of all the public keys listed in the commands,
    we get the list of the transaction’s required signers.
  - ATTACHMENTS: Each TX can refer to zero or more attachments by hash.
    These attachments are ZIP/JAR files containing arbitrary content.
  - TIME-WINDOWS: specify the time window during which the transaction
    can be committed
  - There are*four states*the transaction can occupy:
      - TransactionBuilder, a builder for a transaction in construction
      - WireTransaction, an immutable transaction
      - SignedTransaction, an immutable transaction with 1+ associated signatures
      - LedgerTransaction, a transaction that can be checked for validity
</pre>
<pre zoom>
<span small>Transaction API</span>
- @[https://docs.corda.net/api-transactions.html]
  //*BUILD NEW TRANSACTION:*
  val*00txBuilder*: TransactionBuilder =                  // ← Instantiate TX Builder
    TransactionBuilder(General, specificNotary)

  val 01ourStateAndRef: StateAndRef˂DummyState˃ =        // ← Create TX the input
    serviceHub.toStateAndRef˂DummyState˃(ourStateRef)    //   (Refs. to previous outputs)
  val ourStateRef: StateRef =                            // ←
    StateRef(
      SecureHash.sha256("DummyTransactionHash"), 0)

  val*02ourOutput:*DummyState = DummyState()             // ← Create Outputs
  val ourOtherOutput: DummyState =
      02ourOutput.copy(magicNumber = 77)

  //*CREATE THE COMMAND*
  valo*commandData:*DummyContract.Commands.Create =
    DummyContract.Commands.Create()
  valg*requiredSigners*:List˂PublicKey˃ = listOf(
    serviceHub.legalIdentityKey,
    counterparty.owningKey
  )
  val*03ourCommand:*Command˂DummyContract.Commands.Create˃
    = Command(o*commandData*, g*requiredSigners*)

  //*ADDING ATTACHEMENTS*
  val*ourAttachment*: SecureHash =
    SecureHash.sha256("DummyAttachment")

  //*SET TIMEWINDOW*
  val*04ourTimeWindow:*TimeWindow =
    TimeWindow.between(Instant.MIN, Instant.MAX)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Other examples:
  //TimeWindow.fromOnly(Instant.MIN)
  //TimeWindow.untilOnly(Instant.MAX)

  *00txBuilder*.withItems(
     01ourStateAndRef, 02ourOutput, 03ourCommand, 04ourTimeWindow)

  val onceSignedTx: SignedTransaction =             // sign TX with legal id key.
     serviceHub.signInitialTransaction(00txBuilder)
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Alternatively use another key:
  // val otherKey: PublicKey = serviceHub.
  //   keyManagementService.freshKey()
  // val onceSignedTx2: SignedTransaction = serviceHub.signInitialTransaction(txBuilder, otherKey)


*LedgerTransaction sent to Contract::verify(...):* TODO:(0)
@CordaSerializable
class LedgerTransaction(
     override val inputs: List˂StateAndRef˂*˃˃,
     outputs: List˂TransactionState˂ContractState˃˃,
     /** Arbitrary data passed to the program of each input state. */
     // NOTE: AuthenticatedObject pairs a command with a list of signers.
     val commands: List˂AuthenticatedObject˂CommandData˃,
     val attachments: List˂Attachment˃,
     override val id: SecureHash, // for original serialised-Wire-TX
     notary: Party?,
     signers: List˂PublicKey˃,
     timeWindow: TimeWindow?,
     type: TransactionType
) : BaseTransaction(inputs, outputs, notary, signers, type, timeWindow) {
    ...
}
</pre>

</td>
<td>
<pre zoom>
  <span small>FLOWS</span>
-@[https://docs.corda.net/key-concepts-flows.html]
-*Flows automate the process of agreeing ledger updates*
- Communication between nodes only occurs in the context
  of these flows, and is point-to-point
- Built-in flows are provided to automate common tasks
- Represents a sequence of steps that tells a node how to
  achieve a specific ledger update, such as issuing an asset
  or settling a trade
- Unlike contracts, flows do not execute in a sandbox
  (access to net, disk, time, ...)
- Once a given business process has been encapsulated in a flow
  and installed on the node as part of a CorDapp, the node's
  owner can instruct the node to kick off this business process
  at any time using an RPC call. The flow abstracts all the
  networking, I/O and concurrency issues away from the node owner.
- Flows may last days, across node restarts and even upgrades.
- Flow Initiator: Builds new TX (choose notary), signs,
  verify (run its contract), gather counterparty's signature, finalize TX:

                              *FINALIZE:*
  *SENDER SIDE*                          *RESPONDER SIDE*
   01 → Send TX to notary                 01 → Verify signatures and contract
   02 → Wait for notarised TX             02 → Signs
   03 → Record locally                    03 → send signature back
   04 → Store states in the vault         04 → wait for notarised TX
   05 → Send TX to counterparty           05 → record locally
        for recording                     06 → store states in vault

*FLOW LIBRARY*
- @[https://docs.corda.net/flow-library.html]
- provides a number of built-int flows supplied with Corda,
  covering some*core functionality*:
  - FinalityFlow to verify TXs
  - CollectSignaturesFlow
  - SendTransactionFlow/ReceiveTransactionFlow

*FLOWS API*
- @[https://docs.corda.net/api-flows.html]
  -*Service Hub API*
  @[https://docs.corda.net/api-service-hub.html]
   (Accesible inside the FlowLogic::call())
    - networkMapCache      : Provides information on other nodes on the network
    - identityService      : Allows to resolve anonymous identities to well-known identities
    - attachments          : Gives access to the node's attachments
    - validatedTransactions: Gives access to the TX stored in the node
    - vaultService         : Stores node's current and historic states
    - keyManagementService : Manages signing TXs and generating public keys
    - myInfo               : Other information about the node
    - clock                : Provides access to node's internal time+date
    - Additional, ServiceHub exposes the following properties:
        - loadState             : resolve a StateRef into a TransactionState
        - toStateAndRef         : resolve a StateRef into a StateAndRef
        - signInitialTransaction: signs TransactionBuilder → SignedTransaction
        - createSignature       : create signature to a SignedTransaction
        - addSignature          : add signatures   to a SignedTransaction
        - legalIdentityKey      : node's legal identity key
        - notaryIdentityKey     : notary identity key
  - any flow that started by a SchedulableState must be annotated with:
      - @SchedulableFlow   :If started by an SchedulableState
      - @InitiatedBy       :Indicates that responds to messages
      - @InitiatingFlow    :Indicates that can be started "manually"
      - @StartableByRPC    : Add RPC control

class Initiator(val arg1: Boolean,                                      │ class Responder(val otherParty: Party):
                val arg2: Int,                                          │     FlowLogic<Unit>() { ... }
                val counterparty: Party):
  FlowLogic˂SignedTransaction˃() {
    @Suspendable // ← serializable+restart.
    override fun call() {
      val NMC = serviceHub.networkMapCache
      val x500Name = X500Name(
          "CN=NodeA,O=NodeA,L=London,C=UK")
      //*Retrieve counterparties legal identities {*
      val namedCounterparty: Party? =
          NMC.getNodeByLegalName       (x500Name   )?.legalIdentity
      val keyedCounterparty: Party? =
          NMC.getNodeByLegalIdentityKey(dummyPubKey)?.legalIdentity
      val firstCounterparty: Party  =
          NMC.partyNodes[0]                          .legalIdentity
      //*}*

      //*find nodes providing a specific service *
      val regulator: Party = // could be a regulator, oracle,...
          NMC.getNodesWithService(ServiceType.regulator)[0]
                                                     .legalIdentity

      val packet2: UntrustworthyData˂Boolean˃ =
          sendAndReceive˂Boolean˃(regulator /*counterparty*/, "payload")
      val boolean: Boolean = packet2.unwrap
          { untrustedData -˃ ...  return checkedAndTrustedData }
    }
}
</pre>
<pre zoom>
<span small>BUILT-IN SUBFLOWS</span>
<span small>("BUILDING BLOCKS")</span>
┌──────────────────────────┼──────────────────────────────┐
│ SubFlow                  │ should be used to            │
├──────────────────────────┼──────────────────────────────┤
│ CollectSignaturesFlow    │ collect TXs required signs.  │
│ SignTransactionFlow      │                              │
│ FinalityFlow             │ notarise and record a TX     │
│ ResolveTransactionsFlow  │ verify inputs chain to TX    │
│ ContractUpgradeFlow      │ change a state's contract    │
│ NotaryChangeFlow         │ change a state's notary      │
└──────────────────────────┼──────────────────────────────┘

*Example ussage:*
┌───────────────────────────────────────┬───────────────────────────────────────────────────────────┐
│(Initiator)Party starts                │ Counterparty                                              │
│'CollectSignatures'─Subflow            │                                                           │
├───────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│val fullySignedTx: SignedTransaction = │val counterParty_SignTransactionFlow: SignTransactionFlow =│
│    subFlow(                           │    object : SignTransactionFlow(counterparty) {           │
│      CollectSignaturesFlow(           │      override                                             │
│        twiceSignedTx,                 │      fun checkTransaction(stx: SignedTransaction) =       │
│        SIGS_GATHERING.                │        requireThat {                                      │
│          .childProgressTracker()      │          //  ... checking ...                             │
│      )                                │          if (stx_has_dependencies)                        │
│    )                                  │            subFlow(                                       │
│                                       │              ResolveTransactionsFlow(                     │
│                                       │                twiceSignedTx, counterparty))              │
│                                       │                                                           │
│                                       │            subFlow(                                       │
│                                       │              ResolveTransactionsFlow(                     │
│                                       │                setOf(ourStateRef.txhash), counterparty))  │
│                                       │                                                           │
│                                       │        val outputState =                                  │
│                                       │          stx.tx.outputsOfType˂DummyState˃().single()      │
│                                       │        assert(outputState.magicNumber == 777)             │
│                                       │      }                                                    │
│                                       │    }                                                      │
│                                       │subFlow(counterParty_SignTransactionFlow)                  │
└───────────────────────────────────────┴───────────────────────────────────────────────────────────┘





val additionalParties: Set<Party> = setOf(regulator)
val notarisedTx1: SignedTransaction =
    subFlow(
      FinalityFlow(               // &lt;- Finalizing Flow
        listOf(fullySignedTx),
        additionalParties /*optional*/,
        FINALISATION.childProgressTracker())
    ).single()
</pre>

<pre zoom>
<span small>ProgressTracker</span>
- allows to see the flow's progress visually
  in our node's CRaSH shell.
  ID_OTHER_NODES → SENDING_AND_RECEIVING_DATA → EXTRACTING_VAULT_STATES → OTHER_TX_COMPONENTS
  →TX_BUILDING→TX_SIGNING→TX_VERIFICATION→SIGS_GATHERING→VERIFYING_SIGS→FINALISATION
  progressTracker.currentStep = ...
</pre>
</td>
<td>
<ul zoom >
<span small>Node service hub provided services:</span>
- Information on other nodes on the network and the services they offer
- Access to the contents of the vault and the storage service
- Access to, and generation of, the node's public-private keypairs
- Information about the node itself
- The current time, as tracked by the node
</pre>
<pre zoom>
<span small>TX TIME-WINDOWS</span>
- Restrict TX commit to a given time-window
- The notary is the timestamping authority.
  - It will refuse transactions outside of the window
- Time-windows can have a start and end time,
  or be open at either end allowing all of the following
  situations to be modelled:
  -A TX occurring at some point after the given time (e.g. after a maturity event)
  -A TX occurring at any time before the given time (e.g. before a bankruptcy event)
  -A TX occurring at some point roughly around the given time (e.g. on a specific day)
</pre>
<pre zoom>
<span small>CONSENSUS</span>
- To be committed, transactions must achieve both validity and uniqueness consensus
- Validity consensus requires contractual validity of the
  transaction and all its dependencies
- Uniqueness consensus prevents double-spends.
  This consensus is provided by notaries.
</ul>
  (NODE) ORACLES SERVICES
  <ul zoom>
  <li>A fact can be included in a TX as part of a command</li>
  <li>An oracle is a (network) service that will only sign the TX if the included fact is true</li>
  <li> Upon request, an oracle provide commands that encapsulate a specific fact
      (e.g, the exchange rate at time x) and list the oracle as a required signer.</li>
  <li> To sign a transaction, the only information the oracle needs to see is their
      embedded command. Providing any additional transaction data to the oracle would
      constitute a privacy leak. Similarly, a non-validating notary only needs to see
      a transaction's input states.  <br/>
       To combat this, the transaction proposer(s) uses a Merkle tree to "tear off"
      any parts of the transaction that the oracle/notary doesn't need to see before
      presenting it to them for signing. A Merkle tree is a well-known cryptographic
      scheme that is commonly used to provide proofs of inclusion and data integrity.<br/>
       The advantage of a Merkle tree is that the parts of the transaction that were
      torn off when presenting the transaction to the oracle cannot later be changed
      without also invalidating the oracle's digital signature.
  </li>
  </ul>
  NOTARY SERVICE
  <ul zoom>
  <li>("orderer" in hyperledger or "miner" in bitcoin)</li>
  <li>Notaries prevent "double-spends"</li>
  <li>Notaries may optionally also validate transactions</li>
  <li>A network can have several notaries, each running a different
    consensus algorithm</li>
  <li>notaries may differ in terms of <br/>
    - Structure: a notary may be a single network node,
      a cluster of mutually-trusting nodes, or a cluster of mutually-distrusting nodes<br/>
    - Consensus algorithm: a notary service may choose to run a high-speed, high-trust
      algorithm such as RAFT, a low-speed, low-trust algorithm such as BFT, or any other
      consensus algorithm it chooses
  </li>
  <li>A notary also act as the timestamping authority,</li>
  </ul>
</pre>
</td>
</tr>
</table>
<br/>

<span bgorange>Corda Source Code</span>
<table>
<tr>

<td>
<pre zoom>
<span small href="https://github.com/corda/corda/tree/master/core/src/main/kotlin/net/corda/core">net.corda.core</span>
concurrent/
context/
contracts/
cordapp/
crypto/
flows/
identity/
internal/
messaging/
node/
schemas/
serialization/
transactions/
utilities/
ClientRelevantError.kt
CordaException.kt
CordaInternal.kt
CordaOID.kt
DeleteForDJVM.kt
DoNotImplement.kt
KeepForDJVM.kt
StubOutForDJVM.kt
Utils.kt
</pre>
</td>
<td>
<pre zoom>
<span small href="https://github.com/corda/corda/tree/master/core/src/main/kotlin/net/corda/core/contracts">net.corda.core.contracts</span>
Amount.kt
Attachment.kt
AttachmentConstraint.kt
BelongsToContract.kt
ComponentGroupEnum.kt
ContractAttachment.kt
ContractState.kt
ContractsDSL.kt
FungibleAsset.kt
FungibleState.kt
StatePointer.kt
Structures.kt
TimeWindow.kt
TransactionState.kt
TransactionVerificationException.kt
UniqueIdentifier.kt
</pre>
</td>
</tr>
</table>
<br/>
<span bgorange>DevOps</span>
<table>
<tr>
<td>
<pre zoom>
<span small>PERMISSIONING</span>
-@[https://docs.corda.net/permissioning.html]
This certificate maps a well-known node identity to:
A real-world legal identity


The network operator enforces rules regarding the information that nodes must provide and the know-your-customer processes they must undergo before being granted this certificate.

│*CERTIFICATE HIERARCHY*                                                     │ "project"/certificates file
│                                                                            │
│*network─root   CA: ─ Can be deleted after initial registration   ─────────── network─root─truststore.jks
│ │                                                                          │
│ └─*root network CA*: ─ defines the extent of a compatibility zone ─────────────────────── truststore.jks
│    │                 ─ do NOT contain a role extension                     │
│    └─*doorman     CA*: ─ issued/signed by root─network─CA                  │
│       │                ─ used  day─to─day key signing to reduce the .      │
│       │                  risk of the root─CA private key being compromised.│
│       ├─*node       CA*: ─ issued/signed by doorman─CA            ───────────────────── nodekeystore.jks
│       │  │               ─ uses to issue/sign its identity keys            │             sslkeystore.jks
│       │  │               ─ and TLS certificates                            │                         └┬┘
│       │  │               ─ One by node, can issue child certificates       │            jks:Java keystore format
│       │  │               ─ Maps to a legal identity                        │                (may change to support
│       │  │               ─ can set their own role flags on certificates    │                 PKCS#12 keystores in
│       │  │               ─ X509 Name Constrain guarantees uniqueness       │                 a future)
│       │  │                 in the network                                  │
│       │  └─*Legal Identity*: ─ issued/signed by some node─CA               │
│       │     and  TLS certs                                                 │
│       │     │
│       │     │                                                     ┌────────────────────────────────────────────────┐
│       │     └g*Confidential *: ─ issued/signed legal identity     │*CORDA CERTIFICATE ROLE EXTENSION*              │
│       │      g*identity certs* ─ Only applies to TX parties       │─ custom X.509v3 extension specifying the role  │
│       │        ^^^^^^^^^^^^^^    (not used by notaries)           │  the certificate relates to.                   │
│       │  Party certs are marked as                                │  ─ OID is set to 1.3.6.1.4.1.50530.1.1         │
│       │  either a well known legal                                │  ─ non─critical                                │
│       │  or a confidential identity                               │    (can be ignore "outside Corda")             │
│       │                                                           │  ─ A single ASN.1 integer used to tag the role:│
│       └─*Service Identity: Well known (public) identity of        │    ─ Doorman                                   │
│                            a clustered service (notary,...)       │    ─ Network map                               │
                                                                    │    ─ Service identity                          │
┌─────────────────────────────────────────────────────────────────┐ │      (used in distributed notaries)            │
│*key pairs and certificates restrictions*                        │ │    ─ Node certificate authority                │
│ ─ certificates must follow the X.509v3 standard                 │ │      (can issue TLS and identity certs)        │
│                                                                 │ │    ─ Transport layer security                  │
│ ─ The TLS certificates must follow the TLS v1.2 standard        │ │    ─ Well─known legal identity                 │
│                                                                 │ │    ─ Confidential legal identity               │
│ ─ The root network CA, doorman CA, and node CA keys,            │ └────────────────────────────────────────────────┘
│   as well as the node TLS keys, must follow one of the following│ ┌─────────────────────────────────────┐
│   schemes:                                                      │ │The certificate chain linking a      │
│   ─ ECDSA using the NIST P─256 curve (secp256r1)                │ │g*confidential identity*to a node    │
│   ─ ECDSA using the Koblitz k1 curve (secp256k1)                │ │or legal identity is only provided   │
│   ─ RSA with 3072─bit key size or higher                        │ │on a need─to─know─basis.             │
│                                                                 │ │This ensures that even if an attacker│
│ ─ Node CA certificates must have the basic constraints extension│ │gets access to an unencrypted TX,    │
│   set to true                                                   │ │they cannot identify the TX's        │
│                                                                 │ │participants without additional info │
│ ─ The TLS certificates must have the basic constraints extension│ └─────────────────────────────────────┘
│   set to false                                                  │
│                                                                 │
│*NOTE:*In a typical installation, node administrators need not be│
│ aware of these, only if PKI is managed by external tools        │
└─────────────────────────────────────────────────────────────────┘
</pre>
</td>
<td>
<pre zoom >
<span small>Setting Up</span>
Getting Set Up:@[https://docs.corda.net/getting-set-up.html]

*CordApp Example*
$ git clone @[https://github.com/corda/cordapp-example]
$ cd cordapp-example
$ gradlew deployNodes
$ ./kotlin-source/build/nodes/runnodes.sh
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- (Wait until all the terminal windows display either
  "Webserver started up in XX.X sec" or "Node for "NodeC"
  started up and registered in XX.XX sec")
- Test front end at @[http://localhost:10007/web/example/]
</pre>
</td>
<td>
<pre zoom>
<span small>Docker Image</span>
- @[https://github.com/corda/corda/tree/master/docker]
*Summary*
docker run -d --name corda-test-${SALT} --network=host --hostname=127.0.0.1 \
        -e MY_LEGAL_NAME="O=Test-${SALT},L=Berlin,C=DE"     \
        -e MY_PUBLIC_ADDRESS="localhost"       \
        -e NETWORKMAP_URL="http://localhost:8080"    \
        -e DOORMAN_URL="http://localhost:8080"      \
        -e NETWORK_TRUST_PASSWORD="trustpass"       \
        -e MY_EMAIL_ADDRESS="cordauser@r3.com"      \
        -v $(pwd)/network-root-truststore.jks:/opt/corda/certificates/network-root-truststore.jks \
        -e CORDA_ARGS="--log-to-console --no-local-shell" \
        corda/corda-corretto-4.0 config-generator --generic


</pre>


</td>
<td>
<pre zoom>
<span small>NODE PRE-SETUP</span>
<span small>(TLS Setup)</span>
node    → node   :   generates key pair
                   + certificate signing request
node    → doorman: Certificate signing request
doorman → doorman: signs cert *1
doorman → node   : (root-authority-signed) certificate CERT1
node    → node   : creates and signs (using CERT1) two more certs:
                    - TLS certificate
                    - Signing-certificate *2
                    (node’s well-known-identity)
node    → node   : builds node-info-record
                   address well-known-identity
node    → network: register node-info-record
          map srv
...
node    → ??? : establish TLS session using certificate

  * CERT: X.509 certificate
  * 1: or forwards to well known signing authority
  * 2: an organisation can further use the
       Signing-certificate to create both
       well-known and confidential identities.
</pre>
</td>

</tr>
</table>
</body>
<!--
TODO: Identity Services

TODO: RPC HowTo {
   Example VaultQueryBy by RPC: (https://docs.corda.net/api-vault-query.html)

   @RPCReturnsObservables
   fun <T : ContractState> vaultQueryBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractType: Class<out T>): Vault.Page<T>

   @RPCReturnsObservables
   fun <T : ContractState> vaultTrackBy(
       criteria: QueryCriteria, paging: PageSpecification, sorting: Sort,
       contractType: Class<out T>): DataFeed<Vault.Page<T>, Vault.Update>
}


- https://docs.corda.net/financial-model.html
  Corda provides a large standard library of data types used in
  financial applications and contract state objects.
  These provide a common language for states and contracts.
  Amount<Currency>
  Financial states (LinearState, DealState, FungibleAsset)

- Interest rate swaps contract: https://docs.corda.net/contract-irs.html

- Node detailed
  NODE
┌──────────────────┐
│TLS       Corda ┬─┼── Net iface interacting
│cert      RPCOps│ │   with "other nodes" in
│                │ │   a running flow
│                │ │
│                └─┼── RPC node owner
│ ┌────────────┐   │                 User-defined CordApp
│ │ServiceHub  ┼───┼──────────┬──────────────────────────────────────────┐
│ └────────────┘   │          │┌─────────┬──────────┬─────────┐ ┌───────┐│
│ ┌────────────────┤          ││Services │ Contracts│  States │ │Default││
│ │Messaging   ────┼─── Other │├─────────┼──────────┼─────────┤ │Flows  ││
│ ├────────────────┤    Nodes ││Web APIs │ Whitelist│  Flows  │ └───────┘│
│ │Notary?         │          │└─────────┴──────────┴─────────┘          │
│ ├────────────────┤          └──────────────────────────────────────────┘
│ │Network Map?    │
│ ├────────────────┤
│ │Key Management  │
│ ├────────────────┤
│ │Flow SMM        │
│ ├────────────────┤
│ │PLUGIN REGISTRY │←CorDapps extending node functionality
│ ├────────────────┤
│ │    VAULT       │←stores relevant current/historic states sequences
│ ├────────────────┤
│ │ STORAGE SRV    │←stores [TXs, attachments, flow checkpoints]
└─┴────────────────┘
_______________________________________________
<a href="https://towardsdatascience.com/the-difference-between-blockchains-distributed-ledger-technology-42715a0fa92">
  The Difference Between Blockchains &amp; Distributed Ledger Technology</a>

<a href="https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16">
  Blockchain vs. Distributed Ledger Technologies</a>

<a href="http://www.r3cev.com/blog/2017/2/24/when-is-a-blockchain-not-a-blockchain">When is a Blockchain not a Blockchain</a>

<a href="https://www.linkedin.com/pulse/thoughts-taxonomy-blockchains-distributed-ledger-colin-platt/">Thoughts on the taxonomy of blockchains &amp; distributed ledger technologies</a>

<a href="https://www.cointelligence.com/content/when-do-you-need-blockchain/">When do you need Blockchain</a>

<a href="https://hackernoon.com/blockchains-versus-traditional-databases-c1a728159f79">Blockchain versus Traditional Databases</a>

<a href="https://www.coindesk.com/information/what-is-the-difference-blockchain-and-database/">What is the Difference Between a Blockchain and a Database?</a>

<a href="https://hbr.org/2017/01/the-truth-about-blockchain">The Truth About Blockchain</a>
-->

</html>

