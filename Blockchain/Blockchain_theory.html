<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>changeme title</title>
<!--
 Q:Note what the attribute { and } do:
 A:Those attributes are ignored by the browser but are helpful to fold/unfold text in some
   editors (Vim, Emacs,...)
-->
<!--
TABLE TEMPLATE
<table { >
<tr {>
  <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td>
</tr }>
<tr {>
  <td col1 colspan=6 >
    <ul>
      <li>
      </li>
    </ul>
  </td>  
  <td col2 colspan=6 >
  </td>  
</tr }>
</table } >
-->

<head>
<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 
function onTDDoubleClick()      { zoomDivDOM.innerHTML = 
     "('Esc' to close) Toggle "+
     "<span style='color:blue;' onClick=\"zoomDivFW  = !zoomDivFW ; zoomDivDOM.style.maxWidth  = zoomDivFW  ? '98%' : '30%'\">[Width]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivFH  = !zoomDivFH ; zoomDivDOM.style.maxHeight = zoomDivFH  ? '98%' : '30%'\">[Height]</span> " 
   + " Toggle " 
   + "<span style='color:blue;' onClick=\"zoomDivLft = !zoomDivLft; zoomDivDOM.style.left      = zoomDivLft ? '1%'  : '69%'\">[Horz]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivTop = !zoomDivTop; zoomDivDOM.style.top       = zoomDivTop ? '1%'  : '69%'\">[Vert]</span> " 
   + " <br/> " 
   + this.innerHTML; 
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
  removeToLeftMarginInPre();
}
</script>
<style { >
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
* xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<table { >
<tr {>
  <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td>
</tr }>
<tr {>
  <td col1 colspan=6 >
    <ul>
      <li>
      </li>
    </ul>
  </td>  
  <td col2 colspan=6 >
  </td>  
</tr }>
</table } >
</body>
<!-- {
TODO:
__________________________________
Vocabulary:
{
Ricardian Contract:
  http://iang.org/papers/ricardian_contract.html
  "method  of  recording  a  document  as  a  contract  at  law,  and  linking  it  securely  to  other systems such as accounting for the contract as an issuance of value [24]. It holds three properties:
  i  )  robust: use of identification by Cryptographic hash function.
  ii )  transparent: use of readable text for legal prose.
  iii)  efficient:  use  of  mark-up  language  to  extract  essential information.
  
  “A Ricardian Contract can be defined as a single document that  is  
    a)  a  contract  offered  by  an  issuer  to  holders,  
    b)  for  a valuable right held by holders, and managed by the issuer, 
    c) easily readable by people (like a contract on paper), 
    d) readable by programs (parsable like a database), 
    e) digitally signed, 
    f) carrying the keys and server information, and 
    g) allied with a unique and secure identifier” [24]"
  method  of  recording  a  document  as  a  contract  at  law,  and  linking  it  securely  to  other systems such as accounting for the contract as an issuance of value [24]. It holds three properties:
  
    i  )  robust: use of identification by Cryptographic hash function.
    ii )  transparent: use of readable text for legal prose.
    iii)  efficient:  use  of  mark-up  language  to  extract  essential information.
  
  “A Ricardian Contract can be defined as a single document that  is  
    a)  a  contract  offered  by  an  issuer  to  holders,  
    b)  for  a valuable right held by holders, and managed by the issuer, 
    c) easily readable by people (like a contract on paper), 
    d) readable by programs (parsable like a database), 
    e) digitally signed, 
    f) carrying the keys and server information, and 
    g) allied with a unique and secure identifier” [24]
_______
Trust  Contracts:
  Smart Contracts on Ethereum are based on Turing-complete
  language  (able  to  answer  computable  problem  given  enough
  time  and  space).  Using  a  fees  mechanism  called  “Gas”  is
  garanteed  that  it  will  not  run  forever.  But  some  researchers
  claim  that  this  can  bring  some  problems.  Park  et  Al.  [26],
  propose a new system called Boscoin
  14
  . They instead propose
  the use of “Trust Contracts”, since Turing-Complete ones are
  inherently undecidable and difficult to be read by non-technical
  people,  therefore  it  is  not  easy  to  know  what  a  contract  will
  do before running it.
  Trust  contracts  are  based  on  OWL  and  TAL  (Timed  Au-
  tomata  Language).  OWL  provides  the  structure  of  data  and
  TAL  acts  as  an  operator.  These  contracts  are  decidable,  easy
  to read and is possible to determine the amount of time it takes
  to run [26].
_____
Lamport signatures   quantum-proof cryptographic signatures
_____
Cifrado homomórfico: http://enigma.media.mit.edu/
                     http://www.xataka.com/privacidad/enigma-renace-el-cifrado-homomorfico-y-el-blockchain-como-base-de-una-internet-mas-privada

}
__________________________________
Mining algorithms compared:
REF: https://themerkle.com/scrypt-vs-x11-vs-sha-256/


With several thousand cryptocurrencies in existence right now, it is not surprising to learn a lot of coins use different mining algorithms. Whereas bitcoin uses SHA-256, other coins may use the likes of X11, Keccak, or Scrypt-N. All of these algorithms have their own benefits and requirements to keep mining competitive. Below are some of the different mining algorithms to be found today, and how they compare to one another.

Scrypt vs SHA256 vs ScryptNf X11 X13 Keccak X15 Nist5 NeoScrypt Lyra2RE WhirlpoolX Qubit Quark Axiom Lyra2REv2 
ScyrptJaneNf16 ...

__________________________________
Semantic BlockChain:
   https://semanticblocks.files.wordpress.com/2017/03/linked_blockchain_paper.pdf

   https://docs.google.com/presentation/d/112KMqjwMR820jVf9CF-GLeNneUxb9qpo5j70mUgYErg/edit#slide=id.p

__________________________________
{
http://iang.org/papers/triple_entry.html

    Abstract: The digitally signed receipt, an innovation from financial cryptography, presents a challenge to classical double entry bookkeeping. Rather than compete, the two melded together form a stronger system. Expanding the usage of accounting into the wider domain of digital cash gives 3 local entries for each of 3 roles, the result of which I call triple entry accounting.

    This system creates bullet proof accounting systems for aggressive uses and users. It not only lowers costs by delivering reliable and supported accounting, it makes much stronger governance possible in a way that positively impacts on the future needs of corporate and public accounting.

Introduction

This paper brings together financial cryptography innovations such as the Signed Receipt with the standard accountancy techniques of double entry bookkeeping.

The first section presents a brief backgrounder to explain the importance of double entry bookkeeping. It is aimed at the technologist, and accountancy professionals may skip this. The second section presents how the Signed Receipt arises and why it challenges double entry bookkeeping.

The third section integrates the two together and the Conclusion attempts to predict wider ramifications into Governance issues.
Credits

This paper benefitted from comments by Graeme Burnett and Todd Boyle [TB].
A Very Brief History of Accounting

Accounting or accountancy is these days thought to go back to the genesis of writing; the earliest discovered texts have been deciphered as simple lists of the counts of animal and food stock. The Sumerians of Mesopotamia, around 5000 years ago, used Cuneiform or wedge shaped markings as a base-60 number form, which we still remember as seconds and minutes, and squared, as the degrees in a circle. Mathematics and writing themselves may well have been derived from the need to add, subtract and indeed account for the basic assets and stocks of early society.
Single Entry

Single entry bookkeeping is how 'everyone' would do accounting: start a list, and add in entries that describe each asset. A more advanced arrangement would be to create many lists. Each list or 'book' would represent a category, and each entry would record a date, an amount, and perhaps a comment. To move an asset around, one would cross it off from one list and enter it onto to another list.

Very simple, but it was a method that was fraught with the potential for errors. Worse, the errors could be either accidental, and difficult to track down and repair, or they could be fraudulent. As each entry or each list stood alone, there was nothing to stop a bad employee from simply adding more to the list; even when discovered there was nothing to say whether it was an honest mistake, or a fraud.

Accounting based on single entry bookkeeping places an important limitation on the trust of the books. Likely, only the owner's family or in times long past, his slaves could be trusted with the enterprise's books, leading to a supportive influence on extended families or slavery as economic enterprises.
Double Entry

Double Entry bookkeeping adds an additional important property to the accounting system; that of a clear strategy to identify errors and to remove them. Even better, it has a side effect of clearly firewalling errors as either accident or fraud.

This property is enabled by means of three features, being the separation of all books into two groups or sides, called assets and liabilities, the redundancy of the duplicative double entries with each entry having a match on the other side, and the balance sheet equation, which says that the sum of all entries on the asset side must equal the sum of all entries on the liabilities side.

A correct entry must refer to its counterparty, and its counterpart entry must exist on the other side. An entry in error might have been created for perhaps fraudulent reasons, but to be correct at the local level, it must refer to its counterparty book. If not, it can simply be eliminated as an incomplete entry. If it does refer, the existance of the other entry can be easily confirmed, or indeed recreated depending on the sense of it, and the loop is thus closed.

Previously, in single entry books, the fraudster simply added his amount to a column of choice. In double entry books, that amount has to come from somewhere. If it comes from nowhere, it is eliminated above as an accidental error, and if it comes from somewhere in particular, that place is identified. In this way, fraud leaves a trail; and its purpose is revealed in the other book because the value taken from that book must also have come from somewhere.

This then leads to an audit strategy. First, ensure that all entries are complete, in that they refer to their counterpart. Second, ensure that all movements of value make sense. This simple strategy created a record of transactions that permitted an accountancy of a business, without easily hiding frauds in the books themselves.
Which Came First - Double Entry or the Enterprise?

Double Entry bookkeeping is one of the greatest discoveries of commerce, and its significance is difficult to overstate. Historians think it to have been invented around the 1300s AD, although there are suggestions that it existed in some form or other as far back as the Greek empire. The earliest strong evidence is a 1494 treatise on mathematics by the Venetian Friar Luca Pacioli [LP]. In his treatise, Pacioli documented many standard techniques, including a chapter on accounting. It was to become the basic text in double entry bookkeeping for many a year.

Double Entry bookkeeping arose in concert with the arisal of modern forms of enterprise as pioneered by the Venetian merchants. Historians have debated whether Double Entry was invented to support the dramatically expanded demands of the newer ventures then taking place surrounding the expansion of city states such as Venice or whether Double Entry was an enabler of this expansion.

Our experiences weigh in on the side of enablement. I refer to the experiences of digital money issuers. Our own first deployment of a system was with a single entry bookkeeping system. Its failure rate even though coding was tight was such that it could not sustain more than 20 accounts before errors in accounting crept in and the system lost cohesion. This occurred within weeks of initial testing and was never capable of being fielded. The replacement double entry system was fielded in early 1996 and has never lost a transaction (although there have been some close shaves [IG1]).

Likewise, the company DigiCash BV of the Netherlands fielded an early digital cash system into a bank in the USA. During its testing period, the original single entry accounting system had to be field replaced with a double entry system for the same reason - errors crept in and rendered the accounting underneath the digital cash system unreliable.

Another major digital money system lasted for many years on a single entry accounting system. Yet, the company knew it was running on luck. When a cracker managed to find a flaw in the system, an overnight attack allowed the creation of many millions of dollars worth of value. As this was more than the contractual issue of value to date, it caused dramatic contortions to the balance sheet, including putting it in breach of its user contract and at dire risk of a 'bank run'. Luckily, the cracker deposited the created value into the account of an online game that failed shortly afterwards, so the value was able to be neutralised and monetarily cleansed, without disclosure, and without scandal.

In the opinion of this author at least, single entry bookkeeping is incapable of supporting any enterprise more sophisticated than a household. Given this, I suggest that evolution of complex enterprises required double entry as an enabler.
Computing Double Entry in Quick Time

Double Entry has always been the foundation of accounting systems for computers. The capability to detect, classify and correct errors is even more important to computers than it is to humans, as there is no luxury of human intervention; the distance between the user and the bits and bytes is far greater than the distance between the bookkeeper and the ink marks on his ledgers.

How Double Entry is implemented is a subject in and of itself. Computer science introduces concepts such as transactions, which are defined as units of work that are atomic, consistent, isolated, and durable (or ACID for short). The core question for computer scientists is how to add an entry to the assets side, then add an entry to the liabilities side, and not crash half way through this sequence. Or even worse, have another transaction start half way through. This makes more sense when considered in the context of the millions of entries that a computer might manage, and a very small chance that something goes wrong; eventually something does, and computers cannot handle errors of that nature very well.

For the most part, these concepts simply reduce to "how do we implement double entry bookkeeping" ? As this question is well answered in the literature, we do no more than mention it here.
A Slightly Less Brief History of the Signed Receipt

Recent advances in financial cryptography have provided a challenge to the concept of double entry bookkeeping. The digital signature is capable of creating a record with some strong degree of reliabilty, at least in the senses expressed by ACID, above. A digital signature can be relied upon to keep a record safe, as it will fail to verify if any details in the record are changed.

If we can assume that the the record was originally created correctly, then later errors are revealed, both of an accidental nature and of fraudulent intent. (Computers very rarely make accidental errors, and when they do, they are most normally done in a clumsy fashion more akin to the inkpot being spilt than a few numbers.) In this way, any change to a record that makes some sort of accounting or semantic sense is almost certainly an attempt at fraud, and a digital signature makes this obvious.
The Digital Signature and Digital Cash

A digital signature gives us a particular property, to whit:

    "at a given point in time, this information was seen and marked by the signing computer." 

There are several variants, with softer and harder claims to that property. For example, message digests with entanglement form one simple and effective form of signature, and public key cryptosystems provide another form where signers hold a private key and verifiers hold a public key [MB]. There are also many ways to attack the basic property. In this essay I avoid comparisons, and assume the basic property as a reliable mark of having been seen by a computer at some point in time.

Digital signatures then represent a new way to create reliable and trustworthy entries, which can be constructed into accounting systems. At first it was suggested that a variant known as the blinded signature would enable digital cash [DC]. Then, certificates would circulate as rights or contracts, in much the same way as the share certificates of old and thus replace centralised accounting systems [RAH]. These ideas took financial cryptography part of the way there. Although they showed how to strongly verify each transaction, they stopped short of placing the the digital signature in an overall framework of accountancy and governance. A needed step was to add in the redundancy implied in double entry bookkeeping in order to protect both the transacting agents and the system operators from fraud.
The Initial Role of a Receipt

1: An Interim Receipt
From         Alice
To         Bob
Unit         Euro
Quantity         100
Date         2005.12.25
digital signature

Designs that derived from the characteristics of the Internet, the capabilities of cryptography and the needs of governance led to the development of the signed receipt [GH]. In order to develop this concept, let us assume a simple three party payment system, wherein each party holds an authorising key which can be used to sign their instructions. We call these players Alice, Bob (two users) and Ivan (the Issuer) for convenience.

When Alice wishes to transfer value to Bob in some unit or contract managed by Ivan, she writes out the payment instruction and signs it digitally, much like a cheque is dealt with in the physical world. She sends this to the server, Ivan, and he presumably agrees and does the transfer in his internal set of books. He then issues a receipt and signs it with his signing key. As an important part of the protocol, Ivan then reliably delivers the signed receipt to both Alice and Bob, and they can update their internal books accordingly.
The Receipt is the Transaction

Our concept of digital value sought to eliminate as many risks as possible. This was derived simply from one of the high level requirements, that of being extremely efficient at issuance of value. Efficiency in digital issuance is primarily a function of support costs, and a major determinant of support costs is the costs of fraud and theft.

One risk that consistently blew away any design for efficient digital value at reasonable cost was the risk of insider fraud. In our model of many users and a single centralised server, the issuers of the unit of digital value (as signatory to the contract) and any governance partners such as the server operators are powerful candidates for insider fraud. Events over the last few years such as the mutual funds and stockgate scandals are canonical cases of risks that we decided to address.

2: A Signed Receipt
User's Cheque         
From         Alice
To         Bob
Unit         Euro
Qty         100
Com         Pens
Alice's sig
From         Alice
To         Bob
Unit         Euro
Quantity         100
Date         2005.04.10
Ivan's signature

In order to address the risk of insider fraud, the written receipt was historically introduced as being a primary source of evidence. Mostly forgotten to the buying public these days, the purpose of a written receipt in normal retail trade is not to permit returns and complaints by the customer, but rather to engage her in a protocol of documentation that binds the shop attendant into safekeeping of the monies. A good customer will notice fraud by the shop attendant and warn the owner to look out for the monies identified by the receipt; the same story applies to the invention of the cash till or register, which was originally just a box separating the owner's takings from the monies in the shop attendant's pockets. We extend this primary motive into the digital world by using a signed receipt to bind the Issuer into a governance protocol with the users.

We also go several steps further forward. Firstly, to achieve a complete binding, Alice's original authorisation is also included within the record. The receipt then includes all the evidence of both the user's intention and the server's action in response, and it now becomes a dominating record of the event. This then means that the most efficient record keeping strategy is to drop all prior records and keep safe the signed receipt.

This domination effects both the Issuer and the user, and allows us to state the following principle:

    The User and the Issuer hold the same information. 

As the signed receipt is delivered from Issuer to both users, all three parties hold the same dominating record for each event. This reduces support costs by dramatically reducing problems caused by differences in information.

Secondly, we bind a signed contract of issuance known as a Ricardian Contract into the receipt [IG2]. This invention relates a digitally signed document securely to the signed receipt by means of a unique identifier called a message digest, again provided by cryptography. It provides strong binding for the unit of account, the nature of the issue, the terms, conditions and promises being made by the Issuer, and of course the identity of the Issuer.

Finally, with these enabling steps in place, we can now introduce the principle:

    The Receipt is the Transaction. 

Within the full record of the signed receipt, the user's intention is expressed, and is fully confirmed by the server's response. Both of these are covered by digital signatures, locking these data down. A reviewer such as an auditor can confirm the two sets of data, and can verify the signatures.
The Signed Receipt as a Bookkeeping system

The principle of the Receipt as the Transaction has become sacrosact over time. In our client software, the principle has been hammered into the design consistently, resulting in a simplified accounting regime, and delivering a high reliability. Issues still remain, such as the loss of receipts and the counting of balances by the client side software, but these become reasonably tractable once the goal of receipts as transactions is placed paramount in the designer's mind.
As Single Entry

In order to calculate balances on a related set of receipts, or to present a transaction history, a book would be constructed on the fly from the set. This amounts to using the Signed Receipt as a basis for single entry bookkeeping. In effect, the bookkeeping is derived from the raw receipts, and this raises the question as to whether to keep the books in place.

The principles of Relational Databases provide guidance here. The fourth normal form directs that we store the primary records, in this case the set of receipts, and we construct derivative records, the accounting books, on the fly [4NF].
Recovering Double Entry

Similar issues arise for Ivan the Issuer. The server has to accept each new transaction on the basis of the available balance in the effected books; for this reason Ivan needs those books to be available efficiently. Due to the greater number of receipts and books (one for each user account), both receipts and books will tend to exist, in direct contrast to fourth normal form. A meld between relationally sound sets of receipts and double entry books comes to assist here.

Alice and Bob both are granted a book each within the server's architecture. As is customary, we place those books on the liabilities side. Receipts then can be placed in a separate single book and this could be logically placed on the assets side. Each transaction from Alice to Bob now has a logical contra entry, and is then represented in 3 places within the accounts of the server. Yet, the assets side remains in fourth normal form terms as the liabilities entries are derived, each pair from one entry on the assets side.

By extension, a more sophisticated client-side software agent, working for Alice or Bob, could employ the same techniques. At this extreme, entries are now in place in three separate locations, and each holding potentially three records.
Triple Entry Accounting

The digitally signed receipt, with the entire authorisation for a transaction, represents a dramatic challenge to double entry bookkeeping at least at the conceptual level. The cryptographic invention of the digital signature gives powerful evidentiary force to the receipt, and in practice reduces the accounting problem to one of the receipt's presence or its absence. This problem is solved by sharing the records - each of the agents has a good copy.

In some strict sense of relational database theory, double entry book keeping is now redundant; it is normalised away by the fourth normal form. Yet this is more a statement of theory than practice, and in the software systems that we have built, the two remain together, working mostly hand in hand.

Which leads to the pairs of double entries connected by the central list of receipts; three entries for each transaction. Not only is each accounting agent led to keep three entries, the natural roles of a transaction are of three parties, leading to three by three entries.

We term this triple entry bookkeeping. Although the digitally signed receipt dominates in information terms, in processing terms it falls short. Double entry book keeping fills in the processing gap, and thus the two will work better together than apart. In this sense, our term of triple entry bookkeeping recommends an advance in accounting, rather than a revolution.
Software Considerations

The precise layout of the entries in software and data terms is not settled, and may ultimately become one of those ephemeral implementation issues. The signed receipts may form a natural asset-side contra account, or they may be a separate non-book list underlying the bookkeeping system and its two sides.

Auditing issues arise where construction of the books derives from the receipts, and normalisation issues arise when a receipt is lost. These are issues for future research.

Likewise, it is worth stating that the technique of signing receipts works both with private key signatures and also with entanglement message digest signatures; whether the security aspects of these techniques is adequate to task is dependent on the business environment.
Roles of the Agents

It will be noted that the above design of triple entry bookkeeping assumed that Alice and Bob were agents of some independence. This was made possible, and reflected the usage of the system as a digital cash system, and not as a classical accounting system.

Far from reducing the relevance of this work to the accounting profession, it introduces digital cash as an alternate to corporate bookkeeping. If an accounting system for a corporation or other administrative entity is recast as a system of digital cash, or internal money, then experience shows that benefits accrue to the organisation.

Although the core of the system looks exactly like an accounting system, each department's books are pushed out as digital cash accounts. Departments no longer work so much with budgets as have control over their own corporate money. Fundamental governance control is still held within the accounting department by dint of their operation of the system, and by the limited scope of the money as only being usable within the organisation; the accounting department might step in as a market maker, exchanging payments in internal money for payments in external money to outside suppliers.

We have operated this system on a small scale. Rather than be inefficient on such a small scale, the system has generated dramatic savings in coordination. No longer are bills and salaries paid using conventional monies; many transactions are dealt with by internal money transfers and at the edges of the corporation, formal and informal agents work to exchange between internal money and external money. Paperwork reduces dramatically, as the records of the money system are reliable enough to quickly resolve questions even years after the event.

The innovations present in internal money go beyond the present paper, but suffice to say that they answer the obvious question of why this design of triple entry accounting sprung from the world of digital cash, and has relevence back to the corporate world.
Patterns of Commerce

Todd Boyle looked at a similar problem from the point of view of small business needs in an Internet age, and reached the same conclusion - triple entry accounting [1]. His starting premises were that:

    The major need is not accounting or payments, per se, but patterns of exchange - complex patterns of trade;

    Small businesses could not afford large complex systems that understood these patterns;

    They would not lock themselves into proprietary frameworks; 

From those foundations, Boyle concluded that therefore what is needed is a shared access repository that provides arms-length access. Fundamentally, this repository is akin to the classic double-entry accounting ledger of transaction rows ("GLT" for General Ledger - Transactions), yet its entries are dynamic and shared.

Simple examples will help. When Alice forms a transaction, she enters it into her software. Every GLT transaction requires naming her external counterparty, Bob. When she posts the transaction, her software stores it in her local GLT and also submits it to the shared repository service's GLT.

The Shared Transaction Repository ("STR") then forwards the transaction on to Bob. Both Bob and Alice are now expected to store the handle to the transaction as an index or stub, and the STR then stores the entire transaction.

Boyle's ideas are logically comparable to Grigg and Howland's, although they arive from different directions (the STR is Grigg's Ivan, above) and are not totally equivalent. Where the latter limited themselves to payments, the accuracy of amounts, and protection with hard cryptographic shells, Boyle looked at wider patterns of transactions, and showed that the STR could mediate these transactions, if the core shared data could be extracted and made into a single shared record. Boyle's focus was on the economic substance of the transaction.
Extending the Humble Invoice

Imagine a simple invoicing procedure. Alice creates an invoice and posts it to her software (GLT). As she has named Bob, the GLT automatically posts it to Ivan, the STR, and he forwards it to Bob. At this point Bob has a decision to make, accept or reject. Assuming acceptance, his software can then respond by sending an acceptance message to Ivan. The STR now assembles an accepted invoice record to replace the earlier speculative invoice record and posts that threeways. At some related time (to do with payment policy) Bob also posts a separate transaction to pay for the invoice. This could operate in much the same way as a separate transaction, linking directly to the original invoice.

Now, as the payment links back, and the invoice is a live transaction within the three entries in the three accounting systems, it is possible for a new updated invoice record to refer back to the payment activity. When the payment clears, the new record can again replace the older unpaid copy and promulgate to all three parties.
Patterns of Transactions

Software could be written to facilitate and monitor this flow and similar flows. If the payments system is sufficiently flexible, and integrated with the needs of the users, if might be possible to merge the above invoice with the payment itself, at the Receipts level. Seen in this light, the Signed receipt of Ricardo is simply the smallest and simplest pattern within the more general set of patterns. We could then suggest that the narrow principle of the Receipt is the Transaction could be extended into The Invoice is the Transaction.

A particular transaction in business almost never stands alone. They come in patterns. For example offers and acceptances form a wider transaction but seldom encapsulate the entire fulfillment and payment cycle. Even if there has been a payment accompanying a PO message, the customer then waits for fulfillment.

There is a large body of science and literature built around these patterns of transactions. These have been adopted by the Business Process workgroup of ebXML and other standards bodies, where they are called "Commercial Transactions." Where however the present work distinguishes itself is in breaking down these transactions into the atomic elements. It is to that we now turn.
The Requirements of Triple Entry Accounting

The implementation of Triple Entry Accounting will in time evolve to support patterns of transactions. What has become clear is that double entry does not sufficiently support these patterns, as it is a framework that breaks down as soon as the number of parties exceeds one. Yet, even as double entry is "broken" on the net and unable to support commercial demands, triple entry is not widely understood, nor are the infrastructure requirements that it imposes well recognised.

Below are the list of requirements that we believed to be important [2] [3].

1. Strong Psuedonymity, At Least. As there are many cycles in the patterns, the system must support a clear relationship of participants. At the minimum this requires a nymous architecture of the nature of Ricardo or AADS. (This requirement is very clear, but space prevents any discussion of it.)

2. Entry Signing. In order to neutralise the threats to and by the parties, a mechanism that freezes and confirms the basic data is needed. This is signing, and we require that all entries are capable of carrying digital signatures (see 1, above, which suggests public key signatures).

3. Message Passing. The system is fundamentally one of message passing, in contrast to much of the net's connection based architecture. Boyle recognised early on that a critical component was the generic message passing nature, and Systemics proposed and built this into Ricardo over the period 2001-2004 [4].

4. Entry Enlargement and Migration. Each new version of a message coming in represents an entry that is either to be updated or added. As each message adds to a prior conversation, the stored entry needs to enlarge and absorb the new information, while preserving the other properties.

5. Local Entry Storage and Reports. The persistent saving and responsive availability of entries. In practice, this is the classical accounting general ledger, at least in storage terms. It needs to bend somewhat to handle much more flexible entries, and its report capabilities become more key as they conduct instrinsic reconciliation on a demand or live basis.

6. Integrated Hard Payments. Trade can only be as efficient as the payment. That means that the payment must be at least as efficient as every other part; which in practice means that a payment system should be built-in at the infrastructure level. C.f., Ricardo.

7 Integrated Application-Level Messaging. As distinct to the messaging at the lower protocol levels (1 above), there is a requirement for Alice and Bob to be able to communicate. That is because the vast majority of the patterns turns around the basic communications of the agents. There is no point in establishing a better payment and invoice mechanism than the means of communication and negotiation. This concept is perhaps best seen in the SWIFT system which is a messaging system, first and foremost, to deliver instructions for payments.
Conclusion

Double Entry bookkeeping provides evidence of intent and origin, leading to strategies for dealing with errors of accident and fraud. The financial cryptography invention of the signed receipt provides the same benefits, and thus challenges the 800 year reign of double entry. Indeed, in evidentiary terms, the signed receipt is more powerful than double entry records due to the technical qualities of its signature.

There remain some weaknesses in strict comparison with double entry bookkeeping. Firstly, in the Ricardo instantiation of triple entry accounting, the receipts themselves may be lost or removed, and for this reason we stress as a principle that the entry is the transaction. This results in three active agents who are charged with securing the signed entry as their most important record of transaction.

Secondly, the software ramifications of the triple entry system that are less convenient than that offered by double entry bookkeeping. For this reason, we expand the information held in the receipt into a set of double entry books; in this way we have the best of both worlds on each node: the evidentiary power of the signed entries and the convenience and local crosschecking power of the double entry concept.

Both of these imperitives meld signed receipts in with double entry bookkeeping. As we end up with a logical arrangement of three by three entries, we feel the term triple entry bookkeeping is useful to describe the advance on the older form.
Drawing in the Agents

To fully benefit from triple entry bookkeeping, we have to expand accounting systems out to agents and offer them direct capabilities to do transactions. That is, we make the agents stakeholders by giving them internal money [5]. Use of digital cash to do company accounts empowers the use of this concept as a general replacement for accounting using books and departmental budgets, and is an enabler for verifying and auditing the centralised accounts system by way of signed receipts.
Solving Frauds

Once there, governance receives substantial benefits. Accounts are now much more difficult to change, and much more transparent. It is our opinion that various scandals and failures of governance would have been impossible given these techniques: the mutual funds scandal would have shown a clear audit trail of transactions and thus late timing and otherwise perverted or dropped transactions would have been clearly identified or eliminated completely [NG]. The emerging scandal in the USA known as Stockgate would have been impossible as forgery of shares and value for manipulative trading purposes is revealed by signed receipts. Likewise, Barings would still be a force in investment banking if accounts had been organised around easily transparent digital cash with open and irreducible signed receipts that evidence invisible accounts (88888). Enron style scandals would have permitted more direct "follow the money" governance lifting the veil on various innovative but economically meaningless swaps.
References

[TB] A draft form of this paper credited Todd Boyle as an author, but this was later withdrawn at his request due to wider differences between the views.

[LP] Friar Luca Pacioli, Summa de Arithmetica, Geometria, Proportioni et Proportionalita 1494, Venice.

[IG1] Ian Grigg " The Twilight Zone ," Financial Cryptography blog 16th April 2005

[MB] Entanglement is discussed in: Petros Maniatis and Mary Baker, "Secure History Preservation through Timeline Entanglement," Proc. 11th USENIX Security Symposium, August 2002.

[DC] David Chaum, "Achieving Electronic Privacy," Scientific American, v. 267, n. 2 Aug 1992.

[RAH] Robert A. Hettinga " The Book-Entry/Certificate Distinction " 1995, Cypherpunks

[GH] Gary Howland " Development of an Open and Flexible Payment System 1996, Amsterdam, NL.

[IG2] Ian Grigg " The Ricardian Contract ," First IEEE International Workshop on Electronic Contracting (WEC) 6th July 2004

[4NF] E.F. Codd, " A Relational Model of Data for Large Shared Data Banks ," Comm. ACM 13 (6), June 1970, pp. 377-387.

[1] Todd Boyle, " GLT and GLR: conceptual architecture for general ledgers," Ledgerism.net, 1997-2005.

[2] Todd Boyle, " STR software specification," Goals, 1-5. This section adopts that numbering convention.

[3] Ian Grigg, various design and requirements documents, Systemics, unpublished.

[4] A substantial part of the programming and design was conducted by Edwin Woudt (first demo, SOX layers, UI) and Jeroen van Gelderen (message passing client architecture).

[5] Using internal money instead of an accounting system is not a new idea but has only been recently experienced: Ian Grigg, How we raised capital at 0%, saved our creditors from an accounting nightmare, gave our suppliers a discount and got to bed before midnight. Informal essay (rant), 7 Jul 2003.

[NG] James Nesfield and Ian Grigg " Mutual Funds and Financial Flaws ," U.S. Senate Finance Subcommittee 27th January, 2004
}

__________________________________

{

https://www.us-cert.gov/bsi/articles/knowledge/principles/economy-of-mechanism
United States Computer Emergency Readiness Team Department Homeland Security

One factor in evaluating a system's security is its complexity. If the design, implementation, or security mechanisms are highly complex, then the likelihood of security vulnerabilities increases. Subtle problems in complex systems may be difficult to find, especially in copious amounts of code. For instance, analyzing the source code that is responsible for the normal execution of a functionality can be a difficult task, but checking for alternate behaviors in the remaining code that can achieve the same functionality can be even more difficult. One strategy for simplifying code is the use of choke points, where shared functionality reduces the amount of source code required for an operation. Simplifying design or code is not always easy, but developers should strive for implementing simpler systems when possible.
Detailed Description Excerpts

According to Saltzer and Schroeder [Saltzer 75] in "Basic Principles of Information Protection" from page 8:

    Economy of mechanism: Keep the design as simple and small as possible. This well-known principle applies to any aspect of a system, but it deserves emphasis for protection mechanisms for this reason: design and implementation errors that result in unwanted access paths will not be noticed during normal use (since normal use usually does not include attempts to exercise improper access paths). As a result, techniques such as line-by-line inspection of software and physical examination of hardware that implements protection mechanisms are necessary. For such techniques to be successful, a small and simple design is essential.

}
_


__________________________________


__________________________________

Prove of location: https://blog.foam.space/introduction-to-proof-of-location-6b4c77928022
__________________________________
Clack, Bakshi, Braine.
Smart Contract Templates:  foundations, design land-scape and research directions
http://arxiv.org/abs/1608.00771
__________________________________
The whole point of a blockchain is to establish agreement on a canonical ordering of a set of transactions.
Over time, participants in the network sign the history, effectively endorsing everything that came before
 it and adding a new set of entries to the history. What this means is that a blockchain itself is really
 a kind of collective signature, whose membership is sampled repeatedly from a fluctuating distribution
 of resources allocated in the network, this is the "network" in action, or sometimes called consensus.


Agreement refers to the problem of maintaining a single global truth in the face of a decentralized account-
ing system.  While similar to the correctness problem, the  difference  lies  in  the  fact  that  while
a  malicious user of the network may be unable to create a fraudulent transaction (defying correctness), 
it may be able to create multiple correct transactions that are somehow unaware of each other, and thus
combine to create a fraudulent act. For example, a malicious user may make two simultaneous purchases, 
with only enough funds in their account to cover each purchase individually, but
not both together.   Thus each transaction by itself is correct, but if executed simultaneously in such
a way that the distributed network as a whole is unaware of both, a clear problem arises, commonly referred
to as the “Double-Spend Problem” [1]. Thus the agreement problem can be summarized as the requirement 
that only one set of globally recognized transactions exist in the network


__________________________________
One way to de ne a blockchain is a distributed database (DB) that solves the 
"Strong Byzantine Generals" (SBG) problem[13], the name given to a combination of the Byzantine 
Generals Problem and the Sybil Attack Problem.  In the Byzantine Generals Prob-
lem [14], nodes need to agree on some value for a DB entry, under the constraint that
the nodes may fail in arbitrary ways (including malicious behavior)
.  The Sybil AttackProblem [17] arises when one or more nodes figure out how to get 
unfairly disproportionate influence in the process of agreeing on a value for an entry.  
It's an \attack of the clones"|an army of seemingly independent voters actually working together 
to game the system.


__________________________________
What is a smart contract?  
That depends on the model of computation we are talking about.
There are two competing computational models used in decentralised databases: [ virtual  computer ,  UTXO ]
  *The virtual computer model is used by Ethereum: It models the database as the
in-memory state of a global computer with a single thread of execution determined
by the block chain.  
  * In the UTXO model, as used in Bitcoin, the database is a set of immutable rows keyed by
   (hash:output index) .  Transactions define  outputs  that  append  new  rows  and  
   inputs  which  consume  existing rows.

The term "smart contract" has a different meaning in each model. 

__________________________________
The best-known fault-tolerant consensus algorithm is Paxos;  it was  first published by
Lamport  in  1998  [27].   Since  then,  many  variations  have  been  developed  (e.g.Fast
Paxos" [28]) so there is now a whole family of Paxos algorithms,  including some that
are BFT. [29]
Mike Burrows of Google (co-inventor of Google's Chubby, BigTable, and Dapper) has
said,  "There is only one consensus protocol,  and that's Paxos,"  [30] and all working
protocols for asynchronous consensus we have so far encountered have Paxos at their
core."  [31] Henry Robinson of Cloudera has said, "all other approaches are just broken
versions of Paxos" and it's clear that a good consensus protocol is surprisingly hard to
 find."
Raft,  a  Paxos  derivative,  makes distributed consensus systems easier to design and deploy.

__________________________________
TODO: http://lightning.network/ Transactions for the Future

Instant Payments. Lightning-fast blockchain payments without worrying about block confirmation times.
 Security is enforced by blockchain smart-contracts without creating a on-blockchain transaction
 for individual payments. Payment speed measured in milliseconds to seconds.

Scalability. Capable of millions to billions of transactions per second across the network.
 Capacity blows away legacy payment rails by many orders of magnitude. Attaching payment per 
action/click is now possible without custodians.

Low Cost. By transacting and settling off-blockchain, the Lightning Network allows for exceptionally
low fees, which allows for emerging use cases such as instant micropayments.

Cross Blockchains. Cross-chain atomic swaps can occur off-chain instantly with heterogeneous blockchain
consensus rules. So long as the chains can support the same cryptographic hash function, it is possible
to make transactions across blockchains without trust in 3rd party custodians.

__________________________________
http://www.rsk.co/

A horizontal, usually underground stem that often sends out roots and shoots from its nodes.

RSK is the first open-source smart contract platform with a 2-way peg to Bitcoin that also rewards the Bitcoin miners via merge-mining, allowing them to actively 
participate in the Smart Contract revolution. RSK goal is to add value and functionality to the Bitcoin ecosystem by enabling smart-contracts, near instant payments and higher-scalability.

 

The project has been conceived with the following principles in mind: Bitcoin Friendly

We believe in Bitcoin. We support the Bitcoin community and we want to continue the legacy of Bitcoin´s pioneers. The lack of turing-complete smart-contracts capabilities may become an obstacle to Bitcoin´s growth to it´s full potential. RSK provides the missing technical needs, as a blockchain with a 2way peg to Bitcoin. As RSK does not mint, nor has pre-mined coins, then it has no speculative value and does not compete with Bitcoin.
__________________________________
TODO: Metacoins: The idea behind a metacoin is to have a protocol that lives on top of Bitcoin,
using Bitcoin transactions to store metacoin transactions but having a different state transition
function, APPLY'(S,TX). Because the metacoin protocol cannot prevent invalid metacoin transactions from
appearing in the Bitcoin blockchain, a rule is added:
if APPLY'(S,TX) returns an error, the protocol defaults to APPLY'(S,TX) = S. This provides and easy
mechanism for creating an arbitray cryptocurrency protocol, potentially with advanced features that
cannot be implemented inside of Bitcoin itself, but with a very low devlopment cost since the
complexities of mining and networking are already handled by the Bitcoin protocol.


__________________________________
Ethereum ¿Opinion?: """
Bitcoin UTXO binary state (spent, unspent) gives no opportunity for multi-stage contracts or scripts
which keep any other interanl state beyond that. This makes it hard to make multi-stage options
contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary
for secure computational bounties). It also means that UTXO can only be used to build simple, one-off
contracts and not more complex "stateful" contracts such as decentralized organizations, and makes
meta-protocols difficult to implement. Binary state combined with value-blindness also mean that 
another important application, withdrawal limits, is impossible".
__________________________________
Thecnically, a Bitcoin address is the hash of the elliptic curve public key, and not the public key
itself. However, it is in fact perfectly legitimate cryptographic terminology to
refer to the pubkey hash as a public key itself. This is because Bitcoin's cryptography can be
considered to be a custom digital signature algorithm, where the public key consists of the hash 
of the ECC pubkey, the signature consists of the ECC pubkey concatenated with the ECC signature,
and the verification algorithm involves checking the ECC pubkey in the signature against the ECC
pubkey hash provided as a public key and then verifying the ECC signature against the ECC pubkey.
__________________________________
Pay-to-script-hash (Andersen) 
State-Channels (Coleman)
Tree-signatures (Wuille): A way to express multisignature more "conciselly".
__________________________________
Delegation-(multi)signature: If Bob(and Alice) say YES, then YES.
 If any two of Both, Sandra or Sandy say YES, then YES
__________________________________
Multiple  Independent  Chains  with  Shared  Resources  for  Security.
Pegged sidechains are the most famous example, where mining among chains has the e ect of
being merged [83].  SuperNET [96] and Ethereum's hypercubes and multichain proposals
[97]  t in this category. However, if the goal is simply to get a DB to run at scale, breaking
the DB into many heterogeneous sub-chains adds cognitive and engineering complexity
and introduces risk.
__________________________________
https://www.reddit.com/r/ethereum/comments/453jnh/will_the_hyperledger_be_a_competitor_of_ethereum/

The more I think about it, the more I am starting to believe that the idea of private blockchains (and a bit less so the consortium blockchains) is kind of throwing baby out of the water.

And that baby, from my point of view, is not decentralisation, or censorship resistance (these are non-goals for whoever wants to build private or consortium blockchains). That baby is crypto economics and self-enforcing security associated with it.

If you throw away the "money" element of the public blockchains, with their exchange rates, markets, etc, what is left is a replicating state machine in the case of Bitcoin, and replicated distributed execution in case of Ethereum. Now, Hyperledger, since it is probably implementing something on top of PBFT (Practical Byzantine Fault Tolerance), is exactly a replicating state machine. Blockchain is then the transaction log.

Pretty much every company of certain large size has many replicated databases, based on various technologies. Even before blockchains arrived, there were NoSQL and eventual consistency and CAP theorem. Everyone knew about Byzantine Fault Tolerance, but everyone kept saying: "Nah, we don't want it, it is too expensive". Lots of people tried distributed transactions, saw how slow they were and decided to avoid them at any cost.

Why is everybody suddenly going "Byzantine", or "blockchainy"?

    Because banks do not trust each other? Well, it does not prevent them trading millions with each other via FIX protocol at very high speed. If error happens, sales people call each other, negotiate. If that does not help, they either forgive and forget or sue. Simples!
    Increased cybersecurity threat? True, but private blockchain is not going to help. Rogue sysadmins or malware will get to the private keys in the same way it can get to other stuff. Public blockchain would actually help, because cutting corners there loses you money directly and quickly as opposed to indirectly and sometime later. Look at MIT's three myths of firewalls: http://web.mit.edu/kerberos/firewalls.html
    Potential huge saving from shorter settlements?. If this is such an obvious thing for everyone now, then for some strange reason it has not been done before, based on databases and messaging. I daresay there are already good open standards that allow for all of this.

I think the point that a lot of people missing, or consciously denying, is that the cryptocurrency is the crucial ingredient in the blockchains. It has been proven (by Bitcoin) that something with no intrinsic value, no being legal tender, not being anyone's liability, and not required to pay taxes, can have substantial purchasing power. And that purchasing power is what allows something like that to transcend from kind of boring and inefficient technology to something quite interesting. And it is a great contribution to the theory of money - something that will take some time for the economists to digest.

    enlaceembed
}
-->



</html>
