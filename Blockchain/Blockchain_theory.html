<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Blockchain Theory map</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->
<table { >
<tr {>
  
  <td>
    <span xxbig>CAP Theorem</span><br/>
    <a href="https://en.wikipedia.org/wiki/CAP_theorem">REF</a></b>
    <ul xxxsmall zoom>
      <li> In theoretical computer science, the CAP theorem, also named Brewer's theorem
        after computer scientist Eric Brewer, states that it is impossible for a distributed
        data store to simultaneously provide more than two out of the following three
        guarantees:<br/>
<pre>
  +------------------------+--------------------------+--------------------
  |Consistency             | Availability             | Partition tolerance
  +------------------------+--------------------------+--------------------
  |Every read receives the | Every request receives   | The system continues to 
  |most recent write or    | a (non-error) response   | operate despite an arbitrary
  |an error                | – without guarantee that | number of messages being
  |                        | it contains the most     | dropped (or delayed) by the
  |                        | recent write             | network between nodes
  +------------------------+--------------------------+--------------------
</pre>
      </li>
      <li>Consensus in public blockchains refers to methods to warrant parititon tolerance (global
        vision of state by all nodes), sacrifying availability (transactions are sent for "mining"
        to the network but there is no warranty of success (even error) response.
      </li>
  </ul>
  </td>  

  <td>
  <b>Triple Entry Accountancy</b><a href="http://iang.org/papers/triple_entry.html">REF</a>
  <ul xxxsmall zoom>
    <li></li>
    <li>3 local entries for each of 3 roles, the result of which I call triple entry accounting.</li>
    <li>Bullet proof accounting systems for aggressive uses</li>
    <li>lowers costs by delivering reliable and supported accounting, </li>
    <li>it makes much stronger governance possible in a way that positively impacts
  on the future needs of corporate and public accounting.</li>
    <li>Double Entry: add a clear strategy to identify and remove errors.<br/>
       It has a side effect of clearly firewalling errors as either accident
       or fraud.<br/>
       This property is enabled by means of three features:
       <ul>
         <li>separation of all books into two groups or sides, called assets and liabilities</li>
         <li>redundancy of the duplicative double entries with each entry having a match on the other side</li>
         <li>balance sheet equation (sum of all entries on the asset side must equal the sum of all entries on the liabilities side)</li>
       </ul>
     </li>
     <li>This then leads to an audit strategy:
       <ul>
         <li>First, ensure that all entries are complete, in that they refer to their counterpart.</li>
         <li>Second, ensure that all movements of value make sense. </li>
       </ul>
     </li>
     <li>The digital signature is capable of creating a record with some strong degree of reliabilty, at least in the senses expressed by ACID:
       <ul>
         <li>A digital signature can be relied upon to keep a record safe, as it will fail to verify if
  any details in the record are changed</li>
         <li><b>assuming that the original record was created correctly, then later errors are revealed,
   both of an accidental nature and of fraudulent intent.</b></li>
         <li>digital signature gives us a particular property:
  "at a given point in time, this information was seen and marked by the signing computer.
    providing a new way to create reliable and trustworthy entries "
  (variants with softer and harder claims exits like message digests and public key cryptosystems)</li>
       </ul>
     </li>
     <li><b>Initial Role of a Receipt:</b>
   let's assume a simple three party payment system: Alice, Bob (two users) and Ivan (the Issuer)<br/>
  - each party holds an authorising key which can be used to sign their instructions.<br/>
  - Alice wishes to transfer value to Bob in some unit or contract managed by Ivan:<br/>
<pre>
    Alice -> Alice : + signed payment instruction ( similar to a cheque)
    Alice -> Ivan  :   signed payment instruction ( similar to a cheque)
    Alice -> Alice :   Update internal set of books
    Ivan  -> Ivan  : + signed (receipt)
    Ivan  -> Alice :   signed (receipt)
    Ivan  -> Bob   :   signed (receipt)
    Ivan  -> Ivan  :   Update internal set of books
<pre>
   <b blue xbig>The Receipt is the Transaction!!!</b>
  - The Issuer (Ivan) is the risk source of insider fraud:<br/>
    A single centralised server for issuers of the unit of digital value 
    and any governance partners such as the server operators are powerful candidates 
    for insider fraud.<br/>
  - To address the risk of insider fraud, the written issuer signed receipt was historically introduced 
    as being a primary source of evidence.  To achieve a complete binding, Alice's original authorisation
    is also included within the record. 
<pre>
Interim <b orange>signed</b> Receipt   User's Cheque:
From         Alice                     From         Alice
To           Bob                       To           Bob
Unit         Euro                      Unit         Euro
Quantity     100                       Qty          100
Date         2005.12.25                Com          Pens
<b orange>Issuer signature</b>               <b orange>Owner sig</b>
                                       From         Alice
                                       To           Bob
                                       Unit         Euro
                                       Quantity     100
                                       Date         2005.04.10
                                       <b orange>Issuer signature</b>
<b orange>Owner  signature</b>: evidence of both the user's intention
<b orange>Issuer signature</b>:  server's action in response
<pre>
     </li>
     <li> <b>Most efficient record keeping strategy:<br/>
        drop all interim records and keep safe the (multi)signed receipt</b><br/>
        This allows us to state the following principle:
        <b>The User and the Issuer hold the same information.</b>
     </li>
     <li>We bind a signed contract of issuance known as a Ricardian Contract into the receipt:<br/>
       This invention relates a digitally signed document securely to the signed receipt by means of a 
       unique identifier called a message digest, again provided by cryptography.
        It provides strong binding for the unit of account, the nature of the issue, the terms, conditions 
       and promises being made by the Issuer, and of course the identity of the Issuer.
     </li>
     <li><hr/></li>
     <li>  <b blue>SIGNED RECEIPT AS A BOOK-KEEPING SYSTEM</b></li>
     <li>Single Entry (Signed receipt) system:<br/>
       To calculate balances a book would be constructed on the fly from the set for signed receipts.
       (using the Signed Receipt as a basis for single entry bookkeeping)
     </li>
     <li>Recovering Double Entry:<br/>
        The Issuer server (Ivan) has to accept each new transaction on
        the basis of the available balance in the effected books; 
        for this reason it needs those books to be available efficiently.<br/>
        Alice and Bob both are granted a book each within the server's architecture.<br/>
        We place those books on the liabilities side of the issuer:<br/>
        - Receipts then can be placed in a separate single book (logically placed on the assets side)<br/>
        - Each TX from Alice to Bob now has a logical contra entry, and is then represented
          in 3 places (<b blue>Triple Entry Accounting!!</b>) within the accounts of the server.
     </li>
     <li><b blue><br/>
       - In practice digital signature reduces the accounting problem to one of
         the receipt's presence <br/>
       - Although digitally signed receipt dominates in information terms, in 
         processing terms it falls short.
       </b>
     </li>
     <li><b blue>
       It's Worth stating that the technique of signing receipts works both with private
       key signatures and also with entanglement message digest signatures; whether the security aspects
       of these techniques is adequate to task is dependent on the business environment.
       </b>
     </li>
     <li>Problems: <br/>
     - loss of receipts<br/>
     - counting of balances by the client side software
     </li>
     <li>
       Patterns of Transactions<br/>
        A particular transaction in business almost never stands alone. They come in patterns.
       For example offers and acceptances form a wider transaction but seldom encapsulate the entire
        fulfillment and payment cycle. 
     </li>
     <li>Conclusion<br/>
       Double Entry bookkeeping provides evidence of intent and origin,
       leading to strategies for dealing with errors of accident and fraud. 
       The financial cryptography invention of the signed receipt provides the same benefits,
       and thus challenges the 800 year reign of double entry. Indeed, in evidentiary terms,
       the signed receipt is more powerful than double entry records due to the
       technical qualities of its signature.
     </li>
     <li>REFs:
<pre>
- Todd Boyle,
- Friar Luca Pacioli "Summa de Arithmetica, Geometria, Proportioni et Proportionalita 1494,
- Ian Grigg " The Twilight Zone ," Financial Cryptography blog 16th April 2005,
- Entanglement is discussed in: Petros Maniatis and Mary Baker
     "Secure History Preservation through Timeline Entanglement," Proc. 11th USENIX Security Symposium, August 2002.",
- David Chaum  "Achieving Electronic Privacy" Scientific American  v. 267  n. 2 Aug 1992,
- Robert A. Hettinga " The Book-Entry/Certificate Distinction " 1995, Cypherpunks",
- Gary Howland " Development of an Open and Flexible Payment System 1996, Amsterdam, NL.,
- Ian Grigg " The Ricardian Contract ," First IEEE International Workshop on Electronic
  Contracting (WEC) 6th July 2004",
- E.F. Codd, " A Relational Model of Data for Large Shared Data Banks ," Comm. ACM 13 (6),
  June 1970, pp. 377-387.",
- James Nesfield and Ian Grigg " Mutual Funds and Financial Flaws ," U.S. Senate Finance 
  Subcommittee 27th January, 2004"
</pre>
     </li>
   </ul>
   <br/>
</pre }>
  </td>

  <td>
  <b>Consensus</b>
  <ul xxxsmall zoom>
    <li>The consensus tries to solve the P in the CAP problem (Distributed consensus)</li>
    <li>PoW (Difficulty): The faster to compute something "hard to calculate" is choosen as the master.
        Bizantine Tolerant. The "A"vailability in CAP is lost. A TX can be mined fast or "never".</li>
    <li>PoS: The creator of the next block is chosen via various combinations of random selection and wealth or age (i.e, the stake). </li>
    <li>PoElapsedTime: Used by <a href="https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html">Hyperledger Swatooth</a>
      <a href="https://themerkle.com/what-is-proof-of-elapsed-time/">REF</a>
      "What is even more peculiar is how Proof of Elapsed Time will achieve 
      this goal by using new CPU instructions. ... this consensus algorithm is 
      incredibly energy efficient compared to proof of work, which is another 
      factor to take into consideration. <b>Nor does it appear there will ever be 
      ASIC hardware to gain a competitive edge</b>.<br/>
      Even though it is a distributed model, it seems to rely on some form
      of centralized leadership, which may make it less efficient for cryptocurrency purposes.
    </li>
    <li>Mining algorithms compared:</br>
      <a href="https://themerkle.com/scrypt-vs-x11-vs-sha-256/">REF</a><br/>
        With several thousand cryptocurrencies in existence right now,
        it is not surprising to learn a lot of coins use different 
        mining algorithms. Whereas bitcoin uses SHA-256, other coins
        may use the likes of X11, Keccak, or Scrypt-N. All of these
        algorithms have their own benefits and requirements to keep
        mining competitive. Below are some of the different mining
        algorithms to be found today, and how they compare to one another.<br/>
        
        Scrypt vs SHA256 vs ScryptNf X11 X13 Keccak X15 Nist5
        NeoScrypt Lyra2RE WhirlpoolX Qubit Quark Axiom Lyra2REv2 ScyrptJaneNf16 ...
    </li>
    <li>PAXOS (NON bizantine tolerant)
      The best-known fault-tolerant consensus algorithm is Paxos;
      it was first published by Lamport  in  1998. Since then, many
      variations  have  been  developed  (e.g.Fast Paxos" ) so there
      is now a whole family of Paxos algorithms,  including some that
      are BFT<br/>
       Mike Burrows of Google (co-inventor of Google's Chubby,
      BigTable, and Dapper) has said,  "There is only one consensus protocol,
      and that's Paxos,"  [30] and all working protocols for asynchronous
      consensus we have so far encountered have Paxos at their
      core."<br/>
       Henry Robinson of Cloudera has said, "all other approaches are
      just broken versions of Paxos" and it's clear that a good consensus
      protocol is surprisingly hard to find."<br/>
    </li>
    <li>
      <b>Raft,  a  Paxos  derivative,  makes distributed consensus systems
      easier to design and deploy.</b><br/>
      <a href="http://thesecretlivesofdata.com/raft/">Raft visual explanation</a>,
      <a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">Raft paper</a>, <a href="https://raft.github.io/">https://raft.github.io/</a>
    </li>
    <li><b orange>Turns out that neither 2PC (two-phase-commit) nor Paxos are sufficient for public networks:<br/>
       number of participants is unkown, and nodes can appear/disappear at random .<br/>
        In non-public networks with well-known number of participants nd their identities
        (i.e. a trusted network), then both 2PC and Paxos DO work.</b>
    </li>
  </ul>


  <b>Derived consensus</b>
  <ul xxxsmall zoom >
    <li>PoOwnership: method using Bitcoin's decentralized ledger (also called 
        blockchain) or Bitcoin-related technologies to track the different 
        owners of a certain information over the time:<br/>
        The Bitcoin Core protocol now accepts raw data transactions up to 40 bytes
        per output using the opcode OP_RETURN. Putting the hash of the signature
        of a file's hash in the blockchain makes the owner of the private key 
        associated with the signature the owner of the file in the blockchain
        (as long as someone else doesn't show up with a proof certified
        before). 
    </li>
    <li>PoLocation: <a href="https://blog.foam.space/introduction-to-proof-of-location-6b4c77928022">REF</a>i
       allows users and autonomous agents to privately record authenticated location data at times
       of their choosing, and then reveal their personal information at their discretion, by presenting a
       fraud-proof location claim.
    </li>
  </ul>

  </td>  

  <td>
  <b>Overview</b>
  <ul xxxsmall zoom>
    <li>The whole point of a blockchain is to establish agreement on a canonical ordering of a set of transactions.</li>
    <li>Over time, participants in the network sign the history, effectively endorsing everything that came before it and adding a new set of entries to the history. What this means is that a blockchain itself is really a kind of collective signature, whose membership is sampled repeatedly from a fluctuating distribution of resources allocated in the network, this is the "network" in action, or sometimes called consensus.<br/>
    <li>Agreement refers to the problem of maintaining a single global
      truth in the face of a decentralized accounting system.
      While similar to the correctness problem, the difference lies
      in the fact that while a malicious user of the network may be
      unable to create a fraudulent transaction (defying correctness), 
      it may be able to create multiple correct transactions that are
     somehow unaware of each other, and thus combine to create a fraudulent act.
     For example, a malicious user may make two simultaneous purchases, 
     with only enough funds in their account to cover each purchase individually,
     but not both together.   Thus each transaction by itself is correct,
     but if executed simultaneously in such a way that the distributed network
     as a whole is unaware of both, a clear problem arises, commonly referred
     to as the “Double-Spend Problem” [1]. Thus the agreement problem can be
     summarized as the requirement that only one set of globally recognized
     transactions exist in the network
    </li>
  </ul>
  <p xxxsmall zoom>
   One way to define a blockchain is a distributed database (DB) that solves
   the "Strong Byzantine Generals" (SBG) problem[13], the name given to a
   combination of the Byzantine Generals Problem and the Sybil Attack Problem.
    In the Byzantine Generals Problem [14], nodes need to agree on some value
   for a DB entry, under the constraint that the nodes may fail in arbitrary 
   ways (including malicious behavior) unfairly disproportionate influence in 
   the process of agreeing on a value for an entry.  It's an \attack of the
   clones"|an army of seemingly independent voters actually working together
   to game the system.
  </p>
  </td>


  <td>
  <b>Semantic BlockChain</b>
  <ul xxxsmall zoom>
    <li>https://semanticblocks.files.wordpress.com/2017/03/linked_blockchain_paper.pdf</li>
    <li>https://docs.google.com/presentation/d/112KMqjwMR820jVf9CF-GLeNneUxb9qpo5j70mUgYErg/edit#slide=id.p</li>
  </ul>
  </td>  
<!--
  <td>
  <b>xxx....</b>
  <ul xxxsmall zoom>
    <li>
    </li>
  </ul>
  </td>
-->
</tr }>
</table } >

<table { >
<tr {>
  <th colspan=3 header_delimit >Building blocks</th>
</tr }>
<tr {>

  <td>
  <b>Digital Signature:</b>
  <ul xxxsmall zoom>
    <li>
    </li>
  </ul>
  </td>

  <td>
  <b>Consensus:</b>
  <ul xxxsmall zoom>
    <li>
    </li>
  </ul>
  </td>

  <td>
  <b>Merkle Tree:</b>
  <ul xxxsmall zoom>
    <li>
    </li>
  </ul>
  </td>
</tr }>
</table } >

<table { >
<tr {>
  <th colspan=10 header_delimit >Vocabulary</th>
</tr }>
<tr {>
  <td>
  <b TODO>Ricardian Contract</b>
<pre xxxsmall zoom>
<a href="http://iang.org/papers/ricardian_contract.html">Ri.Contract@iang.org</a>
method  of  recording  a  document  as  a  contract  at  law,  
and  linking  it  securely  to  other systems such as accounting 
for the contract as an issuance of value [24]. It holds three properties:

  i  )  robust: use of identification by Cryptographic hash function.
  ii )  transparent: use of readable text for legal prose.
  iii)  efficient:  use  of  mark-up  language  to  extract  essential information.
  
  "A Ricardian Contract can be defined as a single document that  is  
    a)  a  contract  offered  by  an  issuer  to  holders,  
    b)  for  a valuable right held by holders, and managed by the issuer, 
    c) easily readable by people (like a contract on paper), 
    d) readable by programs (parsable like a database), 
    e) digitally signed, 
    f) carrying the keys and server information, and 
    g) allied with a unique and secure identifier" [24]"
  method  of  recording  a  document  as  a  contract  at  law,  and  linking  it  securely  to  other systems such as accounting for the contract as an issuance of value [24]. It holds three properties:
  
    i  )  robust: use of identification by Cryptographic hash function.
    ii )  transparent: use of readable text for legal prose.
    iii)  efficient:  use  of  mark-up  language  to  extract  essential information.
  
  "A Ricardian Contract can be defined as a single document that  is  
    a)  a  contract  offered  by  an  issuer  to  holders,  
    b)  for  a valuable right held by holders, and managed by the issuer, 
    c) easily readable by people (like a contract on paper), 
    d) readable by programs (parsable like a database), 
    e) digitally signed, 
    f) carrying the keys and server information, and 
    g) allied with a unique and secure identifier" [24]
</pre>
  </td>  
  <td>
  <b>Trust  Contracts</b>
<pre xxxsmall zoom>
Smart Contracts on Ethereum are based on Turing-complete
language  (able  to  answer  computable  problem  given  enough
time  and  space).  Using  a  fees  mechanism  called  “Gas”  is
garanteed  that  it  will  not  run  forever.  But  some  researchers
claim  that  this  can  bring  some  problems.  Park  et  Al.  [26],
propose a new system called Boscoin
14
. They instead propose
the use of “Trust Contracts”, since Turing-Complete ones are
inherently undecidable and difficult to be read by non-technical
people,  therefore  it  is  not  easy  to  know  what  a  contract  will
do before running it.
Trust  contracts  are  based  on  OWL  and  TAL  (Timed  Au-
tomata  Language).  OWL  provides  the  structure  of  data  and
TAL  acts  as  an  operator.  These  contracts  are  decidable,  easy
to read and is possible to determine the amount of time it takes
to run [26].
</pre>
  </td>
  <td>
  <b>Lamport signatures</b>
  <ul xxxsmall zoom>
    <li>quantum-proof cryptographic signatures</li>
    <li><a href="https://github.com/tjade273/QEth">Quantum Safe
         Ethereum proxy with Winternitz One-Time signatures</a></li>
  </ul>
  </td>

  <td>
  <b>Cifrado homomórfico</b>
  <ul xxxsmall zoom>
    <li>http://enigma.media.mit.edu/</li>
    <li>http://www.xataka.com/privacidad/enigma-renace-el-cifrado-homomorfico-y-el-blockchain-como-base-de-una-internet-mas-privada</li>
  </ul>
  </td>

  <td>
  <b>Pay-to-script-hash (Andersen) </b>
  </td>

  <td>
  <b>State-Channels (Coleman)</b>
  </td>
</tr }>
</table } >

<table { >
<tr {>
  <th colspan=3 header_delimit >Smart-Contracts</th>
</tr }>
<tr {>
  <td>
  <b>Economy of mechanism</b><br/>
  <span xxsmall>United States Computer Emergency Readiness Team Department Homeland Security</span>
  <ul xxxsmall zoom>
    <li><a href="https://www.us-cert.gov/bsi/articles/knowledge/principles/economy-of-mechanism">REF</a></li>
    <li>One factor in evaluating a system's security is its complexity.
    If the design, implementation, or security mechanisms are highly complex, 
    then the likelihood of security vulnerabilities increases. Subtle problems 
    in complex systems may be difficult to find, especially in copious amounts 
    of code. For instance, analyzing the source code that is responsible for the
    normal execution of a functionality can be a difficult task, but checking 
    for alternate behaviors in the remaining code that can achieve the same 
    functionality can be even more difficult. One strategy for simplifying code
    is the use of choke points, where shared functionality reduces the amount 
    of source code required for an operation. Simplifying design or code is not
    always easy, but developers should strive for implementing simpler systems 
    when possible.</li>
    <li>According to Saltzer and Schroeder [Saltzer 75] in "Basic Principles of
      Information Protection" from page 8:<br/>
      Economy of mechanism: Keep the design as simple and small as possible. This 
      well-known principle applies to any aspect of a system, but it deserves 
      emphasis for protection mechanisms for this reason: design and 
      implementation errors that result in unwanted access paths will not be 
      noticed during normal use (since normal use usually does not include 
      attempts to exercise improper access paths). As a result, techniques such 
      as line-by-line inspection of software and physical examination of hardware
      that implements protection mechanisms are necessary. For such techniques to
      be successful, a small and simple design is essential.
    </li>
  </ul>
  </td>

  <td>
    <b>What is a smart contract?</b>
  <ul xxxsmall zoom >
    <li>That depends on the model of computation we are talking about.
      There are two competing computational models used in decentralised
      databases: [ virtual  computer ,  UTXO ]:</li>
    <li>The virtual computer model is used by Ethereum: It models the
      database as the in-memory state of a global computer with a single
      thread of execution determined by the block chain.</li>
    <li>In the UTXO model, as used in Bitcoin, the database is a set
      of immutable rows keyed by (hash:output index).  Transactions 
      define outputs that append new rows and inputs which consume
      existing rows.</li>
    <li>The term "smart contract" has a different meaning in each model. </li>
  </ul>
  </td>

  <td>
    <b>Smart Contract Templates</b>
  <ul xxxsmall zoom >
    <li>Clack, Bakshi, Braine. Smart Contract Templates:  foundations, design land-scape and research directions <a href="http://arxiv.org/abs/1608.00771">REF</a>
    </li>
  </ul>
  </td>

  <td>
    <b>Metacoins</b>
  <ul xxxsmall zoom >
    <li>The idea behind a metacoin is to have a protocol that lives on top 
      of Bitcoin, using Bitcoin transactions to store metacoin transactions 
      but having a different state transition function, APPLY'(S,TX).
    </li>
    <li>Because the metacoin protocol cannot prevent invalid metacoin 
      transactions from appearing in the Bitcoin blockchain, a rule is added:
<pre>
if APPLY'(S,TX) returns an error, the protocol defaults to APPLY'(S,TX) = S.
</pre>
      This provides and easy mechanism for creating an arbitray cryptocurrency
      protocol, potentially with advanced features that cannot be implemented
      inside of Bitcoin itself, but with a very low devlopment cost since the
      complexities of mining and networking are already handled by the Bitcoin
      protocol.
    </li>
  </ul>
  </td>


</tr }>
</table } >

<table { >
<tr {>
  <th colspan=3 header_delimit >Payment Channels</th>
</tr }>
<tr {>
  <td>
  <b>http://lightning.network/</b><br/>
  <ul xxxsmall zoom >
    <li>Instant Payments. Lightning-fast blockchain payments without worrying about block confirmation times.</li>
    <li>Security is enforced by blockchain smart-contracts without creating a on-blockchain transaction for individual payments. Payment speed measured in milliseconds to seconds.</li>
    <li>Scalability. Capable of millions to billions of transactions per second across the network.</li>
    <li>Capacity blows away legacy payment rails by many orders of magnitude. Attaching payment per action/click is now possible without custodians.</li>
    <li>Low Cost. By transacting and settling off-blockchain, the Lightning Network allows for exceptionally low fees, which allows for emerging use cases such as instant micropayments.</li>
    <li>Cross Blockchains. Cross-chain atomic swaps can occur off-chain instantly with heterogeneous blockchain consensus rules. So long as the chains can support the same cryptographic hash function, it is possible to make transactions across blockchains without trust in 3rd party custodians.</li>
  </ul >
  </td>
  <td>
    <b>http://www.rsk.co/</b>
    <ul xxxsmall zoom>
      <li>A horizontal, usually underground stem that often sends out roots and shoots from its nodes.</li>
      <li>RSK is the first open-source smart contract platform with a 2-way peg
       to Bitcoin that also rewards the Bitcoin miners via merge-mining, allowing 
       them to actively participate in the Smart Contract revolution. RSK goal
       is to add value and functionality to the Bitcoin ecosystem by enabling
       smart-contracts, near instant payments and higher-scalability.</li>
      <li>The project has been conceived with the following principles in mind: Bitcoin Friendly:<br/>
        We believe in Bitcoin. We support the Bitcoin community and we want to
        continue the legacy of Bitcoin´s pioneers. The lack of turing-complete
        smart-contracts capabilities may become an obstacle to Bitcoin´s growth 
        to it´s full potential. RSK provides the missing technical needs, as a
        blockchain with a 2way peg to Bitcoin. As RSK does not mint, nor has
        pre-mined coins, then it has no speculative value and does not compete
        with Bitcoin.
      </li>
    </ul>
  </td>
</tr }>
</table } >


<table { >
<tr {>
  <th colspan=3 header_delimit >Pegged Chains</th>
</tr }>
<tr {>
  <td>
  <b>Summary</b><br/>
  <ul xxxsmall zoom >
    <li>Multiple  Independent  Chains  with  Shared  Resources  for  Security.
   Pegged sidechains are the most famous example, where mining among chains
   has the efect of being merged [83].  SuperNET [96] and Ethereum's hypercubes
   and multichain proposals [97]  fit in this category. However, if the goal
   is simply to get a DB to run at scale, breaking the DB into many 
   heterogeneous sub-chains adds cognitive and engineering complexity
   and introduces risk.
    </li>
  </ul>
  </td>
</tr }>
</table } >


</body>
<!-- {
{
TODO_start:
ICOs:
________________
https://en.wikipedia.org/wiki/Financial_Information_eXchange
The Financial Information eXchange (FIX) protocol is an electronic communications
protocol initiated in 1992 for international real-time exchange of information 
related to the securities transactions and markets. With trillions of dollars 
traded annually on the NASDAQ alone, financial service entities are investing 
heavily in optimizing electronic trading and employing direct market access (DMA)
 to increase their speed to financial markets. Managing the delivery of trading
applications and keeping latency low increasingly requires an understanding of 
the FIX protocol.
__________________________________
Minimum Viable BlockChain:
https://www.igvita.com/2014/05/05/minimum-viable-block-chain/


Minimum Viable Block Chain = 
 - digital signatures             Triple Entry accountancy
 - consensus(proof-of-work,...),  CAP Theorem
 - block-of-transactions          ledger-performant-implementation

________________
https://amarszalek.net/blog/2018/03/20/simple-blockchain-in-kotlin/
https://amarszalek.net/blog/2018/03/27/blockchain-in-kotlin-proof-of-work/
____________________
https://medium.com/blockchain-engineering/kotlin-akka-part-1-hello-kotlin-a0c0de7d7407
}
-->
</html>
