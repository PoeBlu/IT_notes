<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">
   <title>Blockchain Theory map (alpha)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click/long-press on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>

<table { >
<tr {>
<td>
    <span xxbig>CAP Theorem</span><br/>
    <a href="https://en.wikipedia.org/wiki/CAP_theorem">REF</a></b>
    <ul xxxsmall zoom>
      <li> In theoretical computer science, the CAP theorem, also named Brewer's theorem
        after computer scientist Eric Brewer, states that it is impossible for a distributed
        (distributed == physically distant) data store to simultaneously provide more than 
        two out of the following three guarantees:<br/>
<pre>
  +------------------------+--------------------------+--------------------
  |Consistency             | Availability             | Partition tolerance
  +------------------------+--------------------------+--------------------
  |Every read receives the | Every request receives   | The system continues to 
  |most recent write or    | a (non-error) response   | operate despite an arbitrary
  |an error                | – without guarantee that | number of messages being
  |                        | it contains the most     | dropped (or delayed) by the
  |                        | recent write             | network between nodes
  +------------------------+--------------------------+--------------------
</pre>
      </li>
      <li>Consensus in public blockchains refers to methods to warrant parititon tolerance (global
        vision of state by all nodes), sacrifying availability (transactions are sent for "mining"
        to the network but there is no warranty of success (even error) response.
      </li>
      <li>(C&P from <a href="https://tendermint.com/static/docs/tendermint.pdf">1</a>) Fischer, Lynch,
      and Patterson shown in "Impossibility of distributed consensus with one faulty process",
      (Journal of the ACM, vol 32, n.2, pp 374-382, 1985) that in an asynchronous system (where no
      assumptions are made about time) of deterministic processes, no protocol can guarantee 
      consensus even with one faulty process (non-termination is always a possibility for a
      consensus algorithm). This is called the FLP impossibility result.
      Much research has gone into understanding ways to circumvent the FLP imposibility result
      by slightly modifying th problem domain, e.g, by sacrificing determinism, adding time, adding
      oracles, etc... (Byzantine consensus in asynchronous message-passing systems: a survey,”
      International Journal of Critical Computer-Based Systems , vol. 2, no. 2, pp. 141–161, 2011)
       Bitcoin circumvents the FLP impossibility result by making some assumptions about the 
      synchrony of the network (i.e., nodes soom sync up with the network) and time (i.e, miners
      dedicate limited time and resources to the best blockchain).<br/>
      Basically it introduces the necessity for time-based heuristics, to ensure convergence 
      (or at least repeated iterations of non-convergence).
      </li>
  </ul>
  <br/>
  <b>Blockchain Overview</b>
  <ul xxxsmall zoom>
    <li>The whole point of a blockchain is to establish agreement on a canonical ordering of a set of transactions.</li>
    <li>Over time, participants in the network sign the history, effectively endorsing everything that came before it and adding a new set of entries to the history. What this means is that a blockchain itself is really a kind of collective signature, whose membership is sampled repeatedly from a fluctuating distribution of resources allocated in the network, this is the "network" in action, or sometimes called consensus.<br/>
    <li>Agreement refers to the problem of maintaining a single global
      truth in the face of a decentralized accounting system.
      While similar to the correctness problem, the difference lies
      in the fact that while a malicious user of the network may be
      unable to create a fraudulent transaction (defying correctness), 
      it may be able to create multiple correct transactions that are
     somehow unaware of each other, and thus combine to create a fraudulent act.
     For example, a malicious user may make two simultaneous purchases, 
     with only enough funds in their account to cover each purchase individually,
     but not both together.   Thus each transaction by itself is correct,
     but if executed simultaneously in such a way that the distributed network
     as a whole is unaware of both, a clear problem arises, commonly referred
     to as the “Double-Spend Problem” [1]. Thus the agreement problem can be
     summarized as the requirement that only one set of globally recognized
     transactions exist in the network
    </li>
  </ul>
  <p xxxsmall zoom>
   One way to define a blockchain is a distributed database (DB) that solves
   the "Strong Byzantine Generals" (SBG) problem[13], the name given to a
   combination of the Byzantine Generals Problem and the Sybil Attack Problem.
    In the Byzantine Generals Problem [14], nodes need to agree on some value
   for a DB entry, under the constraint that the nodes may fail in arbitrary 
   ways (including malicious behavior) unfairly disproportionate influence in 
   the process of agreeing on a value for an entry.  It's an \attack of the
   clones"|an army of seemingly independent voters actually working together
   to game the system.
  </p>
</td>  

<td>
  <b xbig orange>Triple Entry Accountancy</b><a href="http://iang.org/papers/triple_entry.html">REF</a>
  <ul xxxsmall zoom>
    <li>3 local entries for each of 3 roles, the result of which I call triple entry accounting.</li>
    <li>Bullet proof accounting systems for aggressive uses</li>
    <li>lowers costs by delivering reliable and supported accounting, </li>
    <li>it makes much stronger governance possible in a way that positively impacts
  on the future needs of corporate and public accounting.</li>
    <li>Double Entry: add a clear strategy to identify and remove errors.<br/>
       It has a side effect of clearly firewalling errors as either accident
       or fraud.<br/>
       This property is enabled by means of three features:
       <ul>
         <li>separation of all books into two groups or sides, called assets and liabilities</li>
         <li>redundancy of the duplicative double entries with each entry having a match on the other side</li>
         <li>balance sheet equation (sum of all entries on the asset side must equal the sum of all entries on the liabilities side)</li>
       </ul>
     </li>
     <li>This then leads to an audit strategy:
       <ul>
         <li>First, ensure that all entries are complete, in that they refer to their counterpart.</li>
         <li>Second, ensure that all movements of value make sense. </li>
       </ul>
     </li>
     <li>The digital signature is capable of creating a record with some strong degree of reliabilty, at least in the senses expressed by ACID:
       <ul>
         <li>A digital signature can be relied upon to keep a record safe, as it will fail to verify if
  any details in the record are changed</li>
         <li><b>assuming that the original record was created correctly, then later errors are revealed,
   both of an accidental nature and of fraudulent intent.</b></li>
         <li>digital signature gives us a particular property:
  "at a given point in time, this information was seen and marked by the signing computer.
    providing a new way to create reliable and trustworthy entries "
  (variants with softer and harder claims exits like message digests and public key cryptosystems)</li>
       </ul>
     </li>
     <li><b>Initial Role of a Receipt:</b>
   let's assume a simple three party payment system: Alice, Bob (two users) and Ivan (the Issuer)<br/>
  - each party holds an authorising key which can be used to sign their instructions.<br/>
  - Alice wishes to transfer value to Bob in some unit or contract managed by Ivan:<br/>
<pre>
    Alice -> Alice : + signed payment instruction ( similar to a cheque)
    Alice -> Ivan  :   signed payment instruction ( similar to a cheque)
    Alice -> Alice :   Update internal set of books
    Ivan  -> Ivan  : + signed (receipt)
    Ivan  -> Alice :   signed (receipt)
    Ivan  -> Bob   :   signed (receipt)
    Ivan  -> Ivan  :   Update internal set of books
<pre>
   <b blue xbig>The Receipt is the Transaction!!!</b>
  - The Issuer (Ivan) is the risk source of insider fraud:<br/>
    A single centralised server for issuers of the unit of digital value 
    and any governance partners such as the server operators are powerful candidates 
    for insider fraud.<br/>
  - To address the risk of insider fraud, the written issuer signed receipt was historically introduced 
    as being a primary source of evidence.  To achieve a complete binding, Alice's original authorisation
    is also included within the record. 
<pre>
Interim <b orange>signed</b> Receipt   User's Cheque:
From         Alice                     From         Alice
To           Bob                       To           Bob
Unit         Euro                      Unit         Euro
Quantity     100                       Qty          100
Date         2005.12.25                Com          Pens
<b orange>Issuer signature</b>               <b orange>Owner sig</b>
                                       From         Alice
                                       To           Bob
                                       Unit         Euro
                                       Quantity     100
                                       Date         2005.04.10
                                       <b orange>Issuer signature</b>
<b orange>Owner  signature</b>: evidence of both the user's intention
<b orange>Issuer signature</b>:  server's action in response
<pre>
     </li>
     <li> <b>Most efficient record keeping strategy:<br/>
        drop all interim records and keep safe the (multi)signed receipt</b><br/>
        This allows us to state the following principle:
        <b>The User and the Issuer hold the same information.</b>
     </li>
     <li>We bind a signed contract of issuance known as a Ricardian Contract into the receipt:<br/>
       This invention relates a digitally signed document securely to the signed receipt by means of a 
       unique identifier called a message digest, again provided by cryptography.
        It provides strong binding for the unit of account, the nature of the issue, the terms, conditions 
       and promises being made by the Issuer, and of course the identity of the Issuer.
     </li>
     <li><hr/></li>
     <li>  <b blue>SIGNED RECEIPT AS A BOOK-KEEPING SYSTEM</b></li>
     <li>Single Entry (Signed receipt) system:<br/>
       To calculate balances a book would be constructed on the fly from the set for signed receipts.
       (using the Signed Receipt as a basis for single entry bookkeeping)
     </li>
     <li>Recovering Double Entry:<br/>
        The Issuer server (Ivan) has to accept each new transaction on
        the basis of the available balance in the effected books; 
        for this reason it needs those books to be available efficiently.<br/>
        Alice and Bob both are granted a book each within the server's architecture.<br/>
        We place those books on the liabilities side of the issuer:<br/>
        - Receipts then can be placed in a separate single book (logically placed on the assets side)<br/>
        - Each TX from Alice to Bob now has a logical contra entry, and is then represented
          in 3 places (<b blue>Triple Entry Accounting!!</b>) within the accounts of the server.
     </li>
     <li><b blue><br/>
       - In practice digital signature reduces the accounting problem to one of
         the receipt's presence <br/>
       - Although digitally signed receipt dominates in information terms, in 
         processing terms it falls short.
       </b>
     </li>
     <li><b blue>
       It's Worth stating that the technique of signing receipts works both with private
       key signatures and also with entanglement message digest signatures; whether the security aspects
       of these techniques is adequate to task is dependent on the business environment.
       </b>
     </li>
     <li>Problems: <br/>
     - loss of receipts<br/>
     - counting of balances by the client side software
     </li>
     <li>
       Patterns of Transactions<br/>
        A particular transaction in business almost never stands alone. They come in patterns.
       For example offers and acceptances form a wider transaction but seldom encapsulate the entire
        fulfillment and payment cycle. 
     </li>
     <li>Conclusion<br/>
       Double Entry bookkeeping provides evidence of intent and origin,
       leading to strategies for dealing with errors of accident and fraud. 
       The financial cryptography invention of the signed receipt provides the same benefits,
       and thus challenges the 800 year reign of double entry. Indeed, in evidentiary terms,
       the signed receipt is more powerful than double entry records due to the
       technical qualities of its signature.
     </li>
     <li>REFs:
<pre>
- Todd Boyle,
- Friar Luca Pacioli "Summa de Arithmetica, Geometria, Proportioni et Proportionalita 1494,
- Ian Grigg " The Twilight Zone ," Financial Cryptography blog 16th April 2005,
- Entanglement is discussed in: Petros Maniatis and Mary Baker
     "Secure History Preservation through Timeline Entanglement," Proc. 11th USENIX Security Symposium, August 2002.",
- David Chaum  "Achieving Electronic Privacy" Scientific American  v. 267  n. 2 Aug 1992,
- Robert A. Hettinga " The Book-Entry/Certificate Distinction " 1995, Cypherpunks",
- Gary Howland " Development of an Open and Flexible Payment System 1996, Amsterdam, NL.,
- Ian Grigg " The Ricardian Contract ," First IEEE International Workshop on Electronic
  Contracting (WEC) 6th July 2004",
- E.F. Codd, " A Relational Model of Data for Large Shared Data Banks ," Comm. ACM 13 (6),
  June 1970, pp. 377-387.",
- James Nesfield and Ian Grigg " Mutual Funds and Financial Flaws ," U.S. Senate Finance 
  Subcommittee 27th January, 2004"
</pre>
     </li>
   </ul>
   <br/>
</pre }>

  <b>Digital cash</b>
  <ul xxxsmall zoom>
  <li>Introduced in 1983 by David Chaim as a research topic in 1983 in a setting 
  with a central server that is trusted to prevent double-spending. To mitigate
  the privacy risk to individuals from this central trusted party, and to
  enforce fungibility, Chaum introduced the blind signature, to provent linking 
  of the central server's signatures (which represent coins), while still 
  allowing the central server to perform double-spend prevention
  </li>
  <li>Bitcoin replaced the need for a central server by introducing Proof-of-work
    as a distributed signature
  </li>
  </ul>

</td>

<td>
  <b xbig orange>Distributed Consensus</b>
  <b>Asynchronous Bizantine Fault Tolerant Consensus</b> (Public BC)
  <ul xxxsmall zoom>
  <li>(TX ordering) Consensus is very simple to implement in syncrhonous systems
    where a central ("God") server with a single internal timer takes care
    of ordering. Due to physical constraint (speed of light) it's not possible
    to establish a global time for distributed nodes  (CAP problem) so that
    all nodes agree at once about the timestamp of each TX generated "randomnly"
    (and asyncrhonously) by any node</li>
  <li>consensus tries to solve the "P"artitioning problem in the CAP problem 
      to warrant all the network physically distributed nodes agree on the same state.
      This is done at the cost of the "A"vailability property, since
      A transaction (=="proposal to change the state") can be executed/mined fast, slow
      or "never".</li>
  <li>PoW (Difficulty): Supports up to 50% of PoW byzantine attackers.
      ("The longest blockchain is also the longest correct blockchain since nobody
        has power enough to generate the longest chain")</li>
  <li><a href="">"XRP" Consensus:</a> ("pseudo-public?") </li>
  <li>PoS: The creator of the next block is chosen via various combinations of random
      selection and wealth or age (i.e, the stake). Much more efficient from an
      energy compsuption point of view (Ethereum)
  </li>
  <li>PoElapsedTime: Used by <a href="https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html">Hyperledger Swatooth</a>
    <a href="https://themerkle.com/what-is-proof-of-elapsed-time/">REF</a>
    "What is even more peculiar is how Proof of Elapsed Time will achieve 
    this goal by using new CPU instructions. ... this consensus algorithm is 
    incredibly energy efficient compared to proof of work, which is another 
    factor to take into consideration. <b>Nor does it appear there will ever be 
    ASIC hardware to gain a competitive edge</b>.<br/>
    Even though it is a distributed model, it seems to rely on some form
    of centralized leadership, which may make it less efficient for cryptocurrency purposes.
  </li>
  <li>Tendermint: <a href="https://tendermint.com/static/docs/tendermint.pdf">white paper</a>
     <span cite>requires no proof-of-work mining and has a high level of protection 
       against double-spend attacks. We make a <b>weak assumption about the participant's
       abilities to keep time, and we assume partial synchrony of the network, with some unknown
       upper bound "Delta" on the time of messages to be delivered. We assume that all 
       non-byzantine nodes have access to an internal clock that can stay sufficiently accurate 
       for a short duration of time until consensus on the next block is achieved</b></span>.<br/>
       Based on modified version of th DLS protocol, resilient up to 1/3 of Byzntine participants.
       (REF: "Consensus in the presence of partial synchrony" Journal of the ACM , vol. 35,
        no. 2, pp. 288–323, 1988).<br/>
<pre>
Valid TXs are grouped into blocks
<b orange>StateHash</b>: Merkle root hash of 
                         persistent account state (<b>external to BC!!!</b>)

Block H
  Header                      Header Hash
    Network name, Height
    Fees,  Time,
    Block H-1 Hash,
    <b orange>StateHash</b>
  Validation for Block H-1    Validation Hash
    <b brown>Validator</b> 1's Signature
    Validator 2's Signature
    ...
  TX_list                     TX_list Hash
    TX#1                      _______________
                              Block H Hash

<b brown>Validator</b> are users with accounts having coins locked in a bond deposit by 
   posting a <b>bond transaction</b>. ... When a validator signs duplicitously, anyone else
   can generate an "evidence transaction" with the conflicting commit-vote signatures
   destroying the bonded coins of the guilty validator (must be done before coins are spent).
</pre>
     <ul>
     <li>
     <b>A block is said to be valid if all the TXs in the block are valid and 
      sufficient signatures are included in the validation</b>
     </li>
     </ul>
  </li>
  <li><b green>hashgraph</b>:<a href="https://squawker.org/technology/blockchain-just-became-obsolete-the-future-is-hashgraph/">REF</a>
    Once an event occurs, everyone knows about it 
    within a couple of minutes. Only the effects of the transaction are 
    necessary in storing, everything else can be discarded. This shrinks the 
    amount of storage currently needed (Bitcoin: 60GB) to a fraction of 1GB, 
    allowing a smart phone to now act as a node. <br/>
    In Bitcoin, transactions are put into containers (blocks) that 
    form a single, long chain. If two miners create two blocks at the same 
    time, the community will eventually choose one and discard the other.<br/>
    In hashgraph, every container is used and none are discarded. <br/>
   """While Ethereum is looking at PoS with Casper, our algorithm uses 
      something called Virtual Voting ? its a voting system ? without having 
      to do the votes. Hashgraph uses a protocol called ?Gossip about Gossip?
      to achieve consensus. Gossip is a well known computer science term, which
      can be defined as calling any random node and telling that node everything
      you know, that it does not know. In distributed ledger technology the 
      "baseline" or minimum bandwidth required is that the transactions go to 
      every node. Gossip about Gossip refers to attaching a small additional 
      amount of information to this Gossip, which contains the last person we 
      talked to, hence, we are gossiping about the information we gossiped. 
      Using this information, we can build the Hashgraph. Once we have the 
      Hashgraph, it is extremely easy to know what a node would vote, because 
      we know what each node knows, and when they knew it. We now can use the 
      data from the Hashgraph as an input to 30 year old voting algorithms, and
      achieve consensus essentially for free. These 30 year old voting algorithms
      have strong math proofs- they are Asynchronous Byzantine Fault Tolerant, 
      which means we know when we will achieve consensus, guaranteed, and our 
      math proofs make no assumptions about the speed of the internet, due to 
      firewalls, ddos attacks, viruses or botnets. In addition, because of 
      gossip about gossip, Hashgraph is extremely fast, (250,000 transactions/sec),
      and we also get fair ordering and time stamping on every event."""
  </li>
  </ul>
  <hr/>
  <b>Non-Bizantine Fault Tolerant Consensus</b> (private/consorcium BCs)
  <ul xxxsmall zoom>
    <li>PAXOS (NON bizantine tolerant)
      The best-known fault-tolerant consensus algorithm is Paxos;
      it was first published by Lamport  in  1998. Since then, many
      variations  have  been  developed  (e.g.Fast Paxos" ) so there
      is now a whole family of Paxos algorithms,  including some that
      are BFT<br/>
       Mike Burrows of Google (co-inventor of Google's Chubby,
      BigTable, and Dapper) has said,  "There is only one consensus protocol,
      and that's Paxos,"  [30] and all working protocols for asynchronous
      consensus we have so far encountered have Paxos at their
      core."<br/>
       Henry Robinson of Cloudera has said, "all other approaches are
      just broken versions of Paxos" and it's clear that a good consensus
      protocol is surprisingly hard to find."<br/>
    </li>
    <li>
      <b>Raft,  a  Paxos  derivative,  makes distributed consensus systems
      easier to design and deploy.</b><br/>
      <a href="http://thesecretlivesofdata.com/raft/">Raft visual explanation</a>,
      <a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">Raft paper</a>, <a href="https://raft.github.io/">https://raft.github.io/</a>
    </li>
    <li><b orange>Turns out that neither 2PC (two-phase-commit) nor Paxos are sufficient for public networks:<br/>
       number of participants is unkown, and nodes can appear/disappear at random .<br/>
        In non-public networks with well-known number of participants nd their identities
        (i.e. a trusted network), then both 2PC and Paxos DO work.</b>
    </li>
  </ul>
  <hr/>
  (BFT) Mining algorithms compared:
  (<a href="https://themerkle.com/scrypt-vs-x11-vs-sha-256/">REF</a>)
  <ul xxxsmall zoom>
  <li><b>Scrypt</b>: designed to make it costly to perform large-scale custom hardware attacks, 
    requiring large amounts of memory.</br>
    Cryptocurrencies such as Tenebrix and Litecoin use a simplified version of Scrypt.
    that still require significant computing memory resources.<br/>
    It did not take long for companies to start producing Scrypt ASICs.<br/>
    Powerful AMD graphics cards are more than capable of mining the Scrypt algorithm<br/>
    Variants:
    <ul>
    <li>Scrypt-N: Changes memory requirement of the algorithm every set amount of time.
        This way even if ASICs are developed for the algorithm, a few years later they
        become obsolete as the "N" changes and creates the need for different circuits 
        in order to mine the hashes.</li>
    <li>Scrypt-OG: 8 times less memory-intensive than Scrypt. (OG="Optimized for GPU")</li>
    <li>Scrypt-Jane:</li>
    </ul>
  </li>
  <li><b>X11</b>: uses 11 different rounds of hashes (hence the 11). Well received due
    to this incredibly energy-efficiency while mining with a GPU or CPU. This algorithm is
    also capable of keeping mining hardware a lot cooler as there is a lower requirement
    for processing power. This effectiveness also translated into lower operation costs due
    to less electricity being used.<br/> 
    X11 did not prove to be ASIC-resistant for too long.<br/>
    Next iterations of this algorithm exists (X13, X14, X15, and X17,...)
  </li>
  <li><b>SHA-256</b>: (bitcoin) part of the SHA-2 cryptographic hash function initially designed
    by the NSA. Non ASIC resistant.</li>
  <li><b>SHA-256D</b>: double SHA-256 cryptographic hashing algorithm</li>
  </ul>
  <hr/>
  <b>Derived consensus</b>
  <ul xxxsmall zoom >
    <li>PoOwnership: method using Bitcoin's decentralized ledger (also called 
        blockchain) or Bitcoin-related technologies to track the different 
        owners of a certain information over the time:<br/>
        The Bitcoin Core protocol now accepts raw data transactions up to 40 bytes
        per output using the opcode OP_RETURN. Putting the hash of the signature
        of a file's hash in the blockchain makes the owner of the private key 
        associated with the signature the owner of the file in the blockchain
        (as long as someone else doesn't show up with a proof certified
        before). 
    </li>
    <li>PoLocation: <a href="https://blog.foam.space/introduction-to-proof-of-location-6b4c77928022">REF</a>i
       allows users and autonomous agents to privately record authenticated location data at times
       of their choosing, and then reveal their personal information at their discretion, by presenting a
       fraud-proof location claim.
    </li>
  </ul>
</td>

<td>
  Implementation Building blocks<br/>
  <span xsmall>REF: <a href="https://www.igvita.com/2014/05/05/minimum-viable-block-chain/">Min. Viable BC</a></span>
  <ul xsmall >
  <li><b>Digital Signature:</b>
    Provides the mechanism for triple entry accountancy (signed receipt)</li>
  <li><b>Distributed Consensus:</b>
    Provides the distributed consensus to globally agree on an given shared state </li>
  <li><a href="https://en.wikipedia.org/wiki/Merkle_tree"><b>Merkle Tree:</b></a>
    <ul xxxsmall zoom>
    <li>certify that (blocks of) data sent/stored is undamaged and unaltered.</li>
    <li>Used also in file systems (ZFS, Brtfs, ZFS, ...), SCMS (Git, Mercurial)
        backup systems (Tahoe-LAFS), NoSQL ddbbs (Cassandra, Riak, ...), 
        protocols (Dat, Apache Wave), ... </li>
    <li>The main difference from a hash list is that <b>one branch of the hash tree
     can be downloaded at a time and the integrity of each branch can be checked
     immediately</b>, even though the whole tree is not available yet.</li>
    </ul>
  </li>
  <ul>
</td>
</tr }>
</table } >

<table { >
<tr {>
<td>
  <b xbig orange>Smart-Contracts</b><br/>
  <b>Economy of mechanism</b><br/>
  <span xxsmall>United States Computer Emergency Readiness Team Department Homeland Security</span>
  <ul xxxsmall zoom>
    <li><a href="https://www.us-cert.gov/bsi/articles/knowledge/principles/economy-of-mechanism">REF</a></li>
    <li>One factor in evaluating a system's security is its complexity.
    If the design, implementation, or security mechanisms are highly complex, 
    then the likelihood of security vulnerabilities increases. Subtle problems 
    in complex systems may be difficult to find, especially in copious amounts 
    of code. For instance, analyzing the source code that is responsible for the
    normal execution of a functionality can be a difficult task, but checking 
    for alternate behaviors in the remaining code that can achieve the same 
    functionality can be even more difficult. One strategy for simplifying code
    is the use of choke points, where shared functionality reduces the amount 
    of source code required for an operation. Simplifying design or code is not
    always easy, but developers should strive for implementing simpler systems 
    when possible.</li>
    <li>According to Saltzer and Schroeder [Saltzer 75] in "Basic Principles of
      Information Protection" from page 8:<br/>
      Economy of mechanism: Keep the design as simple and small as possible. This 
      well-known principle applies to any aspect of a system, but it deserves 
      emphasis for protection mechanisms for this reason: design and 
      implementation errors that result in unwanted access paths will not be 
      noticed during normal use (since normal use usually does not include 
      attempts to exercise improper access paths). As a result, techniques such 
      as line-by-line inspection of software and physical examination of hardware
      that implements protection mechanisms are necessary. For such techniques to
      be successful, a small and simple design is essential.
    </li>
  </ul>
  <b>What is a smart contract?</b>
  <ul xxxsmall zoom >
    <li>That depends on the model of computation we are talking about.
      There are two competing computational models used in decentralised
      databases: [ virtual  computer ,  UTXO ]:</li>
    <li>The virtual computer model is used by Ethereum: It models the
      database as the in-memory state of a global computer with a single
      thread of execution determined by the block chain.</li>
    <li>In the UTXO model, as used in Bitcoin, the database is a set
      of immutable rows keyed by (hash:output index).  Transactions 
      define outputs that append new rows and inputs which consume
      existing rows.</li>
    <li>The term "smart contract" has a different meaning in each model. </li>
  </ul>
  <b>Smart Contract Templates</b>
  <ul xxxsmall zoom >
    <li>Clack, Bakshi, Braine. Smart Contract Templates:  foundations, design land-scape and research directions <a href="http://arxiv.org/abs/1608.00771">REF</a>
    </li>
  </ul>
  <b>Metacoins</b>
  <ul xxxsmall zoom >
    <li>The idea behind a metacoin is to have a protocol that lives on top 
      of Bitcoin, using Bitcoin transactions to store metacoin transactions 
      but having a different state transition function, APPLY'(S,TX).
    </li>
    <li>Because the metacoin protocol cannot prevent invalid metacoin 
      transactions from appearing in the Bitcoin blockchain, a rule is added:
<pre>
if APPLY'(S,TX) returns an error, the protocol defaults to APPLY'(S,TX) = S.
</pre>
      This provides and easy mechanism for creating an arbitray cryptocurrency
      protocol, potentially with advanced features that cannot be implemented
      inside of Bitcoin itself, but with a very low devlopment cost since the
      complexities of mining and networking are already handled by the Bitcoin
      protocol.
    </li>
  </ul>
</td>
<td>
  <b>Ricardian Contract</b><br/>
  <a href="http://iang.org/papers/ricardian_contract.html">REF@iang.org</a>
  <ul xxxsmall zoom>
  <li>method  of  recording  a  document  as  a  contract  at  law,  
and  linking  it  securely  to  other systems such as accounting 
for the contract as an issuance of value </li>
  <li>It holds three properties:
    <ol>
    <li>robust: use of identification by Cryptographic hash function.              </li>
    <li>transparent: use of readable text for legal prose.                         </li>
    <li>efficient:  use  of  mark-up  language  to  extract  essential information.</li>
    </ol>
  </li>

  <li>A Ricardian Contract can be defined as a single document that  is :
    <ol>
    <li>a  contract  offered  by  an  issuer  to  holders,                </li>
    <li>for  a valuable right held by holders, and managed by the issuer, </li>
    <li>easily readable by people (like a contract on paper),             </li>
    <li>readable by programs (parsable like a database),                  </li>
    <li>digitally signed,                                                 </li>
    <li>carrying the keys and server information, and                     </li>
    <li>allied with a unique and secure identifier" [24]"                 </li>
    </ol>
  </li>
  </ul>
  <b orange>Trust  Contracts:
  decidable,  easy to read, computation time can be calculated
  upfront</b>
  <ul xxxsmall zoom>
  <li>Smart Contracts on Ethereum are based on Turing-complete
language  (able  to  answer  computable  problem  given  enough
time  and  space).  Using  a  fees  mechanism  called  "Gas"  is
garanteed  that  it  will  not  run  forever.  
But  some  researchers claim  that  this  can  bring  some  problems.  Park  et  Al.  propose a new system called Boscoin</li>
  <li>They propose "Trust Contracts" since Turing-Complete ones are
    inherently undecidable and difficult to be read by non-technical
    people,  therefore  it  is  not  easy  to  know  what  a 
    contract  will do before running it.</li>
  <li>Trust  contracts  are  based  on  OWL  and  Timed  Automata  Language)<br/>
    OWL provides structure of data</br>
    TAL:acts  as  an  operator.
  </li>
  </ul>
</td>
<td colsep>
</td>
<td>
  <b xbig orange>Payment Channel</b><br/>
  <ul xxxsmall zoom>
  <li>class of techniques designed to allow two "peers" to make multiple transactions
     without commiting all of the transactions to the block chain.
  </li>
  <li>Ussually only two transactions are commited, the first one to "open" the
    bilateral channel between peers (adding liquidity to the channel) and the second
    one to "close" the offchain set of signed transaction to the blockchain (with the
    last aggreed balance for the channel)
  </li>
  </ul>
  <br/>
  <a href="http://lightning.network/">Lightning Network</a><br/>
  <ul xxxsmall zoom >
    <li>Instant Payments. Lightning-fast blockchain payments without worrying about block confirmation times.</li>
    <li>Security is enforced by blockchain smart-contracts without creating a on-blockchain transaction for individual payments. Payment speed measured in milliseconds to seconds.</li>
    <li>Scalability. Capable of millions to billions of transactions per second across the network.</li>
    <li>Capacity blows away legacy payment rails by many orders of magnitude. Attaching payment per action/click is now possible without custodians.</li>
    <li>Low Cost. By transacting and settling off-blockchain, the Lightning Network allows for exceptionally low fees, which allows for emerging use cases such as instant micropayments.</li>
    <li>Cross Blockchains. Cross-chain atomic swaps can occur off-chain instantly with heterogeneous blockchain consensus rules. So long as the chains can support the same cryptographic hash function, it is possible to make transactions across blockchains without trust in 3rd party custodians.</li>
  </ul>
  <br/>
  Teechan
  <ul xxxsmall zoom>
  <li>similar in design to the Lightning Network, save 
    for one crucial differentiating factor: it leverages trusted execution environments (TEEs), that is, secure hardware components found in recent commodity processors such as the latest batch of Intel CPUs with Software Guard Extensions (SGX).
  </li>
  </ul>
  <br/>
  <a href="https://ripple.com/build/payment-channels-tutorial/">Ripple Payment Channel</a> Tutorial<br/>
  <br/>
  <b><a href="http://www.rsk.co/">RSK</a></b>
  <ul xxxsmall zoom>
    <li>A horizontal, usually underground stem that often sends out roots and shoots from its nodes.</li>
    <li>RSK is the first open-source smart contract platform with a 2-way peg
     to Bitcoin that also rewards the Bitcoin miners via merge-mining, allowing 
     them to actively participate in the Smart Contract revolution. RSK goal
     is to add value and functionality to the Bitcoin ecosystem by enabling
     smart-contracts, near instant payments and higher-scalability.</li>
    <li>The project has been conceived with the following principles in mind: Bitcoin Friendly:<br/>
      We believe in Bitcoin. We support the Bitcoin community and we want to
      continue the legacy of Bitcoin´s pioneers. The lack of turing-complete
      smart-contracts capabilities may become an obstacle to Bitcoin´s growth 
      to it´s full potential. RSK provides the missing technical needs, as a
      blockchain with a 2way peg to Bitcoin. As RSK does not mint, nor has
      pre-mined coins, then it has no speculative value and does not compete
      with Bitcoin.
    </li>
  </ul>
</td>
<td colsep></td>
<td>
  <b>Pegged Side Chains</b><br/>
  Technology enabling the atomic movement of assets between blockchains.<br/>
  <ul xxxsmall zoom >
 <li><a href="https://www.blockstream.com/sidechains.pdf">Whitepaper</a></li>
 <li>Multiple  Independent  Chains  with  Shared  Resources  for  Security.
   Pegged sidechains are the most famous example, where mining among chains
   has the efect of being merged [83].  SuperNET [96] and Ethereum's hypercubes
   and multichain proposals [97]  fit in this category. However, if the goal
   is simply to get a DB to run at scale, breaking the DB into many 
   heterogeneous sub-chains adds cognitive and engineering complexity
   and introduces risk.</li>
 <li>"""Proposed solution: In order to transfer asset provide proof/s of possesion
     in the transferrring TXs themselves, avoiding the need for nodes to track
     the sending chain. On a high level, when moving assets from one blockchain to
     anothers, we create a TXs on the first (parente) blockchain locking the assets,
     then create a TXs on the second (side) blockchain whose inputs contain a 
     cryptographic proof that the lock was done correctly. These inputs are
     tagged with an asset type, e.g, the genesis hash of its originating blockchain</li>
 <li><def>Sidechain</def> is a blockchain that validates data from other blockchains</li>
 <li><def>Two-way peg</def>: Mechanism by which coins are transferred between sidechains
     and back at a fixed or otherwise deterministic exchange rate.</li>
 <li>DMMS: Dynamic membership multi-party signature: Signature formed by a set of
     signers which has no fixed size. Bitcoin's blockheaders can be considered
     DMMSes because their proof-of-work has the property that anyone can contribute
     with no enrolment process</li>
 <li><def>Simplified payment verification proof(SPV)</def> is a DMMS that an action 
     occurred on a Bitcoin-kie proof-of-work blockchain</li>
 <li>To transfer parent chain coins into sidechain coins, the parent chain coins are
   sent to a special output on the parent chain that can only be unlocked by an SPV
   proof of possession on the sidechain. To sync the two chains two waiting periods
   are needed:
   <ul>
   <li><def>Confirmation period</def> of a transfer between sidechains: duration for which a coin
     must be locked on the parent chain before it can be transferred to the sidechain,
     allowing for sufficient work to be created sucha that a denial of service attack
     in the next waiting period becomes more difficult (around 1 or 2 days).<br/>
     The user waits for the conf. period, then creates a TX on the sidechain refering
     to this output, providing an SPV proof that it was created and "buried" under
     sufficient work on the parent chain.
   </li>
   <li><def>Contest period</def> delta-time in which a newly-transferred coin main
     not be spent on the sidechain in order to prevent double-spending by transferring
     previously-locked coins during a reorganization. ("in the order of one/two days)</li>
   <li>While locked on the parent chain, the coin can be freely transferred within 
     the sidechain without  further interaction with the parent chain. However, it 
     retains its identity as a parent chain coin, and can only be transferred 
     back to the same chain that it came from.</li>
   <li>Transfering coinx back from the side chain to the parent chain follows the
     same procedure: send the sidechain coins to an SPV-locked output, produce a 
     sufficient SPV proof that this was done, and use the proof to unlock a number
     of previosly-locked outputs with equal denomination on the parent chain.</li>
   </ul>
 </li>
 </ul>
</td>
</tr }>
</table } >

<table { >
<tr {>
  <th colspan=10 header_delimit >(Unordered) Vocabulary</th>
</tr }>
<tr {>
<td>
<div floatl>
  soft-fork: 
  <ul xxxsmall zoom>
  <li>backwards compatible protocol change (addition)
    soft-forks can be implemented with merely a superemajority of the mining
    computational power participating, rather than all full nodes.
    However, participants' security with respect to the soft-forked features is
    only SPV-level until they upgrade. (Soft-forks have been used several times to
    deploy new features and fix security issues in Bitcoin)
  </li>
  </ul>

  hard-fork:
  <ul xxxsmall zoom>
  <li>TODO</li>
  </ul>

  <a href="https://en.bitcoin.it/wiki/Colored_Coins">Colored coins:</a>
  <ul xxxsmall zoom>
  <li>The term loosely describes a class of methods for representing and managing real world assets on top of the Bitcoin Blockchain</li>
  <li>"""Script extensions (for example, to efficiently support coloured coins[jl213])
   have been proposed for Bitcoin. Since such extensions are usable only by a 
   small subset of users, but all users would need to deal with the increased 
   complexity and risk of subtle interactions, these extensions have not been 
   accepted into Bitcoin"""</li>
  <li>Ethereum uses <a href="https://github.com/ethereum/EIPs/pull/610">ERC20 token Standard</a> instead of Colored coins</a>
  </ul>


  <b>Demurrage (economics):</b>
  <ul xxxsmall zoom>
  <li>mechanism for achieving block rewards an idea pioneered for digital 
    currency by Freicoin (http://freico.in) in which all unspent outputs lose 
    value over time, with the lost value being recollected by miners. This 
    keeps the currency supply stable while still rewarding miners. It may be 
    better aligned with user interests than inflation because loss to demurrage
    is enacted uniformly everywhere and instantaneously, unlike inflation; it 
    also mitigates the possibility of long-unspent "lost" coins being reanimated
    at their current valuation and shocking the economy, which is a perceived 
    risk in Bitcoin. Demurrage creates incentives to increase monetary velocity
    and lower interest rates, which are considered (e.g. by Freicoin advocates 
    and other supporters of Silvio Gesell’s theory of interest[Ges16]) to be 
    socially beneficial. In pegged sidechains, demurrage allows miners to be 
    paid in existing already-valued currency
  </li>
  </ul>
</div>
<div floatl>
  <b>Lamport signatures</b>
  <ul xxxsmall zoom>
    <li>quantum-proof cryptographic signatures</li>
    <li><a href="https://github.com/tjade273/QEth">Quantum Safe
         Ethereum proxy with Winternitz One-Time signatures</a></li>
  </ul>
  <b><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption">Homomorphic Encryption</a></b>
  <ul xxxsmall zoom>
    <li>http://enigma.media.mit.edu/</li>
    <li>http://www.xataka.com/privacidad/enigma-renace-el-cifrado-homomorfico-y-el-blockchain-como-base-de-una-internet-mas-privada</li>
  </ul>
  Pay-to-script-hash (Andersen)
  <ul xxxsmall zoom>
    <li>TODO</li>
  </ul>

  State-Channels (Coleman)
  <ul xxxsmall zoom>
    <li>TODO</li>
  </ul>
</div>

<div floatl>
  <b>Semantic BlockChain</b>
  <ul xxxsmall zoom>
    <li>https://semanticblocks.files.wordpress.com/2017/03/linked_blockchain_paper.pdf</li>
    <li>https://docs.google.com/presentation/d/112KMqjwMR820jVf9CF-GLeNneUxb9qpo5j70mUgYErg/edit#slide=id.p</li>
  </ul>
</div>
</td>
</tr }>
</table } >


</body>
<!-- {
{
TODO_start:
__________________________________
https://amarszalek.net/blog/2018/03/20/simple-blockchain-in-kotlin/
https://amarszalek.net/blog/2018/03/27/blockchain-in-kotlin-proof-of-work/
____________________
https://medium.com/blockchain-engineering/kotlin-akka-part-1-hello-kotlin-a0c0de7d7407
_________________________
Several  algorithms  with  greater  complexity  have
been  proposed  for  Byzantine  consensus  in  the
asynchronous case.  FaB Paxos [5] will tolerate
( n − 1) / 5 Byzantine failures in a network of n
nodes, amounting to a tolerance of up to 20% of nodes
in the network colluding maliciously.  Attiya, Doyev, 
and Gill [3] introduce a phase algorithm for the asynchronous case, which can tolerate ( n − 1) / 4 failures, or up to 25% of the network.  Lastly, Alchieri et al., 2008 [6] present BFT-CUP, which achieves Byzantine consensus in the asynchronous case even with unknown participants, with the maximal bound of a tolerance of ( n − 1) / 3 failures, but with additional restrictions on the connectivity of the underlying network 
__________________________
Transaction malleability is a problem in Bitcoin which allows arbitrary users
to tweak transaction data in a way that breaks any later transactions which 
depend on them, even though the actual content of the transaction is unchanged.
An example of a protocol broken by transaction malleability is probabilistic 
payments [Cal12].
_________________
(REF: https://iohk.io/blog/cryptocurrencies-need-a-safeguard-to-prevent-another-DAO-disaster/ )
"Cryptocurrencies need a safeguard to prevent another DAO disaster"
______________________
https://www.lexifi.com/files/resources/MLFiPaper.pdf  (ideas used in Cardanos Blockchain)

____________
https://en.bitcoin.it/wiki/Deterministic_wallet: 
A deterministic wallet is a system of deriving keys from a single starting point known as a seed. The seed allows a user to easily back up and restore a wallet without needing any other information and can in some cases allow the creation of public addresses without the knowledge of the private key. Seeds are typically serialized into human-readable words in a Mnemonic phrase. 
___________________
(REF: https://eprint.iacr.org/2016/633, Making smart-contracts smarters, "The semantic gap")
___________________
https://en.wikipedia.org/wiki/Deterministic_finite_automaton
_________________
https://media.consensys.net/using-machine-learning-to-understand-the-ethereum-blockchain-1778485d603a
_____________________
<a href="https://towardsdatascience.com/the-difference-between-blockchains-distributed-ledger-technology-42715a0fa92">
  The Difference Between Blockchains &amp; Distributed Ledger Technology</a>

<a href="https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16">
  Blockchain vs. Distributed Ledger Technologies</a>

<a href="http://www.r3cev.com/blog/2017/2/24/when-is-a-blockchain-not-a-blockchain">When is a Blockchain not a Blockchain</a>

<a href="https://www.linkedin.com/pulse/thoughts-taxonomy-blockchains-distributed-ledger-colin-platt/">Thoughts on the taxonomy of blockchains &amp; distributed ledger technologies</a>

<a href="https://www.cointelligence.com/content/when-do-you-need-blockchain/">When do you need Blockchain</a>

<a href="https://hackernoon.com/blockchains-versus-traditional-databases-c1a728159f79">Blockchain versus Traditional Databases</a>

<a href="https://www.coindesk.com/information/what-is-the-difference-blockchain-and-database/">What is the Difference Between a Blockchain and a Database?</a>

<a href="https://hbr.org/2017/01/the-truth-about-blockchain">The Truth About Blockchain</a>
}
___________________________
https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
... For the purpose of this investigation, it is necessary to define the concept of tokenization. The concept borrows from the notion that businesses or entities are able to create fungible or non fungible representations of various forms of assets, commodities and services based on certain digital standards that currently exist in our ecosystem.

While the token economy is still developing, its important to distinguish that the first wave of products will initially have various failures and flaws that require time and iteration to perfect. Even though the tokenization of assets, financial products, energy and digital attention are all viable business models, the exact dynamic that they are implemented upon require additional layers of functionality and access that will only be improved upon with time. A successful token economy will be the resultant artifact created from significant developments and discoveries that are being made in game theoretical mechanism design and blockchain innovations.

As described in Josh Stark?s article on cryptoeconomics, the tokens that exhibit the strongest signs of usability are evaluated on whether they form a necessary component within the economics and game theory design of the overall business. If a business can digitize or tokenize various facets of its ecosystem, the lines of products that can be created expand exponentially beyond our traditional means of exchanging physical goods, financial assets, commodities, or technological services. By creating the digital medium upon which tokenized assets can come to fruition, significant developments can evolve from the new ecosystem.

In viewing the ecosystem of blockchain tools, it is apparent that Ethereum is in fact the substrate upon which the token economy can be built upon. And if the token economy model is able to incorporate the functions of private blockchains, scalability solutions and privacy tools like ZK-Snarks, the overall tokenization of digital assets will overshadow the current capabilities upon which our economic models are limited to due to inherent restrictions in organizational feasibilities.
-->
</html>
