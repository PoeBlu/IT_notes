<html>
<head>
   <meta charset="UTF-8">
   <title>Quorum Map</title>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv *[xxxsmall]{ font-size:1rem; } 
#zoomDiv *[ xxsmall]{ font-size:1rem; }
#zoomDiv *[  xsmall]{ font-size:1rem; }


body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]   {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td topic >topic</td>
  <td summa >summa</td>
  <td col1  ></td>
  <td col2  ></td>
</tr>
<tr {>
  <td topic >Quorum</td>
  <td summa >
    <p>The primary features of Quorum, and therefore extensions over public Ethereum, are:</p>
    <ul>
      <li>Transaction and contract privacy</li>
      <li>Multiple voting-based consensus mechanisms</li>
      <li>Network/Peer permissions management</li>
      <li>Higher performance</li>
    </ul>
    <p>Quorum currently includes the following components:</p>
    <ul>
      <li>Quorum Node (modified Geth Client)</li>
      <li>Constellation - Transaction Manager</li>
      <li>Constellation - Enclave</li>
    </ul>
    <p>The Quorum Node includes the following modifications to geth:</p>
    <ol>
      <li>‘Proof of work’ consensus algorithm has been replaced with ‘QuorumChain’ consensus, a vote-based consensus mechanism.</li>
      <li>The P2P layer has been modified to only allow connections to/from permissioned nodes.</li>
      <li>The block generation logic has been modified to replace the ‘global state root’ check with a new ‘global public state root’.</li>
      <li>The block validation logic has been modified to replace the ‘global state root’ in the block header with the ‘global public state root’</li>
      <li>The State Patricia trie has been split into two: a public state trie and a private state trie.</li>
      <li>Block validation logic has been modified to handle ‘Private Transactions’</li>
      <li>Transaction creation has been modified to allow for Transaction data to be replaced by encrypted hashes in order to preserve private data where required</li>
      <li>The pricing of Gas has been removed, although Gas itself remains</li>
    </ol>
  </td>
  <td col1  >
    <ul>
    <li><a href='https://github.com/jpmorganchase/quorum/tree/master/docs'>docs@GitHub</a> Whitepaper (PDF), Design, Privacy, Running, API</li>
    <li><a href='https://github.com/jpmorganchase/quorum/wiki'>Wiki@GitHub</a></li>
    <li><a href='https://www.jpmorgan.com/country/ES/en/Quorum'>J.P.Morgan Quorum Home Page</a><br/><br/><br/></li>
    <li {>
        <a href='https://github.com/jpmorganchase/quorum/wiki/Getting-Set-Up'>Getting-Set-Up</a>
        <ul>
        <li>Using Quorum requires installing, configuring and running 'Quorum Node' + 'Constellation server'
        <li>Manually set up Quorum: [ key generation, genesis block , constellation configuration ]</li>
        <li>Building Quorum Node From Source:
          <pre>
git clone https://github.com/jpmorganchase/quorum.git
cd quorum
make all # Binaries output: ./build/bin
make test
          </pre>
        </li>
        <li {>
      <p> Extra geth Quorum Options:</p>
      <pre xsmall>
--voteaccount value         Address  used to vote for blocks
--votepassword value        Password to unlock the voting address
--blockmakeraccount value   Address that is used to create blocks
--blockmakerpassword value  Password to unlock the block maker address
--singleblockmaker          only node creating blocks
--minblocktime value        Set minimum block time (default: 3)
--maxblocktime value        Set max block time (default: 10)
--permissioned              (See topic Network Permissioning)
      </pre>
        </li }>
    </li }>
    </ul>
  </td>
  <td col2  >
    Using Quorum:
    <p>REF: <a href='https://github.com/jpmorganchase/quorum/wiki/Using-Quorum'  >Using-Quorum</a><br/>
            <a href="https://github.com/jpmorganchase/quorum/blob/master/docs/running.md">Running.md@github.com/jpmorganchase</a>
    <ul {>
      <li>Initialize chain:
        <ol {>
          <li>Generate the genesis block
           <p>The genesis block should include the Quorum voting contract address '0x0000000000000000000000000000000000000020'</p>
           <p>The code can be generated with 
              <a href='http://ethereum.github.io/browser-solidity/#version=soljson-latest.js'>browser solidity</a>
              or with:
              <pre>
solc   --optimize --bin-runtime block_voting.sol
              </pre>
           </p>
           <p>Example genesis file (copy to `genesis.json`):
             <pre xxxsmall {>
{
  "alloc": {
    "0x0000000000000000000000000000000000000020": {
      "code": "6060...656",
      "storage": {
        "0x0000000000000000000000000000000000000000000000000000000000000001": "0x02",
        "0x0000000000000000000000000000000000000000000000000000000000000002": "0x04",
        "0x29ecdbdf95c7f6ceec92d6150c697aa14abeb0f8595dd58d808842ea237d8494": "0x01",
        "0x6aa118c6537572d8b515a9f9154be55a3377a8de7991cd23bf6e5ceb368688e3": "0x01",
        "0x50793743212c6f01d326957d7069005b912f8215f10c7536be6b10782c6c44cd": "0x01",
        "0x38f6c908c5cc7ca668cec2f476abe61b4dbb1df20f0ad8e07ef5dbf6a2f1ffd4": "0x01",
        "0x0000000000000000000000000000000000000000000000000000000000000004": "0x02",
        "0xaca3b76ed4968740c3180dd7fa37f4aa229a2c758a848f53920e9ccb4c4bb74e": "0x01",
        "0xd188ba2dc293670542c1befaf7678b0859e5354a0727d1188b2afb6f47fe24d1": "0x01"
      }
    },
    "0xed9d02e382b34818e88b88a309c7fe71e65f419d": { "balance": "1000000000000000000000000000" },
    "0xca843569e3427144cead5e4d5999a3d0ccf92b8e": { "balance": "1000000000000000000000000000" },
    "0x0fbdc686b912d7722dc86510934589e0aaf3b55a": { "balance": "1000000000000000000000000000" },
    "0x9186eb3d20cbd1f5f992a950d808c4495153abd5": { "balance": "1000000000000000000000000000" },
    "0x0638e1574728b6d862dd5d3a3e0942c3be47d996": { "balance": "1000000000000000000000000000" }
  },
  "coinbase": "0x0000000000000000000000000000000000000000",
  "config": { "homesteadBlock": 0 },
  "difficulty": "0x0",
  "extraData": "0x",
  "gasLimit": "0x2FEFD800",
  "mixhash": "0x00000000000000000000000000000000000000647572616c65787365646c6578",
  "nonce": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "timestamp": "0x00"
}
             </pre }>
           </p>
          </li>
          <li>initialize geth:
             <pre> $ geth init genesis.json </pre>
          </li>
        </ol }>
      </li>
    <li {>The storage key for voters and block makers is calculated with 
      <em>web3.sha3(<256 padded bit aligned key value> + <256 padded bit variable index>)</em> like:
      <pre xxsmall>
(geth JS console)
 account_address_voting = "000000000000000000000000ed9d02e382b34818e88b88a309c7fe71e65f419d"
 // REF: <a href='https://github.com/jpmorganchase/quorum/blob/master/core/quorum/block_voting.sol#L42'>block_voting.sol</a>
 // * Period[] periods                        index 0
 // * uint public voteThreshold               index 1
 // * uint public voterCount                  index 2
 // * mapping(address => bool) public canVote index 3
 votingSmartContract_canVote_index_3 = "0000000000000000000000000000000000000000000000000000000000000003"
 key = account_address_voting + votingSmartContract_canVote_index_3
 web3.sha3(key, {"encoding": "hex"})
"0x29ecdbdf95c7f6ceec92d6150c697aa14abeb0f8595dd58d808842ea237d8494"
      </pre>
    </li }>
    <li>(Optional)  Setup Bootnode that all the other nodes will first connect to in order to find other peers in the network.
      <ol {>
        <li>To generate the key for the first time:
          <pre>
bootnode -genkey tmp_file.txt  
            </pre>
            this will start a bootnode with an enode address and generate a key inside a “tmp_file.txt” file
          </li>
          <li>To later restart the bootnode using the same key (and hence use the same enode url):
            <pre>
$ bootnode -nodekey tmp_file.txt
or 
$ bootnode -nodekeyhex \ 
    77bd02ffa26e3fb8f324bda24ae588066f1873d95680104de5bc2db9e7b2e510 
    # Key from tmp_file.txt
          </pre>
        </li>
      </ol }>
    </li>
    <li {>Start node:
      <pre>
# Start WITHOUT ANY ROLES (makes node an spectator)
$ geth

# Start with VOTING ROLE
$ geth       --voteaccount 0xed9d02e382b34818e88b88a309c7fe71e65f419d 

# Start with BLOCK MAKER ROLE
$ geth --blockmakeraccount 0x9186eb3d20cbd1f5f992a950d808c4495153abd5 
                           ^blocks will be signed with this account
Optional params:
#  --bootnodes $BOOTNODE_ENODE : Optional, indicates the booting node
      </pre>
    </li }>
    </li>
    </ul }>
  </td>
</tr }>

<tr {>
  <td topic >Constellation</td>
  <td summa >
    Constellation forms a network of nodes, each of which advertises a list of public keys that they are the recipient for. Each node exposes an API which allows the user to send a payload to one or more public keys. That payload will be encrypted for the public key before being transferred over the wire to the recipient node. You can think of it as a network of Mail Transfer Agents (MTAs) exchanging PGP-encrypted emails.<br/>
    Constellation is a general-purpose system for submitting information in a secure way. It is comparable to a network of MTA (Message Transfer Agents) where messages are encrypted with PGP. It is not blockchain-specific, and is potentially applicable in many other types of applications where you want individually-sealed message exchange within a network of counterparties.<br/>
</td>
  <td col1  >
    <ul>
      <li><a href='https://github.com/jpmorganchase/constellation'>GitHub</a></li>
    </ul>
  </td>
  <td col2  >
    <ul>
      <li>Installation instructions @<a href='https://github.com/jpmorganchase/constellation'>GitHub</a></li>
      <li>Binaries available at: <a href='https://github.com/jpmorganchase/constellation/releases'>https://github.com/jpmorganchase/constellation/releases</a>
      </li>
    </ul>

  </td>
</tr }>

<tr {>
  <td topic >QuorumChain</td> 
  <td summa >
     A time-based, majority-voting algorithm where the most recent block with the most
     votes is considered the canonical head of the chain. A block is only considered
     valid once a given threshold of votes has been received from valid Voters.
    <p>It's composed of:
      <ul>
        <li {>A Smart Contract <a href='https://github.com/jpmorganchase/quorum/blob/master/core/quorum/block_voting.sol'>BlockVoting</a>  to govern consensus and manage who can partake in consensus
         <pre xxxsmall {>
pragma solidity ^0.4.2;

// Implements a block voting algorithm to reach consensus.
//
// To vote for a block the sender must be allowed to vote. When deployed the
// deployer is the only party that is allowed to vote and can add new voters.
// Note that voters can add new voters and thus have the abbility to add multiple
// voter accounts that they control. This gives them the possibility to vote
// multiple times for a particular block. Therefore voters must be trusted.
contract BlockVoting {
    // Raised when a vote is made
    event Vote(address indexed sender, uint blockNumber, bytes32 blockHash);
    // Raised when a new address is allowed to vote.
    event AddVoter(address);
    // Raised when an address is not allowed to make votes anymore.
    event RemovedVoter(address);
    // Raised when a new address is allowed to create new blocks.
    event AddBlockMaker(address);
    // Raised when an address is not allowed to make blocks anymore.
    event RemovedBlockMaker(address);

    // The period in which voters can vote for a block that is selected
    // as the new head of the chain.
    struct Period {
        // number of times a block is voted for
        mapping(bytes32 => uint) entries;

        // blocks up for voting
        bytes32[] indices;
    }

    // Collection of vote rounds.
    Period[] periods;

    // Canonical hash must have at least voteThreshold votes before its considered valid.
    uint public voteThreshold;

    // Number of addresses that are allowed to make votes.
    uint public voterCount;

    // Collection of addresses that are allowed to vote.
    mapping(address => bool) public canVote;

    // Number of addresses that are allowed to create blocks.
    uint public blockMakerCount;

    // Collection of addresses that are allowed to create blocks.
    mapping(address => bool) public canCreateBlocks;

    // Only allow addresses that are allowed to make votes.
    modifier mustBeVoter() {
        if (canVote[msg.sender]) {
            _;
        } else {
            throw;
        }
    }

    // Only allow addresses that are allowed to create blocks.
    modifier mustBeBlockMaker() {
        if (canCreateBlocks[msg.sender]) {
            _;
        } else {
            throw;
        }
    }

    // Set a new vote threshold. The canonical hash must have at least the given
    // threshold number of votes before it's considered valid.
    function setVoteThreshold(uint threshold) mustBeVoter {
        voteThreshold = threshold;
    }

    // Make a vote to select a particular block as head for the previous head.
    // Only senders that are added through the addVoter are allowed to make a vote.
    // TODO: discuss if we only allow 1 vote per voter
    // (this can deadlock the system if all voters votes for something different
    // (nVotes < threshold) and cannot vote anymore, or gas limit is reached).
    function vote(uint height, bytes32 hash) mustBeVoter {
        // start new period if this is the first transaction in the new block.
        if (periods.length < height) {
            periods.length += height-periods.length;
        }

        // select the voting round.
        Period period = periods[height-1];

        // new block hash entry
        if(period.entries[hash] == 0) period.indices.push(hash);

        // vote
        period.entries[hash]++;

        // log vote
        Vote(msg.sender, block.number, hash);
    }

    // Get canonical head for a given block number.
    // E.g. [block 124] - [block 125] - [block 126 (pending)]
    // getCanonHash(126) will return the hash of block 125
    // (if there are enough votes for it).
    function getCanonHash(uint height) constant returns(bytes32) {
        Period period = periods[height-1];

        bytes32 best;
        for(uint i = 0; i < period.indices.length; i++) {
            if(period.entries[best] < period.entries[period.indices[i]]
            && period.entries[period.indices[i]] >= voteThreshold) {
                best = period.indices[i];
            }
        }
        return best;
    }

    // Add a party that is allowed to make a vote.
    // Only current voters are allowed to add a new voter.
    function addVoter(address addr) mustBeVoter {
        if (!canVote[addr]) {
            canVote[addr] = true;
            voterCount++;
            AddVoter(addr);
        }
    }

    // Remove a party that is allowed to vote.
    // Note, a voter can remove itself as a voter!
    function removeVoter(address addr) mustBeVoter {
        // don't let the last voter remove itself
        // which can cause the algorithm to stall.
        if (voterCount == 1) throw;

        if (canVote[addr]) {
            delete canVote[addr];
            voterCount--;
            RemovedVoter(addr);
        }
    }

    // isVoter returns an indication if the given address is allowed to vote.
    function isVoter(address addr) constant returns (bool) {
        return canVote[addr];
    }

    // addBlockMaker adds the given list to the collection of addresses that
    // are allowed to create blocks.
    function addBlockMaker(address addr) mustBeBlockMaker {
        if (!canCreateBlocks[addr]) {
            canCreateBlocks[addr] = true;
            blockMakerCount++;
            AddBlockMaker(addr);
        }
    }

    // removeBlocksMaker deletes the given address from the collection of
    // addresses that are allowed to create blocks.
    function removeBlockMaker(address addr) mustBeBlockMaker {
        if (blockMakerCount == 1) throw;

        if (canCreateBlocks[addr]) {
            delete canCreateBlocks[addr];
            blockMakerCount--;
            RemovedBlockMaker(addr);
        }
    }

    // isBlockMaker returns an indication if the given address can create blocks.
    function isBlockMaker(address addr) constant returns (bool) {
        return canCreateBlocks[addr];
    }

    // Number of voting rounds.
    function getSize() constant returns(uint) {
        return periods.length;
    }

    // Return a blockhash by period and index.
    function getEntry(uint height, uint n) constant returns(bytes32) {
        Period period = periods[height-1];
        return period.indices[n];
    }
}

         </pre }>
       </li }>
        <li>Ethereum Transactions to propagate votes through the network</li>
        <li>Ethereum's signature validation to validate signatures received from Maker and Voter nodes</li>
      </ul>
    </p>

  </td>
  <td col1 >
    <p>Roles:
    <ul>
      <li>Voter: votes on which block should be the canonical head at a particular height </li>
      <li>Maker: can create a block and sign it by setting their signature in the ExtraData 
          field of the block. <br/>
          Nodes verify that blocks are signed by one of the nodes that have the Maker role 
          by looking up the signer's address in the <em>list of valid Makers in the voting contract</em>
      </li>
      <li>Observer: no role</li>
    </ul>
    </p>
  </td>  
  <td col2  >
    <p { >BlockVoting (smart) contract:
    <ul>
      <li>hard-coded in  genesis block at @0x0000000000000000000000000000000000000020</li>
      <li>Maker and Voter nodes are registered here</li>
      <li>Updating it means Quorum client needs to be updated</li>
      <li>member functions allow Voters and Makers to be added or removed, or tunning
          the minimum number of votes before a block is selected as the winner</li>
      <li>tracks:<br/> 
          - votes received are from valid Voters?<br/>
          - number of votes received for a particular block &gt; voteThreshold ?<br/>
      </li>
      <li>As part of block validation, the contract is called to determine the 
          latest block which meets the required number of votes (the "parent of the proposed block")
      </li>

    </p }>
    <p { >Maker Node:
    <ul>
      <li>There must be at least 1 Maker Node configured in the contract.</li>
      <li>The initial set of Maker Nodes is pre-configured in the genesis block via the genesis.json file</li>
      <li>once the network is established, Maker Nodes can add and remove other Maker Nodes by sending 
          a Transaction with the appropriate function call to the BlockVoting contract</li>
      <li>Maker Nodes can also be setup as Voter Nodes</li>
    </ul>
    </p }>

    <p { >Voter Node:
    <ul>
      <li>once the network is established, Voter Nodes can add and remove other Voter Nodes 
          by sending a Transaction with the appropriate function call to the BlockVoting contract.
          Voter Nodes can also set the voteThreshold that must be met before a block will be
          accepted into the chain.</li>
    </ul>
    </p }>

    <p { >Observer Node:
    <ul>
      <li>receives and validate blocks</li>
    </ul>
    </p }>
 
     <p { >Consensus Process Flow:
    <pre xxsmall>
Loop:
    timeout -> Maker_Node:  if the votes for previous block &gt; threshold
                            creates and signs block
        (block includes votes for its parent block, which were cast in the previous Period)
    Maker_Node -> network: publish block
    network -> Voter_Node: published blocks
    Voter_Node -> Voter_Node: Validates block
                             - checks Maker is allowed (through BlockVoting contract)
                             - checks block's parent block received enough votes (through BlockVoting contract)
                             - Executes all public TXs + participated Private Transactions in the block
                               (after retrieving the TX payload from its Transaction Manager,
                                as defined in the Transaction Processing & Privacy page).
                             - Validates the public state by comparing the public state root hash
                               with the state root within the block.
                             - Hashing all Transactions in the block (Public & Private) and comparing
                               that hash to the Transaction Hash on the block. 
                               (ensures that all Voter Nodes agree on the TX list in the block)
    Voter_Node -> network: TX with vote to BlockVoting contract
                           Since votes for a given block are cast via standard Transactions,
                           they can only be processed when the next block is created.
    ...
, and then the block creation - > validation -> voting process is repeated.

    </pre>
    </p }>
  </td>
</tr }>

<tr {>
  <td topic >Transaction Manager</td> 
  <td summa >
     <ul>
       <li>Quorum’s Transaction Manager is responsible for Transaction privacy. It stores and allows access to encrypted transaction data, exchanges encrypted payloads with other participant's Transaction Managers but does not have access to any sensitive private keys. It utilizes the Enclave for cryptographic functionality (although the Enclave can optionally be hosted by the Transaction Manager itself.)
</li>
       <li>The Transaction Manager is restful/stateless and can be load balanced easily.</li>
       <li><a href='https://github.com/jpmorganchase/quorum/wiki/Transaction-Processing'>https://github.com/jpmorganchase/quorum/wiki/Transaction-Processing</a></li>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >The Enclave</td> 

  <td summa >
     <ul>
       <li>Distributed Ledger protocols typically leverage cryptographic techniques for transaction authenticity, participant authentication, and historical data preservation (i.e. through a chain of cryptographically hashed data.) In order to achieve a separation of concerns, as well as to provide performance improvements through parallelization of certain crypto-operations, much of the cryptographic work including symmetric key generation and data encryption/decryption is delegated to the Enclave.</li>
       <li>The Enclave works hand in hand with the Transaction Manager to strengthen privacy by managing the encryption/decryption in an isolated way. It holds private keys and is essentially a “virtual HSM” isolated from other components.</li>
     </ul>

  </td>
  <td col1 >
  </td>  
  <td col2  >
  </td>

</tr }>

<tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>

</tr }>

<tr {>
  <td topic >Alastria</td> 
  <td summa >
     <ul>
       <li><a href='https://alastria.io/'>https://alastria.io/</a></li>
<!--
       <li> </li>
       <li> </li>
-->
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td >
  </td>

</tr }>

<tr {>
  <td topic >Transaction Processing</td> 
  <td summa >
     <ul>
       <li>'Public Transactions' and 'Private Transactions' are a notional concept only and Quorum does not introduce new Transaction Types, but rather, the Ethereum Transaction Model has been extended to include an optional 'privateFor' parameter (the population of which results in a Transaction being treated as private by Quorum) and the Transaction Type has a new IsPrivate method to identify such Transactions. </li>
       <li>Public Transactions are those Transactions whose payload is visible to all participants of the same Quorum network.</li>
       <li>Private Transactions are those Transactions whose payload is only visible to the network participants whose public keys are specified in the privateFor parameter of the Transaction . privateFor can take multiple addresses in a comma separated list.<br/>
 Quorum Node sets the Transaction_Signature.V = 37 or 38 (as opposed to 27 or 28)<br/>
Private Transactions are NOT executed per standard Ethereum: prior to the sender's Quorum Node propagating the Transaction to the rest of the network, it replaces the original Transaction Payload with a hash of the encrypted Payload that it receives from Constellation. Participants that are party to the Transaction will be able to replace the hash with the actual payload via their Constellation instance, whilst those Participants that are not party will only see the hash.
       </li>
       <li {>
         <p>Example: Party A and Party B are party to Transaction AB, whilst Party C is not.</p>
         <ol>
         <li>
         <p>Party A sends a Transaction to their Quorum Node, specifying the Transaction payload and setting <code>privateFor</code> to be the public keys for Parties A and B</p>
         </li>
         <li>
         <p>Party A's Quorum Node passes the Transaction on to its paired Transaction Manager, requesting for it to store the Transaction payload</p>
         </li>
         <li>
         <p>Party A's Transaction Manager makes a call to its associated Enclave to validate the sender and encrypt the payload</p>
         </li>
         <li>
         <p>Party A's Enclave checks the private key for Party A and, once validated, performs the Transaction conversion. This entails:</p>
         <ol>
         <li>generating a symmetric key and a random Nonce</li>
         <li>encrypting the Transaction payload and Nonce with the symmetric key from i.</li>
         <li>calculating the SHA3-512 hash of the encrypted payload from ii.</li>
         <li>iterating through the list of Transaction recipients, in this case Parties A and B, and encrypting the symmetric key from i. with the recipient's public key (PGP encryption)</li>
         <li>returning the encrypted payload from step ii., the hash from step iii. and the encrypted keys (for each recipient) from step iv. to the Transaction Manager</li>
         </ol>
         </li>
         <li>
         <p>Party A's Transaction manager then stores the encrypted payload (encrypted with the symmetric key) and encrypted symmetric key using the hash as the index, and then securely transfers (via HTTPS) the hash, encrypted payload, and encrypted symmetric key that has been encrypted with Party B's public key to Party B's Transaction Manager.  Party B's Transaction Manager responds with an Ack/Nack response. Note that if Party A does not receive a response/receives a Nack from Party B then the Transaction will not be propagated to the network.  It is a prerequisite for the recipients to store the communicated payload.</p>
         </li>
         <li>
         <p>Once the data transmission to Party B's Transaction Manager has been successful, Party A's Transaction Manager returns the hash to the Quorum Node which then replaces the Transaction's original payload with that hash, and changes the transaction's <code>V</code> value to 37 or 38, which will indicate to other nodes that this hash represents a private transaction with an associated encrypted payload as opposed to a public transaction with nonsensical bytecode.</p>
         </li>
         <li>
         <p>The Transaction is then propagated to the rest of the network using the standard Ethereum P2P Protocol.</p>
         </li>
         <li>
         <p>A block containing Transaction AB is created and distributed to each Party on the network.</p>
         </li>
         <li>
         <p>In processing the block, all Parties will attempt to process the Transaction.  Each Quorum node will recognise a <code>V</code> value of 37 or 38, identifying the Transaction as one whose payload requires decrypting, and make a call to their local Transaction Manager to determine if they hold the Transaction (using the hash as the index to look up).</p>
         </li>
         <li>
         <p>Since Party C does not hold the Transaction, it will receive a <code>NotARecipient</code> message and will skip the Transaction - it will not update its Private StateDB.  Party A and B will look up the hash in their local Transaction Managers and identify that they do hold the Transaction. Each will then make a call to its Enclave, passing in the Encrypted Payload, Encrypted symmetric key and Signature.</p>
         </li>
         <li>
         <p>The Enclave validates the signature and then decrypts the symmetric key using the Party's private key that is held in The Enclave, decrypts the Transaction Payload using the now-revealed symmetric key and returns the decrypted payload to the Transaction Manager.</p>
         </li>
         <li>
         <p>The Transaction Managers for Parties A and B then send the decrypted payload to the EVM for contract code execution.  This execution will update the state in the Quorum Node's Private StateDB only. NOTE: once the code has been executed it is discarded so is never available for reading without going through the above process.</p>
         </li>
         </ol>
       </li }>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td >
  </td>

</tr }>

<tr {>
  <td topic >Network Permissioning</td> 
  <td summa >
    <ul>
      <li>feature controling which nodes can connect to a given node and also to which nodes the given node can dial out to.
</li>
      <li>--permissioned + data-dir/permissioned-nodes.json (whitelist of enodes that this node can connect to/from)
        <pre xsmall { >
[ 
  "enode://6a...f47@127.0.0.1:30300",
  "enode://remoteky1@ip1:port1",
  "enode://remoteky1@ip2:port2",
  ...
]
        </pre } >

<p>Any additions to 'permissioned-nodes.json' will be dynamically picked up by the server when subsequent incoming/outgoing requests are made.</p>
<p>Removing existing connected nodes from 'permissioned-nodes.json' will NOT immediately drop those existing connected nodes, but when current connections are dropped</p>
      </li>
      <li>NOTE: In the current implementation, every node has its own copy of the permissioned-nodes.json file. In this case, if different nodes have a different list of remote keys then each node may have a different list of permissioned nodes - which may have an adverse effect. In a future release, the permissioned nodes list will be moved from the permissioned-nodes.json file to a Smart Contract, thereby ensuring that all nodes will use one global on-chain list to verify network connections. Please see the Product Roadmap for further planned enhancements</li>
      <li><p TODO>Checkout <a href="https://github.com/jpmorganchase/quorum-examples/tree/master/examples/permissions">permissions example</a> on how to run nodes with permissioning enabled, or see the set up instructions below.</p></li>
    </ul>
  </td>
  <td col1 >
<!--
     <ul>
       <li> </li>
     </ul>
-->
  </td>  
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic TODO ><a href="https://github.com/jpmorganchase/quorum/blob/master/docs/api.md">Quorum API</a></td> 
  <td summa >
  </td>
  <td col1 >
  </td>  
  <td col2  >
  </td>
</tr }>

<tr {>
  <td topic >Alastria.io</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li><a href='https://alastria.io/'>https://alastria.io/</a></li>
       <li><a href='https://github.com/marcossanlab/alastria-node'>https://github.com/marcossanlab/alastria-node</a></li>
     </ul>
  </td>  
  <td col2  >
  </td>
</tr }>
</table>
</body>
<!--
_____________________________________________________
Quorum:
  Brian Marchiony Head of CIB Marketing & Communications brian.j.marchiony@jpmorgan.com
  Amber Baldet Program Lead, Blockchain Center of Excellence amber.baldet@jpmorgan.com
  David Voell Engineering Lead, CIB Emerging Technologies david.l.voell@jpmorgan.com
_____________________________________________________
<p>See the <a href="https://github.com/jpmorganchase/quorum/blob/master/docs/api.md#privacy-apis">Quorum API</a> page for details on the <code>sendTransaction</code> call, which includes some modifications to the standard Ethereum call.</p>
    <li>
      <p>Developing Smart Contracts with Solidity</p>
      <p>Smart Contracts can be public or private to one or more network participants.  
      <p>Public  Transactions/Smart Contracts: Send an Ethereum Transaction to the network (TX.to         = "empty" creates a Contract)</p>
      <p>Private Transactions/Smart Contracts: Send an Ethereum Transaction to the network setting TX.privateFor = participant(s) public_key_list</p>
      <p>Example JSON message:
       <pre>
{ 
  "jsonrpc":"2.0",
  "method":"eth_sendTransaction",
  "params":[
    {
     "from": $FROM_AC,
     "to": $TO_AC, 
     "data": $CODEHASH,
     "privateFor": ["$PUBKEY1,PUBKEY2"]
    }
  ],
  "id":$ID
} 
       </pre>
      </p>
_____________________________________________________
Quorum Contract Design Considerations
- Private contracts cannot update public contracts.
(not all participants will be able to execute a private contract, and so if that contract can update a public contract, then each participant will end up with a different state for the public contract.
- Once a contract has been made public, it can't later be made private. You DO need to delete from the blockchain and create a new private contract
_____________________________________________________
Raft-based consensus: geth --raft
REF: https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md
- useful for closed-membership/consortium settings where BYZANTINE FAULT TOLERANCE is NOT A REQUIREMENT
- faster blocktimes (milliseconds vs seconds)
- absence of forking: 
- Compared with QuorumChain, does NOT "unnecessarily" create empty blocks
_____________________________________________________

-->
</html>
