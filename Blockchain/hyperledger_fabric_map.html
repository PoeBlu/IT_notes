<html>
<head>
   <meta charset="UTF-8">
   <title>Hyperledger Fabric</title>
<style>
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[xbig  ]  { font-size:1.3rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[xxsmall], #zoomDiv > * > *[xxsmall], #zoomDiv > * > * > *[xxsmall]{ font-size:1rem; }
#zoomDiv > *[xsmall] , #zoomDiv > * > *[xsmall] , #zoomDiv > * > * > *[xsmall] { font-size:1rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col3]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td summa >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td summa colspan=4 >Summary<td>
</tr>
<tr {>
  <td summa>
    <ul>
      <li><a href='https://godoc.org/github.com/hyperledger/fabric' xbig>GoLang API DOC</a></li>
      <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/'>Fabric</a></li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html">Glossary</a>                </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/releases.html">Release Notes</a>           </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/questions.html">Still Have Questions?</a>  </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/status.html">Status</a>                    </li>
      <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/samples.html'>Fabric Samples</a><br/>
          $ git clone <a href='https://github.com/hyperledger/fabric-samples.git'>https://github.com/hyperledger/fabric-samples.git</a></li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html">Architecture Explained</a></li>
    </ul>
  </td>
  <td col1 >
     <ul>
       <li>There are three types of nodes:
         <ul>
           <li>Client or submitting-client: a client that submits an actual 
               transaction-invocation to the endorsers, and broadcasts transaction-proposals to
               the ordering service.<br/>
               The client represents the entity that acts on behalf of an end-user.<br/>
               It must connect to a peer for communicating with the blockchain.  <br/>
               The client may connect to any peer of its choice. <br/>
               Clients create and thereby invoke transactions.
           </li>
           <li>Peer: node that commits TXs and maintains the state and a copy of the ledger
               (see Sec, 1.2). Besides, peers can have a special endorser role. A peer receives
               ordered state updates in the form of blocks from the ordering service and
               maintain the state and the ledger.  Peers can additionally take up a special
               role of an endorsing peer, or an endorser with respect to a particular chaincode.
           </li>
           <li>Ordering-service-node or orderer: a node running the communication service that 
               implements a delivery guarantee, such as atomic or total order broadcast.</li>
         </ul>
       </li>
  


       <li>
   <pre xsmall { >
                  ┌──────────┐
               ┌─→│MEMBERSHIP│
               ┆  │ No SPoF  ┼───────────────────────────────┐
       0 enroll┆  │ No SPoT  │     ┆                         ┆
               ┆  └──────────┘     ┆                         ┆
               ┆             ┌─────┴─────┐                   ┆
┌───────────┐  ┆             │ PEER      │                   ┆
│APPLICATION│  ┆             │           │                   ┆
│  SDK -----┼--┆───────────→ │ Endorser  │ 3 Relay     ┌─────┴───────┐
│  keys     │  ┆1 Endorse    │ Committer │ Submit TX   │O-SERVICE    │
└───────────┘  ┆  proposal   │           │───────────→ │             │
               ┆             │           │             │ Order TXs in│
               ┆             │ ledger    │             │ a batch     │
               ┆             │           │             │ according to│
               └───────────→ │ chaincode │←─────────── │ consensus*1 │
                2 Submit TX  │           │ 4 Deliver   └─────────────┘
                             │ event     │   batch
                             └───────────┘
 *1 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#consensus" >Consensus</a> is ultimately achieved when
     the order and results of a block's transactions 
     have met the explicit policy criteria checks.

CouchDB: the PEER hold the hash chain (the record of updates),
while updates themselves are stored in a separate
couchDB container (allowing for storage of rich JSON queries).

QUERIES: 
APP -> APP : var request = request(ledger, chaincode, search params)
APP -> PEER: chain.queryByChaincode(request) API 
PEER -> APP: (synch) response_payload

UPDATES (TX FLOW)
--------  connect to peer's event listener port  --------
APP -> PEER: eh.setPeerAddr ()
--------  TX FLOW  --------
APP -> APP : var req = 
       TX_proposal(channel ID, chaincode, function) 
APP -> (endorsing)PEER:
       channel.SendTransactionProposal(req)
PEER -> APP: proposal_response
APP -> APP: 
       tx_request =sign(proposal_response)
APP -> ORDERING_SVC: 
       channel.sendTransaction(tx_request)
??? -> APP: TX_ID
APP -> PEER:
       eh.registerTxEvent (TX_ID, callback)
ORDERING_SVC -> ORDERING_SVC: 
       bundles TX into a block
ORDERING_SVC -> PEERS on channel: block
PEER -> PEER : validate block
</pre>
       </li>
       <li>Nodes are the communication entities of the blockchain.
         A “node” is only a logical function in the sense that 
         multiple nodes of different types can run on the same 
         physical server. What counts is how nodes are grouped in
         “trust domains” and associated to logical entities that
         control them.
       </li>
  </td>
  <td col2 >
    <a href='https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html'><b xbig>TRANSACTION FLOW</a> <br/>
    ("INTEND TO UPDATE THE LEDGER" FLOW)</b>
    <pre xsmall { >
Participant (peer) A : Buyes radishes
Participant (peer) B : Sells radishes

Admin -> +Channel: set up and run
Admin ->  Channel: register and endorse A,B with CA
                   (A and B must endorse any TX)

Admin -> +Chaincode : - Initial key/value State 
                      - Logic for TX

Admin -> A, B : Install chaincode

Channel -> A,B : Request
App@peer1 -> App@peer1: Create TX proposal = Request exec
                     TX.chaincode.funct to call
                     TX.input           input to funct
App@peer1 -> App@peer1: Package TX proposal
App@peer1 -> App@peer1: Sign(Package TX proposal) with user's
                      credentials


App@peer1 -> Channel: Signed TX proposal (purchase req)
Channel -> endorsing peers:
endorsing peer -> endorsing peer: verifies:
                   - TX proposal is well formed
                   - it has not been submitted already
                     in the past (replay-attack protection)
                   - signature is valid (using MSP)
                   - submitter is properly authorized 
                     (ensures that submitter satisfies the 
                      channel’s Writers policy)
endorsing peer -> Chaincode: TX.chaincode.funct(TX.input)
Chaincode -> Chaincode: execute funct against current state
               of database 
Chaincode -> App: (@endorsing peer) 
                  TX.result = [
                     response value, 
                     read set,
                     write set ]
App -> App: SDK parses payload
            for application consumption
            -------------------------------------------
   The submitting client waits until it receives “enough” messages 
   and signatures on (TRANSACTION-ENDORSED, tid, *, *) statements to
   conclude that the TX proposal is endorsed. (may involve one or more
   round-trips of interaction with endorsers)
   If the submitting client does not manage to collect an endorsement
   for a transaction proposal, it abandons this transaction with an
   option to retry later.
   For transaction with a valid endorsement, we now start using the 
   ordering service. --
            -------------------------------------------
App -> (channel) -> Ordering Service :(Just for write 2 ledger)
                        TX.proposal + TX.result + endorsing sign.

Ordering Service -> Ordering Service: Order chronologically
                                      create blocks of TX
                    Serializability is a default isolation guarantee

Ordering Service -> Peers: TX block
Peers -> Peers: validate block
Peers -> Peers: Update ledger
Peers -> Client: event TX inmmutable appended to chain
</pre } >
  </td>
  <td col3 >
   <a href='https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html'>Prerequisites:</a>
   <ul>
     <li><a href='https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites'>Docker CE for Centos</a></li>
     <li>Dependencies: cURL, git,<br/>
         docker 17.06.02-ce+ (2017-09-05)(docker engine 1.13.x NOT supported),
         <a href='https://go-repo.io/'>adding docker-ce repo to yum</a>
         <br/>
         docker-compose 1.14.0+ See <a href='https://docs.docker.com/compose/install/#install-compose'>here</a> to install latest version
     </li>

     <li>Go programming language 1.9.x <br/>
         Check $GOPATH="working directory" (example $HOME/go)
         <a href='https://go-repo.io/'>Install custom golang repo</a>
     </li>
     <li>Node.js 6.9.x Runtime (7.x not yet supported) and NPM (npm install npm@3.10.10 -g)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
   </ul>
   <span xbig>Development and contributing:</a>
   <ul>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/CONTRIBUTING.html">Contributions Welcome!</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/MAINTAINERS.html">Maintainers</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/jira_navigation.html">Using Jira to understand current work items</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">Setting up the development environment</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html">Building Hyperledger Fabric</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#building-outside-of-vagrant">Building outside of Vagrant</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#configuration">Configuration</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#logging">Logging</a></li>
     <li><a href="Gerrit/lf-account.html">Requesting a Linux Foundation Account</a></li>
     <li><a href="Gerrit/gerrit.html">Working with Gerrit</a></li>
     <li><a href="Gerrit/changes.html">Submitting a Change to Gerrit</a></li>
     <li><a href="Gerrit/reviewing.html">Reviewing a Change</a></li>
     <li><a href="Gerrit/best-practices.html">Gerrit Recommended Practices</a></li>
     <li><a href="testing.html">Testing</a></li>
     <li><a href="Style-guides/go-style.html">Coding guidelines</a></li>
     <li><a href="Style-guides/go-style.html#generating-grpc-code">Generating gRPC code</a></li>
     <li><a href="Style-guides/go-style.html#adding-or-updating-go-packages">Adding or updating Go packages</a></li>
   </ul>

  </td>
</tr }>

<tr header_delimit {> 
  <td colspan=4 >Fabric Model</td>
</tr>

<tr {>
  <td summa >
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#assets" xbig>Assets</a>
     <ul>
       <li>Asset definitions enable the exchange of almost anything with monetary value over the network, from whole foods to antique cars to currency futures</li>
       <li>Assets are represented in Hyperledger Fabric as a collection of key-value pairs, with state changes recorded as transactions on a Channel ledger.</li>
       <li>Assets can be represented in binary and/or JSON form</li>
       <li><a class="reference external" href="https://github.com/hyperledger/composer">Hyperledger Composer</a> can easily define assets</li>
  </p>
     </ul>
  </td>
  <td col1 >
    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode" xbig>Chaincode</a><br/>
    <a href='http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html'>Chaincode 4 devs</a>
    <ul>
      <li>Chaincode is software defining an asset or assets, and the transaction instructions for modifying the asset(s).</li>
      <li>Chaincode (smart-contract) are hosted in the network, identified by name and version, for example 'dev-peer0.org1.example.com-fabcar-1.0' when the name is fabcar, the version is 1.0 and the peer it is running against is dev-peer0.org1.example.com</li>
      <li>Chaincode is installed only on peers that need to access the asset states to perform reads and writes</li>
      <li>Chaincode invocations 1 to 1 Transaction</li>
      <li>Chaincode execution is partitioned from transaction ordering, limiting the required levels of trust and verification across node types, and optimizing network scalability and performance</li>
      <li>enforces the rules for reading or altering key value pairs or other state database information</li>
      <li>Chaincode functions execute against the ledger current state database </li>
      <li>Chaincode functions are initiated through a transaction proposal</li>
      <li TODO>To get started developing chaincode, read :doc:'chaincode4ade'. </li>
    </ul>

  </td>  
  <td col2  >
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features" xbig>Ledger Features</a>
     <ul>
       <li>The immutable, shared ledger encodes the entire transaction history for each channel,
           and includes SQL-like query capability for efficient auditing and dispute resolution</li>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric</li>
       <li>Each results in a set of asset key-value pairs that are committed to the ledger as Creates, Updates, or Deletes</li>
       <li>The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in
           blocks, as well as a state database to maintain current fabric state.</li>
       <li>The ledger is part of a Channel (Each channel peer maintains a copy of the ledger) <br/>
           A ledger exists <b>in the life scope of a channel</b>
       </li>

       <li>Query and update ledger using key-based lookups, range queries, and composite key queries</li>
       <li>Read-only queries using a rich query language (if using CouchDB as state database)</li>
       <li>Read-only history queries - Query ledger history for a key, enabling data provenance scenarios</li>
       <li>TRANSACTIONS CONSIST OF THE VERSIONS OF KEYS/VALUES THAT WERE READ IN CHAINCODE 
           (READ SET) AND KEYS/VALUES THAT WERE WRITTEN IN CHAINCODE (WRITE SET)</li>
       <li>Transactions contain signatures of every endorsing peer and are submitted to ordering service</li>
       <li>Transactions may be of two types:<br/>
         - Deploy transactions create new chaincode and take a program as parameter.
           When a deploy transaction executes successfully, the chaincode has been 
           installed 'on' the blockchain. Deployment specifies the endorsement policy
           for the chaincode.<br/>
         - Invoke transactions perform an operation in the context of previously
           deployed chaincode. An invoke transaction refers to a chaincode and to
           one of its provided functions. When successful, the chaincode executes
           the specified function - which may involve modifying the corresponding
           state, and returning an output.
       </li>
     </ul>
  </td>
  <td col3 >
    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels" xbig >Privacy through Channels</a>
    <ul>
      <li>""" One truism about Hyperledger Fabric networks is that members know each other (identity), 
          but they do not know what each other are doing (privacy and confidentiality)."""</li>
      <li>Channel = { ledgerSingleton: ..., ACL: ...., block_policies } </li>
      <li>Channels enable multi-lateral transactions with the high degrees of privacy and confidentiality required by competing businesses and regulated industries that exchange assets on a common network.</li>
      <li>A channel's ledger contains a configuration block defining policies, access control lists, and other pertinent information</li>
      <li>Channel's contain Membership Service Provider instances allowing for crypto materials to be derived from different certificate authorities</li>
      <li>The channel supports atomic delivery of all messages, that is, message communication with total-order delivery and (implementation specific) reliability. In other words, the channel outputs the same messages to all connected peers and outputs them to all peers in the same logical order. This atomic communication guarantee is also called total-order broadcast, atomic broadcast, or consensus in the context of distributed systems. The communicated messages are the candidate transactions for inclusion in the blockchain state</li>

      <li>A channel is defined by members (organizations), anchor peers per member, the shared ledger, chaincode application(s) and the ordering service node(s). Each transaction on the network is executed on a channel, where each party must be authenticated and authorized to transact on that channel. Each peer that joins a channel, has its own identity given by a membership services provider (MSP), which authenticates each peer to its channel peers and services.</li>

      <li>To create a new channel, the client SDK calls configuration system chaincode and references properties such as anchor peer**s, and members (organizations). This request creates a **genesis block for the channel ledger, which stores configuration information about the channel policies, members and anchor peers. When adding a new member to an existing channel, either this genesis block, or if applicable, a more recent reconfiguration block, is shared with the new member.<br/>
        <span TODO>Add client SDK code</span>
      </li>
      <li>The election of a leading peer for each member on a channel determines which peer communicates with the ordering service on behalf of the member. If no leader is identified, an algorithm can be used to identify the leader. The consensus service orders transactions and delivers them, in a block, to each leading peer, which then distributes the block to its member peers, and across the channel, using the gossip protocol.
      </li>
    </ul>

  </td>
</tr }>
<tr header_delimit {> 
  <td colspan=4 >
    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#security-membership-services">Security &amp; Membership Services</a>
  </td>
</tr>
<tr {>
  <td summa >
     <ul>
       <li>Permissioned membership provides a trusted blockchain network, where participants know that all transactions can be detected and traced by authorized regulators and auditors</li>
       <li>All participants have known identities</li>
       <li>Public Key Infrastructure is used to generate cryptographic certificates which are tied to organizations, network components, and end users or client applications</li>
     </ul>
  </td>
  <td col1 >
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/capabilities.html#identity-management">Identity management/Certificat Authority(CA) Service</a>
     <ul>
       <li>Takes care of enrollment and governance process</li>
       <li>To enable permissioned networks, Hyperledger Fabric provides a membership identity service that manages user IDs and authenticates all participants on the network. Access control lists can be used to provide additional layers of permission through authorization of specific network operations. For example, a specific user ID could be permitted to invoke a chaincode application, but blocked from deploying new chaincode. One truism about Hyperledger Fabric networks is that members know each other (identity), but they do not know what each other are doing (privacy and confidentiality).</li>
     </ul>
  </td>
  <td col2 >
    <a href='https://hyperledger-fabric.readthedocs.io/en/latest/msp.html'>Membership Service Providers (MSP)</a>
    Membership Service Provider (MSP) is a component that aims to offer an abstraction of a membership operation architecture.<br/>
    In particular, MSP abstracts away all cryptographic mechanisms and protocols behind issuing and validating certificates, 
    and user authentication. An MSP may define their own notion of identity.
    <!--
      The MSP is a peer component that allows them to verify transaction requests 
      arriving from clients and to sign transaction results(endorsements).
      The Writing policy is defined at channel creation time, and determines
      which user is entitled to submit a transaction to that channel.
    -->
  </td>
  <td col3 >
    <a href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>Example endorsement policies</a>
    <p>The predicate may contain logical expressions and evaluates to TRUE or FALSE.
       Typically the condition will use digital signatures on the transaction invocation issued by endorsing peers for the chaincode.</p>
    <p>Suppose the chaincode specifies the endorser set 
    <pre>E = {Alice,Bob,Charlie,Dave,Eve,Frank,George}</pre>.
     Some example policies:</p>
    <ul>
      <li>A valid signature from on the same tran-proposal from all members of E.</li>
      <li>A valid signature from any single member of E.</li>
      <li>Valid signatures on the same tran-proposal from endorsing peers according to the condition:
       <pre>
(Alice OR Bob) AND 
(any two of: Charlie, Dave, Eve, Frank, George)</pre>
      </li>
      <li>Valid signatures on the same tran-proposal by any 5 out of the 7
          endorsers. (More generally, for chaincode with n &gt; 3f endorsers,
          valid signatures by any 2f+1 out of the n endorsers, or by
          any group of more than (n+f)/2 endorsers</li>
      <li>Suppose there is an assignment of “stake” or “weights” to the endorsers, like
          {Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}
          where the total stake is 100: The policy requires valid signatures
          from a set that has a majority of the stake (i.e., a group with
          combined stake strictly more than 50), such as {Alice, X} with
          any X different from George, or {everyone together except Alice}, and so on.</li>
      <li>The assignment of stake in the previous example condition could be
          static (fixed in the metadata of the chaincode) or dynamic (e.g.,
          dependent on the state of the chaincode and be modified during the
          execution).</li>
      <li>Valid signatures from (Alice OR Bob) on tran-proposal1 and valid
          signatures from (any two of: Charlie, Dave, Eve, Frank, George) on
          tran-proposal2, where tran-proposal1 and tran-proposal2 differ only
          in their endorsing peers and state updates.</li>
    </ul>
  </td>
</tr }>
<tr header_delimit {> <td colspan=4 >ARCHITECTURE</td> </tr>
<tr {>
  <td summa >
     <span xbig><a href="https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html">Ledger</a></span>
     <ul>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions. State transitions are a result of chaincode invocations (‘transactions’) submitted by participating parties. Each transaction results in a set of asset key-value pairs that are committed to the ledger as creates, updates, or deletes.

The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in blocks, as well as a state database to maintain current state. There is one ledger per channel. Each peer maintains a copy of the ledger for each channel of which they are a member. </li>
       <li>The chain is a transaction log, structured as hash-linked blocks, where each block contains a sequence of N transactions. The block header includes a hash of the block’s transactions, as well as a hash of the prior block’s header. In this way, all transactions on the ledger are sequenced and cryptographically linked together. In other words, it is not possible to tamper with the ledger data, without breaking the hash links. The hash of the latest block represents every transaction that has come before, making it possible to ensure that all peers are in a consistent and trusted state.</li>
       <li>The ledger’s current state data represents the latest values for all keys ever included in the chain transaction log. Since current state represents all latest key values known to the channel, it is sometimes referred to as World State.</li>
       <li>State database options:
         <ul>
           <li>LevelDB: default key/value state database embedded in the peer process</li>
           <li>CouchDB: optional alternative external state database, uses a JSON document store, enabling rich query against the chaincode data (when chaincode values like assets are modeled as JSON data)</li>
           <li> It is a good practice to model chaincode asset data as JSON, so that you have the option to perform complex rich queries if needed in the future.</li>
         <ul>
       </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html'>CouchDB configuration</a></li>
     </ul>
  </td>  
  <td col2  >
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html" xbig>Read-Write set semantics</a>
     <ul>
       <li>
         <pre xsmall { >
read set =  [(keys, value, version)]
writ set =  [(unique key, latest_value /*set by TX*/ )] 
      latest_value or isDelete=true

Example:
consider a set of five ordered transactions 
   (T1 ->, T2 -> T3 -> T4 -> T5)
simulated on the same snapshot of the world state:

Initial World state : 
   [ (k1,1,v1), (k2,1,v2), (k3,1,v3), (k4,1,v4), (k5,1,v5) ]
-----------------------------------------
T1 -> Write k1 -> (k1,2,v1')
      Write k2 -> (k2,2,v2')
   Result:
     validation OK (no reads)
-----------------------------------------
T2 -> Read(k1,1,v1)
      Write k3 -> (k3,3,v3')
   Result:
     validation ERROR  (reads k1 v1 < current v2')
-----------------------------------------
T3 -> Write  k2 -> (k2, v2'')
   Result:
     validation OK (no reads)
     k2 updated to (k2,3,v2'')
-----------------------------------------
T4 -> Write(k2, v2'''), read(k2)
   Result:
     validation ERROR  (reads k2 v1 < current v2'')
-----------------------------------------
T5 -> Write k6 -> (k6, v6')
      read(k5)
   Result:
     validation OK (k5,v1 still in version v1 )
-----------------------------------------

Note: Transactions with multiple read-write sets are 
      not yet supported.
</pre } >
       </li>
     </ul>
  </td>
  <td col3 >
     <span xbig TODO ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html" xbig>Gossip data dissemination protocol</a></span> <br/>
     <span xbig TODO ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html">Bringing up a Kafka-based Ordering Service</a></span>
     <ul>
       <li></li>
       <li>This document assumes that the reader generally knows how to set up a Kafka cluster and a ZooKeeper ensemble. The purpose of this guide is to identify the steps you need to take so as to have a set of Hyperledger Fabric ordering service nodes (OSNs) use your Kafka cluster and provide an ordering service to your blockchain network. </li>
     </ul>
  </td>
</tr }>
</tr }>

<tr header_delimit } {> 
  <td colspan=4 >
    Build Your First Network script, REF:
      <a href='http://hyperledger-fabric.readthedocs.io/en/release/build_network.html'   >Doc</a>,
      <a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/'>GitHub code</a>
  </td>
</tr>
<tr {>
  <td summa >
     <span xbig>crypto-config.yaml input to 'cryptogen' tool</span>
         <pre xsmall { >
cat first-network/crypto-config.yaml:
OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    # Specs is an array of Spec entries.
    #  Each Spec entry consists of two fields:
    #   - Hostname:   (Required) (without the domain)
    #   - CommonName: (Optional) Specifies the template or explicit override
    #                 for the CN.  By default, this is the template:
    # Specs:
    #   - Hostname: foo # implicitly "foo.org1.example.com"
    #     CommonName: foo27.org5.example.com # overrides Hostname-based
    #                                          FQDN set above
    #   - Hostname: bar
    #   - Hostname: baz
    # ---------------------------------------------------------------------------
    # "Template"
    # ---------------------------------------------------------------------------
    # Allows for the definition of 1 or more hosts are created sequentially
    # from a template. By default, this looks like "peer%d" from 0 to Count-1.
    # You may override the number of nodes (Count), the starting index (Start)
    # or the template used to construct the name (Hostname).
    #
    # Note: Template and Specs are not mutually exclusive.  You may define both
    # sections and the aggregate nodes will be created for you.  Take care with
    # name collisions
    # ---------------------------------------------------------------------------
    Template:
      Count: 2
      # Start: 5
      # Hostname: {{.Prefix}}{{.Index}} # default
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 2
    Users:
</pre }>
     <span xbig>configtx.yaml input to the 'configtxgen' tool</span>
<pre xsmall { >
$ cat <a href='https://raw.githubusercontent.com/hyperledger/fabric-samples/release/first-network/configtx.yaml'>configtx.yaml</a> (Summary only)
Profiles:
  TwoOrgsOrdererGenesis:
    Orderer:
        <<: *OrdererDefaults
        Organizations:
            - *OrdererOrg
    Consortiums:
        SampleConsortium:
            Organizations:
                - *Org1
                - *Org2
  TwoOrgsChannel:
    Consortium: SampleConsortium
    Application:
      <<: *ApplicationDefaults
      Organizations:
          - *Org1
          - *Org2

# Organizations sect. defines the organizational identities 
Organizations:
  # MSP using sampleconfig.  It *should* never be used
  # in production but may be used as a template for other definitions
  - &lt;OrdererOrg
      Name: OrdererOrg
      ID: OrdererMSP
      MSPDir: crypto-config/ordererOrganizations/example.com/msp

  - &lt;Org1
      Name: Org1MSP
      ID: Org1MSP
      MSPDir: crypto-config/peerOrganizations/org1.example.com/msp

      # location of peers for cross org gossip communication.
      #  Note, this value is only
      # encoded in the genesis block in the Application section context
      AnchorPeers:
        - Host: peer0.org1.example.com
          Port: 7051

  - &lt;Org2
      Name: Org2MSP
      ID: Org2MSP
      MSPDir: crypto-config/peerOrganizations/org2.example.com/msp

      AnchorPeers:
        - Host: peer0.org2.example.com
          Port: 7051

Orderer: &lt;OrdererDefaults
  # OrdererType := "solo" and "kafka"
  OrdererType: solo
  Addresses:
      - orderer.example.com:7050
  # time to wait before creating a batch
  BatchTimeout: 2s
  BatchSize:
      MaxMessageCount: 10
      AbsoluteMaxBytes: 99 MB
      PreferredMaxBytes: 512 KB

  Kafka:
      # A list of Kafka brokers to which the orderer connects
      Brokers:
          - 127.0.0.1:9092

  # list of orgs defined as participants on
  # the orderer side of the network
  Organizations:

Application: &lt;ApplicationDefaults
  Organizations:
</pre } >
     </ol>
  </td>
  <td col1 >
     STEPS:
     <ol>
       <li>Generate certificates using crypto-config.yaml as input:
         <pre xsmall { >
$ cryptogen generate --config=./crypto-config.yaml
</pre }>
       </li>
       <li>Generate Orderer Genesis block:
<pre xsmall { >
$ configtxgen -profile TwoOrgsOrdererGenesis \
   -outputBlock ./channel-artifacts/genesis.block 
</pre } >
       </li>
       <li>Generate channel configuration transaction 'channel.tx'
<pre xsmall { >
$ configtxgen -profile TwoOrgsChannel \
    -channelID $CHANNEL_NAME \
    -outputCreateChannelTx ./channel-artifacts/channel.tx
</pre } >
       </li>
       <li>Generate anchor peer update for Org1MSP/Org2MSP
<pre xsmall { >
$ configtxgen -profile TwoOrgsChannel \
      -outputAnchorPeersUpdate \
      ./channel-artifacts/Org1MSPanchors.tx \ #  
      -channelID $CHANNEL_NAME -asOrg Org1MSP #  
# *1 (same for Org2MSPanchors.tx)
# *2 (same for Org2MSP)
</pre } >
       </li>
     </ol>

  </td>
  <td col2 >
REF: <a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-cli.yaml'>docker-compose-cli.yaml</a>
<pre xsmall { >
DOMAIN=example.com
GOPATH=/opt/gopath
FABRIC_DIR=${GOPATH}/src/github.com/hyperledger/fabric/
WORKING_DIR=${FABRIC_DIR}/peer
BASE_PATH=${WORKING_DIR}/crypto/peerOrganizations
ORG1=org1
ORG2=org2
BASE_PATH_ORG1=${BASE_PATH}/${ORG1}.${DOMAIN}
PEER1_0_TLS=peer0.${ORG1}.${DOMAIN}/tls
    CORE_PEER_TLS_CERT_FILE=BASE_PATH_ORG1/peers/${PEER1_0_TLS}/server.crt
     CORE_PEER_TLS_KEY_FILE=BASE_PATH_ORG1/peers/${PEER1_0_TLS}/server.key
CORE_PEER_TLS_ROOTCERT_FILE=BASE_PATH_ORG1/peers/${PEER1_0_TLS}/ca.crt
CORE_PEER_MSPCONFIGPATH    =BASE_PATH_ORG1/users/Admin@${ORG1}.${DOMAIN}/msp
BASH_CMD="./scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT"
cat << EOF > docker-compse-cli.yaml
version: '2'
networks:
  byfn:
services:
  orderer.${DOMAIN}:
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.${DOMAIN}
    container_name: orderer.${DOMAIN}
    networks:
      - byfn

  peer0.${ORG1}.${DOMAIN}:
  (same for  peer1.${ORG1}.${DOMAIN} changing)
  (same for  peer0.org2.${DOMAIN} changing)
    container_name: peer0.${ORG1}.${DOMAIN}
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.${ORG1}.${DOMAIN}
    networks:
      - byfn

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=${GOPATH}
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.${ORG1}.${DOMAIN}:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=${CORE_PEER_TLS_CERT_FILE}
      - CORE_PEER_TLS_KEY_FILE=${CORE_PEER_TLS_KEY_FILE}
      - CORE_PEER_TLS_ROOTCERT_FILE=${CORE_PEER_TLS_ROOTCERT_FILE}
      - CORE_PEER_MSPCONFIGPATH=${CORE_PEER_MSPCONFIGPATH}
    working_dir: ${WORKING_DIR}
    command: /bin/bash -c '${BASH_CMD}'
    volumes:
        - /var/run/:/host/var/run/
        - ./../chaincode/     :${FABRIC_DIR}/examples/chaincode/go
        - ./crypto-config     :${FABRIC_DIR}/peer/crypto/
        - ./scripts           :${FABRIC_DIR}/peer/scripts/
        - ./channel-artifacts :${FABRIC_DIR}/peer/channel-artifacts
    depends_on:
      - orderer.${DOMAIN}
      - peer0.${ORG1}.${DOMAIN}
      - peer1.${ORG1}.${DOMAIN}
      - peer0.${ORG2}.${DOMAIN}
      - peer1.${ORG2}.${DOMAIN}
    networks:
      - byfn
</pre }>
  </td>  
  <td col3  >
<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-couch.yaml'>docker-compose-couch.yaml</a>
<pre xsmall { >
version: '2'
networks:
  byfn:
services:
  couchdb0:
  # (same for couchdb1/2/3 changing ports - 6984, 7984)
    container_name: couchdb0
    image: hyperledger/fabric-couchdb
    environment:
      - COUCHDB_USER=...
      - COUCHDB_PASSWORD=...
    ports:
      - "5984:5984"
    networks:
      - byfn

  peer0.org1.example.com:
  # (same for peer1.org1.example.com: changing ...0 -> ...1)
  # (same for peer0.org2.example.com: changing ...0 -> ...2)
  # (same for peer1.org2.example.com: changing ...0 -> ...3)
    environment:
      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0:5984
      - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=
      - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=
    depends_on:
      - couchdb0
</pre }>
  </td>
</tr }>
<tr header_delimit } {> 
  <td colspan=4 >
    <a href='https://github.com/hyperledger/fabric-samples/tree/release/fabcar'>Ex. FabCar</a>
  </td>
</tr>
<tr {>
  <td summa >
    <a href='https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go' xbig>fabric-samples fabcar.go</a> (Summary Error checks removed)
    <pre xsmall { >
// structures
type Car struct {                   type SmartContract struct { }

    Make   string `json:"make"`
    Model  string `json:"model"`
    Colour string `json:"colour"`
    Owner  string `json:"owner"`
}

func (s *SmartContract)
     initLedger(
       APIstub shim.ChaincodeStubInterface)
         sc.Response {
    cars := []Car{ // ledger initialization outside Init
        Car{
          Make: "Toyota", Model: "Prius",
          Colour: "blue", Owner: "Tomoko"},
        Car{Make: "Ford", Model: "Mustang",
          Colour: "red", Owner: "Brad"},
        ...  }

    i := 0 ; for i &lt; len(cars) {
        carAsBytes, _ := json.Marshal(cars[i])
        APIstub.PutState
           ("CAR"+strconv.Itoa(i), carAsBytes)
        fmt.Println("Added", cars[i])
        i = i + 1
    }
    return shim.Success(nil)
}

// called when instantiated by the blockchain network
func (s *SmartContract) 
    Init(APIstub shim.ChaincodeStubInterface) 
    sc.Response {
    return shim.Success(nil)
}

/* called as a result of application request to
   run the Smart Contract "fabcar" */
func (s *SmartContract)
    Invoke(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    // Retrieve the requested Smart Contract func.+args.
    function, args := APIstub.GetFunctionAndParameters()
    if function == "queryCar" {
        return s.queryCar(APIstub, args)
    } else if function == "initLedger" {
        return s.initLedger(APIstub)
    } else if function == "createCar" {
        return s.createCar(APIstub, args)
    } else if function == "queryAllCars" {
        return s.queryAllCars(APIstub)
    } else if function == "changeCarOwner" {
        return s.changeCarOwner(APIstub, args)
    }
}

func (s *SmartContract) 
    queryCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    return shim.Success(carAsBytes)
}

func (s *SmartContract) 
    createCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    var car = Car{Make: args[1], Model: args[2],
                  Colour: args[3], Owner: args[4]}
    carAsBytes, _ := json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}

func (s *SmartContract) 
    queryAllCars(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    startKey := "CAR0"
    endKey := "CAR999"
    resultsIterator, err := 
       APIstub.GetStateByRange(startKey, endKey)
    defer resultsIterator.Close()
    
    var buffer /* JSON array */ bytes.Buffer
    buffer.WriteString("[")
    for resultsIterator.HasNext() {
        queryResponse, err := resultsIterator.Next()
        ...
        buffer.WriteString("{\"Key\":")
        buffer.WriteString("\"")
        ...
    }
    ...
    return shim.Success(buffer.Bytes())
}

func (s *SmartContract)
    changeCarOwner(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    car := Car{}
    json.Unmarshal(carAsBytes, &amp;car)
    car.Owner = args[1]
    carAsBytes, _ = json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}


func main /* testing purposes*/() {
    // Create new Contract
    err := shim.Start(new(SmartContract))
}
</pre } >
  </td>
  <td col1 >
         <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/query.js' xbig>fabcar query.js</a> (errors and async code removed)
<pre xsmall { >
var hfc = require('fabric-client');
var path = require('path');
var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    network_url: 'grpc://localhost:7051',
};

var client = new hfc(); // create client
wallet = hfc.newDefaultKeyValueStore(
    { path: options.wallet_path });
client.setStateStore(wallet); // Set wallet path
// associate user to app
user = client.getUserContext(options.user_id, true);
var channel = client.newChannel(options.channel_id);
channel.addPeer(client.newPeer(options.network_url));
// make query
var transaction_id = client.newTransactionID();
const request = {
  chaincodeId: options.chaincode_id,
  txId: transaction_id,
  fcn: 'queryAllCars', args: [''] };
query_responses = channel.queryByChaincode(request);
// console.log("count = ", query_responses.length)
if (query_responses[0] instanceof Error) {
  console.error("error from query = ", query_responses[0]);
}
console.log("Response: ", query_responses[0].toString());
</pre } >
  </td>  
  <td col2  >
         <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/invoke.js' xbig>fabcar invoke.js</a> (errors removed)
    <pre xsmall { >
var hfc = require('fabric-client');
var path = require('path');
var util = require('util');

var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    peer_url: 'grpc://localhost:7051',
    event_url: 'grpc://localhost:7053',
    orderer_url: 'grpc://localhost:7050'
};

var client = null;
var targets = [];
console.log("Create a client and set the wallet location");
client = new hfc();
var wallet = hfc.newDefaultKeyValueStore({ path: options.wallet_path });
console.log("Set wallet path, and associate user ", 
          options.user_id, " with application");
client.setStateStore(wallet);
var user = client.getUserContext(options.user_id, true);
console.log("Check user is enrolled, and set a query URL 
         in the network");
var channel = client.newChannel(options.channel_id);
var peerObj = client.newPeer(options.peer_url);
channel.addPeer(peerObj);
channel.addOrderer(client.newOrderer(options.orderer_url));
targets.push(peerObj);
var tx_id = client.newTransactionID();
console.log("Assigning transaction_id: ", tx_id._transaction_id);
// createCar - requires 5 args, ex: args:
// ['CAR11', 'Honda', 'Accord', 'Black', 'Tom'],
// changeCarOwner - requires 2 args , ex: args: ['CAR10', 'Barry'],
// send proposal to endorser
var request = {
    targets: targets,
    chaincodeId: options.chaincode_id,
    fcn: 'createCar',
    args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
    chainId: options.channel_id,
    txId: tx_id
};
var results = channel.sendTransactionProposal(request);
var proposalResponses = results[0];
var proposal = results[1];
var header = results[2];
let isProposalGood = false;
console.log(util.format(
    'Successfully sent Proposal and received'
  + ' ProposalResponse: Status - %s, message - "%s",'
  + ' metadata - "%s",' 
  + ' endorsement signature: %s',
    proposalResponses[0].response.status,
    proposalResponses[0].response.message,
    proposalResponses[0].response.payload,
    proposalResponses[0].endorsement.signature));
var request = {
    proposalResponses: proposalResponses,
    proposal: proposal,
    header: header
};
// set the transaction listener and 30sec timeout 
// if the TX did not get committed within timeout
// fail the test
var transactionID = tx_id.getTransactionID();
var eventPromises = [];
let eh = client.newEventHub();
eh.setPeerAddr(options.event_url);
eh.connect();

let txPromise = new Promise((resolve, reject) => 
{
  let handle = setTimeout(() => {
    eh.disconnect(); reject(); }, 30000);
  eh.registerTxEvent(transactionID, (tx, code) => {
    clearTimeout(handle);
    eh.unregisterTxEvent(transactionID);
    eh.disconnect();
    if (code === 'VALID') {
        console.log(
            'TX has been committed on peer ' +
            eh._ep._endpoint.addr);
        resolve();
    }
  });
});
eventPromises.push(txPromise);
var sendPromise = channel.sendTransaction(request);
var results = sendPromise.concat(eventPromises)) 
    console.log('event promise all '
    + ' complete and testing complete');
var response = results[0]; // 1st returned value is from
                   // 'sendPromise' which is from
                   // 'sendTransaction()' call
if (response.status === 'SUCCESS') {
    console.log('Successfully sent TX to orderer.');
    return tx_id.getTransactionID();
}
</pre } >
  </td>
  <td col3 >
  </td>
</tr }>

<tr header_delimit } {> <td colspan=4 >NodeJS SDK</td> </tr>
<tr {>
  <td summa >
    <span xbig><a href='https://fabric-sdk-node.github.io/'>Fabric SDK</a></span>
    <p>NodeJS APIs are available to:</p>
    <ul>
      <li>create <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">channels</a></li>
      <li>ask <a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#peer">peer nodes</a> to join the channel</li>
      <li>install <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode">chaincodes</a> in peers using the consensus process (can be preinstalled in setup scripts)</li>
      <li>instantiate chaincodes in a channel</li>
      <li>invoke transactions by calling the chaincode</li>
      <li>
          Query the <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">ledger</a> for transactions or blocks<br/>
      </li>
      <li TODO >receive ledger updates</li>
    </ul>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
  <td col3>
  </td>
</tr }>
<tr header_delimit } {> <td colspan=4 >JAVA</td> </tr>
<tr {>
  <td summa >
    <span xbig><a href='https://github.com/hyperledger/fabric-sdk-java'>JAVA SDK</a></span>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
  <td col3>
  </td>
</tr }>


<tr header_delimit } {> <td colspan=4 ><a href='https://hyperledger.github.io/composer/stable/index.html'>COMPOSER</a></td> </tr>
<tr {>
  <td summa >
     <ul>
     <li><a href='https://composer-playground.mybluemix.net/'>On-oline playground</a></li>
     <li><a href='https://hyperledger.github.io/composer/installing/development-tools.html'>Installing</a></li>
     <li><a href='https://hyperledger.github.io/composer/tutorials/tutorials.html'>
           Playgorund, Developer, Queries Tutorials, deploying to a single/multiple org. in Fabric</a></li>
     </ul>
     Development toolset and framework to develop blockchain apps (model, gui, roles, ...).<br/>
     Composer enables to quickly create business logic running on the blockchain + REST APIs

     <a href='https://hyperledger.github.io/composer/introduction/introduction.html'>REF: introduction</a><br/>
     <span xbig>Businness Networks core concepts</span>
     <ul>
       <li>
<pre { >
 INPUT             OUTPUT
┌──────────────┐   ┌───────────────────────┐
│* .cto        │   │Business Network       │
│- Assets      │   │Archive *.bna          │
│- Participants│   │(Package-up input ready│
│- Transactions│   │ to deploy "somewhere")│
├──────────────┤   └───────────────────────┘
│*.js          │
│- Transaction │
│  Functions   │
├──────────────┤
│*.acl         │
│- Access      │
│  Control     │
├──────────────┤
│*.qry         │
│- Query defini│
│  rules       │
└──────────────┘
</pre } >
       </li>
     </ul>
  </td>
  <td col1>
       models/sample.cto
<pre { >
namespace org.acme.sample

participant SampleParticipant identified by participantId
{
  o String participantId
  o String firstName
  o String lastName
}

asset SampleAsset identified by assetId {
  o String assetId
  --> SampleParticipant owner
  o String value
}

transaction SampleTransaction {
   --> SampleAsset asset
   o String newValue
}

event SampleEvent {
  --> SampleAsset asset
  o String oldValue
  o String newValue
}
</pre } >

  </td>  
  <td col2>lib/sample.js
<pre { >
function sampleTransaction(tx) {
  var oldValue = tx.asset.value;

  tx.asset.value = tx.newValue;

  return getAsetRegistry('org.acme.sample.SampleAsset')
    .then(function (assetRegsitry) {
           return assetRegistry.update(tx.asset);
     })
    .then(function () {
       var event = getFactory().newEvent('org.acme.sample',
          'SampleEvent');
       event.asset = tx.asset;
       event.oldValue = oldValue;
       event.newValue = tx.newValue;
       emit(event);
    });
}
</pre } >
  </td>
  <td col3>permissions.acl
<pre xsmall { >
rule EverybodyCanReadEverything {
  description: "Allow all participants read access to all resources"
  participant: "org.acme.sample.SampleParticipant"
  opeartion: READ
  resource: "org.acme.sample.*"
  action: ALLOW
}

rule EverybodyCanSubmitTransactions {
  description: "Allow all participants to submit TXs"
  participant: "org.acme.sample.SampleParticipant"
  operation: CREATE
  resource: "org.acme.sample.SampleTransaction"
  action: ALLOW
}

rule OwnerhasFullAccessToTherAssets {
  description: "full access to participants assets"
  participant: "org.acme.sample.SampleParticipant"
  operation: ALL
  resource(r): "org.acme.sample.SampleTransaction"
  condition: (r.owner.getIdentifier() === p.getIdentifier())
  action: ALLOW
}

rule SystemACL {
  description: "System ACL to permit all access"
  participant: "org.hyperledger.composer.system.Participant"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}

rule NetworkAdminSsytem {
  description: "full access for network admins. to sys.res."
  participant: "org.hyperledger.composer.system.NetworkAdmin"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}
</pre } >
  </td>
</tr }>

<tr {>
  <td summa >
     <ul>
       <li>(PLUGGABLE) EXECUTION RUNTIMES
         <ul>
           <li>Hyperledger Fabric version 1.0.
     State is stored on the distributed ledger.</li>
           <li>Web, which executes within a web page, and is used by Playground.
     State is stored in browser local storage.</li>
           <li>Embedded, which executes within a Node.js process, 
     used primarily for unit testing business logic.
     State is stored in an in-memory key-value store.</li>
         </ul>
       </li>
       <li>CONNECTION PROFILES
         <ul>
           <li>Used across Hyperledger Composer to specify how
    to connect to an execution runtime.</li>
           <li>There are different configuration options for each type 
    of execution runtime. For example, the profile for 
    an Hyperledger Fabric version 1.0 runtime will contain 
    the TCP/IP addresses and ports for the Fabric peers,
    as well as cryptographic certificates etc.</li>
           <li>Connection Profiles are referred to by name (in both code 
    and on the command line) and the connection profile documents
    (in JSON format) are resolved from the user's home directory.</li>
         </ul>
       </li>
       <li>JAVASCRIPT SDK is a set of Node.js APIs the enables developers to
    create applications to manage and interact with deployed business nets.
  - APIs are split between two npm modules:
         <ul>
           <li>COMPOSER-CLIENT: 
    - submits TXs to a network, CRUD opts on assets and participants
    - installed as local dependency for app.
    - When in production this is only module that needs to be added
      as a direct dependency of the application.</li>
           <li>COMPOSER-ADMIN:
    - manages business networks (creation/deploy, undeploy)
    - installed as a local dependency of admin. apps</li>
         </ul>
       </li>
       <li>REST SERVER: automatically generates a Open API (Swagger) REST API 
    At runtime implements CRUD support for assets/participants 
    and allows TXs to be submitted for processing or retrieved.
       </li>
       <li>LOOPBACK CONNECTOR
         <ul>
           <li>Used by the Composer REST Server</li>
           <li>It may also be used standalone by integration tools that
             support LoopBack natively.</li>
           <li>Can also be used with the LoopBack tools to create more
             sophisticated customizations of the REST APIs.</li>
         </ul>
       </li>
       <li>PLAYGROUND WEB USER INTERFACE
         <ul>
           <li>GUI to define and test business networks.</li>
           <li>Allows business analyst to quickly import samples and
    prototype business logic that executes on the Web or
    Hyperledger Fabric runtime.</li>
         </ul>
       </li>
       <li>YEOMAN CODE GENERATORS to create skeleton projects:
         <ul>
           <li> Angular web application  </li>
           <li> Node.js application      </li>
           <li> Skeleton business network</li>
         </ul>
       </li>
     </ul>
  </td>
  <td col1 >
    <ul>
       <li>BLOCKCHAIN STATE STORAGE:
             Blockchain ledger:  stores all TXs submitted through a business network
             Blockchain state database: current state of assets and participants 
       </li>
       <li>CONNECTION PROFILES:
  - Used to connect to a runtime.
  - JSON document @ user's home directory (or ENV.VAR)  and referenced
    by name when using the Composer APIs or the Command Line tools.
  - C.P. ensures that code and scripts are easily portable from one 
    runtime instance to another. 
       </li>
       <li>ASSETS:
  - Anything that can be owned by someone.
  - Assets MUST HAVE a unique identifier.
  - Assets may be related to other assets or participants.
       </li>
       <li>PARTICIPANTS:<br/>
  - members of a business network.<br/>
  - They may own assets and submit transactions.<br/>
  - Participant MUST HAVE an identifier.<br/>
       </li>
       <li>IDENTITIES AND ID CARDS:<br/>
  - Participants can be associated with an identity.<br/>
  - ID cards are a combination of : <br/>
    - identity<br/>
    - connection profile<br/>
    - metadata.<br/>
  - ID cards simplify the process of connecting to business network
    and extend the concept of an identity outside the B.N. to a<br/>
    'wallet' of identities, each associated with a specific business
    network and connection profile.<br/>
       </li>
       <li>TRANSACTIONS<br/>
  - mechanism by which participants interact with assets.<br/>
       </li>
       <li>QUERIES<br/>
  - used to return data about the blockchain world-state.<br/>
  - Queries are defined within a business network, and can include
    variable parameters for simple customization. By using queries,
    data can be easily extracted from your blockchain network.<br/>
  - Queries are sent by using the Hyperledger Composer API.
       </li>
       <li>EVENTS:<br/>
  - Defined in the business network definition in the same way as assets or participants.<br/>
  - Once events have been defined, they can be emitted by transaction processor functions
    to indicate to external systems that something of importance has happened to the ledger.<br/>
  - Applications can subscribe to emitted events through the composer-client API.
       </li>
       <li>ACCESS CONTROL RULES<br/>
  - fine-grained control over what participants have access to what assets
    in the business network and under what conditions.<br/>
  - Access control language is rich enough to capture sophisticated conditions
    declaratively, such as "only the owner of a vehicle can transfer
    ownership of the vehicle".<br/>
  - Externalizing ACR from TX processor logic makes it easier to inspect,
    debug, develop and maintain.<br/>
       </li>
       <li>HISTORIAN REGISTRY<br/>
  - Specialised registry which records successful transactions,
    including the participants and identities that submitted them.<br/>
  - TXs are stored as HistorianRecord assets, are defined in the
    Hyperledger Composer system namespace.<br/>
       </li>
    </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>

<tr header_delimit } > <td colspan=4 ></td> </tr>
</table>
</body>
<!--
TODO: support for cross-chaincode transactions (post-v1 feature)

_________________________________
<a href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>2.1.1. PROPOSE message format</a>

<p>The format of a PROPOSE message is &lt;PROPOSE,tx,[anchor]&gt; , where
tx is a mandatory and anchor optional argument explained in the following.</p>

tx=&lt;clientID,chaincodeID,txPayload,timestamp,clientSig&gt;, where
<ul>
  <li>clientID is an ID of the submitting client,</li>
  <li>chaincodeID refers to the chaincode to which the transaction pertains,</li>
  <li>txPayload is the payload containing the submitted transaction itself,</li>
  <li>timestamp is a monotonically increasing (for every new transaction) 
      integer maintained by the client,</li>
  <li>clientSig is signature of a client on other fields of tx</li>
</ul>

<p>The details of txPayload will differ between invoke transactions
and deploy transactions (i.e., invoke transactions referring to a
deploy-specific system chaincode). For an invoke-transaction,
txPayload would consist of two fields</p>

<ul>
   <li>txPayload=&lt;operation,metadata&gt;, where<ul>
   <li>operation denotes the chaincode operation (function) and arguments,</li>
   <li>metadata denotes attributes related to the invocation.</li>
</ul>

<p>For a <strong>deploy transaction</strong>, txPayload would consist of three fields</p>
<ul>
  <li>txPayload = &lt;source, metadata, policies&gt; where<ul>
  <li>source denotes the source code of the chaincode,</li>
  <li>metadata denotes attributes related to the chaincode and
  application,</li>
  <li>policies contains policies related to the chaincode that
      are accessible to all peers, such as the endorsement policy.
      Note that endorsement policies are not supplied with
      deploy transaction, but
      deploy contains endorsement policy ID and
      its parameters (see Section 3).</li>
</ul>

<ul>
<li>anchor contains read-version-dependencies, or more
   specifically, key-version pairs (i.e., anchor is a subset of
   PROPOSE request to specified versions of keys in a KVS (see Section 1.2.). 
   If the client specifies the anchor argument, an endorser endorses a transaction
   only upon <em>read</em> version numbers of corresponding keys in its local
   KVS match anchor (see Section 2.2. for more details).
</li>
</ul>
<p>Cryptographic hash of tx is used by all nodes as a unique
transaction identifier tid=HASH(tx)). The client
stores tid in memory and waits for responses from endorsing peers.</p>
________________________________
VIDEO: What's new in Hyperledger Fabric 1.0: Nikolay Vlasov: FASSAIS Summit 2017: https://www.youtube.com/watch?v=6nGIptzBZis
Fabric Composer: Web GUI to develop Fabric apps. https://hyperledger.github.io/composer/
Video Tutorial: https://www.youtube.com/watch?v=fdFUsrsv5iw 
________________________________________
-->

<!--
-->
</html>



