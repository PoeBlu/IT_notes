<html>
<head>
   <meta charset="UTF-8">
   <title>Hyperledger Fabric</title>
<style>
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[xbig  ]  { font-size:1.3rem; }
#zoomDiv > *[xxxsmall], #zoomDiv > * > *[xxxsmall], #zoomDiv > * > * > *[xxxsmall]{ font-size:1rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv > *[ xxsmall], #zoomDiv > * > *[ xxsmall], #zoomDiv > * > * > *[ xxsmall]{ font-size:1rem; }
#zoomDiv > *[  xsmall], #zoomDiv > * > *[  xsmall], #zoomDiv > * > * > *[  xsmall]{ font-size:1rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width: 5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col3]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
   /* Notes:
    * The name (and number) of columns 'topic', 'summa', 'col1', 'col2' is arbitrary.
    * Change at will. For example for development projects there could be a column for each 
    * software life-cycle similar to:  
    * topic -> summary -> documentation -> development -> testing/CI -> deployment -> QA
    * WARN: Don't forget to change the css too.
   */

  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td topic >Topic</td>
  <td summa >Summary<td>
  <td col1  ></td>
  <td col2  ></td>
  <td col3  ></td>
</tr>
<tr {>
  <td topic><a href='https://hyperledger-fabric.readthedocs.io/en/latest/'>Fabric</a></td>
  <td summa>
    <ul>
      <li xbig><a href='https://godoc.org/github.com/hyperledger/fabric'>Go DOC</a></li>
    </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://godoc.org/github.com/hyperledger/fabric'>API</a></li>
       <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html'>Building your first Network</a></li>
       <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/write_first_app.html'>Writing Your First Application</a></li>
       <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/samples.html'>Fabric Samples</a><br/>
           $ git clone <a href='https://github.com/hyperledger/fabric-samples.git'>https://github.com/hyperledger/fabric-samples.git</a></li>

       <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html">Architecture Explained</a></li>
       <li>
   <pre xsmall { >
                  ┌──────────┐
               ┌─→│MEMBERSHIP│
               ┆  │ No SPoF  ┼───────────────────────────────┐
       0 enroll┆  │ No SPoT  │     ┆                         ┆
               ┆  └──────────┘     ┆                         ┆
               ┆             ┌─────┴─────┐                   ┆
┌───────────┐  ┆             │ PEER      │                   ┆
│APPLICATION│  ┆             │           │                   ┆
│  SDK -----┼--┆───────────→ │ Endorser  │ 3 Relay     ┌─────┴───────┐
│  keys     │  ┆1 Endorse    │ Committer │ Submit TX   │O-SERVICE    │
└───────────┘  ┆  proposal   │           │───────────→ │             │
               ┆             │           │             │ Order TXs in│
               ┆             │ ledger    │             │ a batch     │
               ┆             │           │             │ according to│
               └───────────→ │ chaincode │←─────────── │ consensus   │
                2 Submit TX  │           │ 4 Deliver   └─────────────┘
                             │ event     │   batch
                             └───────────┘

CouchDB: the PEER hold the hash chain (the record of updates),
while updates themselves are stored in a separate
couchDB container (allowing for storage of rich JSON queries).

QUERIES: 
APP -> APP : var request = request(ledger, chaincode, search params)
APP -> PEER: chain.queryByChaincode(request) API 
PEER -> APP: (synch) response_payload

UPDATES (TX FLOW)
--------  connect to peer's event listener port  --------
APP -> PEER: eh.setPeerAddr ()
--------  TX FLOW  --------
APP -> APP : var req = 
       TX_proposal(channel ID, chaincode, function) 
APP -> (endorsing)PEER:
       channel.SendTransactionProposal(req)
PEER -> APP: proposal_response
APP -> APP: 
       tx_request =sign(proposal_response)
APP -> ORDERING_SVC: 
       channel.sendTransaction(tx_request)
??? -> APP: TX_ID
APP -> PEER:
       eh.registerTxEvent (TX_ID, callback)
ORDERING_SVC -> ORDERING_SVC: 
       bundles TX into a block
ORDERING_SVC -> PEERS on channel: block
PEER -> PEER : validate block

   </pre>
       </li>
  </td>
  <td col2 >
    <a href='https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html'><b xbig>TRANSACTION FLOW</a> <br/>
    ("INTEND TO UPDATE THE LEDGER" FLOW)</b>
    <pre xsmall { >
Participant (peer) A : Buyes radishes
Participant (peer) B : Sells radishes

Admin -> +Channel: set up and run
Admin ->  Channel: register and endorse A,B with CA
                   (A and B must endorse any TX)

Admin -> +Chaincode : - Initial key/value State 
                      - Logic for TX

Admin -> A, B : Install chaincode

A -> Channel: Request for purchase
Channel -> A,B : Request
XXX -> App@peer1: Create TX proposal = Request exec
                     TX.chaincode.funct to call
                     TX.input           input to funct

App@peer1 -> App@peer1: Package TX proposal
App@peer1 -> App@peer1: Sign(Package TX proposal) with user's
                      credentials

App@peer1 -> Channel: Signed TX proposal
Channel -> endorsing peers:
endorsing peer -> endorsing peer: verifies:
                   - TX proposal is well formed
                   - it has not been submitted already
                     in the past (replay-attack protection)
                   - signature is valid (using MSP)
                   - submitter is properly authorized 
                     (ensures that submitter satisfies the 
                      channel’s Writers policy)
endorsing peer -> Chaincode: TX.chaincode.funct(TX.input)
Chaincode -> Chaincode: execute funct against current state
               of database 
Chaincode -> App: (@endorsing peer) 
                  TX.result = [
                     response value, 
                     read set,
                     write set ]
App -> App: SDK parses payload
            for application consumption
            -------------------------------------------
   The submitting client waits until it receives “enough” messages 
   and signatures on (TRANSACTION-ENDORSED, tid, *, *) statements to
   conclude that the TX proposal is endorsed. (may involve one or more
   round-trips of interaction with endorsers)
   If the submitting client does not manage to collect an endorsement
   for a transaction proposal, it abandons this transaction with an
   option to retry later.
   For transaction with a valid endorsement, we now start using the 
   ordering service. --
            -------------------------------------------
App -> (channel) -> Ordering Service :(Just for write 2 ledger)
                        TX.proposal + TX.result + endorsing sign.

Ordering Service -> Ordering Service: Order chronologically
                                      create blocks of TX
                    Serializability is a default isolation guarantee

Ordering Service -> Peers: TX block
Peers -> Peers: validate block
Peers -> Peers: Update ledger
Peers -> Client: event TX inmmutable appended to chain
    <pre } >
  </td>
  <td col3 >
   <a href='https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html'>Prerequisites:</a>
   <ul>
     <li><a href='https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites'>Docker CE for Centos</a></li>
     <li>Dependencies: cURL, git,<br/>
         docker 17.06.02-ce+ (2017-09-05)(docker engine 1.13.x NOT supported),
         <a href='https://go-repo.io/'>adding docker-ce repo to yum</a>
         <br/>
         docker-compose 1.14.0+ See <a href='https://docs.docker.com/compose/install/#install-compose'>here</a> to install latest version
     </li>

     <li>Go programming language 1.9.x <br/>
         Check $GOPATH="working directory" (example $HOME/go)
         <a href='https://go-repo.io/'>Install custom golang repo</a>
     </li>
     <li>Node.js 6.9.x Runtime (7.x not yet supported) and NPM (npm install npm@3.10.10 -g)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
   </ul>
  </td>
</tr }>

<tr header_delimit {> <td colspan=5 >MODEL</td> </tr>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#assets">Assets</a></td> 
  <td summa >
     <ul>
       <li>Asset definitions enable the exchange of almost anything with monetary value over the network, from whole foods to antique cars to currency futures</li>
       <li>Assets are represented in Hyperledger Fabric as a collection of key-value pairs, with state changes recorded as transactions on a Channel ledger.</li>
       <li>Assets can be represented in binary and/or JSON form</li>
       <li><a class="reference external" href="https://github.com/hyperledger/composer">Hyperledger Composer</a> can easily define assets</li>
  </p>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic >
    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode" >Chaincode</a>
    <a href='http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html'>Chaincode 4 devs</a>
   </td> 
  <td summa >
     <ul>
       <li>Chaincode is software defining an asset or assets, and the transaction instructions for modifying the asset(s).</li>
       <li>Chaincode (smart-contract) are hosted in the network, identified by name and version, for example 'dev-peer0.org1.example.com-fabcar-1.0' when the name is fabcar, the version is 1.0 and the peer it is running against is dev-peer0.org1.example.com</li>
       <li>Chaincode is installed only on peers that need to access the asset states to perform reads and writes</li>
       <li>Chaincode invocations 1 to 1 Transaction</li>
       <li>Chaincode execution is partitioned from transaction ordering, limiting the required levels of trust and verification across node types, and optimizing network scalability and performance</li>
       <li>enforces the rules for reading or altering key value pairs or other state database information</li>
       <li>Chaincode functions execute against the ledger current state database </li>
       <li>Chaincode functions are initiated through a transaction proposal</li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li TODO>To get started developing chaincode, read :doc:'chaincode4ade'. </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">Ledger Features</a></td> 
  <td summa >
     <ul>
       <li>The immutable, shared ledger encodes the entire transaction history for each channel, and includes SQL-like query capability for efficient auditing and dispute resolution</li>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric</li>
       <li>Each results in a set of asset key-value pairs that are committed to the ledger as Creates, Updates, or Deletes</li>
       <li>The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in
           blocks, as well as a state database to maintain current fabric state.</li>
       <li>The ledger is part of a Channel (Each channel peer maintains a copy of the ledger) <br/>
           A ledger exists <b>in the life scope of a channel</b>
       </li>

       <li>Query and update ledger using key-based lookups, range queries, and composite key queries</li>
       <li>Read-only queries using a rich query language (if using CouchDB as state database)</li>
       <li>Read-only history queries - Query ledger history for a key, enabling data provenance scenarios</li>
       <li>TRANSACTIONS CONSIST OF THE VERSIONS OF KEYS/VALUES THAT WERE READ IN CHAINCODE (READ SET) AND KEYS/VALUES THAT WERE WRITTEN IN CHAINCODE (WRITE SET)</li>
       <li>Transactions contain signatures of every endorsing peer and are submitted to ordering service</li>
     </ul>
</ul>
</div>
  </td>
  <td col1 >
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">Privacy through Channels</a></td> 
  <td summa >
     <ul>
       <li>""" One truism about Hyperledger Fabric networks is that members know each other (identity), 
           but they do not know what each other are doing (privacy and confidentiality)."""</li>
       <li>Channel = { ledgerSingleton: ..., ACL: ...., block_policies } </li>
       <li>Channels enable multi-lateral transactions with the high degrees of privacy and confidentiality required by competing businesses and regulated industries that exchange assets on a common network.</li>
       <li>A channel's ledger contains a configuration block defining policies, access control lists, and other pertinent information</li>
       <li>Channel's contain Membership Service Provider instances allowing for crypto materials to be derived from different certificate authorities</li>
       <li>The channel supports atomic delivery of all messages, that is, message communication with total-order delivery and (implementation specific) reliability. In other words, the channel outputs the same messages to all connected peers and outputs them to all peers in the same logical order. This atomic communication guarantee is also called total-order broadcast, atomic broadcast, or consensus in the context of distributed systems. The communicated messages are the candidate transactions for inclusion in the blockchain state</li>

       <li>A channel is defined by members (organizations), anchor peers per member, the shared ledger, chaincode application(s) and the ordering service node(s). Each transaction on the network is executed on a channel, where each party must be authenticated and authorized to transact on that channel. Each peer that joins a channel, has its own identity given by a membership services provider (MSP), which authenticates each peer to its channel peers and services.</li>

       <li>To create a new channel, the client SDK calls configuration system chaincode and references properties such as anchor peer**s, and members (organizations). This request creates a **genesis block for the channel ledger, which stores configuration information about the channel policies, members and anchor peers. When adding a new member to an existing channel, either this genesis block, or if applicable, a more recent reconfiguration block, is shared with the new member.<br/>
         <span TODO>Add client SDK code</span>
       </li>
       <li>The election of a leading peer for each member on a channel determines which peer communicates with the ordering service on behalf of the member. If no leader is identified, an algorithm can be used to identify the leader. The consensus service orders transactions and delivers them, in a block, to each leading peer, which then distributes the block to its member peers, and across the channel, using the gossip protocol.
       </li>
     </ul>
  </td>
  <td col1 >
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#security-membership-services">Security &amp; Membership Services</a></td> 
  <td summa >
     <ul>
       <li>Permissioned membership provides a trusted blockchain network, where participants know that all transactions can be detected and traced by authorized regulators and auditors</li>
       <li>All participants have known identities</li>
       <li>Public Key Infrastructure is used to generate cryptographic certificates which are tied to organizations, network components, and end users or client applications</li>
     </ul>


  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#consensus" >Consensus</a></td> 
  <td summa >
     <ul>
       <li>Consensus is ultimately achieved when the order and results of a block's transactions have met the explicit policy criteria checks.</li>
       <li>Check out the <a href='https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html'>Transaction Flow diagram</a> for a visual representation of consensus.</li>
       <li></li>
       <li></li>
       <li></li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col3 >
  </td>
</tr }>

<tr header_delimit {> <td colspan=5 >ARCHITECTURE</td> </tr>

<tr {>
  <td topic TODO ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html">Bringing up a Kafka-based Ordering Service</a></td> 
  <td summa >
     <ul>
       <li>This document assumes that the reader generally knows how to set up a Kafka cluster and a ZooKeeper ensemble. The purpose of this guide is to identify the steps you need to take so as to have a set of Hyperledger Fabric ordering service nodes (OSNs) use your Kafka cluster and provide an ordering service to your blockchain network. </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>

<tr {>
  <td topic TODO ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html">Ledger</a></td> 
  <td summa >
     <ul>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions. State transitions are a result of chaincode invocations (‘transactions’) submitted by participating parties. Each transaction results in a set of asset key-value pairs that are committed to the ledger as creates, updates, or deletes.

The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in blocks, as well as a state database to maintain current state. There is one ledger per channel. Each peer maintains a copy of the ledger for each channel of which they are a member. </li>
       <li>The chain is a transaction log, structured as hash-linked blocks, where each block contains a sequence of N transactions. The block header includes a hash of the block’s transactions, as well as a hash of the prior block’s header. In this way, all transactions on the ledger are sequenced and cryptographically linked together. In other words, it is not possible to tamper with the ledger data, without breaking the hash links. The hash of the latest block represents every transaction that has come before, making it possible to ensure that all peers are in a consistent and trusted state.</li>
       <li>he ledger’s current state data represents the latest values for all keys ever included in the chain transaction log. Since current state represents all latest key values known to the channel, it is sometimes referred to as World State.</li>
       <li>State database options:
         <ul>
           <li>LevelDB: default key/value state database embedded in the peer process</li>
           <li>CouchDB: optional alternative external state database, uses a JSON document store, enabling rich query against the chaincode data (when chaincode values like assets are modeled as JSON data)</li>
           <li> It is a good practice to model chaincode asset data as JSON, so that you have the option to perform complex rich queries if needed in the future.</li>
         <ul>
</li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html'>CounchDB configuration</a></li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html">Read-Write set semantics</a></td> 
  <td summa >
     <ul>
       <li>
         <pre xsmall { >
read set =  [(keys, value, version)]
writ set =  [(unique key, latest_value /*set by TX*/ )] 
      latest_value or isDelete=true

Example:
consider a set of five ordered transactions (T1 ->, T2 -> T3 -> T4 -> T5)
simulated on the same snapshot of the world state:

Initial World state : 
   [ (k1,1,v1), (k2,1,v2), (k3,1,v3), (k4,1,v4), (k5,1,v5) ]
-----------------------------------------
T1 -> Write k1 -> (k1,2,v1')
      Write k2 -> (k2,2,v2')
   Result:
     validation OK (no reads)
-----------------------------------------
T2 -> Read(k1,1,v1)
      Write k3 -> (k3,3,v3')
   Result:
     validation ERROR  (reads k1 v1 < current v2')
-----------------------------------------
T3 -> Write  k2 -> (k2, v2'')
   Result:
     validation OK (no reads)
     k2 updated to (k2,3,v2'')
-----------------------------------------
T4 -> Write(k2, v2'''), read(k2)
   Result:
     validation ERROR  (reads k2 v1 < current v2'')
-----------------------------------------
T5 -> Write k6 -> (k6, v6')
      read(k5)
   Result:
     validation OK (k5,v1 still in version v1 )
-----------------------------------------

Note: Transactions with multiple read-write sets are not yet supported.
         </pre } >
       </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic TODO ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html">Gossip data dissemination protocol</a></td> 
  <td summa >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>
<tr {>
  <td topic ><a href="https://hyperledger-fabric.readthedocs.io/en/latest/capabilities.html#identity-management">Identity management/Certificat Authority(CA)</a></td> 
  <td summa >
     <ul>
       <li>Takes care of enrollment and governance process</li>
       <li>To enable permissioned networks, Hyperledger Fabric provides a membership identity service that manages user IDs and authenticates all participants on the network. Access control lists can be used to provide additional layers of permission through authorization of specific network operations. For example, a specific user ID could be permitted to invoke a chaincode application, but blocked from deploying new chaincode. One truism about Hyperledger Fabric networks is that members know each other (identity), but they do not know what each other are doing (privacy and confidentiality).</li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col3 >
  </td>
</tr }>
<tr header_delimit } {> <td colspan=5 >DEPLOYMENT</td> </tr>
<tr {>
  <td topic ><a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/byfn.sh'>Build Your First Network script</a></td> 
  <td summa >
     <ul>
       <li>STEPS:
       <ol>
         <li>Generate certificates <br/>
            <code>$ cryptogen generate --config=./crypto-config.yaml</code></li>
         <li>Generate Orderer Genesis block:<br/>
            <code>$ configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block </code>
         </li>
         <li>Generate channel configuration transaction 'channel.tx'<br/>
            <code>$ configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
  
         </li>
         <li>Generate anchor peer update for Org1MSP/Org2MSP
            <pre>
$ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate \
      ./channel-artifacts/Org1MSPanchors.tx \ #  (same for Org2MSPanchors.tx)
      -channelID $CHANNEL_NAME -asOrg Org1MSP #  (same for Org2MSP)
            </pre>
         </li>
       </li>
       <li></li>


     </ul>
  </td>
  <td col1 >
     <ul>
       <li>first-network/crypto-config.yaml:
         <pre xsmall{ >
OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    # Specs is an array of Spec entries.
    #  Each Spec entry consists of two fields:
    #   - Hostname:   (Required) (without the domain)
    #   - CommonName: (Optional) Specifies the template or explicit override
    #                 for the CN.  By default, this is the template:
    # Specs:
    #   - Hostname: foo # implicitly "foo.org1.example.com"
    #     CommonName: foo27.org5.example.com # overrides Hostname-based
    #                                          FQDN set above
    #   - Hostname: bar
    #   - Hostname: baz
    # ---------------------------------------------------------------------------
    # "Template"
    # ---------------------------------------------------------------------------
    # Allows for the definition of 1 or more hosts are created sequentially
    # from a template. By default, this looks like "peer%d" from 0 to Count-1.
    # You may override the number of nodes (Count), the starting index (Start)
    # or the template used to construct the name (Hostname).
    #
    # Note: Template and Specs are not mutually exclusive.  You may define both
    # sections and the aggregate nodes will be created for you.  Take care with
    # name collisions
    # ---------------------------------------------------------------------------
    Template:
      Count: 2
      # Start: 5
      # Hostname: {{.Prefix}}{{.Index}} # default
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 2
    Users:
         </pre }>
       </li>
     </ul>
  </td>  
  <td col2  >
<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/configtx.yaml'>configtx.yaml</a>
     <pre xsmall { >
Profiles:
    TwoOrgsOrdererGenesis:
        Orderer:
            &lt;&lt;: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
    TwoOrgsChannel:
        Consortium: SampleConsortium
        Application:
            &lt;&lt;: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
Organizations:
    - &OrdererOrg
        Name: OrdererOrg
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/example.com/msp
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp
        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051
    - &Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: crypto-config/peerOrganizations/org2.example.com/msp
        AnchorPeers:
            - Host: peer0.org2.example.com
              Port: 7051
Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses:
        - orderer.example.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Kafka:
        Brokers:
            - 127.0.0.1:9092
    Organizations:
Application: &ApplicationDefaults
    Organizations:
         </pre }>
  </td>
  <td col3 >
<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-couch.yaml'>docker-compose-couch.yaml</a>
<pre xsmall { >
version: '2'
networks:
  byfn:
services:
  couchdb0:
  # (same for couchdb1/2/3 changing ports - 6984, 7984)
    container_name: couchdb0
    image: hyperledger/fabric-couchdb
    environment:
      - COUCHDB_USER=...
      - COUCHDB_PASSWORD=...
    ports:
      - "5984:5984"
    networks:
      - byfn

  peer0.org1.example.com:
  # (same for peer1.org1.example.com: changing ...0 -> ...1)
  # (same for peer0.org2.example.com: changing ...0 -> ...2)
  # (same for peer1.org2.example.com: changing ...0 -> ...3)
    environment:
      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0:5984
      - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=
      - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=
    depends_on:
      - couchdb0
</pre }>
<hr/>
<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-cli.yaml'>docker-compose-cli.yaml</a>
<pre xsmall { >
version: '2'
networks:
  byfn:
services:
  orderer.example.com:
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.example.com
    container_name: orderer.example.com
    networks:
      - byfn

  peer0.org1.example.com:
  (same for  peer1.org1.example.com changing)
  (same for  peer0.org2.example.com changing)
    container_name: peer0.org1.example.com
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org1.example.com
    networks:
      - byfn

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT'
    volumes:
        - /var/run/:/host/var/run/
        - ./../chaincode/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
    depends_on:
      - orderer.example.com
      - peer0.org1.example.com
      - peer1.org1.example.com
      - peer0.org2.example.com
      - peer1.org2.example.com
    networks:
      - byfn
</pre }>

  </td>
</tr }>

<tr {>
  <td topic ><a href='https://hyperledger-fabric.readthedocs.io/en/latest/write_first_app.html'>Writing your first app</a></td> 
  <td summa >
     <ul>
       <li> </li>
     </ul>
  </td>
  <td col1 >
     <ul>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>


<tr {>
  <td topic ><a href='https://github.com/hyperledger/fabric-samples/tree/release/fabcar'>Ex. FabCar</a></td> 
  <td summa >
    <pre xsmall { >
<a href='https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go'>fabric-samples fabcar.go Summary</a> (Error checks removed)
// structures
type Car struct {                   type SmartContract struct { }

    Make   string `json:"make"`
    Model  string `json:"model"`
    Colour string `json:"colour"`
    Owner  string `json:"owner"`
}

func (s *SmartContract)
     initLedger(
       APIstub shim.ChaincodeStubInterface)
         sc.Response {
    cars := []Car{ // ledger initialization outside Init
        Car{Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
        Car{Make: "Ford", Model: "Mustang", Colour: "red", Owner: "Brad"},
        ...  }

    i := 0 ; for i &lt; len(cars) {
        carAsBytes, _ := json.Marshal(cars[i])
        APIstub.PutState("CAR"+strconv.Itoa(i), carAsBytes)
        fmt.Println("Added", cars[i])
        i = i + 1
    }
    return shim.Success(nil)
}

// called when instantiated by the blockchain network
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
    return shim.Success(nil)
}

/* called as a result of application request to run the Smart Contract "fabcar" */
func (s *SmartContract)
    Invoke(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    // Retrieve the requested Smart Contract function and arguments
    function, args := APIstub.GetFunctionAndParameters()
    if function == "queryCar" {
        return s.queryCar(APIstub, args)
    } else if function == "initLedger" {
        return s.initLedger(APIstub)
    } else if function == "createCar" {
        return s.createCar(APIstub, args)
    } else if function == "queryAllCars" {
        return s.queryAllCars(APIstub)
    } else if function == "changeCarOwner" {
        return s.changeCarOwner(APIstub, args)
    }
}

func (s *SmartContract) 
    queryCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    return shim.Success(carAsBytes)
}

func (s *SmartContract) 
    createCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]}
    carAsBytes, _ := json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}

func (s *SmartContract) 
    queryAllCars(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    startKey := "CAR0"
    endKey := "CAR999"
    resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
    defer resultsIterator.Close()
    
    var buffer /* JSON array with QueryResults */ bytes.Buffer
    buffer.WriteString("[")
    for resultsIterator.HasNext() {
        queryResponse, err := resultsIterator.Next()
        ...
        buffer.WriteString("{\"Key\":")
        buffer.WriteString("\"")
        ...
    }
    ...
    return shim.Success(buffer.Bytes())
}

func (s *SmartContract)
    changeCarOwner(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    car := Car{}
    json.Unmarshal(carAsBytes, &amp;car)
    car.Owner = args[1]
    carAsBytes, _ = json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}


func main /* testing purposes*/() {
    // Create new Contract
    err := shim.Start(new(SmartContract))
}
    </pre } >
  </td>
  <td col1 >
     <span xbig>NodeJS Client APP Code</span>
     <ul>
       <li>
         <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/query.js'>fabcar query.js</a>
    <pre xsmall { >
var hfc = require('fabric-client');
var path = require('path');
var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    network_url: 'grpc://localhost:7051',
};

Promise.resolve().then(() => {
    console.log("Create a client and set the wallet location");
    var client = new hfc();
    return hfc.newDefaultKeyValueStore({ path: options.wallet_path });
}).then((wallet) => {
    console.log("Set wallet path, and associate user ", options.user_id, " with application");
    client.setStateStore(wallet);
    return client.getUserContext(options.user_id, true);
}).then((user) => {
    console.log("Check user is enrolled, and set a query URL in the network");
    if (user === undefined || user.isEnrolled() === false) {
        console.error("User not defined, or not enrolled - error");
    }
    var channel = client.newChannel(options.channel_id);
    channel.addPeer(client.newPeer(options.network_url));
    return;
}).then(() => {
    console.log("Make query");
    var transaction_id = client.newTransactionID();
    console.log("Assigning transaction_id: ", transaction_id._transaction_id);

    // queryCar - requires 1 argument, ex: args: ['CAR4'],
    // queryAllCars - requires no arguments , ex: args: [''],
    const request = {
        chaincodeId: options.chaincode_id,
        txId: transaction_id,
        fcn: 'queryAllCars',
        args: ['']
    };
    return channel.queryByChaincode(request);
}).then((query_responses) => {
    console.log("returned from query");
    if (!query_responses.length) {
        console.log("No payloads were returned from query");
    } else {
        console.log("Query result count = ", query_responses.length)
    }
    if (query_responses[0] instanceof Error) {
        console.error("error from query = ", query_responses[0]);
    }
    console.log("Response is ", query_responses[0].toString());
}).catch((err) => {
    console.error("Caught Error", err);
});
    </pre } >
</li>
     </ul>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>

<tr header_delimit } {> <td colspan=5 >NodeJS SDK</td> </tr>

<tr {>
  <td topic><a href='https://fabric-sdk-node.github.io/'>Fabric SDK</a></td> 
  <td summa >
<p>NodeJS APIs are available to:</p>
    <ul>
      <li>create <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">channels</a></li>
      <li>ask <a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#peer">peer nodes</a> to join the channel</li>
      <li>install <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode">chaincodes</a> in peers using the consensus process (can be preinstalled in setup scripts)</li>
      <li>instantiate chaincodes in a channel</li>
      <li>invoke transactions by calling the chaincode</li>
      <li>
          Query the <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">ledger</a> for transactions or blocks<br/>
      </li>
      <li TODO >receive ledger updates</li>
    </ul>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
  <td col3>
  </td>
</tr }>
<tr header_delimit } {> <td colspan=5 >JAVA</td> </tr>
<tr {>
  <td topic><a href='https://github.com/hyperledger/fabric-sdk-java'>JAVA SDK</a></td> 
  <td summa >
     <ul>
       <li></li>
     </ul>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
  <td col3>
  </td>
</tr }>
<tr header_delimit } > <td colspan=5 ></td> </tr>
</table>
</body>
<!--
 CA Service:
 http://hyperledger-fabric-ca.readthedocs.io/en/latest/
 *OPTIONAL* certificate authority service that you may choose to
 to generate the ECDSA certificates
_________________________________________________________________________________
There are three types of nodes:

  - Client or submitting-client: a client that submits an actual transaction-invocation to the endorsers, and broadcasts transaction-proposals to the ordering service. The client represents the entity that acts on behalf of an end-user. It must connect to a peer for communicating with the blockchain. The client may connect to any peer of its choice. Clients create and thereby invoke transactions.

  - Peer: a node that commits transactions and maintains the state and a copy of the ledger (see Sec, 1.2). Besides, peers can have a special endorser role. A peer receives ordered state updates in the form of blocks from the ordering service and maintain the state and the ledger.  Peers can additionally take up a special role of an endorsing peer, or an endorser with respect to a particular chaincode.

  - Ordering-service-node or orderer: a node running the communication service that implements a delivery guarantee, such as atomic or total order broadcast.

<a href='https://github.com/hyperledger/fabric-samples/blob/release/basic-network/docker-compose.yml'>basic network docker-compose.yml</a> containing 
[ hyperledger/fabric-ca, hyperledger/fabric-orderer, hyperledger/fabric-peer, hyperledger/fabric-couchdb, hyperledger/fabric-tools ]
_________________________________________________________________________________
<!--
__________________________________________
Roles: 
  - Peers: Endorser , Commiter
  - Consenters: 
_______________________________________________
Contributing
<ul>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/CONTRIBUTING.html">Contributions Welcome!</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/MAINTAINERS.html">Maintainers</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/jira_navigation.html">Using Jira to understand current work items</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">Setting up the development environment</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html">Building Hyperledger Fabric</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#building-outside-of-vagrant">Building outside of Vagrant</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#configuration">Configuration</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#logging">Logging</a></li>
  <li><hr/></li>
  <li><a href="Gerrit/lf-account.html">Requesting a Linux Foundation Account</a></li>
  <li><a href="Gerrit/gerrit.html">Working with Gerrit</a></li>
  <li><a href="Gerrit/changes.html">Submitting a Change to Gerrit</a></li>
  <li><a href="Gerrit/reviewing.html">Reviewing a Change</a></li>
  <li><a href="Gerrit/best-practices.html">Gerrit Recommended Practices</a></li>
  <li><a href="testing.html">Testing</a></li>
  <li><a href="Style-guides/go-style.html">Coding guidelines</a></li>
  <li><a href="Style-guides/go-style.html#generating-grpc-code">Generating gRPC code</a></li>
  <li><a href="Style-guides/go-style.html#adding-or-updating-go-packages">Adding or updating Go packages</a></li>
</ul>
_________________________________________
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html">Glossary</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/releases.html">Release Notes</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/questions.html">Still Have Questions?</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/status.html">Status</a>
_________________________________________
<a href="http://hyperledger-fabric-ca.readthedocs.io/en/latest">Hyperledger Fabric CA’s User Guide</a>
_________________________________________

<p>See the <a class="reference internal" href="ledger.html"><span class="doc">Ledger</span></a> topic for a deeper dive on the databases, storage structure, and “query-ability.”</p>

_________________________________________

See the <a href='https://hyperledger-fabric.readthedocs.io/en/latest/msp.html'>Membership Service Providers (MSP)</a> topic to better understand cryptographic implementations, and the sign, verify, authenticate approach used in Hyperledger Fabric.


_________________________________________
transaction flow: proposal -> endorsement -> ordering -> validation -> commitment
                  -------------- C O N S E N S U S ------------------------------

_____________________________________
The MSP is a peer component that allows them to verify transaction requests arriving from clients and to sign transaction results(endorsements). The Writing policy is defined at channel creation time, and determines which user is entitled to submit a transaction to that channel.
______________________________________
Transactions may be of two types:

    Deploy transactions create new chaincode and take a program as parameter. When a deploy transaction executes successfully, the chaincode has been installed “on” the blockchain. Deployment specifies the endorsement policy for the chaincode.

    Invoke transactions perform an operation in the context of previously deployed chaincode. An invoke transaction refers to a chaincode and to one of its provided functions. When successful, the chaincode executes the specified function - which may involve modifying the corresponding state, and returning an output.

_______________________________
 support for cross-chaincode transactions (post-v1 feature)
_________________________________
Nodes are the communication entities of the blockchain. A “node” is only a logical function in the sense that multiple nodes of different types can run on the same physical server. What counts is how nodes are grouped in “trust domains” and associated to logical entities that control them.
_________________________________
https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html

2.1.1. PROPOSE message format

<p>The format of a <code class="docutils literal"><span class="pre">PROPOSE</span></code> message is <code class="docutils literal"><span class="pre">&lt;PROPOSE,tx,[anchor]&gt;</span></code>, where
<code class="docutils literal"><span class="pre">tx</span></code> is a mandatory and <code class="docutils literal"><span class="pre">anchor</span></code> optional argument explained in the
following.</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">tx=&lt;clientID,chaincodeID,txPayload,timestamp,clientSig&gt;</span></code>, where</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">clientID</span></code> is an ID of the submitting client,</li>
<li><code class="docutils literal"><span class="pre">chaincodeID</span></code> refers to the chaincode to which the transaction
pertains,</li>
<li><code class="docutils literal"><span class="pre">txPayload</span></code> is the payload containing the submitted transaction
itself,</li>
<li><code class="docutils literal"><span class="pre">timestamp</span></code> is a monotonically increasing (for every new
transaction) integer maintained by the client,</li>
<li><code class="docutils literal"><span class="pre">clientSig</span></code> is signature of a client on other fields of <code class="docutils literal"><span class="pre">tx</span></code>.</li>
</ul>
<p>The details of <code class="docutils literal"><span class="pre">txPayload</span></code> will differ between invoke transactions
and deploy transactions (i.e., invoke transactions referring to a
deploy-specific system chaincode). For an <strong>invoke transaction</strong>,
<code class="docutils literal"><span class="pre">txPayload</span></code> would consist of two fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">txPayload</span> <span class="pre">=</span> <span class="pre">&lt;operation,</span> <span class="pre">metadata&gt;</span></code>, where<ul>
<li><code class="docutils literal"><span class="pre">operation</span></code> denotes the chaincode operation (function) and
arguments,</li>
<li><code class="docutils literal"><span class="pre">metadata</span></code> denotes attributes related to the invocation.</li>
</ul>
</li>
</ul>
<p>For a <strong>deploy transaction</strong>, <code class="docutils literal"><span class="pre">txPayload</span></code> would consist of three
fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">txPayload</span> <span class="pre">=</span> <span class="pre">&lt;source,</span> <span class="pre">metadata,</span> <span class="pre">policies&gt;</span></code>, where<ul>
<li><code class="docutils literal"><span class="pre">source</span></code> denotes the source code of the chaincode,</li>
<li><code class="docutils literal"><span class="pre">metadata</span></code> denotes attributes related to the chaincode and
application,</li>
<li><code class="docutils literal"><span class="pre">policies</span></code> contains policies related to the chaincode that
are accessible to all peers, such as the endorsement policy.
Note that endorsement policies are not supplied with
<code class="docutils literal"><span class="pre">txPayload</span></code> in a <code class="docutils literal"><span class="pre">deploy</span></code> transaction, but
<code class="docutils literal"><span class="pre">txPayload</span></code> of a <code class="docutils literal"><span class="pre">deploy</span></code> contains endorsement policy ID and
its parameters (see Section 3).</li>
</ul>
</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">anchor</span></code> contains <em>read version dependencies</em>, or more
specifically, key-version pairs (i.e., <code class="docutils literal"><span class="pre">anchor</span></code> is a subset of
<code class="docutils literal"><span class="pre">KxN</span></code>), that binds or “anchors” the <code class="docutils literal"><span class="pre">PROPOSE</span></code> request to
specified versions of keys in a KVS (see Section 1.2.). If the client
specifies the <code class="docutils literal"><span class="pre">anchor</span></code> argument, an endorser endorses a transaction
only upon <em>read</em> version numbers of corresponding keys in its local
KVS match <code class="docutils literal"><span class="pre">anchor</span></code> (see Section 2.2. for more details).</p>
</li>
</ul>
<p>Cryptographic hash of <code class="docutils literal"><span class="pre">tx</span></code> is used by all nodes as a unique
transaction identifier <code class="docutils literal"><span class="pre">tid</span></code> (i.e., <code class="docutils literal"><span class="pre">tid=HASH(tx)</span></code>). The client
stores <code class="docutils literal"><span class="pre">tid</span></code> in memory and waits for responses from endorsing peers.</p>
_________________________________
https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html

3.3. Example endorsement policies<a class="headerlink" href="#example-endorsement-policies" title="Permalink to this headline">¶</a></h3>
<p>The predicate may contain logical expressions and evaluates to TRUE or
FALSE. Typically the condition will use digital signatures on the
transaction invocation issued by endorsing peers for the chaincode.</p>
<p>Suppose the chaincode specifies the endorser set
<code class="docutils literal"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">{Alice,</span> <span class="pre">Bob,</span> <span class="pre">Charlie,</span> <span class="pre">Dave,</span> <span class="pre">Eve,</span> <span class="pre">Frank,</span> <span class="pre">George}</span></code>. Some example
policies:</p>
<ul class="simple">
<li>A valid signature from on the same <code class="docutils literal"><span class="pre">tran-proposal</span></code> from all members
of E.</li>
<li>A valid signature from any single member of E.</li>
<li>Valid signatures on the same <code class="docutils literal"><span class="pre">tran-proposal</span></code> from endorsing peers
according to the condition
<code class="docutils literal"><span class="pre">(Alice</span> <span class="pre">OR</span> <span class="pre">Bob)</span> <span class="pre">AND</span> <span class="pre">(any</span> <span class="pre">two</span> <span class="pre">of:</span> <span class="pre">Charlie,</span> <span class="pre">Dave,</span> <span class="pre">Eve,</span> <span class="pre">Frank,</span> <span class="pre">George)</span></code>.</li>
<li>Valid signatures on the same <code class="docutils literal"><span class="pre">tran-proposal</span></code> by any 5 out of the 7
endorsers. (More generally, for chaincode with <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">3f</span></code> endorsers,
valid signatures by any <code class="docutils literal"><span class="pre">2f+1</span></code> out of the <code class="docutils literal"><span class="pre">n</span></code> endorsers, or by
any group of <em>more</em> than <code class="docutils literal"><span class="pre">(n+f)/2</span></code> endorsers.)</li>
<li>Suppose there is an assignment of “stake” or “weights” to the
endorsers, like
<code class="docutils literal"><span class="pre">{Alice=49,</span> <span class="pre">Bob=15,</span> <span class="pre">Charlie=15,</span> <span class="pre">Dave=10,</span> <span class="pre">Eve=7,</span> <span class="pre">Frank=3,</span> <span class="pre">George=1}</span></code>,
where the total stake is 100: The policy requires valid signatures
from a set that has a majority of the stake (i.e., a group with
combined stake strictly more than 50), such as <code class="docutils literal"><span class="pre">{Alice,</span> <span class="pre">X}</span></code> with
any <code class="docutils literal"><span class="pre">X</span></code> different from George, or
<code class="docutils literal"><span class="pre">{everyone</span> <span class="pre">together</span> <span class="pre">except</span> <span class="pre">Alice}</span></code>. And so on.</li>
<li>The assignment of stake in the previous example condition could be
static (fixed in the metadata of the chaincode) or dynamic (e.g.,
dependent on the state of the chaincode and be modified during the
execution).</li>
<li>Valid signatures from (Alice OR Bob) on <code class="docutils literal"><span class="pre">tran-proposal1</span></code> and valid
signatures from <code class="docutils literal"><span class="pre">(any</span> <span class="pre">two</span> <span class="pre">of:</span> <span class="pre">Charlie,</span> <span class="pre">Dave,</span> <span class="pre">Eve,</span> <span class="pre">Frank,</span> <span class="pre">George)</span></code>
on <code class="docutils literal"><span class="pre">tran-proposal2</span></code>, where <code class="docutils literal"><span class="pre">tran-proposal1</span></code> and
<code class="docutils literal"><span class="pre">tran-proposal2</span></code> differ only in their endorsing peers and state
updates.</li>

_________________________________
Membership Service Providers (MSP)
http://hyperledger-fabric.readthedocs.io/en/latest/msp.html

Membership Service Provider (MSP) is a component that aims to offer an abstraction of a membership operation architecture.

In particular, MSP abstracts away all cryptographic mechanisms and protocols behind issuing and validating certificates, and user authentication. An MSP may define their own notion of identity.
_________________________________

VIDEO: What's new in Hyperledger Fabric 1.0: Nikolay Vlasov: FASSAIS Summit 2017: https://www.youtube.com/watch?v=6nGIptzBZis

Fabric Composer: Web GUI to develop Fabric apps. https://hyperledger.github.io/composer/

Video Tutorial: https://www.youtube.com/watch?v=fdFUsrsv5iw 
________________________________________
-->
</html>



