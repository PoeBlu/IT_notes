<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Hyperledger Fabric Map</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->

<table>
<tr {>
  <td col0 colspan=1>
    <ul xxsmall>
      <li><a href='https://godoc.org/github.com/hyperledger/fabric' xbig>GoLang API DOC</a></li>
      <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/'>Fabric</a></li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html">Glossary</a>                </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/releases.html">Release Notes</a>           </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/questions.html">Still Have Questions?</a>  </li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/status.html">Status</a>                    </li>
      <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/samples.html'>Fabric Samples</a><br/>
          $ git clone <a href='https://github.com/hyperledger/fabric-samples.git'>https://github.com/hyperledger/fabric-samples.git</a></li>
      <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html">Architecture Explained</a></li>
    </ul>
   <a xbig href='https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html'>Prerequisites:</a>
   <ul xxsmall>
     <li><a href='https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites'>Docker CE for Centos</a></li>
     <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/samples.html#binaries'>Platform-specific binaries (cryptogen,...) used for the fabric-sample demos</a></li>
     <li>Dependencies: cURL, git,<br/>
         docker 17.06.02-ce+ (2017-09-05)(docker engine 1.13.x NOT supported),
         <a href='https://go-repo.io/'>adding docker-ce repo to yum</a>
         <br/>
         docker-compose 1.14.0+ See <a href='https://docs.docker.com/compose/install/#install-compose'>here</a> to install latest version
     </li>

     <li>Go programming language 1.9.x <br/>
         Check $GOPATH="working directory" (example $HOME/go)
         <a href='https://go-repo.io/'>Install custom golang repo</a>
     </li>
     <li>Node.js 6.9.x Runtime (7.x not yet supported) and NPM (npm install npm@3.10.10 -g)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
     <li>Python 2.7 (sudo apt-get install python)</li>
   </ul>
   <span xbig>Development and contributing:</a>
   <ul xxsmall>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/CONTRIBUTING.html">Contributions Welcome!</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/MAINTAINERS.html">Maintainers</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/jira_navigation.html">Using Jira to understand current work items</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">Setting up the development environment</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html">Building Hyperledger Fabric</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#building-outside-of-vagrant">Building outside of Vagrant</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#configuration">Configuration</a></li>
     <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#logging">Logging</a></li>
     <li><a href="Gerrit/lf-account.html">Requesting a Linux Foundation Account</a></li>
     <li><a href="Gerrit/gerrit.html">Working with Gerrit</a></li>
     <li><a href="Gerrit/changes.html">Submitting a Change to Gerrit</a></li>
     <li><a href="Gerrit/reviewing.html">Reviewing a Change</a></li>
     <li><a href="Gerrit/best-practices.html">Gerrit Recommended Practices</a></li>
     <li><a href="testing.html">Testing</a></li>
     <li><a href="Style-guides/go-style.html">Coding guidelines</a></li>
     <li><a href="Style-guides/go-style.html#generating-grpc-code">Generating gRPC code</a></li>
     <li><a href="Style-guides/go-style.html#adding-or-updating-go-packages">Adding or updating Go packages</a></li>
   </ul>
  </td>
  <td col2 colspan=2 >
    <span xxxbig >Model</span><br/>
    <span xbig>Channels</span><br/> REF:<a xxsmall href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels" >Privacy through Channels</a><br/>
    <ul xxsmall>
      <li>enable multi-lateral TXs with the high degrees of privacy and confidentiality 
          ("""members know each other (identity), but they do not know what each other are doing""")</li>
      <li>Channels exist within the purview of a consortium( and all consortia must be defined in
          the scope of the network at large)</li>
      <li style="color:blue">Channel is defined by:
        <ul>
          <li>the shared ledger ("ledger singleton")
  Contains a genesis (configuration) block defining policies,
  ACLs, initial members and anchor peers
          </li>
          <li>members (organizations)</li>
          <li>anchor peers per member</li>
          <li>chaincode application(s)</li>
          <li>ordering service node(s)</li>
          <li>- Membership service provider (ACLs)
<pre>
* Authenticate each peer to other channel's
  nodes.
* crypto materials can be derived
  from different CAs
</pre>
          </li>
          <li>Block policies</li>
        </ul>
      </li>
</pre>
      </li>
      <li>support<b>atomic delivery</b>(also called total-order/atomic broadcast, or consensus) of all messages (== candidate TX): message communication with total-order delivery and (implementation specific) reliability to all connected peers . </li>
   </ul>
   Creating a new Channel:
   <ul xxsmall>
      <li>client SDK calls configuration system chaincode and references properties such as anchor peer**s,
          and members (organizations). This request creates a channel ledger's <b>genesis block</b> </li>
      <li>When adding a new member to an existing channel, either this genesis block, or if applicable, a
          more recent reconfiguration block, is shared with the new member.<br/>
      </li>
    </ul>
    <br/>

    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#assets" xbig>Assets</a>
    <ul xxsmall>
       <li>Assets, "owned" (and fungible?) entities, are represented in Hyperledger Fabric as a collection of key-value pairs, with state changes recorded as transactions on a Channel ledger.</li>
       <li>can be represented in binary and/or JSON form</li>
       <li><a class="reference external" href="https://github.com/hyperledger/composer">Hyperledger Composer</a> can easily define assets</li>
    </ul>
    <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode" xbig>Chaincode</a><br/>
    <a href='http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html'><span TODO>recheck</span>Chaincode 4 devs</a>
    <ul xxsmall>
      <li>Chaincode is software defining an asset or assets, and the transaction instructions for modifying the asset(s).</li>
      <li>Chaincode (smart-contract) are hosted in the network, identified by name and version, for example 'dev-peer0.org1.example.com-fabcar-1.0' when the name is fabcar, the version is 1.0 and the peer it is running against is dev-peer0.org1.example.com</li>
      <li>Chaincode is installed only on peers that need to access the asset states to perform reads and writes</li>
      <li>Chaincode invocation &lt;- 1 to 1 -&gt; Transaction</li>
      <li>Chaincode execution is partitioned from transaction ordering, limiting the required levels of trust and verification across node types, and optimizing network scalability and performance</li>
      <li>enforces the rules for reading or altering key value pairs or other state database information</li>
      <li>Chaincode functions execute against the ledger current state database </li>
      <li>Chaincode functions are initiated through a transaction proposal</li>
    </ul>
<br/>
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features" xbig>Ledger Features</a>
     <ul xxsmall>
       <li>The immutable, shared ledger encodes the entire transaction history for each channel,
           and includes SQL-like query capability for efficient auditing and dispute resolution</li>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric</li>
       <li>Each results in a set of asset key-value pairs that are committed to the ledger as Creates, Updates, or Deletes</li>
       <li>The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in
           blocks, as well as a state database to maintain current fabric state.</li>
       <li>The ledger is part of a Channel (Each channel peer maintains a copy of the ledger) <br/>
           A ledger exists <b>in the life scope of a channel</b>
       </li>

       <li>Query and update ledger using key-based lookups, range queries, and composite key queries</li>
       <li>Read-only queries using a rich query language (if using CouchDB as state database)</li>
       <li>Read-only history queries - Query ledger history for a key, enabling data provenance scenarios</li>
       <li>TRANSACTIONS CONSIST OF THE VERSIONS OF KEYS/VALUES THAT WERE READ IN CHAINCODE 
           (READ SET) AND KEYS/VALUES THAT WERE WRITTEN IN CHAINCODE (WRITE SET)</li>
       <li>Transactions contain signatures of every endorsing peer and are submitted to ordering service</li>
       <li>Transactions may be of two types:<br/>
         - Deploy transactions create new chaincode and take a program as parameter.
           When a deploy transaction executes successfully, the chaincode has been 
           installed 'on' the blockchain. Deployment specifies the endorsement policy
           for the chaincode.<br/>
         - Invoke transactions perform an operation in the context of previously
           deployed chaincode. An invoke transaction refers to a chaincode and to
           one of its provided functions. When successful, the chaincode executes
           the specified function - which may involve modifying the corresponding
           state, and returning an output.
       </li>
     </ul>
  </td>
  <td col1 colspan=3 >
     <ul>
       <li>Nodes are the (logical) communication entities of the blockchain.</li>
       <li>Multiple nodes of different types can run on the same physical server. </li>
       <li>There are three types of nodes:
         <ul>
           <li>Peer: node that commits TXs and maintains the state and a copy of the ledger

               can also have a special <b>endorser peer</b> or <b>endorser respect to a particular chaincode</b> role
           </li>
           <li>Ordering(service): Runs the communication service that 
               implements a delivery guarantee, such as atomic or total order broadcast.</li>
           <li>(submitting) (NodeJS, java, ...) client: Node that submits/invoke/trigger an actual 
               transaction-invocation to (any peer of its choice) peer-endorsers behalf an
               end-user<br/>
           </li>
         </ul>
<pre xxsmall>
...
ordering_service -> leeding_peer: block_of_state_updates *1
leeding_peer -> organization peers: block_of_state_updates *2
peer -> peer: update state/ledger

*1 a member/organization can have more than one peer.
   The election of a leading_peer for each member on a
   channel determines which peer communicates with the 
   ordering service on behalf of the member. 
   If no leader is identified, an algorithm can be used.
*2 Use gossip protocol
</pre>
<br/>
<pre xxsmall { >
                 ┌──────────┐
              ┌─→│MEMBERSHIP│
              ┆  │ No SPoF  ┼──────────────────────────┐
      0 enroll┆  │ No SPoT  │   ┆                      ┆
              ┆  └──────────┘   ┆                      ┆
              ┆            ┌────┴────┐                 ┆
┌───────────┐ ┆            │PEER     │                 ┆
│APPLICATION│ ┆            │         │                 ┆
│  SDK -----┼─┆───────────→│Endorser │3 Relay    ┌─────┴──────┐
│  keys     │ ┆1 Endorse   │Committer│Submit TX  │O-SERVICE   │
└───────────┘ ┆  proposal  │         │──────────→│            │
              ┆            │         │           │Order TXs in│
              ┆            │ledger   │           │a batch     │
              ┆            │         │           │according to│
              └───────────→│chaincode│←──────────│consensus*1 │
               2 Submit TX │         │ 4 Deliver └────────────┘
                           │event    │   batch
                           └─────────┘
 *1 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#consensus" >Consensus</a>

CouchDB: the PEER hold the hash chain (the record of updates),
while updates themselves are stored in a separate
couchDB container (allowing for storage of rich JSON queries).

QUERIES: 
APP -> APP : var request = request(ledger, chaincode, search params)
APP -> PEER: chain.queryByChaincode(request) API 
PEER -> APP: (synch) response_payload

UPDATES (TX FLOW)
--------  connect to peer's event listener port  --------
APP -> PEER: eh.setPeerAddr ()
--------  TX FLOW  --------
APP -> APP : var req = 
       TX_proposal(channel ID, chaincode, function) 
APP -> (endorsing)PEER:
       channel.SendTransactionProposal(req)
PEER -> APP: proposal_response
APP -> APP: 
       tx_request =sign(proposal_response)
APP -> ORDERING_SVC: 
       channel.sendTransaction(tx_request)
??? -> APP: TX_ID
APP -> PEER:
       eh.registerTxEvent (TX_ID, callback)
ORDERING_SVC -> ORDERING_SVC: 
       bundles TX into a block
ORDERING_SVC -> PEERS on channel: block
PEER -> PEER : validate block
</pre>
       </li>
  </td>
  <td col2 colspan=3>
    <span xxxbig>TX FLOW</span><a href='https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html'>(REF)</a> <br/>
    <span>("INTEND TO UPDATE THE LEDGER")</span>
    <pre xxsmall { >
Participant (peer) A : Buyes radishes
Participant (peer) B : Sells radishes

Admin -> +Channel: set up and run
Admin ->  Channel: register and endorse A,B with CA
                   (A and B must endorse any TX)

Admin -> +Chaincode : - Initial key/value State 
                      - Logic for TX

Admin -> A, B : Install chaincode

Channel -> A,B : Request
App@peer1 -> App@peer1: Create TX proposal = Request exec
                     TX.chaincode.funct to call
                     TX.input           input to funct
App@peer1 -> App@peer1: Package TX proposal
App@peer1 -> App@peer1: Sign(Package TX proposal) with user's
                      credentials


App@peer1 -> Channel: Signed TX proposal (purchase req)
Channel -> endorsing peers:
endorsing peer -> endorsing peer: verifies:
                   - TX proposal is well formed
                   - it has not been submitted already
                     in the past (replay-attack protection)
                   - signature is valid (using MSP)
                   - submitter is properly authorized 
                     (ensures that submitter satisfies the 
                      channel’s Writers policy)
endorsing peer -> Chaincode: TX.chaincode.funct(TX.input)
Chaincode -> Chaincode: execute funct against current state
               of database 
Chaincode -> App: (@endorsing peer) 
                  TX.result = [
                     response value, 
                     read set,
                     write set ]
App -> App: SDK parses payload
            for application consumption
            -------------------------------------------
   The submitting client waits until it receives “enough” messages 
   and signatures on (TRANSACTION-ENDORSED, tid, *, *) statements to
   conclude that the TX proposal is endorsed. (may involve one or more
   round-trips of interaction with endorsers)
   If the submitting client does not manage to collect an endorsement
   for a transaction proposal, it abandons this transaction with an
   option to retry later.
   For transaction with a valid endorsement, we now start using the 
   ordering service. --
            -------------------------------------------
App -> (channel) -> Ordering Service :(Just for write 2 ledger)
                        TX.proposal + TX.result + endorsing sign.

Ordering Service -> Ordering Service: Order chronologically
                                      create blocks of TX
                    Serializability is a default isolation guarantee

Ordering Service -> Peers: TX block
Peers -> Peers: validate block
Peers -> Peers: Update ledger
Peers -> Client: event TX inmmutable appended to chain
</pre } >
  </td>
  <td col0 colspan=3 >
    <a xxbig href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#security-membership-services">Security &amp; Membership Services</a>
     <ul xxsmall>
       <li>Permissioned membership provides a trusted blockchain network, where participants know that all transactions can be detected and traced by authorized regulators and auditors</li>
       <li>All participants have known identities</li>
       <li>Public Key Infrastructure is used to generate cryptographic certificates which are tied to organizations, network components, and end users or client applications</li>
     </ul>
     <a xxbig href="https://hyperledger-fabric.readthedocs.io/en/latest/capabilities.html#identity-management">Identity management/Certificat Authority(CA) Service</a>
     <ul xxsmall>
       <li>Takes care of enrollment and governance process</li>
       <li>To enable permissioned networks, Hyperledger Fabric provides a membership identity service that manages user IDs and authenticates all participants on the network. Access control lists can be used to provide additional layers of permission through authorization of specific network operations. For example, a specific user ID could be permitted to invoke a chaincode application, but blocked from deploying new chaincode.</li>
     </ul>
    <a xxbig href='https://hyperledger-fabric.readthedocs.io/en/latest/msp.html'>Membership Service Providers (MSP)</a><br/>
    Membership Service Provider (MSP) is a component that aims to offer an abstraction of a membership operation architecture.<br/>
    In particular, MSP abstracts away all cryptographic mechanisms and protocols behind issuing and validating certificates, 
    and user authentication. An MSP may define their own notion of identity.
    <!--
      The MSP is a peer component that allows them to verify transaction requests 
      arriving from clients and to sign transaction results(endorsements).
      The Writing policy is defined at channel creation time, and determines
      which user is entitled to submit a transaction to that channel.
    -->
    <a xbig href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>Example endorsement policies</a>
    <p>The predicate may contain logical expressions and evaluates to TRUE or FALSE.
       Typically the condition will use digital signatures on the transaction invocation issued by endorsing peers for the chaincode.</p>
    <p>Suppose the chaincode specifies the endorser set 
<pre>
E = {Alice,Bob,
     Charlie,Dave,
     Eve,Frank,George}
</pre>.
     Some example policies:</p>
    <ul xxsmall>
      <li>A valid signature from on the same tran-proposal from all members of E.</li>
      <li>A valid signature from any single member of E.</li>
      <li>Valid signatures on the same tran-proposal from endorsing peers according to the condition:
       <pre>
(Alice OR Bob) AND 
(any two of:
   Charlie, Dave,
   Eve, Frank, George)
</pre>
      </li>
      <li>Valid signatures on the same tran-proposal by any 5 out of the 7
          endorsers. (More generally, for chaincode with n &gt; 3f endorsers,
          valid signatures by any 2f+1 out of the n endorsers, or by
          any group of more than (n+f)/2 endorsers</li>
      <li>Suppose there is an assignment of “stake” or “weights” to the endorsers, like
          {Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}
          where the total stake is 100: The policy requires valid signatures
          from a set that has a majority of the stake (i.e., a group with
          combined stake strictly more than 50), such as {Alice, X} with
          any X different from George, or {everyone together except Alice}, and so on.</li>
      <li>The assignment of stake in the previous example condition could be
          static (fixed in the metadata of the chaincode) or dynamic (e.g.,
          dependent on the state of the chaincode and be modified during the
          execution).</li>
      <li>Valid signatures from (Alice OR Bob) on tran-proposal1 and valid
          signatures from (any two of: Charlie, Dave, Eve, Frank, George) on
          tran-proposal2, where tran-proposal1 and tran-proposal2 differ only
          in their endorsing peers and state updates.</li>
    </ul>

  </td>

</tr }>
</table>


<table>

<tr {>

</tr }>
</table>

<table>
<tr header_delimit } {> 
  <td colspan=12 >
    Build Your First Network script, REF:
      <a href='http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html'   >Doc</a>,
      <a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/'>GitHub code</a>
  </td>
</tr>
<tr {>
  <td></td><td></td><td></td><td></td>
  <td></td><td></td><td></td><td></td>
  <td></td><td></td><td></td><td></td>
</tr>
<tr>
  <td col0 colspan=6 >
     <span xbig>configtx.yaml input to <code>'configtxgen'</code></span><br/>
     Three members(organizations): 
       -OrdererOrg
       -Org1        : peer1
       -Org2
Notice that our SampleConsortium is defined in the system-level profile and then referenced by our channel-level profile.
<pre xsmall { >
crypto material:
─────────────────────────────┬───────────────────────────┬──────────────────────────────┬───────────────────────────┬
INPUT                        → PROCEDURE                 →   OUTPUT                     → PROCEDURE                 →
─────────────────────────────┼───────────────────────────┼──────────────────────────────┼───────────────────────────┼
<a href="https://github.com/hyperledger/fabric-samples/blob/release/first-network/crypto-config.yaml">crypto-config.yaml</a>                   → cryptogen                 →crypto-config/        → Membership service        │
contains def. for:           │                           │ /crypto-config               │ TODO                      │
- OrdererOrgs:               │                           │  /ordererOrganizations       │                           │
- PeerOrgs:numer + "Dom"     │                           │    /example.com              │                           │
    Users: (Count)           │                           │     /msp                     │                           │
                             │                           │      /tlscacerts/            │                           │
                             │                           │      /admincerts/            │                           │
                             │                           │      /cacerts/               │                           │
                             │                           │     /users/Admin@"dom"       │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │     /orderers/orderer."dom"/ │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │     /tlsca/...               │                           │
                             │                           │     /ca/...                  │                           │
                             │                           │  /peerOrganizations          │                           │
                             │                           │   /org1."dom"                │                           │
                             │                           │    /msp/...                  │                           │
                             │                           │    /peers/peer0.org1."dom"   │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │    /peers/peer1.org1."dom"   │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │    /users/Admin@org1."dom"/  │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │    /users/User1@org1."dom"   │                           │
                             │                           │      (/msp/...,/tls/...)     │                           │
                             │                           │    /tlsca/..                 │                           │
                             │                           │    /ca/...                   │                           │
                             │                           │    /  /56be...c0_sk          │                           │
                             │                           │   /org2."dom"                │                           │
                             │                           │       ...                    │                           │
                             │                           │ *1                           │                           │
─────────────────────────────┴───────────────────────────┴──────────────────────────────┴───────────────────────────┴
*1: Each Organization is provisioned a unique root certificate (ca-cert) that binds specific components 
    (peers and orderers) to that Org.</li>

    By assigning each Organization a unique CA certificate, we are mimicking a typical network where a 
    participating Member would use its own Certificate Authority. 

    TXs within Fabric are signed by an entity's private key (keystore), and then verified by means of a pub.key

──────────────────┬───────────────────────────┬─────────────────────┬───────────────────────────┬
INPUT             → PROCEDURE                 →   OUTPUT            → PROCEDURE                 →
──────────────────┼───────────────────────────┼─────────────────────┼───────────────────────────┼
<a href='https://raw.githubusercontent.com/hyperledger/fabric-samples/release/first-network/configtx.yaml'>configtx.yaml</a>*1 → configtxgen               → /channel-artifacts/ →  orderer node daemon        │
                  │  -outputBlock             │   genesis.block *2  │                           │
──────────────────┼───────────────────────────┼─────────────────────┼───────────────────────────┼
configtx.yaml     → configtxgen               → /channel-artifacts/ → (client node)             →
/crypto-config    │  -outputAnchorPeersUpdate │    channel.tx *3    │                           │
──────────────────┼───────────────────────────┼─────────────────────┼───────────────────────────┼
configtx.yaml     → configtxgen               → ./channel-artifacts/→ (client node)             →
                  │  -outputAnchorPeersUpdate │   Org1MSPanchors.tx │                           │
                  │  -channelID $CHANNEL_NAME │                     │                           │
                  │  -asOrg Org1MSP           │                     │                           │
                  │                           │                     │                           │
                  │                           │                     │                           │
──────────────────┴───────────────────────────┴─────────────────────┴───────────────────────────┴

   -channelID channel01 -asOrg Org1MSP
*1: configtx.yaml contains:
   - Profiles     
   - Organizations Identities   
   - Anchor Peers 
   - Orderer address + params 
*2: genesis.block is consumed by Orderer
*3: channel configuration TX
</pre }>
  </td>
  <td col1 colspan=4 style="background-color:#DDDDFF" >
     STEPS:
     <ol>
       <li>Generate certificates using crypto-config.yaml as input:
         <pre xsmall { >
$ cryptogen generate --config=./crypto-config.yaml
</pre }>
       </li>
       <li>Generate Orderer Genesis block:
<pre xsmall { >
$ configtxgen -profile TwoOrgsOrdererGenesis \
   -outputBlock ./channel-artifacts/genesis.block 
</pre } >
       </li>
       <li>Generate channel configuration transaction 'channel.tx'
<pre xsmall { >
$ configtxgen -profile TwoOrgsChannel \
    -channelID $CHANNEL_NAME \
    -outputCreateChannelTx ./channel-artifacts/channel.tx
</pre } >
       </li>
       <li>Generate anchor peer update for Org1MSP/Org2MSP
<pre xsmall { >
$ configtxgen -profile TwoOrgsChannel \
    -outputAnchorPeersUpdate \
    ./channel-artifacts/Org1MSPanchors.tx \ #  
    -channelID $CHANNEL_NAME -asOrg Org1MSP #  
# *2 (same for Org2MSP)
</pre } >
       </li>
       <li>Start the network: (Orderer and peers will stand by waiting for client requests)
<pre xsmall { >
CHANNEL_NAME=$CHANNEL_NAME \
TIMEOUT=<pick_a_value> \
docker-compose -f docker-compose-cli.yaml up -d
</pre } >
       </li>
       <li>Create & Join Channel:
<pre xsmall { >
# enter CLI container (cli defined in docker-compose-cli.yaml)
$ docker exec -it cli bash
root@0d78bb69300d:/opt/gopath/.../fabric/peer#

# STEP: CREATE CHANNEL REQUEST.
root@0d.../peer# export CHANNEL_NAME=mychannel
root@0d.../peer# CA_F="/opt/gopath/src/github.com/hyperledger"
root@0d.../peer# CA_F="${CA_F}:/fabric/peer/crypto"
root@0d.../peer# CA_F="${CA_F}:/ordererOrganizations/"
root@0d.../peer# CA_F="${CA_F}:example.com"
root@0d.../peer# CA_F="${CA_F}:/orderers/orderer.example.com"
root@0d.../peer# CA_F="${CA_F}:/msp/tlscacerts"
root@0d.../peer# CA_F="${CA_F}:/tlsca.example.com-cert.pem"

root@0d...:../peer# peer channel create \
    -o orderer.example.com:7050 \
    -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx \
    --tls $CORE_PEER_TLS_ENABLED 
    --cafile ${CA_F} # orderer’s root cert, allowing 
                        # to verify the TLS handshake
</pre } >

(returns genesis block - <channel-ID.block> - which we will use to join the channel).
It contains the configuration information specified in channel.tx.
       </li>
       <li>Now let’s join peer0.org1.example.com to the channel.
<pre xsmall { >
root@0d.../peer# peer channel \
                 join -b <channel-ID.block>
</pre } >
(join other peers join by making appropriate changes in ENVVARS)
       </li>
     </ol>
     <span xbig>Install & Instantiate Chaincode</span><br/>
     We need to install the chaincode on every peer that will 
     execute and endorse our transactions, and then instantiate
     the chaincode on the channel.
     <ol>
       <li>install (sample Go code) onto one of the four peer nodes.<br/>
           Next command places the <e>source code</e> onto our peer's filesystem:
<pre xsmall { >
.../peer# GIT_REPO="github.com/hyperledger/fabric"
.../peer# GIT_REPO="${GIT_REPO}/examples/chaincode"
.../peer# GIT_REPO="${GIT_REPO}/go/chaincode_example02"
.../peer# peer chaincode install \
                 -n mycc -v 1.0 -p ${GIT_REPO}
</pre } >
       </li>
       <li>Instantiate chaincode on the channel,
           set endorsement policy for the chaincode,
           and launch a chaincode container for the targeted peer.
<pre xsmall { >
root@0d.../peer# peer chaincode \
    instantiate \
    -o orderer.example.com:7050 \
    --tls $CORE_PEER_TLS_ENABLED \ 
    --cafile ${CA_F} \
    -C $CHANNEL_NAME \
    -n mycc -v 1.0 \
    -c '{"Args":["init","a", "100", "b","200"]}' \
    -P "OR ('Org1MSP.member','Org2MSP.member')" 

# Note: -(P)olicy: <a href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">required endorsement level</a>
#                 for TX against this chaincode 

</pre } >
     </ol>
     <span xbig>Query and invoque</span><br/>
     <ol>
       <li>Query for the value of a to make sure the chaincode was properly instantiated and the state DB was populated.
<pre xsmall { >
root@0d.../peer# peer chaincode query \
          -C $CHANNEL_NAME -n mycc \
          -c '{"Args":["query","a"]}'
</pre } >
       </li>Let’s move 10 from a to b:
<pre xxsmall { >
root@0d.../peer# peer chaincode invoke \
    -o orderer.example.com:7050  \
    --tls $CORE_PEER_TLS_ENABLED \
    --cafile ${CA_F} \
    -C $CHANNEL_NAME -n mycc \
    -c '{"Args":["invoke","a","b","10"]}'
</pre } >
       </li>
     </ol>
  </td>
  <td col2 colspan=2 >
REF: <a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-cli.yaml'>docker-compose-cli.yaml</a>
<pre xxsmall { >
...
services:
  orderer.${DOMAIN}:
    container_name: orderer.${DOMAIN}
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.${DOMAIN}
...
  peer0.${ORG1}.${DOMAIN}:
  (same for  peer1.${ORG1}.${DOMAIN})
  (same for  peer0.${ORG2}.${DOMAIN})
    container_name: peer0.${ORG1}.${DOMAIN}
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.${ORG1}.${DOMAIN}

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    ...
    volumes:
        ...
        - ./crypto-config     :.../peer/crypto/
        - ./channel-artifacts :.../channel-artifacts
    depends_on:
      - orderer.${DOMAIN}
      - peer0.${ORG1}.${DOMAIN}
      - ...
</pre }>

<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-couch.yaml'>docker-compose-couch.yaml</a>
<pre xsmall { >
...
services:
  couchdb0:
    # (same for couchdb1/2/3 changing
    #  ports - 6984, 7984)
    container_name: couchdb0
    image: hyperledger/fabric-couchdb
    environment:
      - COUCHDB_USER=...
      - COUCHDB_PASSWORD=...
    ports:
      - "5984:5984"
    networks:
      - byfn

  peer0.org1.example.com:
    # (same for peer0/1, org1/2)
    ...
    depends_on:
      - couchdb0
</pre }>

  </td>  
</tr }>


</table>



<table>
<tr header_delimit } {> 
  <td colspan=12 >
    <a href='https://github.com/hyperledger/fabric-samples/tree/release/fabcar'>Ex. FabCar</a>
  </td>
</tr>
<tr {>
  <td col0 >
    <a href='https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go' xbig>fabric-samples fabcar.go</a> (Summary Error checks removed)
    <pre xxsmall { >
// structures
type Car struct {                   type SmartContract struct { }

    Make   string `json:"make"`
    Model  string `json:"model"`
    Colour string `json:"colour"`
    Owner  string `json:"owner"`
}

func (s *SmartContract)
     initLedger(
       APIstub shim.ChaincodeStubInterface)
         sc.Response {
    cars := []Car{ // ledger initialization outside Init
        Car{
          Make: "Toyota", Model: "Prius",
          Colour: "blue", Owner: "Tomoko"},
        Car{Make: "Ford", Model: "Mustang",
          Colour: "red", Owner: "Brad"},
        ...  }

    i := 0 ; for i &lt; len(cars) {
        carAsBytes, _ := json.Marshal(cars[i])
        APIstub.PutState
           ("CAR"+strconv.Itoa(i), carAsBytes)
        fmt.Println("Added", cars[i])
        i = i + 1
    }
    return shim.Success(nil)
}

// called when instantiated by the blockchain network
func (s *SmartContract) 
    Init(APIstub shim.ChaincodeStubInterface) 
    sc.Response {
    return shim.Success(nil)
}

/* called as a result of application request to
   run the Smart Contract "fabcar" */
func (s *SmartContract)
    Invoke(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    // Retrieve the requested Smart Contract func.+args.
    function, args := APIstub.GetFunctionAndParameters()
    if function == "queryCar" {
        return s.queryCar(APIstub, args)
    } else if function == "initLedger" {
        return s.initLedger(APIstub)
    } else if function == "createCar" {
        return s.createCar(APIstub, args)
    } else if function == "queryAllCars" {
        return s.queryAllCars(APIstub)
    } else if function == "changeCarOwner" {
        return s.changeCarOwner(APIstub, args)
    }
}

func (s *SmartContract) 
    queryCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    return shim.Success(carAsBytes)
}

func (s *SmartContract) 
    createCar(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    var car = Car{Make: args[1], Model: args[2],
                  Colour: args[3], Owner: args[4]}
    carAsBytes, _ := json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}

func (s *SmartContract) 
    queryAllCars(
      APIstub shim.ChaincodeStubInterface)
        sc.Response {
    startKey := "CAR0"
    endKey := "CAR999"
    resultsIterator, err := 
       APIstub.GetStateByRange(startKey, endKey)
    defer resultsIterator.Close()
    
    var buffer /* JSON array */ bytes.Buffer
    buffer.WriteString("[")
    for resultsIterator.HasNext() {
        queryResponse, err := resultsIterator.Next()
        ...
        buffer.WriteString("{\"Key\":")
        buffer.WriteString("\"")
        ...
    }
    ...
    return shim.Success(buffer.Bytes())
}

func (s *SmartContract)
    changeCarOwner(
      APIstub shim.ChaincodeStubInterface, args []string)
        sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    car := Car{}
    json.Unmarshal(carAsBytes, &amp;car)
    car.Owner = args[1]
    carAsBytes, _ = json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}


func main /* testing purposes*/() {
    // Create new Contract
    err := shim.Start(new(SmartContract))
}
</pre } >
  </td>
  <td col1 >
         <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/query.js' xbig>fabcar query.js</a> (errors and async code removed)
<pre xxsmall { >
var hfc = require('fabric-client');
var path = require('path');
var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    network_url: 'grpc://localhost:7051',
};

var client = new hfc(); // create client
wallet = hfc.newDefaultKeyValueStore(
    { path: options.wallet_path });
client.setStateStore(wallet); // Set wallet path
// associate user to app
user = client.getUserContext(options.user_id, true);
var channel = client.newChannel(options.channel_id);
channel.addPeer(client.newPeer(options.network_url));
// make query
var transaction_id = client.newTransactionID();
const request = {
  chaincodeId: options.chaincode_id,
  txId: transaction_id,
  fcn: 'queryAllCars', args: [''] };
query_responses = channel.queryByChaincode(request);
// console.log("count = ", query_responses.length)
if (query_responses[0] instanceof Error) {
  console.error("error from query = ", query_responses[0]);
}
console.log("Response: ", query_responses[0].toString());
</pre } >
  </td>  
  <td col2  >
         <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/invoke.js' xbig>fabcar invoke.js</a> (errors removed)
    <pre xxsmall { >
var hfc = require('fabric-client');
var path = require('path');
var util = require('util');

var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    peer_url: 'grpc://localhost:7051',
    event_url: 'grpc://localhost:7053',
    orderer_url: 'grpc://localhost:7050'
};

var client = null;
var targets = [];
console.log("Create a client and set the wallet location");
client = new hfc();
var wallet = hfc.newDefaultKeyValueStore({ path: options.wallet_path });
console.log("Set wallet path, and associate user ", 
          options.user_id, " with application");
client.setStateStore(wallet);
var user = client.getUserContext(options.user_id, true);
console.log("Check user is enrolled, and set a query URL 
         in the network");
var channel = client.newChannel(options.channel_id);
var peerObj = client.newPeer(options.peer_url);
channel.addPeer(peerObj);
channel.addOrderer(client.newOrderer(options.orderer_url));
targets.push(peerObj);
var tx_id = client.newTransactionID();
console.log("Assigning transaction_id: ", tx_id._transaction_id);
// createCar - requires 5 args, ex: args:
// ['CAR11', 'Honda', 'Accord', 'Black', 'Tom'],
// changeCarOwner - requires 2 args , ex: args: ['CAR10', 'Barry'],
// send proposal to endorser
var request = {
    targets: targets,
    chaincodeId: options.chaincode_id,
    fcn: 'createCar',
    args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
    chainId: options.channel_id,
    txId: tx_id
};
var results = channel.sendTransactionProposal(request);
var proposalResponses = results[0];
var proposal = results[1];
var header = results[2];
let isProposalGood = false;
console.log(util.format(
    'Successfully sent Proposal and received'
  + ' ProposalResponse: Status - %s, message - "%s",'
  + ' metadata - "%s",' 
  + ' endorsement signature: %s',
    proposalResponses[0].response.status,
    proposalResponses[0].response.message,
    proposalResponses[0].response.payload,
    proposalResponses[0].endorsement.signature));
var request = {
    proposalResponses: proposalResponses,
    proposal: proposal,
    header: header
};
// set the transaction listener and 30sec timeout 
// if the TX did not get committed within timeout
// fail the test
var transactionID = tx_id.getTransactionID();
var eventPromises = [];
let eh = client.newEventHub();
eh.setPeerAddr(options.event_url);
eh.connect();

let txPromise = new Promise((resolve, reject) => 
{
  let handle = setTimeout(() => {
    eh.disconnect(); reject(); }, 30000);
  eh.registerTxEvent(transactionID, (tx, code) => {
    clearTimeout(handle);
    eh.unregisterTxEvent(transactionID);
    eh.disconnect();
    if (code === 'VALID') {
        console.log(
            'TX has been committed on peer ' +
            eh._ep._endpoint.addr);
        resolve();
    }
  });
});
eventPromises.push(txPromise);
var sendPromise = channel.sendTransaction(request);
var results = sendPromise.concat(eventPromises)) 
    console.log('event promise all '
    + ' complete and testing complete');
var response = results[0]; // 1st returned value is from
                   // 'sendPromise' which is from
                   // 'sendTransaction()' call
if (response.status === 'SUCCESS') {
    console.log('Successfully sent TX to orderer.');
    return tx_id.getTransactionID();
}
</pre } >
  </td>
</tr }>

</table>

<hr/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

<table>
<tr header_delimit {> <td colspan=12 >ARCHITECTURE</td> </tr>
<tr {>
  <td col0 colspan=4 >
     <span xbig><a href="https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html">Ledger</a></span>
     <ul xxsmall>
       <li>The ledger is the sequenced, tamper-resistant record of all state transitions. State transitions are a result of chaincode invocations (‘transactions’) submitted by participating parties. Each transaction results in a set of asset key-value pairs that are committed to the ledger as creates, updates, or deletes.

The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in blocks, as well as a state database to maintain current state. There is one ledger per channel. Each peer maintains a copy of the ledger for each channel of which they are a member. </li>
       <li>The chain is a transaction log, structured as hash-linked blocks, where each block contains a sequence of N transactions. The block header includes a hash of the block’s transactions, as well as a hash of the prior block’s header. In this way, all transactions on the ledger are sequenced and cryptographically linked together. In other words, it is not possible to tamper with the ledger data, without breaking the hash links. The hash of the latest block represents every transaction that has come before, making it possible to ensure that all peers are in a consistent and trusted state.</li>
       <li>The ledger’s current state data represents the latest values for all keys ever included in the chain transaction log. Since current state represents all latest key values known to the channel, it is sometimes referred to as World State.</li>
       <li>State database options:
         <ul>
           <li>LevelDB: default key/value state database embedded in the peer process</li>
           <li>CouchDB: optional alternative external state database, uses a JSON document store, enabling rich query against the chaincode data (when chaincode values like assets are modeled as JSON data)</li>
           <li> It is a good practice to model chaincode asset data as JSON, so that you have the option to perform complex rich queries if needed in the future.</li>
         <ul>
       </li>
     </ul>
  </td>
  <td col1  colspan=4 >
    <a xbig TODO href='https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html'>CouchDB configuration</a></li>
    <a xbig TODO href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html" xbig>Gossip data dissemination protocol</a></span> <br/>
    <a xbig TODO href="https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html">Bringing up a Kafka-based Ordering Service</a></span>:The purpose of this guide is to identify the steps you need to take so as to have a set of Hyperledger Fabric ordering service nodes (OSNs) use your Kafka cluster and provide an ordering service to your blockchain network. </a><br/>
 </ul>
  </td>  
  <td col2  colspan=4  >
     <a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html" xbig>Read-Write set semantics</a>
     <ul xxsmall>
       <li>
         <pre xxsmall { >
TX simulation:  read set + write set are prepared
read  set [("key", "value in" , "version"   )] -> TX -> [("key", "value out", "version++" )] 
 * "value out" or isDelete=true

Example:
consider a set of five ordered transactions 
   (T1 ->, T2 -> T3 -> T4 -> T5)
simulated on the same snapshot of the world state:
    
Initial state: 
   [/* key value  version */
     ( k1 ,  1  ,    1   ),
     ( k2 ,  2  ,    2   ),
     ( k3 ,  3  ,    3   ),
     ( k4 ,  4  ,    4   ),
     ( k5 ,  5  ,    5   )]
-----------------------------------------
T1 -> Write k1 -> (k1,2,v1')
      Write k2 -> (k2,2,v2')
   Result:
     validation OK (no reads)
-----------------------------------------
T2 -> Read(k1,1,v1)
      Write k3 -> (k3,3,v3')
   Result:
     validation ERROR  (reads k1 version1 < current version 2')
-----------------------------------------
T3 -> Write  k2 -> (k2, v2'')
   Result:
     validation OK (no reads)
     k2 updated to (k2,3,v2'')
-----------------------------------------
T4 -> Write(k2, v2'''), read(k2)
   Result:
     validation ERROR  (reads k2 v1 &lt; current v2'')
-----------------------------------------
T5 -> Write k6 -> (k6, v6')
      read(k5)
   Result:
     validation OK (k5,v1 still in version v1 )
-----------------------------------------

Note: Transactions with multiple read-write sets are not yet supported.
</pre } >
       </li>
     </ul>
  </td>
</tr }>
</tr }>

</table>


<table>
<tr header_delimit } {> <td colspan=12 >NodeJS SDK</td> </tr>
<tr {>
  <td col0 >
    <span xbig><a href='https://fabric-sdk-node.github.io/'>Fabric SDK</a></span>
    <p>NodeJS APIs are available to:</p>
    <ul xxsmall >
      <li>create <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">channels</a></li>
      <li>ask <a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#peer">peer nodes</a> to join the channel</li>
      <li>install <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode">chaincodes</a> in peers using the consensus process (can be preinstalled in setup scripts)</li>
      <li>instantiate chaincodes in a channel</li>
      <li>invoke transactions by calling the chaincode</li>
      <li>
          Query the <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">ledger</a> for transactions or blocks<br/>
      </li>
      <li TODO >receive ledger updates</li>
    </ul>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
</tr }>
</table>

<table>
<tr header_delimit } {> <td colspan=12 >JAVA</td> </tr>
<tr {>
  <td col0 >
    <span xbig><a href='https://github.com/hyperledger/fabric-sdk-java'>JAVA SDK</a></span>
  </td>
  <td col1>
  </td>  
  <td col2>
  </td>
</tr }>
</table>

<table>
<tr header_delimit } {> <td colspan=12 ><a href='https://hyperledger.github.io/composer/stable/index.html'>COMPOSER</a></td> </tr>
<tr {>
  <td col0 >
     <ul xxsmall>
     <li><a href='https://composer-playground.mybluemix.net/'>On-oline playground</a></li>
     <li><a href='https://hyperledger.github.io/composer/installing/development-tools.html'>Installing</a></li>
     <li><a href='https://hyperledger.github.io/composer/tutorials/tutorials.html'>
           Playgorund, Developer, Queries Tutorials, deploying to a single/multiple org. in Fabric</a></li>
     </ul>
     Development toolset and framework to develop blockchain apps (model, gui, roles, ...).<br/>
     Composer enables to quickly create business logic running on the blockchain + REST APIs

     <a href='https://hyperledger.github.io/composer/introduction/introduction.html'>REF: introduction</a><br/>
     <span xbig>Businness Networks core concepts</span>
     <ul xxsmall>
       <li>
<pre xxsmall { >
 INPUT             OUTPUT
┌──────────────┐   ┌───────────────────────┐
│* .cto        │   │Business Network       │
│- Assets      │   │Archive *.bna          │
│- Participants│   │(Package-up input ready│
│- Transactions│   │ to deploy "somewhere")│
├──────────────┤   └───────────────────────┘
│*.js          │
│- Transaction │
│  Functions   │
├──────────────┤
│*.acl         │
│- Access      │
│  Control     │
├──────────────┤
│*.qry         │
│- Query defini│
│  rules       │
└──────────────┘
</pre } >
       </li>
     </ul>
  </td>
  <td col1>
       models/sample.cto
<pre xxsmall { >
namespace org.acme.sample

participant SampleParticipant identified by participantId
{
  o String participantId
  o String firstName
  o String lastName
}

asset SampleAsset identified by assetId {
  o String assetId
  --> SampleParticipant owner
  o String value
}

transaction SampleTransaction {
   --> SampleAsset asset
   o String newValue
}

event SampleEvent {
  --> SampleAsset asset
  o String oldValue
  o String newValue
}
</pre } >

  </td>  
  <td col2>lib/sample.js
<pre xxsmall { >
function sampleTransaction(tx) {
  var oldValue = tx.asset.value;

  tx.asset.value = tx.newValue;

  return getAsetRegistry('org.acme.sample.SampleAsset')
    .then(function (assetRegsitry) {
           return assetRegistry.update(tx.asset);
     })
    .then(function () {
       var event = getFactory().newEvent('org.acme.sample',
          'SampleEvent');
       event.asset = tx.asset;
       event.oldValue = oldValue;
       event.newValue = tx.newValue;
       emit(event);
    });
}
</pre } >


permissions.acl
<pre xxsmall { >
rule EverybodyCanReadEverything {
  description: "Allow all participants read access to all resources"
  participant: "org.acme.sample.SampleParticipant"
  opeartion: READ
  resource: "org.acme.sample.*"
  action: ALLOW
}

rule EverybodyCanSubmitTransactions {
  description: "Allow all participants to submit TXs"
  participant: "org.acme.sample.SampleParticipant"
  operation: CREATE
  resource: "org.acme.sample.SampleTransaction"
  action: ALLOW
}

rule OwnerhasFullAccessToTherAssets {
  description: "full access to participants assets"
  participant: "org.acme.sample.SampleParticipant"
  operation: ALL
  resource(r): "org.acme.sample.SampleTransaction"
  condition: (r.owner.getIdentifier() === p.getIdentifier())
  action: ALLOW
}

rule SystemACL {
  description: "System ACL to permit all access"
  participant: "org.hyperledger.composer.system.Participant"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}

rule NetworkAdminSsytem {
  description: "full access for network admins. to sys.res."
  participant: "org.hyperledger.composer.system.NetworkAdmin"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}
</pre } >
  </td>
</tr }>
</table>

<table>
<tr {>
  <td col0 >
     <ul>
       <li>(PLUGGABLE) EXECUTION RUNTIMES
         <ul xxsmall>
           <li>Hyperledger Fabric version 1.0.
     State is stored on the distributed ledger.</li>
           <li>Web, which executes within a web page, and is used by Playground.
     State is stored in browser local storage.</li>
           <li>Embedded, which executes within a Node.js process, 
     used primarily for unit testing business logic.
     State is stored in an in-memory key-value store.</li>
         </ul>
       </li>
       <li>CONNECTION PROFILES
         <ul xxsmall>
           <li>Used across Hyperledger Composer to specify how
    to connect to an execution runtime.</li>
           <li>There are different configuration options for each type 
    of execution runtime. For example, the profile for 
    an Hyperledger Fabric version 1.0 runtime will contain 
    the TCP/IP addresses and ports for the Fabric peers,
    as well as cryptographic certificates etc.</li>
           <li>Connection Profiles are referred to by name (in both code 
    and on the command line) and the connection profile documents
    (in JSON format) are resolved from the user's home directory.</li>
         </ul>
       </li>
       <li>JAVASCRIPT SDK is a set of Node.js APIs the enables developers to
    create applications to manage and interact with deployed business nets.
  - APIs are split between two npm modules:
         <ul xxsmall>
           <li>COMPOSER-CLIENT: 
    - submits TXs to a network, CRUD opts on assets and participants
    - installed as local dependency for app.
    - When in production this is only module that needs to be added
      as a direct dependency of the application.</li>
           <li>COMPOSER-ADMIN:
    - manages business networks (creation/deploy, undeploy)
    - installed as a local dependency of admin. apps</li>
         </ul>
       </li>
       <li>REST SERVER: automatically generates a Open API (Swagger) REST API 
    At runtime implements CRUD support for assets/participants 
    and allows TXs to be submitted for processing or retrieved.
       </li>
       <li>LOOPBACK CONNECTOR
         <ul xxsmall>
           <li>Used by the Composer REST Server</li>
           <li>It may also be used standalone by integration tools that
             support LoopBack natively.</li>
           <li>Can also be used with the LoopBack tools to create more
             sophisticated customizations of the REST APIs.</li>
         </ul>
       </li>
       <li>PLAYGROUND WEB USER INTERFACE
         <ul xxsmall >
           <li>GUI to define and test business networks.</li>
           <li>Allows business analyst to quickly import samples and
    prototype business logic that executes on the Web or
    Hyperledger Fabric runtime.</li>
         </ul>
       </li>
       <li>YEOMAN CODE GENERATORS to create skeleton projects:
         <ul xxsmall>
           <li> Angular web application  </li>
           <li> Node.js application      </li>
           <li> Skeleton business network</li>
         </ul>
       </li>
     </ul>
  </td>
  <td col1 >
    <ul xxsmall >
       <li>BLOCKCHAIN STATE STORAGE:
             Blockchain ledger:  stores all TXs submitted through a business network
             Blockchain state database: current state of assets and participants 
       </li>
       <li>CONNECTION PROFILES:
  - Used to connect to a runtime.
  - JSON document @ user's home directory (or ENV.VAR)  and referenced
    by name when using the Composer APIs or the Command Line tools.
  - C.P. ensures that code and scripts are easily portable from one 
    runtime instance to another. 
       </li>
       <li>ASSETS:
  - Anything that can be owned by someone.
  - Assets MUST HAVE a unique identifier.
  - Assets may be related to other assets or participants.
       </li>
       <li>PARTICIPANTS:<br/>
  - members of a business network.<br/>
  - They may own assets and submit transactions.<br/>
  - Participant MUST HAVE an identifier.<br/>
       </li>
       <li>IDENTITIES AND ID CARDS:<br/>
  - Participants can be associated with an identity.<br/>
  - ID cards are a combination of : <br/>
    - identity<br/>
    - connection profile<br/>
    - metadata.<br/>
  - ID cards simplify the process of connecting to business network
    and extend the concept of an identity outside the B.N. to a<br/>
    'wallet' of identities, each associated with a specific business
    network and connection profile.<br/>
       </li>
       <li>TRANSACTIONS<br/>
  - mechanism by which participants interact with assets.<br/>
       </li>
       <li>QUERIES<br/>
  - used to return data about the blockchain world-state.<br/>
  - Queries are defined within a business network, and can include
    variable parameters for simple customization. By using queries,
    data can be easily extracted from your blockchain network.<br/>
  - Queries are sent by using the Hyperledger Composer API.
       </li>
       <li>EVENTS:<br/>
  - Defined in the business network definition in the same way as assets or participants.<br/>
  - Once events have been defined, they can be emitted by transaction processor functions
    to indicate to external systems that something of importance has happened to the ledger.<br/>
  - Applications can subscribe to emitted events through the composer-client API.
       </li>
       <li>ACCESS CONTROL RULES<br/>
  - fine-grained control over what participants have access to what assets
    in the business network and under what conditions.<br/>
  - Access control language is rich enough to capture sophisticated conditions
    declaratively, such as "only the owner of a vehicle can transfer
    ownership of the vehicle".<br/>
  - Externalizing ACR from TX processor logic makes it easier to inspect,
    debug, develop and maintain.<br/>
       </li>
       <li>HISTORIAN REGISTRY<br/>
  - Specialised registry which records successful transactions,
    including the participants and identities that submitted them.<br/>
  - TXs are stored as HistorianRecord assets, are defined in the
    Hyperledger Composer system namespace.<br/>
       </li>
    </ul>
  </td>  
  <td col2  >
  </td>
</tr }>
</table>


</body>
<!--
TODO: support for cross-chaincode transactions (post-v1 feature)

_________________________________
<a href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>2.1.1. PROPOSE message format</a>

<p>The format of a PROPOSE message is &lt;PROPOSE,tx,[anchor]&gt; , where
tx is a mandatory and anchor optional argument explained in the following.</p>

tx=&lt;clientID,chaincodeID,txPayload,timestamp,clientSig&gt;, where
<ul>
  <li>clientID is an ID of the submitting client,</li>
  <li>chaincodeID refers to the chaincode to which the transaction pertains,</li>
  <li>txPayload is the payload containing the submitted transaction itself,</li>
  <li>timestamp is a monotonically increasing (for every new transaction) 
      integer maintained by the client,</li>
  <li>clientSig is signature of a client on other fields of tx</li>
</ul>

<p>The details of txPayload will differ between invoke transactions
and deploy transactions (i.e., invoke transactions referring to a
deploy-specific system chaincode). For an invoke-transaction,
txPayload would consist of two fields</p>

<ul>
   <li>txPayload=&lt;operation,metadata&gt;, where<ul>
   <li>operation denotes the chaincode operation (function) and arguments,</li>
   <li>metadata denotes attributes related to the invocation.</li>
</ul>

<p>For a <strong>deploy transaction</strong>, txPayload would consist of three fields</p>
<ul>
  <li>txPayload = &lt;source, metadata, policies&gt; where<ul>
  <li>source denotes the source code of the chaincode,</li>
  <li>metadata denotes attributes related to the chaincode and
  application,</li>
  <li>policies contains policies related to the chaincode that
      are accessible to all peers, such as the endorsement policy.
      Note that endorsement policies are not supplied with
      deploy transaction, but
      deploy contains endorsement policy ID and
      its parameters (see Section 3).</li>
</ul>

<ul>
<li>anchor contains read-version-dependencies, or more
   specifically, key-version pairs (i.e., anchor is a subset of
   PROPOSE request to specified versions of keys in a KVS (see Section 1.2.). 
   If the client specifies the anchor argument, an endorser endorses a transaction
   only upon <em>read</em> version numbers of corresponding keys in its local
   KVS match anchor (see Section 2.2. for more details).
</li>
</ul>
<p>Cryptographic hash of tx is used by all nodes as a unique
transaction identifier tid=HASH(tx)). The client
stores tid in memory and waits for responses from endorsing peers.</p>
________________________________
VIDEO: What's new in Hyperledger Fabric 1.0: Nikolay Vlasov: FASSAIS Summit 2017: https://www.youtube.com/watch?v=6nGIptzBZis
Fabric Composer: Web GUI to develop Fabric apps. https://hyperledger.github.io/composer/
Video Tutorial: https://www.youtube.com/watch?v=fdFUsrsv5iw 
________________________________________
-->

</html>



