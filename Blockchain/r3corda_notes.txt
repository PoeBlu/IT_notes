REF: https://docs.corda.net/key-concepts.html

THE NETWORK {
  * A Corda network is made up of nodes running (JVM) Corda Services (Notary+,Oracle*, ...) and CorDapps
  * The network is permissioned, with access controlled by a doorman: Enforces rules regarding the infor. that nodes must provide and the KYC processes that they must complete before being admitted to the network.
  * Communication between nodes is point-to-point, instead of relying on global broadcasts with TLS-encrypted messages sent over AMQP/1.0. 
}

THE LEDGER {
  * The ledger is subjective from each peer's perspective. Each peer only sees a subset of facts on the ledger.
  * Two peers are always guaranteed to see the exact same version of any on-ledger facts they share.
}

STATES {
  * Can contain arbitrary data, allowing them to represent facts of any kind (stocks, bonds, loans, KYC data, identity information...).
  * Represent on-ledger facts
  * Evolve by marking the current state as historic and creating an updated state
  * Each node has a vault where it stores any relevant states to itself
  * Each node on the network maintains a vault: a database where it tracks all the current and historic states that it is aware of, and which it considers to be relevant to itself
}

CONTRACTS {
  * A valid transaction must be accepted by the contract of each of its input and output states
  * Contracts are written in a JVM programming language (e.g. Java or Kotlin)
  * Contract execution is deterministic and its acceptance of a transaction is based on the transaction's contents alone. A contract should either always accept or always reject a given transaction. Can not depend on the validation date or other contextual info.
}

TRANSACTION {
   * Transactions are proposals to update the ledger
   * A transaction proposal will only be committed if: 
     {
      - It doesn't contain double-spends
      - It is contractually valid
        {
         - Each state points to a contract
         - A contract takes a transaction as input, and states 
           whether the transaction is considered valid based on the contract’s rules
         - A transaction is only valid if the contract of every
           input state and every output state considers it to be valid
        }

      - It is signed by the required parties
     }
   * A transaction can contain any number of inputs and outputs of any type:
     - They can include many different state types (e.g. both cash and bonds)
     - They can be issuances (have zero inputs) or exits (have zero outputs)
     - They can merge or split fungible assets (e.g. combining a $2 state and a $5 state into a $7 cash state)
   * There are two basic types of transactions:
     - Notary-change transactions (used to change a state’s notary - see Notaries)
     - General transactions (used for everything else)

   * TX input states references are a combination of:
     - The hash of the transaction that created the input
     - The input’s index in the outputs of the previous transaction

   * - Initially, a transaction is just a proposal to update the ledger.
       representing the future state of the ledger desired by the 
       transaction builder(s): 
     - To become reality, the transaction must receive signatures from 
       all of the required signers.
     - Once all the required signatures are gathered, the transaction 
       becomes committed meaning:
       - TX’s inputs are marked as historic, and cannot be used anymore
       - TX’s outputs become part of the current state of the ledger
   * TX commands: Including a command in a transaction allows us to
      indicate the transaction’s intent, affecting how we check the
      validity of the transaction.
     - Each command is also associated with a list of one or more signers.
       By taking the union of all the public keys listed in the commands, 
       we get the list of the transaction’s required signers.  
   * ATTACHMENTS: Each TX can refer to zero or more attachments by hash.
     These attachments are ZIP/JAR files containing arbitrary content.

   * TIME-WINDOWS: specify the time window during which the transaction 
     can be committed
}

FLOWS {
    * Flows automate the process of agreeing ledger updates
    * Communication between nodes only occurs in the context of these flows,
      and is point-to-point
    * Built-in flows are provided to automate common tasks
    * Represents a sequence of steps that tells a node how to 
      achieve a specific ledger update, such as issuing an asset
      or settling a trade
    * Once a given business process has been encapsulated in a flow 
      and installed on the node as part of a CorDapp, the node's
      owner can instruct the node to kick off this business process 
      at any time using an RPC call. The flow abstracts all the
      networking, I/O and concurrency issues away from the node owner.
    * Flows may last days, across node restarts and even upgrades.
}

CONSENSUS {
    * To be committed, transactions must achieve both validity and 
      uniqueness consensus
    * Validity consensus requires contractual validity of the 
      transaction and all its dependencies
    * Uniqueness consensus prevents double-spends. 
      This consensus is provided by notaries.
}

NOTARIES {
    * Notaries prevent "double-spends"
    * Notaries may optionally also validate transactions
    * A network can have several notaries, each running a different
      consensus algorithm
    * notaries may differ in terms of 
      {
      - Structure: a notary may be a single network node, a cluster of mutually-trusting nodes, or a cluster of mutually-distrusting nodes
      - Consensus algorithm: a notary service may choose to run a high-speed, high-trust algorithm such as RAFT, a low-speed, low-trust algorithm such as BFT, or any other consensus algorithm it chooses
       }
    * A notary also act as the timestamping authority,
}

TIME-WINDOWS {
   * If a transaction includes a time-window, it can only be committed during that window
   * The notary is the timestamping authority, refusing to commit transactions outside of that window
   * Time-windows can have a start and end time, or be open at either end allowing all of the following situations to be modelled:
     -A TX occurring at some point after the given time (e.g. after a maturity event)
     -A TX occurring at any time before the given time (e.g. before a bankruptcy event)
     -A TX occurring at some point roughly around the given time (e.g. on a specific day)
}

ORACLES {
   * A fact can be included in a TX as part of a command
   * An oracle is a (network) service that will only sign the TX if the included fact is true
   * Upon request, an oracle provide commands that encapsulate a specific fact
     (e.g, the exchange rate at time x) and list the oracle as a required signer.
}

NODES {
  * A node is JVM run-time with a unique network identity running the Corda software

  * The node has two interfaces with the outside world:
    - A network layer, for interacting with other nodes
    - RPC, for interacting with the node's owner

  * The node's functionality is extended by installing CorDapps in the plugin registry

  * The core elements of the architecture are 
    - A persistence layer for storing data It has two parts:
      - The vault, where the node stores any relevant current and historic states
      - The storage service, where it stores transactions, attachments and flow checkpoints
    - A network interface for interacting with other nodes (as part of a running flow).
      Node's owner doesn't interact with other network nodes directly.
    - An RPC interface for interacting with the node's owner
    - A service hub for allowing the node's flows to call upon the node's other services
      - Information on other nodes on the network and the services they offer
      - Access to the contents of the vault and the storage service
      - Access to, and generation of, the node’s public-private keypairs
      - Information about the node itself
      - The current time, as tracked by the node
    - A plugin registry for extending the node by installing CorDapps
      The node also has several plugins installed by default to handle common tasks such as:
      - Retrieving transactions and attachments from counterparties
      - Upgrading contracts
      - Broadcasting agreed ledger updates for recording by counterparties
}

BUILDING A CORDAPP [
  * CorDapps are installed at the level of the individual node, rather than on the network itself.
  * CorDapp developers will usually define:
    - States     implementing <<ContractState>>
    - Contracts  implementing <<Contract>>
    - Flows      implementing <<FlowLogic>>
    - Web APIs
    - Services
  * JAVA   TEMPLATE: https://github.com/corda/cordapp-template-java
  * KOTLIN TEMPLATE: https://github.com/corda/cordapp-template-kotlin 
  * Your CorDapp may need to define two types of plugins:
    - CordaPluginRegistry subclasses that can overwrite:
        - customizeSerialization: set of the classes       to be whitelisted for object serialisation
        - requiredSchemas       : set of the MappedSchemas to use for persistence and vault queries
      - must be added also to resources/META-INF/services/net.corda.core.node.CordaPluginRegistry
    - WebServerPluginRegistry subclasses, that can overwrite:
    - webApis        : list of JAX-RS annotated REST access classes.
    - staticServeDirs: map of static web content to virtual paths 
      (The static web content itself should be placed inside src/main/resources)
      must be added also to resources/META-INF/services/net.corda.webserver.services.WebServerPluginRegistry

API {
  States
  {
  }
  Persistence
  {
  }
  Contracts
  {
  }
  Vault Query
  {
  }
  Transactions
  {
  }
  Flows
  {
  }
  Core types
  {
  }
}
]


DEMOS {
    https://docs.corda.net/running-the-demos.html#irs-demo
    https://docs.corda.net/running-the-demos.html#simm-demo
}


src
├── main
│   ├── java
│   │   └── com
│   │       └── template
│   │           ├── Main.java
│   │           ├── api
│   │           │   └── TemplateApi.java
│   │           ├── client
│   │           │   └── TemplateClientRPC.java
│   │           ├── contract
│   │           │   └── TemplateContract.java
│   │           ├── flow
│   │           │   └── TemplateFlow.java
│   │           ├── plugin
│   │           │   └── TemplatePlugin.java
│   │           ├── service
│   │           │   └── TemplateService.java
│   │           └── state
│   │               └── TemplateState.java
│   └── resources
│       ├── META-INF
│       │   └── services
│       │       ├── net.corda.core.node.CordaPluginRegistry
│       │       └── net.corda.webserver.services.WebServerPluginRegistry
│       ├── certificates
│       │   ├── sslkeystore.jks
│       │   └── truststore.jks
│       └──templateWeb
│           ├── index.html
│           └── js
│               └── template-js.js
└── test
    └── java
        └── com
            └── template
                └── contract
                    └── TemplateTests.java

@CordaSerializable
interface ContractState {
    val contract: Contract
    val participants: List<AbstractParty>
}
Every ContractState can implement the QueryableState interface if it wishes to be inserted into the node’s local database and accessible using SQL.

interface QueryableState : ContractState {
    fun supportedSchemas(): Iterable<MappedSchema>
    fun generateMappedObject(schema: MappedSchema): PersistentState
}

Nodes have an internal SchemaService which decides what to persist and what not by selecting the MappedSchema to use.

interface SchemaService {
    data class SchemaOptions(val databaseSchema: String? = null, val tablePrefix: String? = null)    
    val schemaOptions: Map<MappedSchema, SchemaOptions>
    fun selectSchemas(state: ContractState): Iterable<MappedSchema>
    fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState
}

open class MappedSchema(schemaFamily: Class<*>,
                        val version: Int,
                        val mappedTypes: Iterable<Class<*>>) {
    val name: String = schemaFamily.name
    override fun toString(): String = "${this.javaClass.simpleName}(name=$name, version=$version)"
}

All Corda contracts are JVM classes th implement the next net.corda.core.contracts.Contract interface:
@CordaSerializable
interface Contract {
    @Throws(IllegalArgumentException::class)
    fun verify(tx: LedgerTransaction)

    val legalContractReference: SecureHash
}


@CordaSerializable
class LedgerTransaction(
     override val inputs: List<StateAndRef<*>>,
     outputs: List<TransactionState<ContractState>>,
     /** Arbitrary data passed to the program of each input state. */
     // NOTE: AuthenticatedObject pairs a command with a list of signers. 
     val commands: List<AuthenticatedObject<CommandData>>,
     val attachments: List<Attachment>,
     override val id: SecureHash, // for original serialised-Wire-TX
     notary: Party?,
     signers: List<PublicKey>,
     timeWindow: TimeWindow?,
     type: TransactionType
) : BaseTransaction(inputs, outputs, notary, signers, type, timeWindow) {
    ...
}

requireThat-DSL Example (replacing throw IllegalArgumentException...):
   requireThat {
       "No inputs should be consumed @ Issue" using (tx.inputs.isEmpty())
       "Only one output state permitted"    using (tx.outputs.size == 1)
       val out = tx.outputs.single() as XState
       "sender == recipient not allowed"    using (out.sender != out.recipient)
       "All participants must be signers"   using (command.signers.containsAll(out.participants))
       "X's value must be >0 "              using (out.x.value > 0)
   }


   @CordaSerializable
   data class AuthenticatedObject<out T : Any>(
       val signers: List<PublicKey>,
       /** If any public keys were recognised, the looked up institutions are available here */
       val signingParties: List<Party>, // signer’s identities, if known
       val value: T // object being signed (a command, in this case)
   )

requireSingleCommand() helper method to extract commands:

   class XContract : Contract {
      interface Commands : CommandData {
          class Issue : TypeOnlyCommandData(), Commands
          class Transfer : TypeOnlyCommandData(), Commands
      }
  
      override fun verify(tx: LedgerTransaction) {
          val command = tx.commands.requireSingleCommand<Commands>()
  
          when (command.value) {
              is Commands.Issue -> {
                  // Issuance verification logic.
              }
              is Commands.Transfer -> {
                  // Transfer verification logic.
              }
          }
      }
  
      override val legalContractReference: SecureHash = SecureHash.sha256("X contract hash")
  }

There are four states the transaction can occupy:

    TransactionBuilder, a builder for a transaction in construction
    WireTransaction, an immutable transaction
    SignedTransaction, an immutable transaction with 1+ associated signatures
    LedgerTransaction, a transaction that can be checked for validity

val txBuilder: TransactionBuilder = TransactionBuilder(General, specificNotary)
