<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Ethereum Map (beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<table style='width:100%'{>
<tbody>
<tr>
<th></th>
<th colsep></th>
<th colspan=4 header_delimit>
  <a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">Ethereum VM</a>,
  <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Formal Spec</a>,
  <a href="https://github.com/ethereum/go-ethereum/tree/master/core/vm">Geth VM</a>
  </th>
</tr>
<tr>
<td>
  Who is Who
<pre xxxsmall zoom>
- Vitalik Buterin, Ethereum Original Creator.

- Raul Jordan, Prysmatic labs: Sharding Protocol 
  minimal sharding protocol implementation:
</pre>


</td>
<td>
  External Links
  <ul xxxsmall zoom>
  <li><a TODO href="https://github.com/ethereum/wiki/wiki/Design-Rationale">Design Rationale</a></li>
  <li><a href="https://theethereum.wiki/w/index.php/Main_Page">Ethereum Wiki</a></li>
  <li><a href="https://solidity.readthedocs.io/">Solidity</a></li>
  <li><a href="./EEA-TS-0001-0-v1.00-EEA-Enterprise-Ethereum-Specification-R1.pdf">EEA Client Specification</a></li>
  <li><a href="https://entethalliance.org/resources/">Enterprise Ethereum Alliance Resources</a></li>
  <li><a href="https://github.com/bkrem/awesome-solidity">Awesome Solidity</a>: Curated list of libraries,
     auditing/secuirity tools, dev tools, security tutorial links, ...
  </li>
  <li><a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">Awesome EVM</a></li>
  <li><a href="https://ethereum.stackexchange.com/users/87/afri">"Afri" Ethereum FAQ answers on Stackoverflow</a></li>
  </ul>
wei → ... ether → Units
<pre xxxsmall zoom>
wei                         :                                1 wei      <--- discussion around APIs ...
gwei(shannon|nanoether|nano):                    1.000.000.000 weis     <--- gas prices
szabo|microether|micro      :                            1.000 gweis
finney|milliether|milli     :                        1.000.000 gweis    <--- micropayments
ether                       :                    1.000.000.000 gweis    <--- main unit
kether(grand|einstein)      :                            1.000 ethers 
mether                      :                        1.000.000 ethers
gether                      :                    1.000.000.000 ethers
tether                      :                1.000.000.000.000 ethers
</pre>

<a href="https://en.wikipedia.org/wiki/Ethereum#Milestones">Pub. Network Versions</a>
<pre xxxsmall zoom>
Homestead → Metropolis → Serenity →

Homestead : January 2016, ~80% complete 
            block reward set to 5 ether

Metropolis Part 1,Byzantium     : "Ethereum" for the masses.
Metropolis Part 2,Constantinople: Planned. Lay the fundations of PoS(Casper consensus)
 
Serenity  : "last phase", one key principle: switch to proof of stake

<a href="https://www.trustnodes.com/2018/06/16/casper-sharding-merger-confirmed-constantinople-back-table">2018/06/17 Casper and sharding merger confirmed</a>

</pre>

</td>
<td colsep></td>
<td>
  Summary
<pre xxxsmall zoom>
- EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.
- Persistent storage is quite expensive.
- The Solidity compiler makes interesting choices in order to minimize gas usage.

- To interact with a Smart Contract, you send it raw bytes.
- It does some computation, possibly changing its own state, 
  and then sends you raw bytes in return. 
- Method calling does not actually exist. It is a collective 
  illusion created by the ABI.
- The ABI is specified like a low-level format, but in function
  it's more like a serialization format for a cross-language RPC framework.
- We could draw analogies between the architectural tiers of DApp and Web App:
  - The blockchain is like the backing database
  - A contract is like a web service
  - A transaction is like a request
  - ABI is the data-interchange format, like Protocol Buffer


 EVM Events:
 - In the wild, there are three main uses for event logs:
   - As ersatz return values, because a transaction does not record a method's return values.
   - As a kind of cheaper alternative data storage, as long as the contract does not need access to it.
   - Events that DApp clients can subscribe to.
 - Event logging map to EVM logging primitives.

event Deposit( address indexed _from, bytes32 indexed _id, uint _value);

 - limitations:
   - There may be at most 3 indexed parameters.
   - If the type of an indexed parameter is larger than 32 bytes, 
     only the KECCAK256 digest of the data is stored.
 -  EVM Log Primitives
   - log0, log1, ..., log4 EVM instructions.
 - The EVM logging facility uses different terminologies than Solidity:
   "topics": There may be up to 4 topics exactly 32 bytes each
            Solidity consumes one topic for the event's signature so only 3 are available
   "data"  : Payload of the event. It may be arbitrary number of bytes

 - Bloom filters are used to speed up search-by-topic


</pre>
  <hr xxxsmall />
  Ethereum Account
<pre xxxsmall zoom>
Account:
---------
address
wei balance
Map&lt;256b,256b> storage
</pre>
  <ul xxxsmall zoom>
  <li>There are two kinds of accounts in Ethereum which share the same address space:
    <ul>
    <li>External account : controlled by public-private key pairs (i.e. humans)<br/>
        account.address: determined from the public key</li>
    <li>contract accounts: controlled by the code stored together with the account. 
        account.address in a contract is determined at the time the contract is created derived from the nonce = function(creator address, num.transactions sent)</li>
    </ul>
  </li>
  <li>account.balance: can be modified by sending transactions that include Ethers.</li>
  <li>account.storage: Persistent memory area 
    <ul>
    <li>It is not possible to enumerate storage from within a contract </li>
    <li>It is comparatively costly to read and even more so, to modify storage</li>
    <li>A contract can neither read nor write to any storage apart from its own</li>
    </ul>
  </li>
  </ul>
</td>
<td>
  Message Calls
<pre xxxsmall zoom>
Message Calls
-------------
sender
target(can be==sender)
payload
ether
gas
return data
</pre>
  <ul xxxsmall zoom>
  <li>Contracts can user message calls to call other contracts or send Ether to
     non-contract accounts.<br/>
     Every transaction consists of a top-level message call which in turn can 
     create further message calls.<br/>
     Contracts can decide how much of its remaining gas should be sent with the
     inner message call and how much it wants to retain. If an out-of-gas 
     exception happens in the inner call (or any other exception), this will be
     signalled by an error value put onto the stack. In this case, only the gas
     sent together with the call is used up. In Solidity, the calling contract 
     causes a manual exception by default in such situations, so that exceptions
     "bubble up" the call stack.<br/>
     Calls depth is limited to 1024 (Loops must be used over recursive calls)<br/>
     After finished execution, contracts can return data stored at a 
     preallocated location in the caller’s memory.
  </li>
  <li>Delegatecall (See libraries): Special variant of a message call, is 
    identical to a message call apart from the fact that the code at the target
    address is executed in the context of the calling contract and msg.sender 
    and msg.value do not change their values.<br/>
    This means that a contract can dynamically load code from a different 
    address at runtime.<br/>
    Storage, current address and balance still refer to the calling contract, 
    only the code is taken from the called address.<br/>
    This makes it possible to implement the “library” feature in Solidity:
    Reusable library code that can be applied to a contract’s storage in order to e.g. implement a complex data structure.
  </li>
  </ul>
</td>  
<td>
  (EVM) Memory:
  <ul xxxsmall zoom>
  <li>A contract obtains a freshly cleared instance for each message call</li>
  <li>Memory is linear and can be addressed at byte level</li>
  <li>Reads are limited to a width of 256 bits</li>
  <li>Writes can be either 8 bits or 256 bits wide</li>
  <li>Memory is expanded by a word (256-bit), when accessing 
      (either reading or writing) a previously untouched memory word (ie.
      any offset within a word). At the time of expansion, the cost in gas 
      must be paid. Memory is more costly the larger it grows (it scales
      quadratically)
  </li>
  <li>calldata: Separate area of memory whe message call payload is placed</li>
  </ul>
  <hr/>
  (EVM) Stack:
  <ul xxxsmall zoom>
  <li>EVM memory area list of 256bits up to 1024 elements used for computations</li>
  <li>The 16 topmost elements can be moved to the top or swaped wih the top ele</li>
  <li>All other operations take the topmost one (or two, or more) elements and push the result onto the stack</li>
  <li>top elements can be moved to/from storage/memory, but deeper elements can
      be accessed without first removing elements on top of them.
  </li>
  <li>(EVM)full computational state: can be defined by the tuple:<br/>
    (block_state, transaction, message, code, memory, stack, pc, gas)
    block_state = global state = all accounts (balances + storage)
  </li>
  <li>selfdestruct(target): Destructor for contract @ address
    <ul>
    <li>Remaining Ethers are sent to target</li>
    <li>storage & code are removed from the blockchain state</li>
    </ul>
  </li>
  <hr/>
  <a href="https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go">(EVM) Instructions</a>
</td>  
</tr>
</table>

<table>
<tr>
<td>
  <b>Transactions</b>
<pre xxxsmall zoom>
Transaction
-------------
address sender
target
payload        "message" sent from src. account to a target (account or code)
wei ether

wei gasPrice
wei gas

return data


What are the v, r, s values for the TX's signature?
- r and s are outputs of an ECDSA signature
- v is the recovery id.
<a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">Bitcoin REF</a> 
  applies also to Ethereum. Ethereum makes further adjustments to v, as explained in 
<a href="https://github.com/ethereum/EIPs/issues/155">EIP 155</a>, to prevent replay attack.

</pre>
  <ul xxxsmall zoom>
  <li>Note that a TX in blockchain is an intention to modify the state of the ddbb.
    It's up to the consensus algorithm to decide when and/or whether the TX will
    be accepted</li>
  <li><code>transaction.target := address | code | "zero-account"</code>
<pre {>
if target == code 
   => code is executed
      input data = transaction.payload 
if target == "zero.." 
   => step 1: new contract created
      step 2: transaccion.payload is executed 
      step 3: exec. output stored as contract.code
      (=> trans.payload == code factory of contract code)
</pre>
  </li>
  <li>transaction.ether: Price in Wei of one unit of gas, in which VM operations are priced.<br/>
- The product of gasPrice and gas represents the maximum amount of Wei we are willing to pay for executing the transaction. gasPrice is used by miners to rank transactions for inclusion in the blockchain. 
  </li>
  <li>transaction.gas: Its purpose is to limit the amount of work needed to execute the transaction 
      and to pay for this execution. <br/>
           transaction creator (sender?) chooses the gas to pay.<br/>
             - If execution gas < transaction.gas => Refund to sender<br/>
             - If execution gas > transaction.gas => out-of-gas exception triggered
                 (reverts all modifications made to the state in current call frame)
  </li>
  <li>nonce: increasing numeric value which is used to uniquely identify transactions.
      A nonce can only be used once and until a transaction is mined, it is possible
      to send multiple versions of a transaction with the same nonce, however, 
      once mined, any subsequent submissions will be rejected.
  </li>
  </ul>
  <b>block validation algorithm (Consensus)</b><br/>
  <ol xxxsmall zoom>
  <li>Check if the previous block referenced exists and is valid</li>
  <li>Check that the timestamp of the block is greater than that of the referenced previous
  block and less than 15 minutes into the future.</li>
  <li>Check that the block number, difficulty, transaction root, uncle root and gas limit 
  (various low-level Ethereum-specific concepts) are valid.</li>
  <li>Check that the proof of work on the block is valid</li>
  <li>Let S[0] be the STATE_ROOT of the previous block</li>
  <li>Let TX be the block's transaction list, with n transactions. For all "i" in 
  0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any applications returns an error, or
  if the total gas consumed in the block up until this point exceeds the GASLIMIT, 
  return an error</li>
  <li>Let S_FINAL be S[n], but adding the block reward paid to the miner</li>
  <li>Check if S_FINAL is the same as the STATE_ROOT. If it is, the block is valid;
      otherwise, it is not.</li>
  <li>Note: coinbase: In a mining node indicates the address where rewards will go.
        Must be set to an account owned by miner</li>
  </ol>
</td>
<td colsep></td>
<td>
  <ul xxxsmall zoom>
  <li><def>Calls vs Transactions:</def>
    <ul>
    <li>Calls: invoque an smart-contract function and return a value, 
      but nothing is mined/verified by the consensus.</li>
    <li>Transactions: Verified by the consensus miners. 
      Expends gases, do not return any value (is asynchronous)
      We need events to return the value</li>
    </ul>
  </li>
  <li><def>state transition function</def>,  APPLY (S, TX) -> S' can be defined as follows:
    <ol>
    <li>Check if the transaction is well-formed (ie, has the right number of values), the signature is valid, and the nonce matches the nonce in the sender's account.  If not, return an error.</li>
    <li>Calculate the transaction fee as STAR_GAS * GAS_PRICE, and determine the sending address from the signature. Subtract the fee from the sender's account balance and increment the sender's nonce. If there is not enought balance to spend, return an error.</li>
    <li>Initialize GAS = STARTGAS, and take off a certain quantity of gas per byte to pay for the bytes in the transaction.</li>
    <li>Transfer the transaction value from the sender's account to the receiving account.  If the receiving account does not yet exist, create if. If the receiving account is a contract, run the contract's code either to completion or until the execution runs out of gas.</li>
      <li>If the value transfer failed because the sender did not have enough money, or the code execution ran out of gas, revert all state changes except the payment of the fees, and add the fees to the miner's account</li>
      <li>Otherwise, refund the fees for all remaining gas to the sender, and send the fees paid for gas consumed to the miner</li>
    </ol>
  </li>
  <li>
    There are two mechanisms you can use to transact with Ethereum:
    <ul>
      <li>Transaction signing via an Ethereum client (geth, parity,...).
          It forces to have the wallet on the client node and unlock the 
          account.</li>
      <li>Offline transaction signing (recomended)
        The "raw" transaction must be signed first
        (See https://docs.web3j.io/transactions.html#transaction-mechanisms ->
        raw transactions for more info)</li>
    </ul>
  </li>
  </ul>
  <br/>
  Transactions in solidity:
  <ul xxxsmall zoom>
  <li>
<pre>
addressInstance.balance (uint256): balance in Wei
addressInstance.transfer(uint256 amount): 
    msg.sender ->(amount in wei) ->addressInstance
    throws on failure 

addressInstance.send(uint256 amount): returns (bool):
    msg.sender ->(amount in wei) ->addressInstance
    returns true/false, does NOT throw an exception
</pre>
  In addressInstance.transfer (or send), if addressInstance
  is a contract address, its code (more specifically: its fallback function, if present) 
  will be executed together with the transfer call. This is a limitation of the EVM and
  cannot be prevented. <br/>
  If that execution runs out of gas or fails in any way, the Ether transfer will be
  reverted and the current contract will stop with an exception.
  </li>
  </ul>
</td>  
<td colsep></td>
<td>
  <b>Events &amp; LOGS</b>
  <ul xxxsmall zoom>
  <li>Logs: It is possible to store data in a specially indexed data structure 
      that maps all the way up to the block level.<br/>
      This feature called 'logs' is used to implement events.</li>
  <li>Contracts *CAN NOT* access log data after it has been created, but they 
      can be efficiently accessed from outside the blockchain. <br/>
      Since some part of the log data is stored in bloom filters,
      it is possible to search for this data in an efficient and cryptographically 
      secure way, so network peers that do not download the whole blockchain 
      ("light clients") can still find these logs.</li>
  <li>Logs were designed to be a form of storage that costs significantly less gas than contract storage:<br/>
      Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes. 
      Up to 3 parameters can be indexed.<br/>
  </li>
  </ul>
  Solidity code:
<pre xxxsmall zoom>
event EventDepositLog(
    uint256 indexed _market,
    address indexed _sender,
    uint256 _amount,
     uint256 _time);
</pre>
  JS Client Log monitoring:
<pre xxxsmall zoom>
var depositEvent =
  cryptoExContract.EventDepositLog(
     {_sender: userAddress} /* filter */, 
     {fromBlock: 0, toBlock: 'latest'} /* range*1
  );
// *1 If block range ommited => "real-time" event logs

depositEvent.watch
   /* to cancel: depositEvent.stopWatching() */(
  function(err, result) {
    if (err) { ...    return; }
    console.log(
         "_market:"+result.args._market
       + "_sender:"+result.args._sender );
  }
)
</pre>
</td>  
<td colsep></td>
<td>
  <a href="https://ens.domains/">Ethereum Name Service</a> <a TODO href="https://docs.ens.domains/en/latest/userguide.html">ENS User Guide</a>, <a href="https://github.com/ethereum/go-ethereum/tree/master/contracts/ens">Geth implementation</a>, <a href="https://github.com/ethereum/EIPs/issues/137">EIPs issue</a>
  <ul xxxsmall zoom>
  <li>goal: resolve human-readable names to Ethereum addresses, Swarm/IPFS hashes, ....<br/>
      provide also metadata about names (contracts ABIs, whois info,...)</li>
  <li>ENS operates on a system of <b orange>dot-separated hierarchial names called domains</b>, 
      with the owner of a domain having full control over the distribution of subdomains.</li>
  <li> Top-level domains (.eth, .test,...) owned by 'registrars' smart contracts
    Anyone may, by following the rules imposed by these registrar contracts, 
    obtain ownership of a second-level domain for their own use.</li>
  <li>"""No more long addresses: ENS eliminates the need to copy - and worse, type - long hexadecimal addresses."""<br/> 
         With ENS, you'll be able to send money to your friend at <code>'aardvark.eth'</code> instead of <code>'0x4cbe58c50480...'</code>,
         interact with your favorite contract at <code>'mycontract.eth</code>', or visit a Swarm-hosted site at 'swarmsite.eth'."""
  </li>
  <li>Secure: ENS is built on smart contracts on the Ethereum blockchain, meaning
      it doesn't suffer from the insecurity of the DNS system.  You can be confident
      names you enter work the way their owner intended.</li>
  <li>Truly Distributed: ENS operates in a distributed fashion for both its infrastructure
     and governance. Anyone can register a .eth domain name for themselves by participating
     in an auction process, mediated by the blockchain.</li>
  <li>Terminology
    <ul>
    <li>domain     : complete, human-readable form of a name; eg, ‘vitalik.wallet.eth’.</li>
    <li>label      : a single component of a domain; eg, ‘vitalik’, ‘wallet’, or ‘eth’ </li>
    <li>label hash : keccak-256(label) eg, keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0</li>
    <li>node       : namehash function output used to uniquely identify a name in ENS</li>
    </ul>
  </li>
  <li>JS Client code to register: <a href="https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial">REF</a> 
<pre xxxsmall zoom> 
var name = "MyPersonalDemocracy"
registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
var democracy = eth.contract(daoCompiled.Democracy.info.abiDefinition).at(democracy.address);
democracy.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})

(Wait for the previous transactions to be picked up and then)

registrar.setAddress.sendTransaction(name, democracy.address, true,{from: eth.accounts[0]});
</pre>
  </li>
  </ul>
  Architecture: 
<pre xxxsmall zoom>
DOMAIN            | REGISTRY CONTRACT                  | RESOLVER(S) INTERFACE
------            | -----------------                  | ---------------------
- owner (address) | - owned (sub)domains list          | translate name → address
- resolver        | ----------------                   +-------------------------
- time-to-live    | + issues subdomains to users  *1 
  for all records |   following logic in contract *1   | RECORD:
                  | + Set resolver+TTL for domain *1   | -------
                  | + Transfer ownership               | - type: (Ethereum address, Swarm content hash, ...)
                  | *1 Only owner of affected domain   |          New record types may be defined via EIP
                                                       |          with no need to make changes to the registry or resolvers
                                                       |
                                                       | - Namehash: 32-byte hash of name (compaq storage+privacy)
                                                       |             defined recursively to preserve the hierarchal nature
                                                       | ----------
                                                       | - Iface method/s to be implemented by resolver
                                                       |    in order to provide records of that kind.
</pre>
  MainNet/... Deployments
<pre xxxsmall zoom>
General-purpose resolver implementations are offered for users whose requirements are straightforward, 
such as serving an infrequently changed address for a name.

  MAINNET DEPLOYMENT: 0x314159265dd8dbb310642f98f50c066173c1259b
                      users may register names under the eth TLD using an auction based registrar.
  ROPSTEN 
  TESTNET DEPLOYMENT: 0x112234455c3a32fd11230c42e7bccd4a84e02010
                      users may register names under two top level domains:
                      .eth , auction based 
                      .test, allows anyone to claim an unused name for test purposes expiring after 28 days
  RINKEBY
  TESTNET DEPLOYMENT: 0xe7410170f87102df0055eb195163a03b7f2bff4a
                      .test supported
</pre>


  Ext. Links
  <ul xxxsmall zoom>
  <li><a href="https://github.com/ethereum/EIPs/issues/137">EIP137</a> - Ethereum Name Service</li>
  <li><a href="https://github.com/ethereum/EIPs/issues/162">EIP162</a> - Initial ENS Registrar Specification</li>
  <li><a href="https://www.npmjs.com/package/ethereum-ens">ethereum-ens</a> Javascript library</li>
  <li>Nick’s talk on ENS at DevCon 2: <a href="https://www.youtube.com/watch?v=pLDDbCZXvTE">https://www.youtube.com/watch?v=pLDDbCZXvTE</a></li>
  <li><a href="https://arachnid.github.io/devcon2/#/title">DevCon 2 talk slides</a></li>
  <li><a class="reference external" href="https://registrar.ens.domains">https://registrar.ens.domains</a></li>
  </ul>
</td>
</tr>
</table>

<table>
<tr>
  <th colspan=4 header_delimit><a href='http://solidity.readthedocs.io/en/develop/'>SOLIDITY LANG.</a>, See also <a href='https://github.com/ConsenSys/smart-contract-best-practices'>Best Practices</a>
  </th>
  <td colsep></td>
  <th header_delimit><a href='https://github.com/ConsenSys/smart-contract-best-practices'>Tokens</a>
  <td colsep></td>
  <th header_delimit><a href='https://erc725alliance.org/'>Identity</a>
  <td colsep></td>
</tr>
<tr>
<td>
  Grammar summary 
<pre  xxxsmall zoom>
REF: <a href='https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt'>https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt</a>
{
Elementary:
Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*
NumberUnit = ('wei' | 'szabo' | 'finney' | 'ether') |
             ('seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years')
(Notice: NumberUnit can NOT be applied to variables, only to literals:
   M wei;     // &lt;- wrong
   M * 1 wei; // &lt;- correct

ElementaryTypeName = 'address' /*20 byte*/| 'bool' | 'string' | 'var' 
     |  'int(8|6|24|32|...|256)' 
     | 'uint(8|6|24|32|...|256)' 
     | 'byte(s|1-32)'
     | 'fixed'  | 'fixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256 
     | 'ufixed' | 'ufixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256
}

{
PrimaryExpression = Identifier | ('true' | 'false')  | (/*DecimalNumber*/ [0-9]+) | ...

Expression =
    ( Expression ('++' | '--') 
      | FunctionCall 
      | (/*IndexAccess*/ Expression '[' Expression? ']')
      | (/*MemberAccess*/ Expression '.' Identifier) 
      | '(' Expression ')' 
    )
  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
  | Expression '**' Expression
  | Expression ('*' | '/' | '%') Expression
  | Expression ('+' | '-') Expression
  | Expression ('&lt;&lt;' | '>>') Expression
  | Expression '&' Expression
  | Expression '^' Expression
  | Expression '|' Expression
  | Expression ('&lt;' | '>' | '&lt;=' | '>=') Expression
  | Expression ('==' | '!=') Expression
  | Expression '&&' Expression
  | Expression '||' Expression
  | Expression '?' Expression ':' Expression
  | Expression ('=' | '|=' | '^=' | '&=' | 
                '&lt;&lt;=' | '>>=' | '+=' |
                '-=' | '*=' | '/=' | '%=') Expression
  | Expression? (',' Expression)
  | PrimaryExpression
}

{
TypeNameList = '(' ( TypeName (',' TypeName )* )? ')'

FunctionTypeName = 'function' TypeNameList ( 'internal' | 'external' | 'constant' | 'payable' )*
                   ( 'returns' TypeNameList )?
TypeName =
     ElementaryTypeName 
   | /*UserDefined*/Identifier ( '.' Identifier )* 
   | ( 'mapping' '(' ElementaryTypeName '=>' TypeName ')' ) 
   | (TypeName '[' Expression? ']') 
   | FunctionTypeName


FunctionCall = ( PrimaryExpression | ( 'new' TypeName ) | TypeName ) 
               ( ( '.' Identifier ) | ( '[' Expression ']' ) )*
               '(' FunctionCallArguments ')'

FunctionDefinition = 'function' Identifier? ParameterList
                     ( FunctionCall | Identifier | 'constant'
                     | 'payable' | 'external' | 'public'
                     | 'internal' | 'private' )*
                     ( 'returns' ParameterList )? ( ';' | Block )

// semantic restriction: mappings & structs (recursively) containing mappings not allowed in argument lists
}


{
VariableDeclaration = TypeName (/*StorageLocation*/ ('memory' | 'storage'))? Identifier
VariableDefinition = ('var' (/*IdentifierList*/ '(' ( Identifier? ',' )* Identifier? ')') | VariableDeclaration) ( '=' Expression )?
SimpleStatement = VariableDefinition | Expression
}


{
Statement = 
   (  ('if' '(' Expression ')' Statement ( 'else' Statement )?) 
   | ('while' '(' Expression ')' Statement)
   | ('for' '(' (SimpleStatement)? ';' (Expression)? ';' (Expression)? ')' Statement)
   | ( /*block*/ '{' Statement* '}')
   | InlineAssemblyStatement 
   | ('do' Statement 'while' '(' Expression ')' ) 
   | /*place holder*/'_' 
   | 'continue' | 'break' | 'return' Expression?  |'throw' 
   | SimpleStatement )
   ';'
}


{ Contracts:
IndexedParameterList = '(' ( TypeName 'indexed'? Identifier? (',' TypeName 'indexed'? Identifier?)* )? ')'

ContractPart = 
    ( TypeName ( 'public' | 'internal' | 'private' )? Identifier ('=' Expression)? ';' )
  | ( 'using' Identifier 'for' ('*' | TypeName) ';' )
  | ( 'struct' Identifier '{' ( VariableDeclaration ';' (VariableDeclaration ';')* )? '}' ) 
  | ( 'modifier' Identifier ParameterList? Block )
  | ( 'event' Identifier IndexedParameterList 'anonymous'? ';' )
  | ( 'enum' Identifier '{' Identifier? (',' Identifier)* '}' )
  | FunctionDefinition

InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )* ')' )?

ContractDefinition = ( 'contract' | 'library' ) Identifier
                     ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                     '{' ContractPart* '}'
}
</pre>
</td>
<td colsep></td>
<td>
  FUNCTIONS:
  <ul xxxsmall zoom>
  <li>
<pre>
modifier inState(State _state)    { if (state != _state) throw;  _;  }
modifier require(bool _condition) { if (!_condition) throw; _;       }

function confirmPurchase(<parameter_list types>)
    inState(State.Created)          // precondition
    require(msg.value == 2 * value) // precondition
    // VISIBILITY MODIFIERS {
    [internal]  only this contract and child ones
    [private]   only this contract
    [external]
    [public]
    // }
    // MUTABILITY MODIFIERS {
    [payable]  /* allows funct to receive ether when called as:
                * myContractInstance.myPayableFunction.call. \
                *   value("ETH_TO_BE_SENT")("ADDITIONAL_DATA")
                * Ej:
                *   function deposit() payable {
                *     deposits[msg.sender] += msg.value;
                *   };
                */
    [pure]      /* does NOT modify the contract storage 
                 * and storage can NOT be accesed 
                 * (utility libraries, ...)*/
    [view] /* does NOT modify the contract storage 
              but storage can be accesed  ("getters")*/
    [constant] /* alias for pure */
    // }
    [returns ('return types')]
    { 
      ... 
    }
</pre>
  Fallback function (function called when no other function matches):
<pre xxxsmall zoom>
event EventFallback(address from, int256 amount);
...
function () payable {
  if (! this.owner.send(amount)) { throw ; }
  EventFallback(msg.sender, receiver, amount);
}; 
</pre>
To use and external function f as an internal function,
  just use f, if you want to use its external form, use this.f (not recomended) <br/>
  external vs public: (Best practice) use external if function will only ever be 
  called externally and use public if function will also be called internally.
  external avoid copying parameters twice (very important with big arrays)<br/>
</li>
  <li>IMPORTS:
<pre>
import ""filename"";
import * as symbolName from ""filename"";
import {symbol1 as alias, symbol2} from ""filename"";
import ""filename"" as symbolName;
</pre>
  </li>
  <li>STRUCTS, ENUMS
<pre>
struct Voter {   ┃ enum State {
  uint weight;   ┃    Created,
  bool voted;    ┃    Locked,
}                ┃    Inactive 
                 ┃ }
</pre>
  </li>
  <li>
<pre>
var x = 1/4; // x type: ufixed0x8 
var x = 1/3  // x type: ufixed0x256, no finity bin.repre
</pre>
  </li>
  </ul>
</td>  
<td bgorange>  
  <a href="https://solidity.readthedocs.io/en/v0.4.24/control-structures.html#error-handling-assert-require-revert-and-exceptions">ERROR CONTROL</a><br/>
<pre bgorange xxxsmall zoom>
Solidity uses state-reverting exceptions to handle errors:
 - Capturing ("catch-ing") Exceptions IS NOT (YET?) POSSIBLE (2018-06-11)!.
 - EVM rollbacks any stat change in current call and all its sub-calls
   including events pending to register.
   (there is no safe way to continue execution while warrantying atomicity
    and reproducibility of results)
 - TX is still mined and TXReceipt status flaged with "fail" error
   See <a href="https://etherscan.io/tx/0x9f00a37416a64735b02ab76da4477ea297bfd4923b1564c1b3579d542b3f4071">Example failed TX mined</a>

PROGRAMATICALLY TRIGGERING EXCEPTIONS: 
┌───────────────────────────────────────────────┬──────────────────────────────────────────────┬───────────────────────────────────────────────┐
│      assert                                   │     require                                  │   revert                                      │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ (programming error)                           │ (pre/post check in in/out-data)              │ (business logic exceptions)                   │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - Check for conditions and throw an exception │ - Check for conditions and throw an exception│ - replaces deprecated 'throw'                 │
│   if the condition is not met                 │   if the condition is not met                │ - can be used to flag an error and revert the │
│ - Should only be used to test for internal    │ - Should be used to ensure valid conditions, │   current call.                               │
│   errors, and to check invariants             │   such as inputs, or contract state variables│ - It is possible to provide a string message  │
│ - If used properly, analysis tools can        │   are met, or to validate return values from │   containing details about the error that will│
│   evaluate your contract to identify          │   calls to external contracts                │   be passed back to the caller.               │
│   the conditions and function calls which will│ - optionally a message-string can be provided│                                               │
│   reach a failing assert.                     │                                              │                                               │
│   Properly functioning code should never reach│                                              │                                               │
│   a failing assert statement                  │                                              │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - compiles to INVALID 0xfe instruction        │  - compiles to REVER 0xfd instruction        │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ assert( "my code-logic assertion")            │ require("required cond.", "messsage");       │  if ("not condtion for input") revert("....") │
└───────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────────┘

┌─────────┬────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────┐   ┌─────────────────────────────────────────────────────┐
│         │ assert-style exception                                 │ revert/require-style exception                       │   │low level ops (return false, no exception raised)    │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Condition│ - access array at index greater than array             │ - Calling throw (deprecated)                         │   │- create a contract using "new" but contract creation│
│that     │  length (or negative)                                  │ - Calling require evaluating to false                │   │  does not finish properly.                          │
│triggers │ - access fixed-length bytes"N" at a too large or       │ - call a function via a message call but it does not │   │- perform external function call targeting a contract│
│exception│   negative index                                       │   finish properly (i.e. it runs out of gas, has no   │   │  that contains no code                              │
│in the   │ - divide or modulo by zero (ex.: 5 / 0 , 23 % 0)       │   matching function, or throws an exception itself), │   │- contract receives Ether via public function        │
│at (EVM) │ - shift by a negative amount                           │   except when a low level operation call, send,      │   │  without payable modifier (including constructor    │
│runtime  │ - convert a value too big|negative into an enum type   │   delegatecall or callcode is used.                  │   │  or fallback                                        │
│         │ - call to zero-initialized variable of internal        │                                                      │   │- contract receives Ether via public getter function │
│         │   function type                                        │                                                      │   │- .transfer() fails                                  │
│         │ - call assert with an argument that evaluates to false │                                                      │   │                                                     │
│         │ - call function not matching any func. in contract     │                                                      │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Gas ussag│ Consume all gas available to the call                  │ - Do NOT consume any gas (v.Metrópolis+)             │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Propagati│ - Rethrown ("bubble up") in sub-calls                  │ - Rethrown ("bubble up") in sub-calls                │   │- return false *1                                    │
└─────────┴────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────┘   └─────────────────────────────────────────────────────┘
                                                                                                                                 *1 or true if called account is non-existent
                                                                                                                                    Existence must be checked prior to call

Solidity compiler automatically generate exceptions (assert or require/revert?) if:
 - If your contract receives Ether via a public function without payable modifier 
   (including the constructor and the fallback function)
 - If your contract receives Ether via a public getter function
 - If you call a zero-initialized variable of internal function type
 - If a addressInstance.transfer() fails</li>


The provided string in require/revert will be abi-encoded as if it were a call to a function Error(string).
For example:
   revert("Not enough Ether provided."); will cause the following hexadecimal data be set as error return data:

0x08c379a0                                                         // Function selector for Error(string)
0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
0x000000000000000000000000000000000000000000000000000000000000001a // String length
0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
</pre>
</td>

<td colsep></td>
<td>
  Simple Coin
<pre  xxxsmall zoom>
pragma solidity ^0.4.0;
contract /*Simple*/Coin {

  address public minter; // public => readable ""outside""

  // state variable. Permanently stored in contract storage
  mapping ( address => uint) public balances;

  event EventSent( address from, address to, uint amount);

  // This is the constructor whose code is run only       
  // when the contract is created.                        
                                                          
  function Coin() { minter = msg.sender; }                

  function mint( address receiver, uint amount) {         
    if (msg.sender != minter) return ;                    
    balances[receiver] += amount;                         
  }                                                       
                                                          
  function send( address receiver, uint amount) {                 
    if (balances[msg.sender] &lt; amount) return ;
      balances[msg.sender] -= amount;
      balances[receiver] += amount;
      EventSent(msg.sender, receiver, amount);
  }

  function arithmetics(uint _a, uint _b)
    // returns 2-tuple 
    returns (uint o_sum, uint o_product) {
    // alt return (o_sum, o_product) -
    o_sum = _a + _b;
    o_product = _a * _b;
  }
}
</pre>
  JS to use it:
<pre  xxxsmall zoom>
Coin.Sent().watch(
 {},
 '',
 function (error, result) {
   if (!error) {
     console.log(""Coin transfer: "" + result.args.amount +
       "" coins were sent from "" + result.args.from +
       "" to "" + result.args.to + ""."");
  
     console.log(""Balances now:\n"" +
       ""Sender: "" + Coin.balances.call(result.args.from) +
       ""Receiver: "" + Coin.balances.call(result.args.to));
   }
}
</pre>
  <hr xxxsmall zoom />
  <b><a href='https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md'>ERC20 Coin</a></b><br/>
  <ul xxxsmall zoom>
  <li>Estándar interface to Fungible Assets Contracts that different wallets will understand out-of-the-box</li>
  <li><a href='https://theethereum.wiki/w/index.php/ERC20_Token_Standard'>ERC20 @ Ethereum WiKi</a></li>
  <li><a href='https://edcon.io/ppt/two/Dmitry%20Khovratovich_Secure%20Token%20Development%20and%20Deployment_EDCON.pdf'>Problems with the Standard</a></li>
  <li><a href='https://tokenmarket.net/what-is/ethereum-token-wallets/'>ERC20 compliant wallets</a></li>
  </ul>
  Example implementations
  <ul xxxsmall zoom>
  <li><a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol">OpenZeppelin StandardToken.sol</a></li>
  <li><a href="https://github.com/ConsenSys/Tokens/blob/master/contracts/StandardToken.sol">ConsenSys StandardToken.sol</a></li>
  <li><a href='https://etherscan.io/tokens'>Popular Token List @ Etherscan</a></li>
  </ul>
</td>
<td colsep></td>
<td>
  <a TODO href="https://erc725alliance.org/">ERC-725 Identity Std</a>
<pre xxxsmall zoom>
- What is ERC 725?
  ERC 725 is a proposed standard for blockchain-based identity 
  authored by Fabian Vogelsteller, creator of ERC 20 and Web3.js. ERC 
  725 describes proxy smart contracts that can be controlled by 
  multiple keys and other smart contracts. ERC 735 is an associated 
  standard to add and remove claims to an ERC 725 identity smart 
  contract. These identity smart contracts can describe humans, groups
  , objects, and machines. ERC 725 lives on the Ethereum 
  blockchain.


- Why ERC 725?
  ERC 725 allows for self-sovereign identity. Users should be able to 
  own and manage their identity instead of ceding ownership of 
  identity to centralized organizations. We have seen the negative 
  effects of having centralized identity with damaging leaks and 
  unfair selling of user data and identity. An open, portable 
  standard for identities will enable decentralized reputation, 
  governance, and more. Users will be able to take their identity 
  across different Dapps and platforms that support this standard.

</pre>
</td>
<td colsep></td>
<td>
<a href='https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol'>Minimum Signature.Num.</a>
<pre xxxsmall zoom>
Inheritable "property" contract:
<b>enables methods to be protected by requiring the acquiescence of either a
   single, or, crucially, each of a number of, designated owners.</b>
// REF: <a href="https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol">Wallet.sol gist</a>
// @authors: Gav Wood <g@ethdev.com>
contract multiowned {
    struct PendingState { uint yetNeeded; uint ownersDone; uint index; }
    mapping(bytes32 /* operation_hash */ => PendingState) <b orange>mapPendingOps</b>; // ongoing ops
    uint public minimum_required; // minimum owners confirmations for same operation
   
    mapping(address => uint /*<b brown>bit idx</b>*/) <b brown>mapOwner2Idx</b>; // <b>allow reverse lookup</b>
    bytes32[] m_pendingIndex;

    modifier onlyOwner { if (<b brown>mapOwner2Idx</b>[msg.sender] == 0) throw ; _ }

       /* same operation hash must be signed/accepted by a minimum number 
        * of the set of owners (specified in the constructor) before execution */
<b>    modifier  <b blue>onlyMany/*¡¡SIGNATURE!!*/Owners</b>(bytes32 _operation_hash) {
        if (!<b blue>confirmAndCheck</b>(_operation_hash)) throw ;  _ }</b>

<b>    constructor(address[] _owners /* "who" can confirm */,
           uint minimum_required /*minimum. confirmations*/) {</b>
        <b brown>mapOwner2Idx</b>[msg.sender] = 1;
        for (uint i = 0; i &lt; _owners.length; ++i) 
            { <b brown>mapOwner2Idx</b>[_owners[i]] = 2 + i; }
        minimum_required = minimum_required;
    }

    function <b>hasConfirmed(bytes32 _operation_hash, address _owner)</b> constant returns (bool) {
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        uint ownerIndex = <b brown>mapOwner2Idx</b>[_owner];
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine bit to set
        return (pending.ownersDone &<b green>ownerIdxBit</b> == 0) ? false : true;
    }

    function <b blue>confirmAndCheck</b>(bytes32 _operation_hash) internal returns (bool) {
        uint ownerIndex = <b brown>mapOwner2Idx</b>[msg.sender]; // get idx for msg.sender
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        if (pending.yetNeeded == 0) {
            pending.yetNeeded = minimum_required; // reset confirmations needed
            pending.ownersDone = 0; // reset owners confirmed to none (bitmap→0)
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation_hash;
        }
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine the bit to set
        if (pending.ownersDone & <b green>ownerIdxBit</b> == 0) {
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1 /* enough confirmations. reset→run*/) {
                delete m_pendingIndex[<b orange>mapPendingOps</b>[_operation_hash].index];
                delete <b orange>mapPendingOps</b>[_operation_hash];
                return true;
            } else {
                pending.yetNeeded--;
                pending.ownersDone |= <b green>ownerIdxBit</b>;
                return false;
            }
        }
    }
}
</pre>
<a href='https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial'>Voting</a>
<pre xxxsmall zoom>
contract Voting {
  uint       public <b orange>MIN_QUORUM</b>  ;
  uint       public <b orange>DEBATING_PERIOD</b> ;
  address    public <b green>FOUNDER</b>        ;
  Proposal[] public proposals      ;
  uint       public numProposals   ;
  
  struct <b blue>Vote     { int UpOrDown; address voter; }</b>
  struct Proposal {
    <b blue>Vote[]  votes</b>      ; mapping (address => bool) voted;
    bytes32 data        ; string  description;
    uint    creationDate; bool    active     ;
    boolean result;
  }
  
  constructor(uint _minimumQuorum, uint _debating_period) {
    <b green>FOUNDER</b>          = msg.sender;  
    <b orange>MIN_QUORUM</b>      = _minimumQuorum || 10;
    <b orange>DEBATING_PERIOD</b> = _debating_period * 1 minutes || 30 days;
  }

  function newProposal(bytes32 _data, string _descrip) returns (uint <b yellow>proposalID</b>) {
      <b yellow>proposalID</b>     = proposals.length++;
      Proposal p     = proposals[<b yellow>proposalID</b>];
      p.data         = _data;
      p.description  = _descrip  ;    p.creationDate = now;
      p.active       = true      ;    numProposals   = <b yellow>proposalID</b>+1;
  }
  
  function vote(uint _<b yellow>proposalID</b>, int _UpOrDown /*+1|-1*/) returns (uint <b brown>voteID</b>){
      if (_UpOrDown < -1 && _UpOrDown > 1 ) revert("UpOrDown is not valid") ;
      Proposal p = proposals[_<b yellow>proposalID</b>];
      if (p.voted[msg.sender] == true) return;
      <b brown>voteID</b> = p.<b blue>votes</b>.length++;
      p.<b blue>votes[<b brown>voteID</b>] = /*new*/Vote({UpOrDown: _UpOrDown, voter: msg.sender})</b>;
      p.voted[msg.sender] = true;
  }
  
  function executeProposal(uint _<b yellow>proposalID</b>) returns (int <b brown>result</b>) {
      Proposal proposal = proposals[_<b yellow>proposalID</b>];
      if (/*timeout?*/ now &gt; (proposal.creationDate + <b orange>DEBATING_PERIOD</b>) &amp;&amp; proposal.active){   
          uint quorum = 0;
          for (uint i = 0; i &lt;  proposal.<b blue>votes</b>.length; ++i) {
              Vote v = proposal.<b blue>votes</b>[i];
              quorum += 1;
              <b brown>result</b> += v.UpOrDown;
          }
          if (quorum &gt; <b orange>MIN_QUORUM</b>) {
              proposal.active = false;
              proposal.result = result &gt;=0 ? true : false;
          }
      }
  }
}
</pre>
</td>
</tr>
</table>

<table>
<tr>
<td>
  <a href="https://solidity.readthedocs.io/en/v0.4.24/types.html#arrays">Arrays</a>
<pre xxxsmall zoom>
- Fixed   Size Array declaration: T[k] a1 = T[k]
- Dynamic Size Array declaration: T[ ] a2 = T[]

    uint[2**20] m_aLotOfIntegers;
 +--------+-----------------------+-------------------+----------------------+--------------------+
 |        | Admited type          | Creation          | Resize               | Delete             |
 +--------+-----------------------+-------------------+----------------------+--------------------+
 |Storage | *any*                 | (just declare it) |- set/reassign .length| delete myArray;    |
 |Arrays  |                       |                   |- push(el)            | myArray.length = 0;|
 +--------+-----------------------+-------------------+----------------------+--------------------+
 |Memory  | *any* but mapping     | Use 'new'         | Not allowed          |                    |
 |Arrays  | (ABI comp. for        | new uint[](7)     |(fix size determined  |                    |
 |        |  public/extern fun)   | new bytes(len)    | at runtime)          |                    |
 +--------+-----------------------+-------------------+----------------------+--------------------+

Ex: 
var x = uint[][5] // fixed-(5)size-array of
                  // dynamic-uint-arrays
    x[2][1]       // second uint in third dyn-array

Special (tightly packed in calldata) arrays
bytes : (tightly packed) byte[]
string: (UTF-8) similar to bytes, but does not YET allow
        length/index/push access
        Use use bytes(myString).length / bytes(myString)[7] = 'x' to
        access the low-byte-representation of myString 

Array Literals expression (not immediately assigned to a variable)
   type     : memory array of fixed 
   base type: common type of array elements.

  ...
  calledFunction(<b orange>[uint(1), 2, 3]</b>);


Limitations:
- arrays of arrays not (YET) allowed in external functions
- (EVM limitation): dynamic content from external funct. no allowed in return
  Workaround: use large statically-sized arrays

- Deleting an enement in the array (delete myArray[idx1]) generates gaps over time
- This can lead to unpredictable gas costs if a contract itself has to search 
  through those gaps.
</pre>
  <a href="https://solidity.readthedocs.io/en/v0.4.24/types.html#mappings">Mappings</a>
<pre xxxsmall zoom>
Only allowed for state variables (or as storage reference types in internal functions)
Solidity Mappings are NOT iterable.
Declaration:
   mapping(_KeyType => _ValueType) public balance; 
           ↑
           almost any type except 
           mapping,dyn-array,contract,enum,struct

virtually initialized: every possible key exists mapped to zero-byte-repr

Can we get all elements stored in a mapping in the contract? <a href="https://ethereum.stackexchange.com/questions/15337/can-we-get-all-elements-stored-in-a-mapping-in-the-contract">REF</a>
<b>Mappings do not store their keys, only the value which is stored at the state
 memory address calculated by a sha3 hash of the the key itself. Any lookup into
 a mapping has to provide that original key or be able to calculate it.

This means that a contract has no way of discovering mapped data without 
assistance which can lead to orphaned data bloating the state database, 
particularly after a contract is selfdestructed.
</b>

contract authors are responsible for garbage collection writing total discoverable 
data contracts in which all data can be discovered and deleted if and when required.

The simplest pattern to key storage is a simple lookup table:

Solution 1: Using aux. array to store keys. (Can generate gaps when removing in the array)
 +-------------------------------------------+------------------------------------------+
 |ETHEREUM CODE                              | CLIENT CODE                              |
 +-------------------------------------------+------------------------------------------+
 |mapping (address =&gt; uint) public balances; | for(i = 0; i < k.size(); i++) {          |
 |address[] public mapKeys   ;               |     someFunc( k.balances(k.mapKeys(i)) );|
 |function size() public returns (uint) {    | }                                        |
 |    return mapKeys.length;                 |                                          |
 |}                                          |                                          |
 +-------------------------------------------+------------------------------------------+
Solution 2: Using Linked List Indexes
 +---------------------------------------------+------------------------------------------+
 |ETHEREUM CODE                                | CLIENT CODE                              |
 +---------------------------------------------+------------------------------------------+
 |mapping (address =&gt; address) llIndex;     | var current = k.llIndex(0);              |
 |mapping (address =&gt; uint) public balances;| while (current) {                        |
 |function add(address _addr_as_idx) public    |     console.log( k.balances(current) );  |
 |{                                            |     current = k.llIndex(current);        |
 |    llIndex[_addr_as_idx] = llIndex[0x0];    | }                                        |
 |    llIndex[0x0] = _addr_as_idx;             |                                          |
 |}                                            |                                          |
 +---------------------------------------------+------------------------------------------+
Note: llIndex will grow as:
| STEP 1         | STEP 2         | STEP 3         | STEP 4 ...
| 0x      addr01 | 0x      addr02 | 0x      addr03 | 
|                | addr02  addr01 | addr02  addr01 | 
|                                 | addr03  addr02 | 


// Deleting: No gaps but require a search to find parent node
 +---------------------------------------------+
 |ETHEREUM CODE                                |
 +---------------------------------------------+
 |function remove(address _addr) {
 |    address parent;
 |    // Warning: unbounded gas loop
 |    while (llIndex[parent] != _addr) parent = llIndex[parent];
 |
 |    llIndex[parent] = llIndex[ llIndex[parent]];
 |    delete llIndex[address];
 |    delete balances[address];
 |}

Double Linked List indexes
In such cases it's worth removing search loops altogether at the expense of an 
extra storage slot per indexed element. For this we can use a Double Linked List
index using a nested bool mapping for bidirectional links where we interpret
PREV == false and NEXT == true):

mapping(address => ( mapping(bool => address) ) dllIndex;
mapping(address => uint) balances;
function add(address _addr)
{
    // Link the new node 
    dllIndex[_addr][PREV] = 0x0;
    dllIndex[_addr][NEXT] = dllIndex[0x0][NEXT];

    // Insert the new node
    dllIndex[dllIndex[0x0][NEXT]][PREV] = _addr;
    dllIndex[0x0][NEXT] = _addr;
}

function remove(address _addr)
{
    // Stitch the neighbours together
    dllIndex[ dllIndex[_addr][PREV] ][NEXT] = dllIndex[_addr][TRUE];
    dllIndex[ dllIndex[_addr][NEXT] ][PREV] = dllIndex[_addr][PREV];

    // Delete state storage
    delete dllIndex[_addr][PREV];
    delete dllIndex[_addr][NEXT];
    delete balances[_addr];
}

We now have a directly addressable and fully iterable storage structure, which is not just a Double Linked List but a Circular Double Linked List by default with the head at 0x0. This gives us two very desirable properties for free...
FIFO and FILO Queues

First In First Out (FIFO) and First In Last Out (FILO) queues are a very common concept in computing. FIFO can be used for task queues while FILO is also used for memory 'stacks'.

FIFO's can be used in any contracts that require atomic sequential order processing. Here a new order is simply inserted previous to the head, while the oldest order is simply taken from next to the head. No search loops required.

If you think these structures might be useful, check out my Circular Double Linked List Index Library which is used by my Intrinsically Tradable Tokens (ITT) contract.



</pre>
</td>
<td>
  <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">Iterable Mappings</a>
<pre xxxsmall zoom>
library IterableMapping
  function insert(itmap storage self, uint key, uint value) returns (bool replaced)
  function remove(itmap storage self, uint key) returns (bool success)
  function contains(itmap storage self, uint key) returns (bool)
  function iterate_start(itmap storage self) returns (uint keyIndex)
  function iterate_valid(itmap storage self, uint keyIndex) returns (bool)
  function iterate_next(itmap storage self, uint keyIndex) returns (uint r_keyIndex)
  function iterate_get(itmap storage self, uint keyIndex) returns (uint key, uint value)

// <b>USSAGE:</b>
contract User
{
  IterableMapping.itmap data; // Just a struct holding our data.
  function insert(uint k, uint v) returns (uint size) // Insert something
  {
    IterableMapping.insert(data, k, v);
    return data.size; // We can still access members of the struct 
                      // BUT we should take care not to mess with them.
  }

  function sum() returns (uint s)  // Computes total sum 
  {
    for (
      var i = IterableMapping.iterate_start(data);
      IterableMapping.iterate_valid(data, i);
       i = IterableMapping.iterate_next(data, i))
    {
        var (key, value) = IterableMapping.iterate_get(data, i);
        s += value;
    }
  }
}
</pre>
  <hr xxxsmall />
  <a href="https://raw.githubusercontent.com/ethereum/dapp-bin/master/library/linkedList.sol">Double Linked List</a>
<pre xxxsmall zoom>
library DoublyLinkedList
    function append(data storage self, bytes32 _data) /// Appends `_data` to the end of the list `self`.
    function remove(data storage self, uint80 _index) /// Removes the element identified by the iterator `_index` from the list `self`.
    function find(data storage self, bytes32 _value) returns (uint80) /// @return an iterator pointing to the first element whose data
                                                                      /// is `_value` or an invalid iterator otherwise.
    function iterate_start(data storage self) returns (uint80)        /// Iterator interface
    function iterate_valid(data storage self, uint80 _index) returns  (bool)
    function iterate_prev(data storage self, uint80 _index) returns (uint80)
    function iterate_next(data storage self, uint80 _index) returns (uint80)
    function iterate_get(data storage self, uint80 _index) returns (bytes32)

// USSAGE:
contract Test {
    using DoublyLinkedList for DoublyLinkedList.data;
    DoublyLinkedList.data public list;
    function Test() {
        list.append("abc");
        list.append("abc");
        list.append("def");
    }
    function remove(bytes32 data) returns (bool success) {
        var it = list.find(data);
        if (list.iterate_valid(it)) { list.remove(it); return true; }
        return false;
    }
}
</pre>
</td>
<td colsep></td>
<td>
  Strings
<pre xxxsmall zoom>
CAN NOTs:                               |  CANs:
 - Can NOT be concatenated.             |  - Can be used as keys for mappings
 - *Can NOT be check for equality*      |
   Something like can be used instead:  |
   sha3("string1") == sha3("string2")   |
   or                                   |
   keccak256(bytes("string1")) ==       |
   keccak256(bytes("string2"))          |

check if string is empty: 
   bytes memory tempEmptyStringTest = bytes(emptyStringTest);
   require(tempEmptyStringTest.length &gt; 0, "string can not be empty/null");
</pre>

  String Libraries:
  <ul xxxsmall zoom>
  <li><a href="https://github.com/Arachnid/solidity-stringutils">Arachnid StringUtils</a></li>
  </ul>
</td>
<td>
   Date/Time
<pre xxxsmall zoom>
// DateTime is stored as uint

// "<b orange>now</b>" returns the (uint) current block timestamp (alias for block.timestamp)

uint <b brown>timeOutWindow</b> = <b brown>_inputTimeOutWindow</b> <b orange>* 1 minutes || 30 days</b>;
uint <b brown>time_origin</b> = ...

function myTimeOutDependentFunction(...) returns (...) {
    ...
    if (<b orange>now</b> &gt; (<b brown>time_origin + timeOutWindow</b>) throw;
    ... Do something ...
}
</pre>
</td>
<td colsep></td>
<td>
  GLOBAL METHODS:
<pre xxxsmall zoom>
block.blockhash(uint blockNumber) 
  returns (bytes32): 
  hash of the given block - only works for 256 most
  recent blocks excluding current
</pre>

  GLOBAL VARS:
<pre xxxsmall zoom>
block.coinbase (address): current block miner’s address
block.difficulty (uint) : current block difficulty
block.gaslimit (uint)   : current block gaslimit
block.number (uint)     : current block number
block.timestamp (uint)  : current block timestamp
msg.data (bytes)        : complete calldata
msg.gas (uint)          : remaining gas
msg.sender (address)    : sender of the message (current call)
msg.sig (bytes4)        : first four bytes of the calldata 
                          (i.e. function identifier)
msg.value (uint)        : number of wei sent with the message
now (uint)              : current block timestamp 
                          (alias for block.timestamp)
tx.gasprice (uint)      : gas price of the transaction
tx.origin (address)     : sender of the transaction 
                          (full call chain)
</pre>
  GLOBAL Math.&amp;Crypto Functs
<pre  xxxsmall zoom>
addmod(uint x, uint y, uint k) 
  returns (uint): /* compute (x + y) % k */
mulmod(uint x, uint y, uint k)
  returns (uint): /* compute (x * y) % k */
keccak256(...)
  returns (bytes32): compute Ethereum-SHA-3 hash
                of the (tightly packed) arguments
sha3(...) 
  returns (bytes32): alias to keccak256()
sha256(...) 
  returns (bytes32): compute SHA-256 hash of the
                      (tightly packed) arguments
ripemd160(...) 
  returns (bytes20): compute RIPEMD-160 hash of 
  the (tightly packed) arguments
ecrecover
  (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address):
    recover the address associated with the public key 
    from elliptic curve signature or return zero on error
</pre>
  </li>
  </ul>
</td>

</tr>
</table>

<table>
<tr>
<td>
  <a href='http://ethereum.stackexchange.com/questions/269/what-exactly-is-an-ethereum-client-and-what-clients-are-there/335'>Development Tools</a>
  <ul xxxsmall zoom>
  <li><a href='http://ethereum.github.io/browser-solidity'><def>Browser Solidity</def></a></li>
  <li><a href='https://plugins.jetbrains.com/plugin/9475-intellij-solidity'>Solidity IntelliJ plugin</a> (alpha/bet/betaa state, not using latest compiler versions)</li>
  <li TODO><a href="https://remix.ethereum.org/"><def>Remix Online Solidity IDE</def></a> </li>
  <li>Start ethereum Node in test network:
<pre xxxsmall zoom>
$ geth --rpcapi personal,db,eth,net,web3 --rpc --rinkeby
or
$ parity --chain testnet
</pre>
  </li>
  <li><a href='http://truffleframework.com/docs/'><def>Truffle Framework</def></a>
    smart contract compile, link, deploy, binary management, testing, 
    interactive console, auto-rebuild on-change, external script runner that executes scripts 
    within a Truffle environment. Ussage:
<pre>
$ mkdir demo &amp;&amp; cd demo # create project working dir:
$ truffle init # Init truffle.
Dapp work:
$ cp .../""MyContract"".sol contracts
(remove default example contracts in ./contracts and migrations/2_deploy_contracts.js  if desired)

$ "edit" migrations/2_deploy_contracts.js to add MyContract
WARN: ¡¡¡do not touch 1_initial_migration.js!!!


Compile sol to json: WARN: (requires solc installed)
$ truffle compile
(compiles /contracts/*.sol → build/contracts/*.json )
JS clients apps can then use the contract with code similar to:
import metacoin_artifacts from '../../build/contracts/MetaCoin.json'

Migrate to default network defined in truffle.js (localhost:8545)
(Ussually this correspond to the testrpc daemon)
$ truffle migrate
$ truffle test 
---------------------------
Deploy to ""real""/""test"" network

$ truffle deploy 
# sends contract to the Ethe. network. Will also update
# contracts.json adding the {""address"":...""} for the
#deployed contract
---------------------------
Create  ""JS"" front-end app (if profile present)
$ truffle serve # start web server with front-end
<!-- TODO_START :
config/app.json: build, deploy and ether-node rpc setup
./app: JS front-end app.
"truffle compile generated config/development/contracts.json: 
Contains the JS interface to the Eth. contract."
test/example.js:
Note: 
 contract.value.call() -> NO new transactions => NO Eth expended
 contract.setValue(5) -> new transaction => eth expended     
      
contract('Example', function(accounts) {
  it('should do more complex interaction', function(done) {
    var example = Example.at(Example.deployed_address);
    example.value.call().then( function(value) {
      assert.equal(value, 0, 'Value should be zero after deployment');
    }).then(function() {
      return example.setValue(5);
    }).then(function(tx) {
      return example.value.call();
    }).then(function(value) {
      assert.equal(value, 5, 'Value should be five');
    })
    .then(done).catch(done);
  });
});
Deploying new contract:
> web3.eth.getCoinbase(function(e,r) { console.log(e, r); })
null ""0x82e.....""
> Example.new({ from: ""=x82e..."" }).then(function(instance) { ... })
-->
</pre>
  </li>
  <li TODO><a href='https://github.com/ethpm/ethpm-js'>https://github.com/ethpm/ethpm-js</a>
      Javascript library for publishing and consuming Ethereum packages,
      provides utilities for publishing and consuming Ethereum packages based
      on the Ethereum Package Manager specification. It is meant to be integrated
      directly into development tools to support their use of the Ethereum Package Management ecosystem.
  </li>
  <li><a href="https://etherscan.io/pushTx"><def>https://etherscan.io/pushTx</def></a>: Send raw-transactions</li>
  </ul>

</td>
<td>
  <a href="https://docs.web3j.io/">Web3J</a><br/>
<pre xxxsmall zoom>
<a href="https://docs.web3j.io/getting_started.html">pom / gradle dependencies</a>
<a href="https://github.com/web3j/sample-project-gradle/blob/master/src/main/java/org/web3j/sample/Application.java">Example app</a>
<a href="https://docs.web3j.io/infura.html">Using infura</a>


SYNC. REQUESTS                        | CompletableFuture (Future ON ANDROID): | RXJAVA OBSERVABLE:
Web3ClientVersion web3ClientVersion = | Web3ClientVersion web3ClientVersion =  | web3.web3ClientVersion()
    web3.web3ClientVersion()          |     web3.web3ClientVersion()           |     .observable().subscribe(x -&gt; {
    .send().getWeb3ClientVersion();   |     .sendAsync().get();                |     String clientVersion = 
                                      |                  ^blocking             |         x.getWeb3ClientVersion();
                                      |                                        | });


TRANSACT WITH A SMART CONTRACT WRAPPER:       | CALL A SMART CONTRACT WRAPPER:
----------------------------------------------+---------------------------------------------
(changes status in blockchain, needs mining)  | (local query, no mining needed)
TransactionReceipt transactionReceipt =       | Type result = 
   contract.someMethod(                       |    contract.someMethod(<param1>, ...).send();
     "param1", ...).send();                   |
                                              | The "someMethod" in *.sol contract needs to be 
                                              | marked as "view". Otherwise the java wrapper
                                              | will generate code for new TXs returning
                                              | a TX receipt
</pre>
FILTERS
<pre xxxsmall zoom>
Subscribe for "new-blocks" events:                  | Subscribe for "new-TXs" events:                  | Subscribe for "new pending-TX" events: 
----------------------------------------------------+--------------------------------------------------+----------------------------------------
Subscription subscription =                         | Subscription subscription =                      | Subscription subscription = 
  web3j.blockObservable(false).subscribe(block -> { |   web3j.transactionObservable().subscribe(tx -> {|    web3j.pendingTransactionObservable().
    ...                        ^                    |       ...                                        |      subscribe(tx -> { ...  });
  });                          |                    |   });
                               |
                            Optionally:
  catchUpToLatestAndSubscribeToNewBlocksObservable(
        <startBlockNumber>, <fullTxObjects>)
        .subscribe(block -> {
            ...
});

<b>subscription.unsubscribe(); //when no longer required </b>
</pre>

<pre xxxsmall zoom>
<b>TOPIC FILTERS:</b> <b red>not supported on Infura</b>

EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
        DefaultBlockParameterName.LATEST, <contract-address>)
             .addSingleTopic(...)|.addOptionalTopics(..., ...)|...;
web3j.ethLogObservable(filter).subscribe(log -> {
    ...
});
</pre>
</td>
<td>
  Troubleshooting Common problems
  <ul xxxsmall zoom>
  <li><def>solc *bin output is empty, but there are no compilation warnings</def>
<pre>
PROBLEM:
    Next code compiles "OK" using
    SOLC INPUT               |  SOLC OUTPUT
    -------------------------|--------------------
    pragma solidity ^0.4.8;  |  A.bin  6060604...
    contract A {             |  B.bin  6060604...
      uint public a1;        |
    }                        |
                             |
    contract B <b>is A</b> { |
      uint8 public b1;       |
    }                        |

  <b red>Adding any constructor to the A contract, and keeping same B 
  generates erroneus empty B.bin</b>

SOLUTION:
   solc compiler consider the class abstract and does not generate any
   bin due to some of the following reasons:

 - B will need to provide parent A constructor with a parameter
   contract B is A {
     uint8 public b1;
   
     <b blue>constructor(address _a) A(_a) { // or A(0x00112...)
        ...
     }</b>
   }

 - B does NOT implementsall mehtods of declared interfaces or base clases
</pre>
  </li>
  <li>Problem: <def>Transaction with same hash already imported</def> error:
<pre xxxsmall zoom>
<a href="https://ethereum.stackexchange.com/questions/9055/cant-broadcast-ethereum-transaction-whats-wrong-with-this-transaction">REF.1</a>, <a href="https://gitter.im/web3j/web3j?at=58d1e9ce5917e26076be161c">REF 2.web3j Gitter</a><br/>
Solution: This means that the same transaction is sent twice with onley the nonce different.<br/>
 Probably it's a client error.
"""
</pre>
  </li>
  </ul>
</td>
<td>
  <b>PRICE CALCULATION</b>
  <ul xxxsmall zoom>
  <li><a TODO href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees">Design-Rational: Gas and fees</a></li>
  <li>
<pre>
Instruction cost: <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">REF</a> 
The most expensive operations by far are storage usage:
- sstore costs 20000 gas for first write to a new position
- sstore costs  5000 gas for subsequent writes to an existing position
- sload  costs   500 gas
- Most instructions costs 3~10 gases.
- Gas costs are set somewhat arbitrarily, and could well change in 
  the future. As costs change, compilers would make different choices.

TX cost: <a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603">REF</a>
- 21000 paid for every transaction.
-     4 paid for every zero byte of data or code for a transaction.
-    68 paid for every non-zero byte of data or code for a transaction.

- Small negative numbers are mostly 1s, costing you quite a lot of gas.

Logging Gas Costs:  <a href="https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9">REF</a>
  - The gas costs for the logging primitives depends on how many topics you have and how much data you log:
    (constants are defined in protocol_params)

LogDataGas       uint64 = 8   // Per byte in a LOG operation's data
topicLogTopicGas uint64 = 375 // Per LOG 
LogGas           uint64 = 375 // Per LOG operation
MemoryGas        uint64 = 3    // Per byte of memory used

If you are passing in the log data as calldata to a TX,
you’ll need to pay for the transaction data too. The gas costs for calldata are:

TxDataZeroGas      uint64 = 4     // zero tx data abyte
TxDataNonZeroGas   uint64 = 68    // non-zero tx data byte

Assuming all 32 bytes are non-zero, this is still a lot cheaper than storage:

// cost of 32 bytes of log data
32 * 68 = 2176 // tx data cost
32 *  8 =  256 // log data cost
32 *  3 =   96 // memory usage cost
375 // log call cost
----
total (2176 + 256 + 96 + 375) ~14% of sstore for 32 bytes
Most of the gas cost is actually spent on transaction data, not for the log operation itself

The reason that a log operation is cheap is because the log data isn’t really stored in the 
blockchain. Logs, in principle, can be recalculated on the fly as necessary.
Miners, in particular, can simply throw away the log data, because future calculations 
can't access past logs anyway.

The network as a whole does not bear the cost of logs. 
Only the API service nodes need to actually process, store, and index the logs.

So the cost structure of logging is just the minimal cost to prevent log spamming.
</pre>
  </li>
  <li>Extracted from stack-overflow:<br/>
   <p>
   Q: """The price of ETH has gone from ~8 USD/ETH to ~90 ETH/USD in 6 months,
      but when I view transactions on the blockchain (example), I see that most people are still using
      the default gas price of 2e10 wei/gas. Shouldn't we be lowering the gas prices on our transactions
      to account for this price change? 
      I have built a Dapp where low transaction fees are an important selling point. I intend to drop
      my gas price to 5e9 (a 75% reduction). Will my transactions still clear in a timely fashion?"""
   </p>
   <p>
   A: """Absolutely. Everyone should. There's a great site here that will help you understand gas and gas prices.
   It's called Ethereum Gas Station: http://ethgasstation.info/
   They just recently made this post which explains something they call the Safe Gas Price:
    https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91"""
  </p>
  </li>
  <li>(Interesting "offtopic") See Wikipedia entries on:
<a hef='https://en.wikipedia.org/wiki/Hal_Finney_%28computer_scientist%29' >Hal Finney</a>
<a hef='https://en.wikipedia.org/wiki/Nick_Szabo'                          >Nick Szabo</a>
<a hef='https://en.wikipedia.org/wiki/Claude_Shannon'                      >Claude Shannon</a>
<a hef='https://en.wikipedia.org/wiki/Charles_Babbage'                     >Charles Babbage</a>
<a hef='https://en.wikipedia.org/wiki/Ada_Lovelace'                        >Ada Lovelace</a>
<a hef='https://en.bitcoin.it/wiki/Wei_Dai'                                >Wei Dai</a>
  </li>
  </ul>
  <a href='http://ethgasstation.info/calculator.php'>eth gas station calc</a>
<pre  xxxsmall zoom>
200€/ether:
Transaction gas price: 21000 gas/tx       32bytes Contract storage: 20000 gas
+----------+-----------------+--------+   +----------+-----------------+--------+
| gasprice | total gas price | total €|   | gasprice | total gas price | total €|
+----------+-----------------+--------+   +----------+-----------------+--------+
|  1gwei   | 21000 *  1gwei  | 0,0042 |   |  1gwei   | 21000 *  1gwei  | 0,0040 |
| 20gwei   | 21000 * 20gwei  | 0,0420 |   | 20gwei   | 21000 * 20gwei  | 0,0400 |
+----------+-----------------+--------+   +----------+-----------------+--------+

For a transaction updating 64bytes (32bytes from debitor account to 32bytes creditor account)
+----------+-----------+
| gasprice | total € *1|
+----------+-----------+
|  1gwei   |   0,0122  |
| 20gwei   |   0,2440  |
+----------+-----------+

Logs cost: 375 gas for a LOG operation + 8 gas per log data byte + 375 gas for each topic. 200€/eth:

+----------+-----------+----------+--------------------+------------
|log  size | num.topics| gasprice | total gas price*1  |     total €
+----------+-----------+----------+--------------------+------------
|1024bytes |     3     |   1gwei  |  9692 *  1gwei     | 0,0019384 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0011192 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0005596 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0002798 €
+----------+-----------+----------+--------------------+------------
|          |           |  20gwei  |  9692 * 20gwei     | 0,0387680 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0223840 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0111920 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0055960 €
+----------+-----------+----------+--------------------+------------

(375 gas/LOG * 1LOG ) + (8 gas/byte * 1024byte) + (375 gas/topic * 3 topic) = 375 + 8192 + 1125 = 9692
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 3 topic) = 375 + 4096 + 1125 = 5596
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 1 topic) = 375 + 2048 +  375 = 2798
(375 gas/LOG * 1LOG ) + (8 gas/byte *  128byte) + (375 gas/topic * 0 topic) = 375 + 1024        = 1399    
</pre>
</td>

</tr>
</table>
  DevOps
<table>
<tr>
<td>
   <a TODO href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#network-formation">RLPx: Crypto.Net.&amp;Transport Proto.</a>

<pre xxxsmall zoom>
each node is expected to maintain a static private key which is saved and 
restored between sessions.  It is recommended that the private key can only 
be reset manually, for example, by deleting a file or database entry.

There are two kinds of connections which can be established.  A node can connect to:
  - a known peer which has previously been connected to 
    and from which a corresponding session token is available for
    authenticating the requested connection
  - a new peer
</pre>
</td>
<td>
  <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">Geth Console</a>
<pre xxxsmall zoom>
Interactive mode:
  $ get (--preload "scripts/myScript1.js,scripts/myScript2.js" attach # Attach to local running process
Non-interactive mode:
  $ get --exec "eth.blockNumber" attach
  $ geth --exec 'loadScript("/tmp/checkbalances.js")' attach http://123.123.123.123:8545

---------------------
Examples:
CHECKING ACCOUNT BALANCES
$ cat /Users/username/gethload.js
function checkAllBalances() {
  var totalBal = 0;
  for (var acctNum in eth.accounts) {
    var acct = eth.accounts[acctNum];
    var acctBal = web3.fromWei(eth.getBalance(acct), "ether");
    totalBal += parseFloat(acctBal);
    console.log("  eth.accounts[" + acctNum + "]:" + acct 
              + "  balance: " + acctBal + " ether");
  }
  console.log("  Total balance: " + totalBal + " ether");
};
---------------------
&gt; loadScript("/Users/username/gethload.js")
&gt; checkAllBalances();
  eth.accounts[0]: 0xd1ade25ccd3d550a7eb532ac759cac7be09c2719 	balance: 63.11848 ether
  eth.accounts[1]: 0xda65665fc30803cb1fb7e6d86691e20b1826dee0 	balance: 0 ether
  eth.accounts[2]: 0xe470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32 	balance: 1 ether
</pre>
</td>
<td>
  Disk Space
<pre xxxsmall zoom>
<a href="https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs/826#826">REF</a>
Last Update: May 14th, 2018 / Block ~ 5_600_000
Geth (Go) 1.8.3 Ubuntu 16.4 LTS,  VPS + SSD | Parity (Rust)
--------------------------------------------+--------------------------------------------
Client / Mode    | Block Number |Disk Space | Client / Mode      |Block Number|Disk Space
=================|==============|========== | ===================|============|==========
geth light       | 5_600_000    |363M       | parity light       |5_600_000   | 89M
geth fast full   | 5_600_000    |142G       | parity warp fast   |5_600_000   | 82G
geth full full   | ?_???_??? [1]|239G + [1] | parity full fast   |5_600_000   | 78G
geth full archive| 4_980_000 [2]|671G       | parity full archive|5_600_000   |1.1T
                                            |                                      
[1] disk was full, I wasn't able to repeat  |
    this sync mode                          |
[2] I didn't manage to fully sync           |
    within 6 weeks, unfortunately.          |
--------------------------------------------+--------------------------------------------
</pre>
</td>
<td colsep> </td>
<td>
  <p TODO>EXTERNAL STORAGE (IPFS, Maidsafe, SWARN,...)
<!--
TODO: Compare with alternative Storage "providers": IPFS , Maidsafe, Storj
- IPFS is just a protocol like http. It is unmotivated (don't have tokens).
- Eris is permissioned blockchain thing and use IPFS underneath.
- Storj, SAFE Network, Sia and Filecoin: motivated storage networks with different underlying protocols and design decisions.
- Swarm is an organizational idea. A philosophical structure.
  ""serverless hosting incentivised peer-to-peer storage and content distribution""
  ""From the end user's perspective, Swarm is not that different from WWW,
    except that uploads are not to a specific server. The objective is to peer-to-peer
    storage and serving solution that is DDOS-resistant, zero-downtime, fault-tolerant
    and censorship-resistant as well as self-sustaining due to a built-in incentive
    system which uses peer to peer accounting and allows trading resources for payment.
    Swarm is designed to deeply integrate with the devp2p multiprotocol network layer
    of Ethereum as well as with the Ethereum blockchain for domain name resolution, 
    service payments and content availability insurance. """"""

""""""Two major features of swarm that sets it apart from other decentralised distributed storage solutions (bittorent, zeronet, IPFS) are 'upload and disappear' and the incentive system. The former refers to fact that Swarm does not only serve content, but it also provides a cloud storage service. Unlike related systems, you do not only publish the fact you host content, but there is a genuine sense in which you can just upload stuff to the swarm and potentially disappear (drop off as a node, disconnect or just operate without storage entirely) right away. Swarm aspires to be the generic storage and delivery service catering for all usecases ranging from serving low latency realtime interactive web applications as well as acting as guaranteed persistent storage for rarely used content. The incentive system makes sure that participating nodes following their rational self interest nontheless converge on an emergent swarm behaviour that is beneficial for the entire system as well as economically self-sustaining. In particular, it allows nodes in the network to pool their bandwidth and storage resources in the most efficient way to collectively provide services. """""""
here are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account.
-->

  </p>
  <b TODO TODO>FORMAL VERIFICATION</b>
<!--
FORMAL Verification
https://github.com/pirapira/eth-isabelle
https://github.com/pirapira/ethereum-formal-verification-overview
"Why3 Solidity
Why3 is a platform for deductive program verification. It provides a rich language for specification and programming, called WhyML, and relies on external theorem provers, both automated and interactive, to discharge verification conditions. (See the specific section below for the list of supported provers.) Why3 comes with a standard library of logical theories (integer and real arithmetic, Boolean operations, sets and maps, etc.) and basic programming data structures (arrays, queues, hash tables, etc.). A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism. WhyML is also used as an intermediate language for the verification of C, Java, or Ada programs. (See Projects using Why3 below.) Why3 can be easily extended with support for new theorem provers. Why3 can be used as a software library, through an OCaml API. 

"
"https://forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts

""""""We just merged a first pull request that allows Solidity contracts to be formally verified using a toolkit called why3.
This means that a computer creates and checks a mathematical proof of assertions about the behaviour of the contract.
Only a small subset of Solidity is supported for now, but that makes it already possible to verify a recursive binary search routine on arrays:
https://gist.github.com/chriseth/0c671e0dac08c3630f47""""""

""""""How to use it on the example
The solidity compiler (only solc at latest develop for now) can translate the source code into a different programming language which can be understood by why3 (the language is a dialect of ocaml). To do that, call it as ""solc \-\-formal -o /tmp/output_directory/ source.sol"". Furthermore, using special tags in the Solidity comments of the form ""///@why3 ..."" you can formulate assertions and requirements that can be understood by the why3 framework and will be literally inserted into the generated code.

After that, you can use ""why3 ide /tmp/output_directory/solidity.mlw"" to start a graphical version of the toolkit and perform the verification.
How to install why3
I am not aware of any binary packages, so you have to download the source from the website.
As why3 itself is only a frontend to the real workhorses, the provers, you need to install a prover. I tried ""alt-ergo"" and Z3 - the first is part of the ubuntu distribution, the second has binaries for most platforms.

After installing the prover (and making sure it is in the PATH), call ""why3 config \-\-detect"" and it should detect your prover. """""""
"Video Tutorial:
https://www.youtube.com/watch?v=Mzh4fyoaBJ0&feature=youtu.be&list=PL9oaY6Y4QxRZybj86eGItGVApxLXVIXHz"
https://gitter.im/ethereum/formal-methods
"https://en.wikipedia.org/wiki/Logical_harmony

Logical harmony, a name coined by Sir Michael Dummett, is a supposed constraint on the rules of inference (https://en.wikipedia.org/wiki/Rules_of_inference) that can be used in a given logical system(https://en.wikipedia.org/wiki/Logical_system)"
-->
  <hr xxxsmall />
  <a TODO href="http://ethereumj.io/blog/2015/09/09/friendly-ether-bot/">External Inputs (Oracles)</a>
  <a href="https://azure.microsoft.com/en-us/blog/cryptletsdd/">MS.Bletchley Cryplets</a>
</td>
</tr>
</table>
</body>
<br/>
<!--
TODO_START:
_____________________________
See also alternatives to Whisper: "Message Contract" and "Telehash"
https://github.com/ethereum/wiki/wiki/Whisper
"""""""
In a nutshell whisper is a communication protocol for DApps to communicate with each other.
Use case
    DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.

    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.
""""""
"
_______________________________________________________
RPC Methods: JS API to Ethereum network:
https://github.com/ethereum/wiki/wiki/JavaScript-API
"eth_accounts                                           eth_getTransactionCount
eth_blockNumber                                        eth_getTransactionReceipt
eth_call                                               eth_hashrate
eth_coinbase                                           eth_mining
eth_compileSolidity                                    eth_newBlockFilter
eth_estimateGas                                        eth_newFilter (includes log/event filters)
eth_gasPrice                                           eth_sendTransaction
eth_getBalance                                         eth_sendRawTransaction
eth_getBlockByNumber                                   eth_sign
eth_getBlockByHash                                     eth_syncing
eth_getCode (only supports block number “latest”)      eth_uninstallFilter
eth_getCompilers                                       net_listening
eth_getFilterChanges                                   net_peerCount
eth_getFilterLogs                                      net_version
eth_getLogs                                            miner_start
eth_getStorageAt                                       miner_stop
eth_getTransactionByHash                               rpc_modules
eth_getTransactionByBlockHashAndIndex                  web3_clientVersion
eth_getTransactionByBlockNumberAndIndex                web3_sha3
_______________________________________________________
_______________________________________________________
Geth:
"- Keys are stored under <DATADIR>/keystore(backup regularly)
- keyfiles format(2017-05): UTC--<created_at UTC ISO8601>-<address hex>

geth account [arguments...]
geth account help <subcommand>
      subcommand:
    - new       :  create new accounts. Will ask for password/passphrase. Will return public address {168bc315a2ee09042d83d7c5811b533620531f67}
    - list      :  list all existing accounts. Example
                    | Account #0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b}
                    | Account #1: {c385233b188811c9f355d4caec14df86d6248235}
                    | Account #2: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
    - import    :  import a private key into a new account
                    | $ geth --datadir /someOtherEthDataDir  account import ./key.prv
                    | The new account will be encrypted with a passphrase.
                    | Please enter a passphrase now.
                    | Passphrase:
                    | Repeat Passphrase:
                    | Address: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
    -           :   | export (unencrypted format >>NOT<< supported)
    - update    :  migrate to newest key format. account will be saved in newest version in encrypted format
                   you are prompted for passphrase to unlock old-format account wallet and another to save updated file
                   (can also be used to change file/wallet password)
                    | $ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b
                    | Unlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b | Attempt 1/3
                    | Passphrase:
                    | 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b
                    | Account 'a94f5374fce5edbc8e2a8697c15331677e6ebf0b' unlocked.
                    | Please give a new password. Do not forget this password.
                    | Passphrase:
                    | Repeat Passphrase:
                    | 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b

    -           :  change password



using account NON-interactively (not connected to a geth node):
   STEP 1: unlock account wallet for one session: 
   $ getch ??? --unlock <comma_separated_account_list>(in hex)  # with on list -> first found account
   Example:
   $ geth --unlock primary --rpccorsdomain localhost --verbosity 6 2>> geth.log 
   $ geth --unlock "0x407d73d8a49eeb85d32cf465507dd71d507100c1,0,5,e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32"


_______________________________________________________
 - Libraries / Libraries dispatcher / ...
 https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736
 https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd
 https://blog.aragon.one/advanced-solidity-code-deployment-techniques-dc032665f434
 https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd

______________________________________________

{
"Alt 2: npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use
"
}


{ INSTALL SOLIDITY COMPILER (solc)    
Alt 1   "npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use"   
Alt 2   "PPAs for Ubuntu. For the latest stable version.
Solidity Documentation, Release 0.4.8-develop
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc

If you want to use the cutting edge developer version:
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc"  
}
_____________________________________
LexiFi's Modeling Language for Finance

Screenshot

Developed by the company LexiFi, the Modeling Language for Finance (MLFi) is the first formal language that accurately describes the most sophisticated capital market, credit, and investment products. MLFi is implemented as an extension of OCaml.

MLFi users derive two important benefits from a functional programming approach. First, the declarative formalism of functional programming languages is well suited for specifying complex data structures and algorithms. Second, functional programming languages have strong list processing capabilities. Lists play a central role in finance where they are used extensively to define contract event and payment schedules.

In addition, MLFi provides crucial business integration capabilities inherited from OCaml and related tools and libraries. This enables users, for example, to interoperate with C and Java programs, manipulate XML schemas and documents, and interface with SQL databases.

Data models and object models aiming to encapsulate the definitions and behavior of financial instruments were developed by the banking industry over the past two decades, but face inherent limitations that OCaml helped overcome.

LexiFi's approach to modeling complex financial contracts received an academic award in 2000, and the MLFi implementation was elected “Software Product of the Year 2001” by the magazine Risk, the leading financial trading and risk management publication. MLFi-based solutions are gaining growing acceptance throughout Europe and are contributing to spread the use of OCaml in the financial services industry
___________________________
The ASTRÉE Static Analyzer

David Monniaux (CNRS), member of the ASTRÉE project, says: “ASTRÉE is a static analyzer based on abstract interpretation that aims at proving the absence of runtime errors in safety-critical software written in a subset of the C programming language.”

“Automatically analyzing programs for exactly checking properties such as the absence of runtime errors is impossible in general, for mathematical reasons. Static analysis by abstract interpretation works around this impossibility and proves program properties by over-approximating the possible behaviors of the program: it is possible to design pessimistic approximations that, in practice, allow proving the desired property on a wide range of software.”

“So far, ASTRÉE has proved the absence of runtime errors in the primary control software of the Airbus A340 family. This would be impossible by software testing, for testing only considers a limited subset of the test cases, while abstract interpretation considers a superset of all possible outcomes of the system.”

“ASTRÉE is written in OCaml and is about 44000 lines long (plus external libraries). We needed a language with good performance (speed and memory usage) on reasonable equipment, easy support for advanced data structures, and type and memory safety. OCaml also allows for modular, clear and compact source code and makes it easy to work with recursive structures such as syntax trees.”

____________________________________________
https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall
Difference between CALL, CALLCODE and DELEGATECALL
   
CALL and CALLCODE take the same number of operands (in the execution stack).
For the exception flag being pushed on top of the stack: 0 means exception, 1 means successful execution.
CALL is easy to understand, but I could not digest the subtle difference between CALL & CALLCODE. It is stated in the yellow paper that for

CALLCODE: This means that the recipient is in fact the same account as at present, simply that the code is overwritten.

What does it mean by the code is overwritten? Does that mean I can ask the contract to execute some external code? It would be helpful if anyone can provide me an example to differentiate between the two.

EDIT: DELEGATECALL was added in Homestead what is the difference?
Response:
DELEGATECALL basically says that I'm a contract and I'm allowing (delegating) you to do whatever you want to my storage. DELEGATECALL is a security risk for the sending contract which needs to trust that the receiving contract will treat the storage well.

DELEGATECALL was a new opcode that was a bug fix for CALLCODE which did not preserve msg.sender and msg.value. If Alice invokes Bob who does DELEGATECALL to Charlie, the msg.sender in the DELEGATECALL is Alice (whereas if CALLCODE was used the msg.sender would be Bob).
Details

When D does CALL on E, the code runs in the context of E: the storage of E is used.

When D does CALLCODE on E, the code runs in the context of D. So imagine that the code of E is in D. Whenever the code writes to storage, it writes to the storage of account D, instead of E.

contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3("setN(uint256)")), _n); // E's storage is set, D is not modified 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }
}

contract E {
  uint public n;
  address public sender;

  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    // msg.sender is D if invoked by D's callcodeSetN. None of E's storage is updated
    // msg.sender is C if invoked by C.foo(). None of E's storage is updated

    // the value of "this" is D, when invoked by either D's callcodeSetN or C.foo()
  }
}

contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}

When D does CALLCODE on E, msg.sender inside E is D as commented in the code above.

When an account C invokes D, and D does DELEGATECALL on E, msg.sender inside E is C. That is, E has the same msg.sender and msg.value as D.

____________________________________________

    <hr/>
    Libraries: similar to contracts, but their purpose is that
    they are deployed only once at a specific address and their code is reused
    using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. 
    In comparison to contracts:
    <ul>
      <li>No state variables</li>
      <li>Cannot inherit nor be inherited</li>
      <li>Cannot recieve Ether</li>
    </ul>
____________________________________________

'Ethereum client' refers to any node able to parse and verify the blockchain, its smart contracts ... .
 It also provides (JSON-RPC?) interfaces to create transactions and mining"
____________________________________________

Third party non-official clients:

parity (Rust client): https://github.com/ethcore/parity

ethereumj Java client: https://github.com/ethereum/ethereumj

ethereumjs-vm: https://github.com/ethereumjs/ethereumjs-vm

node-blockchain-server: https://github.com/ethereumjs/node-blockchain-server

____________________________________________
____________________________________________
http://martin.swende.se/blog/EVM-Assembly-trick.html#
"""I recently discovered a method to do generic proxying of Ethereum calls. Skip further down for nitty gritty details, I’ll start this off with some basics.
The problem

Sometimes, it’s convenient to build contract factories. For example, say you want to implement crowdsourcing, or auctions, or games, or DAOs. In those cases, instead of having one “Mother” auction which keeps track of active auctions (which, in turn keep track of bidders, offers and items), it makes sense to implement each auction/crowdfund/game/DAO as it’s own contract.

One problem is that these contracts are quite heavy; creating them may be very expensive and the creation of several may be limited by block gas limits. To counter this, the library-model can be used instead: """
____________________________

<a href='http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers'>Function modifiers</a>

_________________________
Security Considerations:
http://solidity.readthedocs.io/en/develop/security-considerations.html#security-considerations
________________________
The Ethereum Package Registry
   https://www.ethpm.com/
 A package index for Ethereum smart contract packages.

The Ethereum Package Registry is a package index for Ethereum smart contract packages. The registry is based on the ERC190 Smart Contract Packaging Specification.

"""Dear Ethereum,

We need to talk. You're not the easiest platform to work with. Don't get me wrong, you have some great qualities but it's time to grow up and start acting a bit more... mature

Since we care about you and really want you to succeed we made you something that should help. It's called a package index.

I know change can be a little scary but we're sure that once you try it you'll love it. Developers are going to like you more. Their bosses may even stop seeing you as the dangerous kid teaching their devs bad habits like copy/pasting code.

Please give it a try. We really do want the best for you.

Piper & Tim
"""
___________________
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids
List of Chain ID's:
CHAIN_ID    Chain(s)
1   Ethereum mainnet
2   Morden (disused), Expanse mainnet
3   Ropsten
4   Rinkeby
30  Rootstock mainnet
31  Rootstock testnet
42  Kovan
61  Ethereum Classic mainnet
62  Ethereum Classic testnet
1337    Geth private chains (default)
_____________________________
https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88
_____________________________
Add notes about Zepellin https://openzeppelin.org/ Open framework or reusable security contracts for Solidity language (Ethereum)
- create links to interesting sites:
http://www.digitalchamber.org/smart-contract-alliance.html 
http://ethereum.stackexchange.com/
https://www.google.es/?q=smart+contract+formal+verification
_____________________________
formal verification for Smart Contracts ( https://chriseth.github.io/notes/talks/formal_devcon2/#/ ,  http://www.cs.umd.edu/~aseem/solidetherplas.pdf , 
https://www.google.es/?q=smart+contract+formal+verification )

______________________
APP: Ethereum atomic Swaps
   https://github.com/AltCoinExchange/ethatomicswap
  created by https://www.altcoin.io, "A truly decentralized cryptocurrency exchange. Powered by Atomic Swaps."
______________________
1 Log per TX (NO compactado):
Cost  TX:    21000 gas/TX    * 1TX       = 21000
Coste evento:  375 gas/LOG   * 1LOG      =   375
Coste Topic:   375 gas/topic * 3topic    =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes =  1240
                                          ------
                                 TOTAL     23740 gas   = 23740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.228  Eu

5 Logs per TX (compactado):
Cost  TX:    21000 gas/TX    * 1TX        = 21000
Coste evento:  375 gas/LOG   * 1LOG       =   375
Coste Topic:   375 gas/topic * 3topic     =  1125
Coste byte/logs: 8 gas/byte  * 1500 bytes = 12400
                                           ------
                                  TOTAL     34900 gas  = 34900 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.33504 Eu (0.07 Eu 1Log)


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
                                               ------
                                      TOTAL    101000 gas  = 101000 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.9696 Eu


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
Coste evento:  375 gas/LOG   * 1LOG           =   375
Coste Topic:   375 gas/topic * 3topic         =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes      =  1240
                                               ------
                                      TOTAL    103740 gas  = 103740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.995904 Eu
-------------------------------------------------
________________________________
https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#.gbg2nh4o5

Onward with Ethereum Smart Contract Security

If you’re new to Ethereum development, I recommend you read our Hitchhiker’s Guide to Smart Contracts in Ethereum before proceeding.

Learning Ethereum Smart Contract security is a very hard endeavor. There are few good guides and compilations, such as Consensys’ Smart Contracts 
Best Practices, or the Solidity Documentation Security Considerations. But the concepts are very hard to remember and internalize without writing your own code.

I’ll attempt a slightly different approach. I’ll explain some recommended strategies to improve smart contract security and show code examples where not
 following them results in problems. I’ll also show you code samples you can use to protect your smart contracts. Hopefully, this will help create a muscle
 memory of things to avoid, which will trigger mental warnings when writing actual code.

Without further ado, let’s dive into the best practices:
Fail as early and loudly as possible

A simple yet powerful programming good practice is to make your code fail as promptly as possible. And be loud about it. Let’s see an example of a function
 that behaves timidly:

// UNSAFE CODE, DO NOT USE!

contract BadFailEarly {
  uint constant DEFAULT_SALARY = 50000;
  mapping(string => uint) nameToSalary;

  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length != 0 && nameToSalary[name] != 0) {
      return nameToSalary[name];
    } else {
      return DEFAULT_SALARY;
    }
  }
}

We want to avoid a contract failing silently, or continuing execution in an unstable or inconsistent state. The function getSalary is checking for conditions 
before returning the stored salary, which is a good thing. The problem is, in case those conditions are not met, a default value is returned. This could hide 
an error from the caller. This is an extreme case, but this kind of programming is very common, and normally arises from fear of errors breaking our app.
Truth is, the sooner we fail, the easier it will be to find the problem. If we hide errors, they can propagate to other parts of the code and cause inconsistencies
 which are difficult to trace. A more correct approach would be:

contract GoodFailEarly {
  mapping(string => uint) nameToSalary;
  
  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length == 0) throw;    
    if (nameToSalary[name] == 0) throw;
    
    return nameToSalary[name];
  }
}

This version also shows another desirable programming pattern which is separating preconditions and making each fail separately. Note that some of these
 checks (especially those depending on internal state) can be implemented via Function Modifiers.
Favor pull over push payments

Every Ether transfer implies potential code execution. The receiving address can implement a fallback function that can throw an error. Thus, we should never 
trust that a send call will execute without error. A solution: our contracts should favor pull over push for payments. Take a look at this innocent looking code for 
a bidding function:

// UNSAFE CODE, DO NOT USE!

contract BadPushPayments {
  address highestBidder;
  uint highestBid;
 
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0) {
      // return bid to previous winner
      if (!highestBidder.send(highestBid)) {
        throw;
      }
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
}

Note that the contract calls the send function and checks its return value, which seems reasonable. But it calls send in the middle of a function, which is unsafe. Why? Remember that, as stated above, send can trigger the execution of code in another contract.

Imagine someone bids from an address which simply throws an error every time someone sends money to it. What happens when someone else tries to outbid that? The send call will always fail, bubbling up and making bid throw an exception. A function call that ends in error leaves the state unchanged (any changes made are rolled back). That means nobody else can bid, and the contract is broken.

The easiest solution is to separate payments into a different function, and have users request (pull) funds independently of the rest of the contract logic:

contract GoodPullPayments {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  
  function bid() external {
    if (msg.value < highestBid) throw;
    
    if (highestBidder != 0) {
      refunds[highestBidder] += highestBid;
    }
    
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdrawBid() external {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund)) {
      refunds[msg.sender] = refund;
    }
  }
}

This time, we use a mapping to store refund values for each outbid bidder, and provide a function to withdraw their funds. In case of a problem in the send call, only that bidder is affected. This is a simple pattern that solves many other problems (such as reentrancy), so remember: when sending ether, favor pull over push payments.

I’ve implemented a contract you can inherit from to easily use this pattern. Here’s an example showing how to use it.
Order your function code: conditions, actions, interactions

As an extension of the fail-early principle, a good practice is to structure all your functions as follows: first, check all the pre-conditions; then, make changes to your contract’s state; and finally, interact with other contracts.

Conditions, actions, interactions. Sticking to this function structure will save you lots of problems. Let’s see an example of a function using this pattern:

function auctionEnd() {
  // 1. Conditions
  if (now <= auctionStart + biddingTime)
    throw; // auction did not yet end
  if (ended)
    throw; // this function has already been called

  // 2. Effects
  ended = true;
  AuctionEnded(highestBidder, highestBid);

  // 3. Interaction
  if (!beneficiary.send(highestBid))
    throw;
  }
}

This is in line with the fail fast principle, as conditions are checked in the beginning. It also leaves potentially dangerous interactions with other contracts to the very end.
Be aware of platform limits

The EVM has a lot of hard limits on what our contracts can do. These are platform-level security considerations, but may threaten your particular contract’s security if you don’t know about them. Let’s take a look at the following innocent-looking employee bonus management code:

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (var i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

Read the code: it’s pretty straight-forward and seems correct. It hides 3 potential problems, though, based on platform limits.

The first problem is that the type of i will be uint8, because this is the smallest type that is required to hold the value 0. If the array has more than 255 elements, the loop will not terminate, resulting in gas depletion. Better use the explicit type uint for no surprises and higher limits. Avoid declaring variables using var if possible. Let’s fix that:

// STILL UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

The second thing you should consider is the gas limit. Gas is Ethereum’s mechanism to charge for network resources. Every function call that modifies state has a gas cost. Imagine calculateBonus calculates the bonus for each employee based on some complex computation like calculating the profit over many projects. This would spend a lot of gas, which could easily reach the transaction’s or block’s gas limit. If a transaction reaches the gas limit, all changes will be reverted but the fee is still paid. Be aware of variable gas costs when using loops. Let’s optimize the contract by separating the bonus calculation from the for loop. Please note that this still has the issue that as the employees array grows, the gas cost grows.

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  mapping(address => uint) bonuses;  
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation modifying the bonus...
    bonuses[employee] = bonus;
  }
}

Last, there is the call stack depth limit. The EVM’s call stack has a hard limit of 1024. That means that if the amount of nested calls reaches 1024, the contract will fail. An attacker can call a contract recursively 1023 times and then call our contract’s function, causing sends to silently fail because of this limit. PullPaymentCapable.sol was described above, and allows to easily implement pull payments. Inheriting from PullPaymentCapable and using asyncSend protects you from this.

Here’s a modified version of the code that fixes all these issues:

import './PullPaymentCapable.sol';

contract GoodArrayUse is PullPaymentCapable {
  address[] employees;
  mapping(address => uint) bonuses;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      asyncSend(employee, bonus);
    }
  }

  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation...
    bonuses[employee] = bonus;
  }
}

To sum up, be sure to remember about (1) limits in the types you’re using, (2) limits in the gas costs of your contract, and (3) the call stack depth limit.
Write tests

Writing tests is a lot of work, but will save you from regression problems. A regression bug appears when a previously correct component gets broken based on a recent change.

I’ll be writing a more extensive guide on testing soon, but if you’re curious you can check Truffle’s testing guide.
Fault tolerance and Automatic bug bounties

Thanks to Peter Borah for inspiration on these two ideas. Code reviews and security audits are not enough to be safe. Our code needs to be ready for the worst. In case there is a vulnerability in our smart contract, there should be a way for it to safely recover. Not only that, but we should try to find those vulnerabilities as early as possible. That’s where automatic bug bounties built into our contract can help.

Let’s take a look at this simple implementation of an automatic bug bounty for a hypothetical Token contract:

import './PullPaymentCapable.sol';
import './Token.sol';

contract Bounty is PullPaymentCapable {
  bool public claimed;
  mapping(address => address) public researchers;
  
  function() {
    if (claimed) throw;
  }
  
  function createTarget() returns(Token) {
    Token target = new Token(0);
    researchers[target] = msg.sender;
    return target;
  }
  
  function claim(Token target) {
    address researcher = researchers[target];
    if (researcher == 0) throw;
    
    // check Token contract invariants
    if (target.totalSupply() == target.balance) {
      throw;
    }
    asyncSend(researcher, this.balance);
    claimed = true;
  }
}

As before, we’re using PullPaymentCapable to make our outgoing payments safe. This Bounty contract allows researchers to create copies of the Token contract we want audited. Anyone can contribute to the bug bounty by sending transactions to the Bounty contract’s address. If any researcher manages to corrupt his copy of the Token contract, making some invariant break (for example, in this case, making the total supply of tokens different from the Token’s balance), he’ll get the bounty reward. Once the bounty is claimed, the contract won’t accept any more funds (that nameless function is called the contract’s fallback function, and is executed every time the contract is sent money directly).

As you can see, this has the nice property that it is a separate contract and requires no modification of our original Token contract. Here’s a full implementation available on GitHub for anyone to use.

As for fault tolerance, we will need to modify our original contract to add extra safety mechanisms. A simple idea is to allow a contract’s curator to freeze the contract as an emergency mechanism. Let’s see a way to implement this behavior via inheritance:

contract Stoppable {
  address public curator;
  bool public stopped;

  modifier stopInEmergency { if (!stopped) _ }
  modifier onlyInEmergency { if (stopped) _ }
  
  function Stoppable(address _curator) {
    if (_curator == 0) throw;
    curator = _curator;
  }
  
  function emergencyStop() external {
    if (msg.sender != curator) throw;
    stopped = true;
  }
}

Stoppable allows one to specify a curator address that can stop the contract. What does “stopping the contract” mean? That’s to be defined by the child contract inheriting from Stoppable by using the function modifiers stopInEmergency and onlyInEmergency. Let’s see an example:

import './PullPaymentCapable.sol';
import './Stoppable.sol';

contract StoppableBid is Stoppable, PullPaymentCapable {
  address public highestBidder;
  uint public highestBid;
  
  function StoppableBid(address _curator)
    Stoppable(_curator)
    PullPaymentCapable() {}
  
  function bid() external stopInEmergency {
    if (msg.value <= highestBid) throw;
    
    if (highestBidder != 0) {
      asyncSend(highestBidder, highestBid);
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdraw() onlyInEmergency {
    suicide(curator);
  }
}

In this toy example, the bid can now be stopped by a curator, defined when the contract is created. While the StoppableBid is in normal mode, only the bid function can be called. If something weird happens and the contract is in an inconsistent state, the curator can step in and activate the emergency state. This makes the bid function uncallable, and allows the function withdraw to work.

In this case, emergency mode would only allow the curator to destroy the contract and recover the funds, but in a real case, recovery logic could be more complex (for example returning funds to their owners). Here’s an implementation of Stoppable available on GitHub for anyone to use.
Limit the amount of funds deposited

Another way to protect our smart contracts from attacks is to limit their scope. Attackers will most probably target high-profile contracts managing millions of dollars. Not all smart contracts need to have such high stakes. Especially if we’re conducting experiments. In such cases, it might be useful to limit the amount of funds our contract accepts. This is as simple as a hard limit on the balance of the contract’s address.

Here’s a simplified example on how to do this:

contract LimitFunds {
  
  uint LIMIT = 5000;
  
  function() { throw; }
  
  function deposit() {
    if (this.balance > LIMIT) throw;
    ...
  }
}

The short fallback function will reject any direct payments to the contract. The deposit function will first check if the contract’s balance exceeds the desired limit, or throw an exception. More interesting things like dynamic or managed limits are easy to implement too.
Write simple and modular code

Security comes from a match between our intention and what our code actually allows to do. This is very hard to verify, especially if the code is huge and messy. That’s why it’s important to write simple and modular code.

This means, functions should be as short as possible, code dependencies should be reduced to the minimum, and files should be as small as possible, separating independent logic into modules, each with a single responsibility.

Naming is also one of the best ways to express our intention when coding. Think a lot about the names you chose, to make your code as clear as possible.

Let’s study an example of bad naming of Events. Look at this function from The DAO. I’m not going to copy the function code here because it’s very long.

The biggest problem is that it’s too long and complex. Try to keep your functions much shorter, say, up to 30 or 40 lines of code max. Ideally, you should be able to read functions and understand what they do in less than a minute. Another problem is the bad naming for the event Transfer in line 685. The name differs from a function called transfer by only 1 character! This is inviting confusion for everyone. In general, the recommended naming for events is that they should start with “Log”. In this case, a better name would be LogTransfer.

Remember, write your contracts as simple, modular, and well-named as possible. This will greatly facilitate others and yourself in auditing your code.
Don’t write all your code from scratch

Finally, as the old adage reads: “Don’t roll your own crypto”. I think it also applies to Smart Contract code. You’re dealing with money, your code and data is public, and you’re running in a new and experimental platform. The stakes are high and the chances to mess-up are everywhere.

These practices help secure our smart contracts. But ultimately, we should create better developer tools to build smart contracts. There are some interesting initiatives including better type systems, Serenity Abstractions, and the Rootstock platform.

There’s lots of good and secure code already written and frameworks are starting to appear. We’ve started to compile some of the best practices in this GitHub repo we called OpenZeppelin. Feel free to take a look and contribute with new code or security audits.
Wrapping up

To recap, the security patterns described in this article are:

    Fail as early and loudly as possible
    Favor pull over push payments
    Order your function code: conditions, actions, interactions
    Be aware of platform limits
    Write tests
    Fault tolerance and Automatic bug bounties
    Limit the amount of funds deposited
    Write simple and modular code
    Don’t write all your code from scratch

If you want to join the discussion about secure smart contract development patterns join us on slack. Let’s improve the smart contract development standards together!

To be up to date with our work in smart contract security, follow us on Medium and Twitter.
_______________________________________

See also: https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab#.xk3bv3cw8
_______________________________
<strong>Ethereum</strong><br>
Ethereum was able to successfully execute a hard fork called Byzantium. As part of this hard fork increased anonymity was provided through Zero-knowledge proofs, or zk-snark proofs. It also included more predictable gas charges which were becoming difficult to calculate with the increased number of ICOs. InfoQ previously covered this hard fork in the following <a href="https://www.infoq.com/news/2017/08/Ethereum-HardFork" target="_blank">article</a>.</p>
________________________
Ethereum ¿Opinion?: """
Bitcoin UTXO binary state (spent, unspent) gives no opportunity for multi-stage contracts or scripts
which keep any other interanl state beyond that. This makes it hard to make multi-stage options
contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary
for secure computational bounties). It also means that UTXO can only be used to build simple, one-off
contracts and not more complex "stateful" contracts such as decentralized organizations, and makes
meta-protocols difficult to implement. Binary state combined with value-blindness also mean that 
another important application, withdrawal limits, is impossible".
__________________________________
  <a href='https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/' TODO>How to build server less applications for Mist</a>
________________________
throw vs revert
_________________
https://github.com/ethereum/wiki/wiki/Whisper
In a nutshell whisper is a communication protocol for DApps to communicate with each other.
Use case

    DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.

    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.
_______________________________
https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c

_______________________________
Solidity: TODO: Walk over map keys /lists

_______________________________
Solidity: TODO: Walk over array elements:
bytes32[] public namesInUse;
for (uint i = 0; i < namesInUse.length; i++) {
   require(namesInUse[i] != username);
}
____________________________

_______________________________
Solidity: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1
__________________
Solidity: https://coursetro.com/posts/code/102/Solidity-Mappings-&-Structs-Tutorial
_____________
https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
Through technical evaluations of tools like Plasma and formats of obtaining consensus in Casper, it is apparent that database management tools like MapReduce and Abstract Rewrite Systems will be implemented in Ethereum. In Plasma, MapReduce is an integral part of assembling the coordination of an account based system and a bitmap-UTXO commitment structure of a multichain setup.
...
Plasma shares quite a bit of influence from a heavily cryptoeconomic incentive structure focused platform called Truebit which was designed to increase the offchain computational capabilities of the Ethereum network. By architecting the Truebit system around a verification game in which Solvers of the overall consensus mechanism can be challenged by Verifiers which obtain a reward if they identify a nefarious counterparty, an internal cryptoeconomic ?checks and balances? of the system is created to incentive a dominant strategy of behaving fairly. As Plasma through the influence of TrueBit is focused on creating a multichain interoperability network, the internal enforcement of the system is paramount toward achieving information and consensus fidelity.
...
Ethereum Casper Proof of Stake

An example of cryptoeconomic incentive layers can also be seen in Ethereum?s transition to a proof of stake consensus mechanism via implementations of Casper. While proof of work has its own internalized game theoretical incentive structure to dissuade participants from commandeering the network, the transition to proof of stake has even further internal structures for disincentivizing participants from equivocating or trying to create alternative instances of the blockchain when encountering forks. The staking protocol creates a Byzantine Fault Tolerant environment where Ether would be bonded into the consensus mechanism. What this means is that individuals would be bound by a fidelity bond to behave honorably within the system.
....
Cosmos and Tendermint

Cosmos is also building an ecosystem that relies on the Tendermint consensus mechanism that relies heavily upon Byzantine Fault Tolerance algorithms. The platform depends on validators that have similar roles as miners in the bitcoin network. The validators have staking tokens called Atoms which are used to secure the network via a proof of stake mechanism that relies upon the trust generated by the bonded validators. The interplay between the players in the ecosystem is also indicative of a game theoretical structure where validators can lose their tokens or the tokens delegated to them if discovered to be violating the protocol. Due to this bonded deposit design of stakeholders within this system, the consensus mechanism allows for an incentivization mechanism that secures the network. This security design allows for the proper functioning of the Application Blockchain Interface (ABCI), the Inter-Blockchain Communication protocol (IBC) as well as the varying interactions between the Cosmos hub and zones.
....
_______________

https://plasma.io/plasma.pdf
The orchestrated transaction processing paradigm using the interplay between rootchains, plasma chains, and child chains through a combination of fraud-proof mechanism designs and fidelity bond incentive structures help satisfy dynamics between the block-withholding and mass withdrawal surfaces. It also allows for further cryptoeconomic structures to be filled using mechanisms from systems like Casper or Truebit for mirroring concepts used in erasure coding in terms of the data availability problem that is prevalent in the space. For a multichain architecture, Ethereum would be able to combine the database coordination and throughput capabilities of a distributed database system with the public chain compatible capabilities of an actual blockchain.
______________________
__________________________________________
http://fc17.ifca.ai/wtsc/Defining%20the%20Ethereum%20Virtual%20Machine%20for%20Interactive%20Theorem%20Provers.pdf
__________________________________________
https://github.com/pirapira?utf8=%E2%9C%93&tab=repositories&q=&type=source&language=  
 ( Lot of interesting repos related to Ethereum)

_________________
selfdestruct(address recipient):
  destroy current contract
  send its funds to recipient 
________________________________
Are there well-solved and simple storage patterns for Solidity?
<a href="https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity">REF</a>


 100
down vote
accepted

Here are some simple and useful patterns in increasing order of utility.

Event logs are omitted for brevity. In practice, it's desirable to emit events for every important state change.

Simple List Using Array

Strengths

    Reliably chronological order
    Provides a count
    Random access by Row Number (not Id)

Weaknesses

    No random access by Id
    No assurance of uniqueness
    No check for duplicates
    Uncontrolled growth of the list

Example:

pragma solidity ^0.4.6;

contract simpleList {

  struct EntityStruct {
    address entityAddress;
    uint entityData;
    // more fields
  }

  EntityStruct[] public entityStructs;

  function newEntity(address entityAddress, uint entityData) public returns(uint rowNumber) {
    EntityStruct memory newEntity;
    newEntity.entityAddress = entityAddress;
    newEntity.entityData    = entityData;
    return entityStructs.push(newEntity)-1;
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityStructs.length;
  }
}

Mapping with Struct

Strengths

    Random access by unique Id
    Assurance of Id Uniqueness
    Enclose arrays, mappings, structs within each "record"

Weaknesses

    Unable to enumerate the keys
    Unable to count the keys
    Needs a manual check to distinguish a default from an explicitly "all 0" record

Example:

contract mappingWithStruct {

  struct EntityStruct {
    uint entityData;
    bool isEntity;
  }

  mapping (address => EntityStruct) public entityStructs;

  function isEntity(address entityAddress) public constant returns(bool isIndeed) {
    return entityStructs[entityAddress].isEntity;
  }

  function newEntity(address entityAddress, uint entityData) public returns(bool success) {
    if(isEntity(entityAddress)) throw; 
    entityStructs[entityAddress].entityData = entityData;
    entityStructs[entityAddress].isEntity = true;
    return true;
  }

  function deleteEntity(address entityAddress) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    entityStructs[entityAddress].isEntity = false;
    return true;
  }

  function updateEntity(address entityAddress, uint entityData) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    entityStructs[entityAddress].entityData = entityData;
    return true;
  }
}

Array of Structs with Unique Ids

Strengths

    Random access by Row number
    Assurance of Id uniqueness
    Enclose arrays, mappings and structs with each "record"

Weaknesses

    No random access by Id
    Uncontrolled growth of the list

Example:

contract arrayWithUniqueIds {

  struct EntityStruct {
    address entityAddress;
    uint entityData;
  }

  EntityStruct[] public entityStructs;
  mapping(address => bool) knownEntity;

  function isEntity(address entityAddress) public constant returns(bool isIndeed) {
    return knownEntity[entityAddress];
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityStructs.length;
  }

  function newEntity(address entityAddress, uint entityData) public returns(uint rowNumber) {
    if(isEntity(entityAddress)) throw;
    EntityStruct memory newEntity;
    newEntity.entityAddress = entityAddress;
    newEntity.entityData = entityData;
    knownEntity[entityAddress] = true;
    return entityStructs.push(newEntity) - 1;
  }

  function updateEntity(uint rowNumber, address entityAddress, uint entityData) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    if(entityStructs[rowNumber].entityAddress != entityAddress) throw;
    entityStructs[rowNumber].entityData    = entityData;
    return true;
  }
}

Mapped Structs with Index

Strengths

    Random access by unique Id or row number
    Assurance of Id uniqueness
    Enclose arrays, mappings and structs within each "record"
    List maintains order of declaration
    Count the records
    Enumerate the Ids
    "Soft" delete an item by setting a boolean

Weaknesses

    Uncontrolled growth of the list

Example:

contract MappedStructsWithIndex {

  struct EntityStruct {
    uint entityData;
    bool isEntity;
  }

  mapping(address => EntityStruct) public entityStructs;
  address[] public entityList;

  function isEntity(address entityAddress) public constant returns(bool isIndeed) {
      return entityStructs[entityAddress].isEntity;
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityList.length;
  }

  function newEntity(address entityAddress, uint entityData) public returns(uint rowNumber) {
    if(isEntity(entityAddress)) throw;
    entityStructs[entityAddress].entityData = entityData;
    entityStructs[entityAddress].isEntity = true;
    return entityList.push(entityAddress) - 1;
  }

  function updateEntity(address entityAddress, uint entityData) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    entityStructs[entityAddress].entityData    = entityData;
    return true;
  }
}

Mapped Structs with Delete-enabled Index

Strengths

    Random access by unique Id or row number
    Assurance of Id uniqueness
    Enclose arrays, mapping and structs within each "record"
    Count the records
    Enumerate the ids
    Logically control the size of the active list with delete function

Weaknesses

    Marginally increased code complexity
    Marginally higher storage costs
    Key list is inherently unordered

Example:

contract mappedWithUnorderedIndexAndDelete {

  struct EntityStruct {
    uint entityData;
    uint listPointer;
  }

  mapping(address => EntityStruct) public entityStructs;
  address[] public entityList;

  function isEntity(address entityAddress) public constant returns(bool isIndeed) {
    if(entityList.length == 0) return false;
    return (entityList[entityStructs[entityAddress].listPointer] == entityAddress);
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityList.length;
  }

  function newEntity(address entityAddress, uint entityData) public returns(bool success) {
    if(isEntity(entityAddress)) throw;
    entityStructs[entityAddress].entityData = entityData;
    entityStructs[entityAddress].listPointer = entityList.push(entityAddress) - 1;
    return true;
  }

  function updateEntity(address entityAddress, uint entityData) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    entityStructs[entityAddress].entityData = entityData;
    return true;
  }

  function deleteEntity(address entityAddress) public returns(bool success) {
    if(!isEntity(entityAddress)) throw;
    uint rowToDelete = entityStructs[entityAddress].listPointer;
    address keyToMove   = entityList[entityList.length-1];
    entityList[rowToDelete] = keyToMove;
    entityStructs[keyToMove].listPointer = rowToDelete;
    entityList.length--;
    return true;
  }

}

This last one has an explainer here: https://medium.com/@robhitchens/solidity-crud-part-2-ed8d8b4f74ec#.ekc22r5lf

and here: https://bitbucket.org/rhitchens2/soliditycrud/src/83703dcaf4d0c4b0d6adc0377455c4f257aa29a7/docs/?at=master

Folder Tree Example: How can we organize storage of a folder or object tree in Solidity?

Linked List example shows a way to maintain an ordered list using a library. https://github.com/ethereum/dapp-bin/blob/master/library/linkedList.sol 0
shareimprove this answer
edited Sep 11 '17 at 4:09
answered Mar 16 '17 at 22:13
Rob Hitchens B9lab
19.6k33263

    2
    Linked lists are quite useful too: they allow enumeration, random access by ID and by index, are inherently ordered, etc. Only downside is O(n) lookup/insertion/deletion by index – Tjaden Hess♦ Mar 22 '17 at 22:54
    1
    This makes me think of renaming the function because it appears the purpose of the function is misunderstood. It doesn't validate the input. It's not necessary to do so since anything successfully passed in will be a valid address. Instead, it's checking if the key is already used/ a;ready exists to ensure unique keys. No duplicate keys are allowed. Possibly I should change the function name to something like function keyExists() to prevent confusion. – Rob Hitchens B9lab May 20 '17 at 12:25
    1
    It's only a con in certain cases where the data is transient. Suppose you have a case where 90% or more of the data is to be logically deleted. You would end up with an unpruned list pointing to many obsolete records and this might not be ideal. – Rob Hitchens B9lab Sep 26 '17 at 17:28
    1
    Not even close. Have a look at medium.com/@robhitchens/solidity-crud-part-1-824ffa69509a and web3 example. JS will fetch the length, iterate, and fetch the rows one at a time. – Rob Hitchens B9lab Sep 26 '17 at 17:59
    1
    Suppose you have a dataset where rows are appended and consumed then routinely set to inactive or usedUp. You could end up with clients that have to iterate over an ever-increasing list of obsolete information. Sometimes (not majority) it makes sense to truly remove something from the list. The delete-enabled pattern solves for that. – Rob Hitchens B9lab Apr 18 at 16:37

_____________________
https://entethalliance.org/enterprise-ethereum-alliance-advances-web-3-0-era-public-release-enterprise-ethereum-architecture-stack/
 The Enterprise Ethereum Alliance (EEA), with over 500 members, today unveiled the next phase of its Enterprise Ethereum specification strategy, with the public release of its Enterprise Ethereum Architecture Stack. This stack defines the building blocks needed to drive the Web 3.0 era of decentralized, connective intelligence ? the next generation of Enterprise Ethereum applications that, like the Internet, will work anywhere, and are capable of facilitating smart contracts without intermediaries. The stack, available as a free public document to download, incorporates components developed by the Ethereum Foundation.
_________________________
https://entethalliance.org/resources/
_________________________
Signing transactions Flow:
 - Identify the next available nonce for the sender account
 - Create the RawTransaction object
 - Encode the RawTransaction object using Recursive Length Prefix encoding
 - Sign the RawTransaction object
 - Send the RawTransaction object to a node for processing

The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.
_______________________
Tooling:
https://github.com/adridadou/eth-contract-api

 EthereumJ native API or how to call contracts easily and with type safety http://www.davidroon.com/ethcontractapi/
____________________________
ERC223: Safer ERC20 token standard:
https://github.com/ethereum/EIPs/issues/223
____________________________
https://github.com/paritytech/parity/issues/6342___________________________
____________________________
https://github.com/oraclize/ethereum-examples
http://www.oraclize.it/
_______________________________
Solidity Arrays vs Linked-lists:
https://ethereum.stackexchange.com/questions/51399/deleting-index-of-an-array-in-terms-of-optimization-for-looping
_______________________________
Consensys techs:
Balanc3             TravelBlocks                                 Linnia
Cellarius           Waterloo                                     Catalyst and Hub Account Manager
ConsenSys Academy   Panvala                                      Meridio
Plasma              Gitcoin                                      MetaMask
Gitcoin             Infura                                       N0d.capital
Token Foundry       Kaleido                                      Nethereum
Viant               Applied Researcher: Sharding                 Numia
uPort               Applied Researcher: Sidechains (PegaSys)     OpenLaw
Trustology          Quantitative/Qualitative Researcher          PegaSys
TruSet              Senior Design Researcher - Ujo Music















Ujo: Ethereum blockchain-based open music industry peer-to-peer platform built by ConsenSys.
Ujo aims to increase transparency and efficiency in the music industry through an automated,
decentralised rights management and payments system upon which any music service or
application can be built. Creators and rights holders register works and their stakes in those
works in smart contracts on the blockchain. Payments are delivered automatically and
instantly based on that information using the self-enforcing smart contract technology. Artists
may also publish policies for how their music may be used, facilitating an open marketplace in
which anybody can innovate a new business model, app or service as long as they meet the
terms of those policies.
__________________________________________
https://aleth.io:

https://media.consensys.net/alethio-lighting-up-the-blockchain-with-real-time-stats-a80bb30576db
Alethio’s analytics platform helps users visualize, interpret, and react to blockchain data in real time.


"""Though Ethereum has become a household name, what’s actually happening on the
 network remains a mystery for many. Current blockchain explorers provide little
 clarity into the evolving ecosystem. They are often geared towards developers
 and leave average users in the dark. At the same time, seasoned and committed 
users, from individuals to enterprises, still don’t have the resources they need
 to really make sense of the blockchain — whether that’s accessing real time 
block data, analyzing the application layer, detecting anomalies, or monitoring
 the statistical signals that translate to larger KPIs.

At Alethio, we take issue with this. For Ethereum to realize its true potential, users’ interactions with the blockchain should be fully transparent and understandable. As Ethereum grows in size and complexity, we believe the tools that inform user’s decisions, large or small, should evolve as well."""
_______________________
https://io.builders/blog/our-first-month-tools-languages-and-developments/
  Our first month: Tools, languages and developments
  Madrid, Spain
  Friday, June 1, 2018

  Time goes fast, and 5 weeks have passed since our 
  official Team start. We don't have everybody on board 
  but we have started with some developments. These are 
  the tools we are using:
  <ul>
  <li>Intellij IDEA and Atom as IDE</li>
  <li>Gitlab as CI. It allows us to create pipelines from 
  day one, natively integrated in our source code. With 
  its powerful docker based platform we are able to 
  compile, pass specific linters, test and audit the 
  security of our builds. 
  <a href="https://github.com/IoBuilders/solidity-test-and-security-pipeline/tree/master" target="_blank">Checkout out pipeline</a>.
  Our vision is to have full coverage and automatically 
  audited code, to be 100% sure that our smart contracts are safe from well known bugs and follow good practices.</li>
  <li>React Native for mobile development</li>
  <li>NodeJs, Java, Groovy and GO for backend development</li>
  <li><a href="https://www.jpmorgan.com/global/Quorum" target="_blank">Quorum</a> as the DLT</li>
  <li>Solidity 0.4.24</li>
  <li><a href="https://github.com/sc-forks/solidity-coverage" target="_blank">Solidity Coverage</a> as test coverage tool</li>
  <li><a href="http://truffleframework.com/" target="_blank">Truffle framework</a>: Lifecycle for solidity.</li>
  <li><a href="http://truffleframework.com/ganache/" target="_blank">Ganache</a>: Light node of Ethereum for testing purpose.</li>
  <li><a href="https://github.com/duaraghav8/Solium" target="_blank">Solium</a>: Linter &amp; security static analysis.</li>
  <li><a href="https://github.com/ConsenSys/mythril/wiki" target="_blank">Mythril</a>: Security analysis.
  
  <br></li>
  </ul>  
   
  Besides this, we have used <a href="https://www.gv.com/sprint/">Design Sprint</a> by Google Ventures,
  to discover and analize the customer journey, functional 
  approach of our first venture and develop/test it with 
  a prototype with real users. Hypothesis validation is on going!
  Thanks for Reading! Keep Posted!!!
  “With confidence, you have won before you have started.” —Marcus Garvey 
__________________________
<td>
  <a href="https://github.com/ConsenSys/mythril/wiki">Mythril</a>
  Mythril is a security analysis tool for Ethereum smart 
  contracts. It was introduced at HITBSecConf 2018.

  Mythril detects a range of security issues, including 
  integer underflows, owner-overwrite-to-Ether-withdrawal,
  and others. However, the analysis will not detect business
  logic issues and is not equivalent to formal verification.
</td>
-->
</html>
