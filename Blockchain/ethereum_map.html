<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Ethereum Map</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->
<table style='width:100%'{>
<tbody>
<tr {>
  <th colspan=3 header_delimit {   >Ethereum VM</th>
</tr }>
<tr {>
  <td col1 >
         <pre {>
Account:
---------
address
wei balance
Map&lt;256b,256b> storage
         </pre }>
     <ul>
       <li { >There are two kinds of accounts in Ethereum which share the same address space:
         <ul>
           <li>External account : controlled by public-private key pairs (i.e. humans)<br/>
               account.address: determined from the public key</li>
           <li>contract accounts: controlled by the code stored together with the account. 
               account.address in a contract is determined at the time the contract is created derived from the nonce = function(creator address, num.transactions sent)</li>
         </ul>
       </li }>
       <li>account.balance: can be modified by sending transactions that include Ethers.</li>
       <li { >account.storage: Persistent memory area 
         <ul>
           <li>It is not possible to enumerate storage from within a contract </li>
           <li>It is comparatively costly to read and even more so, to modify storage</li>
           <li>A contract can neither read nor write to any storage apart from its own</li>
         </ul>
       </li } >

     </ul>
  </td>
  <td col2 >
         <pre>
Message Calls
-------------
sender
target(can be==sender)
payload
ether
gas
return data
         </pre>
     <ul>
       <li>
Contracts can user message calls to call other contracts or send Ether to non-contract accounts.

Every transaction consists of a top-level message call which in turn can create further message calls.

contracts can decide how much of its remaining gas should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signalled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions "bubble up" the call stack.

Calls depth is limited to 1024 (Loops must be used over recursive calls)

After finished execution, contracts can return data stored at a preallocated location in the caller’s memory.
       </li>

       <li>Delegatecall (See libraries): Special variant of a message call, is identical to a 
           message call apart from the fact that the code at the target address is executed in the context
           of the calling contract and msg.sender and msg.value do not change their values.<br/>
           This means that a contract can dynamically load code from a different address at runtime.
           Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.<br/>
           This makes it possible to implement the “library” feature in Solidity:
           Reusable library code that can be applied to a contract’s storage in order to e.g. implement a complex data structure.
       </li>
     </ul>
  </td>  
  <td col3 >
    (EVM) Memory:
     <ul>
       <li>A contract obtains a freshly cleared instance for each message call</li>
       <li>Memory is linear and can be addressed at byte level</li>
       <li>Reads are limited to a width of 256 bits</li>
       <li>Writes can be either 8 bits or 256 bits wide</li>
       <li>Memory is expanded by a word (256-bit), when accessing 
           (either reading or writing) a previously untouched memory word (ie.
           any offset within a word). At the time of expansion, the cost in gas 
           must be paid. Memory is more costly the larger it grows (it scales
           quadratically)
       </li>
       <li>calldata: Separate area of memory whe message call payload is placed</li>
     </ul>
    <hr/>
    (EVM) Stack:
    <ul>
    <li>EVM memory area list of 256bits up to 1024 elements used for computations</li>
    <li>The 16 topmost elements can be moved to the top or swaped wih the top ele</li>
    <li>All other operations take the topmost one (or two, or more) elements and push the result onto the stack</li>
    <li>top elements can be moved to/from storage/memory, but deeper elements can
        be accessed without first removing elements on top of them.
    </li>
    <li>(EVM)full computational state: can be defined by the tuple:<br/>
      (block_state, transaction, message, code, memory, stack, pc, gas)
      block_state = global state = all accounts (balances + storage)
    </li>
    <li>selfdestruct(target): Destructor for contract @ address
      <ul>
      <li>Remaining Ethers are sent to target</li>
      <li>storage & code are removed from the blockchain state</li>
      </ul>
    </li>
  </td>  
</tr }>

<tr {>
  <th colspan=3 header_delimit }   >Transactions</th>
</tr }>
<tr {>
  <td col1 >
         <pre {>
Transaction
-------------
address sender
target
payload
wei ether
wei gasPrice?
wei gas
return data
         </pre }>
"message" sent from src. account to a target (account or code)
     <ul>
       <li><code>transaction.target := address | code | "zero-account"</code>
         <pre {>
if target == code 
   => code is executed
      input data = transaction.payload 
if target == "zero.." 
   => step 1: new contract created
      step 2: transaccion.payload is executed 
      step 3: exec. output stored as contract.code
      (=> trans.payload == code factory of contract code)
         </pre }>
       </li>
       <li>transaction.ether: Price in Wei of one unit of gas, in which VM operations are priced.<br/>
- The product of gasPrice and gas represents the maximum amount of Wei we are willing to pay for executing the transaction. gasPrice is used by miners to rank transactions for inclusion in the blockchain. 
       </li>
       <li>transaction.gas: Its purpose is to limit the amount of work needed to execute the transaction 
           and to pay for this execution. 
           transaction creator (sender?) chooses the gas to pay.
             - If execution gas < transaction.gas => Refund to sender
             - If execution gas > transaction.gas => out-of-gas exception triggered
                 (reverts all modifications made to the state in current call frame)
       </li>

       <li>nonce: increasing numeric value which is used to uniquely identify transactions.
           A nonce can only be used once and until a transaction is mined, it is possible
           to send multiple versions of a transaction with the same nonce, however, 
           once mined, any subsequent submissions will be rejected.
       </li>

       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li>Calls vs Transactions:
           <ul>
             <li>Calls: invoque an smart-contract function and return a value, 
                 but nothing is mined/verified by the consensus.</li>
             <li>Transactions: Verified by the consensus miners. 
                  Expends gases, do not return any value (is asynchronous)
                  We need events to return the value</li>
           </ul>
       </li>

       <li { >state transition function,  APPLY (S, TX) -> S' can be defined as follows:
         <ol>
           <li>Check if the transaction is well-formed (ie, has the right number of values), the signature is valid, and the nonce matches the nonce in the sender's account.  If not, return an error.</li>
           <li>Calculate the transaction fee as STAR_GAS * GAS_PRICE, and determine the sending address from the signature. Subtract the fee from the sender's account balance and increment the sender's nonce. If there is not enought balance to spend, return an error.</li>
           <li>Initialize GAS = STARTGAS, and take off a certain quantity of gas per byte to pay for the bytes in the transaction.</li>
           <li>Transfer the transaction value from the sender's account to the receiving account.  If the receiving account does not yet exist, create if. If the receiving account is a contract, run the contract's code either to completion or until the execution runs out of gas.</li>
           <li>If the value transfer failed because the sender did not have enough money, or the code execution ran out of gas, revert all state changes except the payment of the fees, and add the fees to the miner's account</li>
           <li>Otherwise, refund the fees for all remaining gas to the sender, and send the fees paid for gas consumed to the miner</li>
         </ol>
       </li } >
       <li {>
         There are two mechanisms you can use to transact with Ethereum:
         <ul>
           <li>Transaction signing via an Ethereum client (geth, parity,...).
               It forces to have the wallet on the client node and unlock the 
               account.</li>
           <li>Offline transaction signing (recomended)
             The "raw" transaction must be signed first
             (See https://docs.web3j.io/transactions.html#transaction-mechanisms ->
             raw transactions for more info)</li>
         </ul>
       </li } >
<!--
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li>Transactions in solidity:
         <pre { >
addressInstance.balance (uint256): balance in Wei
addressInstance.transfer(uint256 amount): 
    msg.sender ->(amount in wei) ->addressInstance
    throws on failure 

addressInstance.send(uint256 amount): returns (bool):
    msg.sender ->(amount in wei) ->addressInstance
    returns true/false, does NOT throw an exception
         </pre } >
         In addressInstance.transfer (or send), if addressInstance
         is a contract address, its code (more specifically: its fallback function, if present) 
         will be executed together with the transfer call. This is a limitation of the EVM and
         cannot be prevented. <br/>
         If that execution runs out of gas or fails in any way, the Ether transfer will be
         reverted and the current contract will stop with an exception.
       </li>
<!--
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>

<tr {>
  <th colspan=3 header_delimit } { >LOGS</th>
</tr }>
<tr {>
  <td col1 >
     <ul>
         <li>Logs: It is possible to store data in a specially indexed data structure 
             that maps all the way up to the block level.<br/>
             This feature called 'logs' is used to implement events.</li>
         <li>Contracts *CAN NOT* access log data after it has been created, but they 
             can be efficiently accessed from outside the blockchain. <br/>
             Since some part of the log data is stored in bloom filters,
             it is possible to search for this data in an efficient and cryptographically 
             secure way, so network peers that do not download the whole blockchain 
             ("light clients") can still find these logs.</li>
         <li>Logs were designed to be a form of storage that costs significantly less gas than contract storage:<br/>
             Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes. 
             Up to 3 parameters can be indexed.<br/>
         </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li>
Solidity code:
             <pre { >
event EventDepositLog(
    uint256 indexed _market,
    address indexed _sender,
    uint256 _amount,
     uint256 _time);
             </pre } >
JS Client Log monitoring:
             <pre { >
  var depositEvent =
    cryptoExContract.EventDepositLog(
       {_sender: userAddress} /* filter */, 
       {fromBlock: 0, toBlock: 'latest'} /* range*1
    );
  // *1 If block range ommited => "real-time" event logs

  depositEvent.watch
     /* to cancel: depositEvent.stopWatching() */(
    function(err, result) {
      if (err) { ...    return; }
      console.log(
           "_market:"+result.args._market
         + "_sender:"+result.args._sender );
    }
  )
             </pre } >

       </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>


<tr {>
  <th colspan=3 header_delimit }   >Consensus</th>
</tr }>
<tr {>
  <td col1 >
     <ul>
       <li>Ehtereum block validation algorithm:
         <ol>
         <li>Check if the previous block referenced exists and is valid</li>
         <li>Check that the timestamp of the block is greater than that of the referenced previous
     block and less than 15 minutes into the future.</li>
         <li>Check that the block number, difficulty, transaction root, uncle root and gas limit 
     (various low-level Ethereum-specific concepts) are valid.</li>
         <li>Check that the proof of work on the block is valid</li>
         <li>Let S[0] be the STATE_ROOT of the previous block</li>
         <li>Let TX be the block's transaction list, with n transactions. For all in i in 
     0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any applications returns an error, or
     if the total gas consumed in the block up until this point exceeds the GASLIMIT, 
     return an error</li>
         <li>Let S_FINAL be S[n], but adding the block reward paid to the miner</li>
         <li>Check if S_FINAL is the same as the STATE_ROOT. If it is, the block is valid;
             otherwise, it is not.</li>
         </ol>
       </li>
       <li>coinbase: In a mining node indicates the address where rewards will go.
           Must be set to an account owned by miner</li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li TODO> Proof of work vs Proof of stake</li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li TODO>CAP Theorem</li>
     </ul>
  </td>  
</tr }>


<tr {>
  <th colspan=3 header_delimit }   ><a href='http://solidity.readthedocs.io/en/develop/'>SOLIDITY LANGUAGE</a></th>
</tr }>

<tr {>
  <td col1 >
     <a href='https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/' TODO>How to build server less applications for Mist</a>
     <ul>
       <li>FUNCTIONS:
         <pre small { >
modifier inState(State _state)    { if (state != _state) throw;  _;  }
modifier require(bool _condition) { if (!_condition) throw; _;       }

function confirmPurchase(<parameter_list types>)
    inState(State.Created)          // precondition
    require(msg.value == 2 * value) // precondition
    // VISIBILITY MODIFIERS {
    [internal]  only this contract and child ones
    [private]   only this contract
    [external]
    [public]
    // }
    // MUTABILITY MODIFIERS {
    [payable]  /* allows funct to receive ether when called as:
                * myContractInstance.myPayableFunction.call. \
                *   value("ETH_TO_BE_SENT")("ADDITIONAL_DATA")
                * Ej:
                *   function deposit() payable {
                *     deposits[msg.sender] += msg.value;
                *   };
                */
    [pure]      /* does NOT modify the contract storage 
                 * and storage can NOT be accesed 
                 * (utility libraries, ...)*/
    [view] /* does NOT modify the contract storage 
              but storage can be accesed  ("getters")*/
    [constant] /* alias for pure */
    // }
    [returns ('return types')]
    { 
      ... 
    }
         </pre } >
Fallback function (function called when no other function matches):
         <pre { >
    event EventFallback(address from, int256 amount);
    ...
    function () payable {
      if (! this.owner.send(amount)) { throw ; }
      EventFallback(msg.sender, receiver, amount);
    }; 
         </pre } >
         To use and external function f as an internal function,
         just use f, if you want to use its external form, use this.f (not recomended) <br/>
         external vs public: (Best practice) use external if function will only ever be 
         called externally and use public if function will also be called internally.
         external avoid copying parameters twice (very important with big arrays)<br/>
       </li>
       <li>IMPORTS:
         <pre { >
import ""filename"";
import * as symbolName from ""filename"";
import {symbol1 as alias, symbol2} from ""filename"";
import ""filename"" as symbolName;
         </pre } >
       </li>
       <li>STRUCTS, ENUMS
         <pre { >
struct Voter {   ┃ enum State {
  uint weight;   ┃    Created,
  bool voted;    ┃    Locked,
}                ┃    Inactive 
                 ┃ }

         </pre } >
       </li>
       <li>
         <pre { >
var x = 1/4; // x type: ufixed0x8 
var x = 1/3  // x type: ufixed0x256, no finity bin.repre
         </pre } >
       </li>

<!--
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col2 >
    Grammar summary extracted from 
    <a href='https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt'>https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt</a>
    <pre xsmall  { >
{
Elementary:
Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*
NumberUnit = ('wei' | 'szabo' | 'finney' | 'ether') |
             ('seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years')
(Notice: NumberUnit can NOT be applied to variables, only to literals:
   M wei;     // &lt;- wrong
   M * 1 wei; // &lt;- correct

ElementaryTypeName = 'address' /*20 byte*/| 'bool' | 'string' | 'var' 
     |  'int(8|6|24|32|...|256)' 
     | 'uint(8|6|24|32|...|256)' 
     | 'byte(s|1-32)'
     | 'fixed'  | 'fixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256 
     | 'ufixed' | 'ufixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256
}

{
PrimaryExpression = Identifier | ('true' | 'false')  | (/*DecimalNumber*/ [0-9]+) | ...

Expression =
    ( Expression ('++' | '--') 
      | FunctionCall 
      | (/*IndexAccess*/ Expression '[' Expression? ']')
      | (/*MemberAccess*/ Expression '.' Identifier) 
      | '(' Expression ')' 
    )
  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
  | Expression '**' Expression
  | Expression ('*' | '/' | '%') Expression
  | Expression ('+' | '-') Expression
  | Expression ('&lt;&lt;' | '>>') Expression
  | Expression '&' Expression
  | Expression '^' Expression
  | Expression '|' Expression
  | Expression ('&lt;' | '>' | '&lt;=' | '>=') Expression
  | Expression ('==' | '!=') Expression
  | Expression '&&' Expression
  | Expression '||' Expression
  | Expression '?' Expression ':' Expression
  | Expression ('=' | '|=' | '^=' | '&=' | 
                '&lt;&lt;=' | '>>=' | '+=' |
                '-=' | '*=' | '/=' | '%=') Expression
  | Expression? (',' Expression)
  | PrimaryExpression
}

{
TypeNameList = '(' ( TypeName (',' TypeName )* )? ')'

FunctionTypeName = 'function' TypeNameList ( 'internal' | 'external' | 'constant' | 'payable' )*
                   ( 'returns' TypeNameList )?
TypeName =
     ElementaryTypeName 
   | /*UserDefined*/Identifier ( '.' Identifier )* 
   | ( 'mapping' '(' ElementaryTypeName '=>' TypeName ')' ) 
   | (TypeName '[' Expression? ']') 
   | FunctionTypeName


FunctionCall = ( PrimaryExpression | ( 'new' TypeName ) | TypeName ) 
               ( ( '.' Identifier ) | ( '[' Expression ']' ) )*
               '(' FunctionCallArguments ')'

FunctionDefinition = 'function' Identifier? ParameterList
                     ( FunctionCall | Identifier | 'constant'
                     | 'payable' | 'external' | 'public'
                     | 'internal' | 'private' )*
                     ( 'returns' ParameterList )? ( ';' | Block )

// semantic restriction: mappings & structs (recursively) containing mappings not allowed in argument lists
}


{
VariableDeclaration = TypeName (/*StorageLocation*/ ('memory' | 'storage'))? Identifier
VariableDefinition = ('var' (/*IdentifierList*/ '(' ( Identifier? ',' )* Identifier? ')') | VariableDeclaration) ( '=' Expression )?
SimpleStatement = VariableDefinition | Expression
}


{
Statement = 
   (  ('if' '(' Expression ')' Statement ( 'else' Statement )?) 
   | ('while' '(' Expression ')' Statement)
   | ('for' '(' (SimpleStatement)? ';' (Expression)? ';' (Expression)? ')' Statement)
   | ( /*block*/ '{' Statement* '}')
   | InlineAssemblyStatement 
   | ('do' Statement 'while' '(' Expression ')' ) 
   | /*place holder*/'_' 
   | 'continue' | 'break' | 'return' Expression?  |'throw' 
   | SimpleStatement )
   ';'
}


{ Contracts:
IndexedParameterList = '(' ( TypeName 'indexed'? Identifier? (',' TypeName 'indexed'? Identifier?)* )? ')'

ContractPart = 
    ( TypeName ( 'public' | 'internal' | 'private' )? Identifier ('=' Expression)? ';' )
  | ( 'using' Identifier 'for' ('*' | TypeName) ';' )
  | ( 'struct' Identifier '{' ( VariableDeclaration ';' (VariableDeclaration ';')* )? '}' ) 
  | ( 'modifier' Identifier ParameterList? Block )
  | ( 'event' Identifier IndexedParameterList 'anonymous'? ';' )
  | ( 'enum' Identifier '{' Identifier? (',' Identifier)* '}' )
  | FunctionDefinition

InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )* ')' )?

ContractDefinition = ( 'contract' | 'library' ) Identifier
                     ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                     '{' ContractPart* '}'
}


    </pre } >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li>Simple Coin
         <pre small { >
pragma solidity ^0.4.0;
contract /*Simple*/Coin {

  address public minter; // public => readable ""outside""

  // state variable. Permanently stored in contract storage
  mapping ( address => uint) public balances;

  event EventSent( address from, address to, uint amount);

  // This is the constructor whose code is run only       
  // when the contract is created.                        
                                                          
  function Coin() { minter = msg.sender; }                

  function mint( address receiver, uint amount) {         
    if (msg.sender != minter) return ;                    
    balances[receiver] += amount;                         
  }                                                       
                                                          
  function send( address receiver, uint amount) {                 
    if (balances[msg.sender] &lt; amount) return ;
      balances[msg.sender] -= amount;
      balances[receiver] += amount;
      EventSent(msg.sender, receiver, amount);
  }

  function arithmetics(uint _a, uint _b)
    // returns 2-tuple 
    returns (uint o_sum, uint o_product) {
    // alt return (o_sum, o_product) -
    o_sum = _a + _b;
    o_product = _a * _b;
  }
}
         </pre } >

// JS to use it:
         <pre small { >
Coin.Sent().watch(
 {},
 '',
 function (error, result) {
   if (!error) {
     console.log(""Coin transfer: "" + result.args.amount +
       "" coins were sent from "" + result.args.from +
       "" to "" + result.args.to + ""."");
  
     console.log(""Balances now:\n"" +
       ""Sender: "" + Coin.balances.call(result.args.from) +
       ""Receiver: "" + Coin.balances.call(result.args.to));
   }
}
         </pre } >
       </li>

<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>
<tr {>
  <td col1 >
     <ul>
       <li>
         <pre { >
pragma solidity ^0.4.5;

library ArrayUtils {
  // internal functions can be used in internal library 
  // functions because (part of same context)
  function map(uint[] memory self, function (uint) returns (uint) f)
    internal
    returns (uint[] memory r)
  {
    r = new uint[](self.length);
    for (uint i = 0; i &lt; self.length; i++) {
      r[i] = f(self[i]);
    }
  }

  function reduce(
    uint[] memory self,
    function (uint x, uint y) returns (uint) f
  )
    internal
    returns (uint r)
  {
    r = self[0];
    for (uint i = 1; i &lt; self.length; i++) {
      r = f(r, self[i]);
    }
  }

  function range(uint length) 
    internal 
    returns (uint[] memory r) 
  {
    r = new uint[](length);
    for (uint i = 0; i &lt; r.length; i++) {
      r[i] = i;
    }
  }
}
         </pre } >

         <pre { >
contract Pyramid {
  using ArrayUtils for *;
  function pyramid(uint l) returns (uint) {
    return ArrayUtils.range(l).map(square).reduce(sum);
  }
  function square(uint x) internal returns (uint) {
    return x * x;
  }
  function sum(uint x, uint y) internal returns (uint) {
    return x + y;
  }
}
         </pre } >
       </li>
<!--
       <li> </li>
-->
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li>EXTERNAL FUNCTIONS AND CALLBACKS:
         <pre { >
pragma solidity ^0.4.5;

contract Oracle {
  struct Request {
    bytes data;
    function(bytes memory) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function 
    query(bytes data, function(bytes memory) 
    external 
    callback 
  {
    requests.push(Request(data, callback));
    NewRequest(requests.length - 1);
  }

  function 
    reply(uint requestID, bytes response) 
  {
    // Here goes the check that the
    // reply comes from a trusted source
    requests[requestID].callback(response);
  }
}
         </pre } >
         <pre { >
contract OracleUser {
  // known contract
  Oracle constant oracle = Oracle(0x1234567);
  function buySomething() {
    oracle.query(""USD"", this.oracleResponse);
  }
  function oracleResponse(bytes response) {
    if (msg.sender != address(oracle)) throw;
    // Use the data
  }
}
         </pre } >
       </li>

<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li>GLOBAL METHODS:
         <pre { >
block.blockhash(uint blockNumber) 
  returns (bytes32): 
  hash of the given block - only works for 256 most
  recent blocks excluding current
         </pre } >
       
         GLOBAL CONTROL METHODS:
         <pre { >
assert(bool condition): 
  throws if condition not met
revert()              :
  abort execution, revert state changes 
selfdestruct(address recipient):
  destroy current contract
  send its funds to recipient 
         </pre } >
         <code>this</code>: (current contract’s type),
         explicitly convertible to Address
       GLOBAL VARIABLES:
         <pre { >
block.coinbase (address): current block miner’s address
block.difficulty (uint) : current block difficulty
block.gaslimit (uint)   : current block gaslimit
block.number (uint)     : current block number
block.timestamp (uint)  : current block timestamp
msg.data (bytes)        : complete calldata
msg.gas (uint)          : remaining gas
msg.sender (address)    : sender of the message (current call)
msg.sig (bytes4)        : first four bytes of the calldata 
                          (i.e. function identifier)
msg.value (uint)        : number of wei sent with the message
now (uint)              : current block timestamp 
                          (alias for block.timestamp)
tx.gasprice (uint)      : gas price of the transaction
tx.origin (address)     : sender of the transaction 
                          (full call chain)
         </pre } >
       GLOBAL Mathematical and Cryptographic Functions
         <pre { >
addmod(uint x, uint y, uint k) 
  returns (uint): /* compute (x + y) % k */
mulmod(uint x, uint y, uint k)
  returns (uint): /* compute (x * y) % k */
keccak256(...)
  returns (bytes32): compute Ethereum-SHA-3 hash
                of the (tightly packed) arguments
sha3(...) 
  returns (bytes32): alias to keccak256()
sha256(...) 
  returns (bytes32): compute SHA-256 hash of the
                      (tightly packed) arguments
ripemd160(...) 
  returns (bytes20): compute RIPEMD-160 hash of 
  the (tightly packed) arguments
ecrecover
  (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address):
    recover the address associated with the public key 
    from elliptic curve signature or return zero on error
         </pre } >
       </li>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>
<tr {>
  
  <td col1 >
<span TODO>String manipulation (substring, indexof,... in solidity)</span>
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col2 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>


<tr {>
  <th colspan=3 header_delimit }   >ERROR CONTROL</th>
</tr }>

<tr {>
  <td col1 >
     <ul>
       <li>EXCEPTIONS: CATCHING EXCEPTIONS IS NOT YET POSSIBLE (2017-03-01)!
        <p>The effect of an exception is that the currently executing call is stopped 
           and reverted (i.e. all changes to the state and balances are undone) and
           the exception is also “bubbled up” through Solidity function calls
           (low-level ""send""|""delegatecall""|""callcode"" will return false)
        </p>
        <p>Currently, Solidity automatically generates a runtime exception in the following situations:
          <li>...</li>
          <li>If your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function)</li>
          <li>If your contract receives Ether via a public getter function</li>
          <li>If you call a zero-initialized variable of internal function type</li>
          <li>If a addressInstance.transfer() fails</li>
        <p>a user-provided exception is generated with throw or assert(false condition)<br/>
           Internally, Solidity performs a revert operation (instruction 0xfd) when a 
           user-provided exception is thrown.<br/>
           In contrast, it performs an invalid operation (instruction 0xfe) if a runtime
           exception is encountered. In both cases, this causes the EVM to revert all
           changes made to the state.
        </p>
       </li>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col2 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>

<tr {>
  <th colspan=3 header_delimit }   >PRICE CALCULATION</th>
</tr }>

<tr {>
  <td col1 >
     <ul>
       <li>Extracted from stack-overflow:<br/>
        <p>
        Q: """The price of ETH has gone from ~8 USD/ETH to ~90 ETH/USD in 6 months,
           but when I view transactions on the blockchain (example), I see that most people are still using
           the default gas price of 2e10 wei/gas. Shouldn't we be lowering the gas prices on our transactions
           to account for this price change? 
           I have built a Dapp where low transaction fees are an important selling point. I intend to drop
           my gas price to 5e9 (a 75% reduction). Will my transactions still clear in a timely fashion?"""
        </p>
        <p>
        A: """Absolutely. Everyone should. There's a great site here that will help you understand gas and gas prices.
        It's called Ethereum Gas Station: http://ethgasstation.info/
        They just recently made this post which explains something they call the Safe Gas Price:
         https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91"""
       </p>
</li>
     </ul>
  </td>  
  <td col2 >
  Wikipedia entries on:
<a hef='https://en.wikipedia.org/wiki/Hal_Finney_%28computer_scientist%29' >Hal Finney</a>
<a hef='https://en.wikipedia.org/wiki/Nick_Szabo'                          >Nick Szabo</a>
<a hef='https://en.wikipedia.org/wiki/Claude_Shannon'                      >Claude Shannon</a>
<a hef='https://en.wikipedia.org/wiki/Charles_Babbage'                     >Charles Babbage</a>
<a hef='https://en.wikipedia.org/wiki/Ada_Lovelace'                        >Ada Lovelace</a>
<a hef='https://en.bitcoin.it/wiki/Wei_Dai'                                >Wei Dai</a>


    <a hef='http://ethgasstation.info/calculator.php'>http://ethgasstation.info/calculator.php</a>
    <pre xsmall { >
wei                         :                                1 wei      <--- discussion around APIs ...
gwei(shannon|nanoether|nano):                    1.000.000.000 weis     <--- gas prices
szabo|microether|micro      :                            1.000 gweis
finney|milliether|milli     :                        1.000.000 gweis    <--- micropayments
ether                       :                    1.000.000.000 gweis    <--- main unit
kether(grand|einstein)      :                            1.000 ethers 
mether                      :                        1.000.000 ethers
gether                      :                    1.000.000.000 ethers
tether                      :                1.000.000.000.000 ethers

200€/ether:
Transaction gas price: 21000 gas/tx       32bytes Contract storage: 20000 gas
+----------+-----------------+--------+   +----------+-----------------+--------+
| gasprice | total gas price | total €|   | gasprice | total gas price | total €|
+----------+-----------------+--------+   +----------+-----------------+--------+
|  1gwei   | 21000 *  1gwei  | 0,0042 |   |  1gwei   | 21000 *  1gwei  | 0,0040 |
| 20gwei   | 21000 * 20gwei  | 0,0420 |   | 20gwei   | 21000 * 20gwei  | 0,0400 |
+----------+-----------------+--------+   +----------+-----------------+--------+

For a transaction updating 64bytes (32bytes from debitor account to 32bytes creditor account)
+----------+-----------+
| gasprice | total € *1|
+----------+-----------+
|  1gwei   |   0,0122  |
| 20gwei   |   0,2440  |
+----------+-----------+

Logs cost: 375 gas for a LOG operation + 8 gas per log data byte + 375 gas for each topic. 200€/eth:

+----------+-----------+----------+--------------------+------------
|log  size | num.topics| gasprice | total gas price*1  |     total €
+----------+-----------+----------+--------------------+------------
|1024bytes |     3     |   1gwei  |  9692 *  1gwei     | 0,0019384 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0011192 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0005596 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0002798 €
+----------+-----------+----------+--------------------+------------
|          |           |  20gwei  |  9692 * 20gwei     | 0,0387680 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0223840 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0111920 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0055960 €
+----------+-----------+----------+--------------------+------------

(375 gas/LOG * 1LOG ) + (8 gas/byte * 1024byte) + (375 gas/topic * 3 topic) = 375 + 8192 + 1125 = 9692
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 3 topic) = 375 + 4096 + 1125 = 5596
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 1 topic) = 375 + 2048 +  375 = 2798
(375 gas/LOG * 1LOG ) + (8 gas/byte *  128byte) + (375 gas/topic * 0 topic) = 375 + 1024        = 1399    
    </pre } >

  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>



<tr {>
  <th colspan=3 header_delimit }   ><a href='http://ethereum.stackexchange.com/questions/269/what-exactly-is-an-ethereum-client-and-what-clients-are-there/335'>TOOLS</a></th>
</tr }>

<tr {>
  <td col1 >
     <ul>
       <li><a href='http://ethereum.github.io/browser-solidity'>Browser Solidity</a></li>
       <li>(NodeJS) TestRPC Ethereum RPC client for testing and development.<br/>
         It uses ethereumjs to simulate full client behavior and make developing Ethereum applications much faster. <br/>
         It also includes all popular RPC functions and features (like events) and can be run deterministically to make development a breeze.<br/>
         Install: <code> npm install -g ethereumjs-testrpc </code>
         Can also be embeded in JS code like:
         <pre>
// As a Web3 provider:
var TestRPC = require(""ethereumjs-testrpc"");
web3.setProvider(TestRPC.provider());
// As a general http server:
var TestRPC = require(""ethereumjs-testrpc"");
var server = TestRPC.server();
server.listen(port, function(err, blockchain) {...});
         </pre>
       </li>
       <li TODO>Remix (Solidity Browser) https://remix.ethereum.org/</li>
       <li><a href='http://truffleframework.com/docs/'>Truffle Framework</a>
        Built-in smart contract compilation, linking, deployment , binary management, testing, <span TODO>Network management for deploying to many public & private networks</span>, Interactive console for direct contract communication, Instant rebuilding of assets during development, External script runner that executes scripts within a Truffle environment.<br/>
        STEPS:
       <ol>
         <li>create working dir for project: <code> $ mkdir demo && cd demo</code></li>
         <li>Init truffle.<code>$ truffle init</code></li>
         <li>Dapp work:<br/>
           <ul>
             <li><code>$ cp .../""MyContract"".sol contracts</code><br/>
               (remove default example contracts in ./contracts and migrations/2_deploy_contracts.js  if desired)
             </li>
             <li><code>$ "edit" migrations/2_deploy_contracts.js to add MyContract  </code>
                WARN: ¡¡¡do not touch 1_initial_migration.js!!!
             </li>
           </ul>
         </li>
         <li>Compile sol to json: WARN: requires solc installed.<br/><code>$ truffle compile</code>
             (compiles /contracts/*.sol -> build/contracts/*.json )
              JS clients apps can then use the contract with code similar to:
              import metacoin_artifacts from '../../build/contracts/MetaCoin.json'
         </li>
         <li>Migrate to default network defined in truffle.js (localhost:8545)
             (Ussually this correspond to the testrpc daemon)
         </li>
         <li>$ truffle migrate</li>
         <li>$ truffle test </li>
         <li>Deploy to ""real""/""test"" network<br/>
           <pre>
$ truffle deploy 
# sends contract to the Ethe. network. Will also update
# contracts.json adding the {""address"":...""} for the
#deployed contract"</li>
           </pre>
         <li>Create  ""JS"" front-end app (if profile present)
         <li><code>$ truffle serve # start web server with front-end</code></li>
       </ol>
<!-- TODO:
config/app.json: build, deploy and ether-node rpc setup
./app: JS front-end app.
"tuffle compile generated config/development/contracts.json: 
Contains the JS interface to the Eth. contract."
test/example.js:
Note: 
 contract.value.call() -> NO new transactions => NO Eth expended
 contract.setValue(5) -> new transaction => eth expended     
      
contract('Example', function(accounts) {
  it('should do more complex interaction', function(done) {
    var example = Example.at(Example.deployed_address);
    example.value.call().then( function(value) {
      assert.equal(value, 0, 'Value should be zero after deployment');
    }).then(function() {
      return example.setValue(5);
    }).then(function(tx) {
      return example.value.call();
    }).then(function(value) {
      assert.equal(value, 5, 'Value should be five');
    })
    .then(done).catch(done);
  });
});
Deploying new contract:
> web3.eth.getCoinbase(function(e,r) { console.log(e, r); })
null ""0x82e.....""
> Example.new({ from: ""=x82e..."" }).then(function(instance) { ... })

-->
       </li>
       <li TODO><a href='https://github.com/ethpm/ethpm-js'>https://github.com/ethpm/ethpm-js</a>
         Javascript library for publishing and consuming Ethereum packages,
         provides utilities for publishing and consuming Ethereum packages based
         on the Ethereum Package Manager specification. It is meant to be integrated
         directly into development tools to support their use of the Ethereum Package Management ecosystem.
       </li>
     </ul>
  </td>  
  <td col2 >
<!--
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
-->
  </td>  
  <td col3 >
     <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>

<tr {>
  <th colspan=3 header_delimit } { ><a href='https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md'>ERC20 Coin/Fungible Assets Contract Interface</a></th>
</tr }>

<tr {>
  <td col1 >
     <ul>
       <li><a href='https://theethereum.wiki/w/index.php/ERC20_Token_Standard'>ERC20 @ Ethereum WiKi</a></li>
       <li><a href='https://edcon.io/ppt/two/Dmitry%20Khovratovich_Secure%20Token%20Development%20and%20Deployment_EDCON.pdf'>Problems with the Standard</a></li>
       <li><a href='https://tokenmarket.net/what-is/ethereum-token-wallets/'>ERC20 compliant wallets</a></li>
<!--
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col2 >
    Example implementations
    <ul>
      <li><a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol">OpenZeppelin StandardToken.sol</a></li>
      <li><a href="https://github.com/ConsenSys/Tokens/blob/master/contracts/StandardToken.sol">ConsenSys StandardToken.sol</a></li>
    </ul>
    <ul>
<!--
       <li> </li>
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li><a href='https://etherscan.io/tokens'>Popular Token List @ Etherscan</a></li>
<!--
       <li> </li>
       <li> </li>
-->
     </ul>
  </td>  
</tr }>

<tr {>
  <th colspan=3 header_delimit } { TODO >EXTERNAL STORAGE (IPFS, Maidsafe, SWARN,...)</th>
</tr }>
<!--
TODO: Compare with alternative Storage "providers": IPFS , Maidsafe, Storj
"WARM: Swarm is alpha software. Use at your own risk.

Code is currently at POC 0.2 codename 'sworm'. The source is now in the main branch of the go-ethereum repository. "
"http://swarm-gateways.net/bzz:/theswarm.eth/

Swarm
""serverless hosting incentivised peer-to-peer storage and content distribution""

""""""From the end user's perspective, Swarm is not that different from WWW, except that uploads are not to a specific server. The objective is to peer-to-peer storage and serving solution that is DDOS-resistant, zero-downtime, fault-tolerant and censorship-resistant as well as self-sustaining due to a built-in incentive system which uses peer to peer accounting and allows trading resources for payment. Swarm is designed to deeply integrate with the devp2p multiprotocol network layer of Ethereum as well as with the Ethereum blockchain for domain name resolution, service payments and content availability insurance. """"""

""""""Two major features of swarm that sets it apart from other decentralised distributed storage solutions (bittorent, zeronet, IPFS) are 'upload and disappear' and the incentive system. The former refers to fact that Swarm does not only serve content, but it also provides a cloud storage service. Unlike related systems, you do not only publish the fact you host content, but there is a genuine sense in which you can just upload stuff to the swarm and potentially disappear (drop off as a node, disconnect or just operate without storage entirely) right away. Swarm aspires to be the generic storage and delivery service catering for all usecases ranging from serving low latency realtime interactive web applications as well as acting as guaranteed persistent storage for rarely used content. The incentive system makes sure that participating nodes following their rational self interest nontheless converge on an emergent swarm behaviour that is beneficial for the entire system as well as economically self-sustaining. In particular, it allows nodes in the network to pool their bandwidth and storage resources in the most efficient way to collectively provide services. """""""
here are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account.
-->
<tr {>
  <th colspan=3 header_delimit } { TODO >FORMAL VERIFICATION</th>
</tr }>
<!--
FORMAL Verification
https://github.com/pirapira/eth-isabelle
https://github.com/pirapira/ethereum-formal-verification-overview
"Why3 Solidity
Why3 is a platform for deductive program verification. It provides a rich language for specification and programming, called WhyML, and relies on external theorem provers, both automated and interactive, to discharge verification conditions. (See the specific section below for the list of supported provers.) Why3 comes with a standard library of logical theories (integer and real arithmetic, Boolean operations, sets and maps, etc.) and basic programming data structures (arrays, queues, hash tables, etc.). A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism. WhyML is also used as an intermediate language for the verification of C, Java, or Ada programs. (See Projects using Why3 below.) Why3 can be easily extended with support for new theorem provers. Why3 can be used as a software library, through an OCaml API. 

"
"https://forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts

""""""We just merged a first pull request that allows Solidity contracts to be formally verified using a toolkit called why3.
This means that a computer creates and checks a mathematical proof of assertions about the behaviour of the contract.
Only a small subset of Solidity is supported for now, but that makes it already possible to verify a recursive binary search routine on arrays:
https://gist.github.com/chriseth/0c671e0dac08c3630f47""""""

""""""How to use it on the example
The solidity compiler (only solc at latest develop for now) can translate the source code into a different programming language which can be understood by why3 (the language is a dialect of ocaml). To do that, call it as ""solc --formal -o /tmp/output_directory/ source.sol"". Furthermore, using special tags in the Solidity comments of the form ""///@why3 ..."" you can formulate assertions and requirements that can be understood by the why3 framework and will be literally inserted into the generated code.

After that, you can use ""why3 ide /tmp/output_directory/solidity.mlw"" to start a graphical version of the toolkit and perform the verification.
How to install why3
I am not aware of any binary packages, so you have to download the source from the website.
As why3 itself is only a frontend to the real workhorses, the provers, you need to install a prover. I tried ""alt-ergo"" and Z3 - the first is part of the ubuntu distribution, the second has binaries for most platforms.

After installing the prover (and making sure it is in the PATH), call ""why3 config --detect"" and it should detect your prover. """""""
"Video Tutorial:
https://www.youtube.com/watch?v=Mzh4fyoaBJ0&feature=youtu.be&list=PL9oaY6Y4QxRZybj86eGItGVApxLXVIXHz"
https://gitter.im/ethereum/formal-methods
"https://en.wikipedia.org/wiki/Logical_harmony

Logical harmony, a name coined by Sir Michael Dummett, is a supposed constraint on the rules of inference (https://en.wikipedia.org/wiki/Rules_of_inference) that can be used in a given logical system(https://en.wikipedia.org/wiki/Logical_system)"

-->



<tr {>
  <th colspan=3 header_delimit } { TODO >External Inputs (Oracles)</th>
</tr }>
<!--
http://ethereumj.io/blog/2015/09/09/friendly-ether-bot/

""Ethereum is a great system to achieve consensus between an independent peers, but if we want to pump data from the real world into the system , how exactly we do it ?"""
TODO: Microsoft Cryplets
TODO: Oracle patterns

-->

<!--
-->
<tr {>
  <th colspan=3 header_delimit } { >
    <a href='https://github.com/ConsenSys/smart-contract-best-practices'>Smart-Contracts Best Practices</a>
  </th>
</tr }>
<tr {>
  <td col1 TODO >
     <ul>
<- -
       <li> </li>
       <li> </li>
       <li> </li>
- ->
     </ul>
  </td>  
  <td col2 >
     <ul>
<- -
       <li> </li>
       <li> </li>
       <li> </li>
- ->
     </ul>
  </td>  
  <td col3 >
     <ul>
<- -
       <li> </li>
       <li> </li>
       <li> </li>
- ->
     </ul>
  </td>  
</tr }>

<!--
-->
<tr {>
  <th colspan=3 header_delimit } { TODO >TODO_XXX</th>
</tr }>
<!--
-->

<tr {>
  <th colspan=3 header_delimit } END></th>
</tr }>
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 

-->
<!--
TODO:
_______________________________________________________
See also alternatives to Whisper: "Message Contract" and "Telehash"
https://github.com/ethereum/wiki/wiki/Whisper
"""""""
In a nutshell whisper is a communication protocol for DApps to communicate with each other.
Use case
    DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.

    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.
""""""
"
_______________________________________________________
_______________________________________________________
RPC Methods: JS API to Ethereum network:
https://github.com/ethereum/wiki/wiki/JavaScript-API
"eth_accounts                                           eth_getTransactionCount
eth_blockNumber                                        eth_getTransactionReceipt
eth_call                                               eth_hashrate
eth_coinbase                                           eth_mining
eth_compileSolidity                                    eth_newBlockFilter
eth_estimateGas                                        eth_newFilter (includes log/event filters)
eth_gasPrice                                           eth_sendTransaction
eth_getBalance                                         eth_sendRawTransaction
eth_getBlockByNumber                                   eth_sign
eth_getBlockByHash                                     eth_syncing
eth_getCode (only supports block number “latest”)      eth_uninstallFilter
eth_getCompilers                                       net_listening
eth_getFilterChanges                                   net_peerCount
eth_getFilterLogs                                      net_version
eth_getLogs                                            miner_start
eth_getStorageAt                                       miner_stop
eth_getTransactionByHash                               rpc_modules
eth_getTransactionByBlockHashAndIndex                  web3_clientVersion
eth_getTransactionByBlockNumberAndIndex                web3_sha3
_______________________________________________________
_______________________________________________________
Geth:
"- Keys are stored under <DATADIR>/keystore(backup regularly)
- keyfiles format(2017-05): UTC--<created_at UTC ISO8601>-<address hex>

geth account [arguments...]
geth account help <subcommand>
      subcommand:
    - new       :  create new accounts. Will ask for password/passphrase. Will return public address {168bc315a2ee09042d83d7c5811b533620531f67}
    - list      :  list all existing accounts. Example
                    | Account #0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b}
                    | Account #1: {c385233b188811c9f355d4caec14df86d6248235}
                    | Account #2: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
    - import    :  import a private key into a new account
                    | $ geth --datadir /someOtherEthDataDir  account import ./key.prv
                    | The new account will be encrypted with a passphrase.
                    | Please enter a passphrase now.
                    | Passphrase:
                    | Repeat Passphrase:
                    | Address: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
    -           :   | export (unencrypted format >>NOT<< supported)
    - update    :  migrate to newest key format. account will be saved in newest version in encrypted format
                   you are prompted for passphrase to unlock old-format account wallet and another to save updated file
                   (can also be used to change file/wallet password)
                    | $ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b
                    | Unlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b | Attempt 1/3
                    | Passphrase:
                    | 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b
                    | Account 'a94f5374fce5edbc8e2a8697c15331677e6ebf0b' unlocked.
                    | Please give a new password. Do not forget this password.
                    | Passphrase:
                    | Repeat Passphrase:
                    | 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b

    -           :  change password



using account NON-interactively (not connected to a geth node):
   STEP 1: unlock account wallet for one session: 
   $ getch ??? --unlock <comma_separated_account_list>(in hex)  # with on list -> first found account
   Example:
   $ geth --unlock primary --rpccorsdomain localhost --verbosity 6 2>> geth.log 
   $ geth --unlock "0x407d73d8a49eeb85d32cf465507dd71d507100c1,0,5,e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32"


CHECKING ACCOUNT BALANCES FROM GETH CONSOLE
    $ cat /Users/username/gethload.js
    function checkAllBalances() {
        var totalBal = 0;
        for (var acctNum in eth.accounts) {
            var acct = eth.accounts[acctNum];
            var acctBal = web3.fromWei(eth.getBalance(acct), "ether");
            totalBal += parseFloat(acctBal);
            console.log("  eth.accounts[" + acctNum + "]: \t" + acct + " \tbalance: " + acctBal + " ether");
        }
        console.log("  Total balance: " + totalBal + " ether");
    };
    ---------------------
    > loadScript("/Users/username/gethload.js")
    > checkAllBalances();
      eth.accounts[0]: 0xd1ade25ccd3d550a7eb532ac759cac7be09c2719         balance: 63.11848 ether
      eth.accounts[1]: 0xda65665fc30803cb1fb7e6d86691e20b1826dee0         balance: 0 ether
      eth.accounts[2]: 0xe470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32         balance: 1 ether
_______________________________________________________
 - Libraries / Libraries dispatcher / ...
 https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736
 https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd
 https://blog.aragon.one/advanced-solidity-code-deployment-techniques-dc032665f434
 https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd

______________________________________________

{
"Alt 2: npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use
"
}


{ INSTALL SOLIDITY COMPILER (solc)    
Alt 1   "npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use"   
Alt 2   "PPAs for Ubuntu. For the latest stable version.
Solidity Documentation, Release 0.4.8-develop
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc

If you want to use the cutting edge developer version:
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc"  
}
_____________________________________
LexiFi's Modeling Language for Finance

Screenshot

Developed by the company LexiFi, the Modeling Language for Finance (MLFi) is the first formal language that accurately describes the most sophisticated capital market, credit, and investment products. MLFi is implemented as an extension of OCaml.

MLFi users derive two important benefits from a functional programming approach. First, the declarative formalism of functional programming languages is well suited for specifying complex data structures and algorithms. Second, functional programming languages have strong list processing capabilities. Lists play a central role in finance where they are used extensively to define contract event and payment schedules.

In addition, MLFi provides crucial business integration capabilities inherited from OCaml and related tools and libraries. This enables users, for example, to interoperate with C and Java programs, manipulate XML schemas and documents, and interface with SQL databases.

Data models and object models aiming to encapsulate the definitions and behavior of financial instruments were developed by the banking industry over the past two decades, but face inherent limitations that OCaml helped overcome.

LexiFi's approach to modeling complex financial contracts received an academic award in 2000, and the MLFi implementation was elected “Software Product of the Year 2001” by the magazine Risk, the leading financial trading and risk management publication. MLFi-based solutions are gaining growing acceptance throughout Europe and are contributing to spread the use of OCaml in the financial services industry
___________________________
The ASTRÉE Static Analyzer

David Monniaux (CNRS), member of the ASTRÉE project, says: “ASTRÉE is a static analyzer based on abstract interpretation that aims at proving the absence of runtime errors in safety-critical software written in a subset of the C programming language.”

“Automatically analyzing programs for exactly checking properties such as the absence of runtime errors is impossible in general, for mathematical reasons. Static analysis by abstract interpretation works around this impossibility and proves program properties by over-approximating the possible behaviors of the program: it is possible to design pessimistic approximations that, in practice, allow proving the desired property on a wide range of software.”

“So far, ASTRÉE has proved the absence of runtime errors in the primary control software of the Airbus A340 family. This would be impossible by software testing, for testing only considers a limited subset of the test cases, while abstract interpretation considers a superset of all possible outcomes of the system.”

“ASTRÉE is written in OCaml and is about 44000 lines long (plus external libraries). We needed a language with good performance (speed and memory usage) on reasonable equipment, easy support for advanced data structures, and type and memory safety. OCaml also allows for modular, clear and compact source code and makes it easy to work with recursive structures such as syntax trees.”

____________________________________________
https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall
Difference between CALL, CALLCODE and DELEGATECALL
   
CALL and CALLCODE take the same number of operands (in the execution stack).
For the exception flag being pushed on top of the stack: 0 means exception, 1 means successful execution.
CALL is easy to understand, but I could not digest the subtle difference between CALL & CALLCODE. It is stated in the yellow paper that for

CALLCODE: This means that the recipient is in fact the same account as at present, simply that the code is overwritten.

What does it mean by the code is overwritten? Does that mean I can ask the contract to execute some external code? It would be helpful if anyone can provide me an example to differentiate between the two.

EDIT: DELEGATECALL was added in Homestead what is the difference?
Response:
DELEGATECALL basically says that I'm a contract and I'm allowing (delegating) you to do whatever you want to my storage. DELEGATECALL is a security risk for the sending contract which needs to trust that the receiving contract will treat the storage well.

DELEGATECALL was a new opcode that was a bug fix for CALLCODE which did not preserve msg.sender and msg.value. If Alice invokes Bob who does DELEGATECALL to Charlie, the msg.sender in the DELEGATECALL is Alice (whereas if CALLCODE was used the msg.sender would be Bob).
Details

When D does CALL on E, the code runs in the context of E: the storage of E is used.

When D does CALLCODE on E, the code runs in the context of D. So imagine that the code of E is in D. Whenever the code writes to storage, it writes to the storage of account D, instead of E.

contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3("setN(uint256)")), _n); // E's storage is set, D is not modified 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }
}

contract E {
  uint public n;
  address public sender;

  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    // msg.sender is D if invoked by D's callcodeSetN. None of E's storage is updated
    // msg.sender is C if invoked by C.foo(). None of E's storage is updated

    // the value of "this" is D, when invoked by either D's callcodeSetN or C.foo()
  }
}

contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}

When D does CALLCODE on E, msg.sender inside E is D as commented in the code above.

When an account C invokes D, and D does DELEGATECALL on E, msg.sender inside E is C. That is, E has the same msg.sender and msg.value as D.

____________________________________________

    <hr/>
    Libraries: similar to contracts, but their purpose is that
    they are deployed only once at a specific address and their code is reused
    using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. 
    In comparison to contracts:
    <ul>
      <li>No state variables</li>
      <li>Cannot inherit nor be inherited</li>
      <li>Cannot recieve Ether</li>
    </ul>
____________________________________________

'Ethereum client' refers to any node able to parse and verify the blockchain, its smart contracts ... .
 It also provides (JSON-RPC?) interfaces to create transactions and mining"
____________________________________________

Third party non-official clients:

parity (Rust client): https://github.com/ethcore/parity

ethereumj Java client: https://github.com/ethereum/ethereumj

ethereumjs-vm: https://github.com/ethereumjs/ethereumjs-vm

node-blockchain-server: https://github.com/ethereumjs/node-blockchain-server

____________________________________________
____________________________________________
http://martin.swende.se/blog/EVM-Assembly-trick.html#
"""I recently discovered a method to do generic proxying of Ethereum calls. Skip further down for nitty gritty details, I’ll start this off with some basics.
The problem

Sometimes, it’s convenient to build contract factories. For example, say you want to implement crowdsourcing, or auctions, or games, or DAOs. In those cases, instead of having one “Mother” auction which keeps track of active auctions (which, in turn keep track of bidders, offers and items), it makes sense to implement each auction/crowdfund/game/DAO as it’s own contract.

One problem is that these contracts are quite heavy; creating them may be very expensive and the creation of several may be limited by block gas limits. To counter this, the library-model can be used instead: """
____________________________

<a href='http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers'>Function modifiers</a>

_________________________
Security Considerations:
http://solidity.readthedocs.io/en/develop/security-considerations.html#security-considerations
________________________
The Ethereum Package Registry
   https://www.ethpm.com/
 A package index for Ethereum smart contract packages.

The Ethereum Package Registry is a package index for Ethereum smart contract packages. The registry is based on the ERC190 Smart Contract Packaging Specification.

"""Dear Ethereum,

We need to talk. You're not the easiest platform to work with. Don't get me wrong, you have some great qualities but it's time to grow up and start acting a bit more... mature

Since we care about you and really want you to succeed we made you something that should help. It's called a package index.

I know change can be a little scary but we're sure that once you try it you'll love it. Developers are going to like you more. Their bosses may even stop seeing you as the dangerous kid teaching their devs bad habits like copy/pasting code.

Please give it a try. We really do want the best for you.

Piper & Tim
"""
___________________
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids
List of Chain ID's:
CHAIN_ID    Chain(s)
1   Ethereum mainnet
2   Morden (disused), Expanse mainnet
3   Ropsten
4   Rinkeby
30  Rootstock mainnet
31  Rootstock testnet
42  Kovan
61  Ethereum Classic mainnet
62  Ethereum Classic testnet
1337    Geth private chains (default)
_____________________________
https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88
_____________________________
Add notes about Zepellin https://openzeppelin.org/ Open framework or reusable security contracts for Solidity language (Ethereum)
- create links to interesting sites:
http://www.digitalchamber.org/smart-contract-alliance.html 
http://ethereum.stackexchange.com/
https://www.google.es/?q=smart+contract+formal+verification
_____________________________
formal verification for Smart Contracts ( https://chriseth.github.io/notes/talks/formal_devcon2/#/ ,  http://www.cs.umd.edu/~aseem/solidetherplas.pdf , 
https://www.google.es/?q=smart+contract+formal+verification )

______________________
APP: Ethereum atomic Swaps
   https://github.com/AltCoinExchange/ethatomicswap
  created by https://www.altcoin.io, "A truly decentralized cryptocurrency exchange. Powered by Atomic Swaps."
______________________
1 Log per TX (NO compactado):
Cost  TX:    21000 gas/TX    * 1TX       = 21000
Coste evento:  375 gas/LOG   * 1LOG      =   375
Coste Topic:   375 gas/topic * 3topic    =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes =  1240
                                          ------
                                 TOTAL     23740 gas   = 23740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.228  Eu

5 Logs per TX (compactado):
Cost  TX:    21000 gas/TX    * 1TX        = 21000
Coste evento:  375 gas/LOG   * 1LOG       =   375
Coste Topic:   375 gas/topic * 3topic     =  1125
Coste byte/logs: 8 gas/byte  * 1500 bytes = 12400
                                           ------
                                  TOTAL     34900 gas  = 34900 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.33504 Eu (0.07 Eu 1Log)


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
                                               ------
                                      TOTAL    101000 gas  = 101000 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.9696 Eu


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
Coste evento:  375 gas/LOG   * 1LOG           =   375
Coste Topic:   375 gas/topic * 3topic         =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes      =  1240
                                               ------
                                      TOTAL    103740 gas  = 103740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.995904 Eu
-------------------------------------------------
________________________________
https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#.gbg2nh4o5

Onward with Ethereum Smart Contract Security

If you’re new to Ethereum development, I recommend you read our Hitchhiker’s Guide to Smart Contracts in Ethereum before proceeding.

Learning Ethereum Smart Contract security is a very hard endeavor. There are few good guides and compilations, such as Consensys’ Smart Contracts 
Best Practices, or the Solidity Documentation Security Considerations. But the concepts are very hard to remember and internalize without writing your own code.

I’ll attempt a slightly different approach. I’ll explain some recommended strategies to improve smart contract security and show code examples where not
 following them results in problems. I’ll also show you code samples you can use to protect your smart contracts. Hopefully, this will help create a muscle
 memory of things to avoid, which will trigger mental warnings when writing actual code.

Without further ado, let’s dive into the best practices:
Fail as early and loudly as possible

A simple yet powerful programming good practice is to make your code fail as promptly as possible. And be loud about it. Let’s see an example of a function
 that behaves timidly:

// UNSAFE CODE, DO NOT USE!

contract BadFailEarly {
  uint constant DEFAULT_SALARY = 50000;
  mapping(string => uint) nameToSalary;

  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length != 0 && nameToSalary[name] != 0) {
      return nameToSalary[name];
    } else {
      return DEFAULT_SALARY;
    }
  }
}

We want to avoid a contract failing silently, or continuing execution in an unstable or inconsistent state. The function getSalary is checking for conditions 
before returning the stored salary, which is a good thing. The problem is, in case those conditions are not met, a default value is returned. This could hide 
an error from the caller. This is an extreme case, but this kind of programming is very common, and normally arises from fear of errors breaking our app.
Truth is, the sooner we fail, the easier it will be to find the problem. If we hide errors, they can propagate to other parts of the code and cause inconsistencies
 which are difficult to trace. A more correct approach would be:

contract GoodFailEarly {
  mapping(string => uint) nameToSalary;
  
  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length == 0) throw;    
    if (nameToSalary[name] == 0) throw;
    
    return nameToSalary[name];
  }
}

This version also shows another desirable programming pattern which is separating preconditions and making each fail separately. Note that some of these
 checks (especially those depending on internal state) can be implemented via Function Modifiers.
Favor pull over push payments

Every Ether transfer implies potential code execution. The receiving address can implement a fallback function that can throw an error. Thus, we should never 
trust that a send call will execute without error. A solution: our contracts should favor pull over push for payments. Take a look at this innocent looking code for 
a bidding function:

// UNSAFE CODE, DO NOT USE!

contract BadPushPayments {
  address highestBidder;
  uint highestBid;
 
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0) {
      // return bid to previous winner
      if (!highestBidder.send(highestBid)) {
        throw;
      }
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
}

Note that the contract calls the send function and checks its return value, which seems reasonable. But it calls send in the middle of a function, which is unsafe. Why? Remember that, as stated above, send can trigger the execution of code in another contract.

Imagine someone bids from an address which simply throws an error every time someone sends money to it. What happens when someone else tries to outbid that? The send call will always fail, bubbling up and making bid throw an exception. A function call that ends in error leaves the state unchanged (any changes made are rolled back). That means nobody else can bid, and the contract is broken.

The easiest solution is to separate payments into a different function, and have users request (pull) funds independently of the rest of the contract logic:

contract GoodPullPayments {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  
  function bid() external {
    if (msg.value < highestBid) throw;
    
    if (highestBidder != 0) {
      refunds[highestBidder] += highestBid;
    }
    
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdrawBid() external {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund)) {
      refunds[msg.sender] = refund;
    }
  }
}

This time, we use a mapping to store refund values for each outbid bidder, and provide a function to withdraw their funds. In case of a problem in the send call, only that bidder is affected. This is a simple pattern that solves many other problems (such as reentrancy), so remember: when sending ether, favor pull over push payments.

I’ve implemented a contract you can inherit from to easily use this pattern. Here’s an example showing how to use it.
Order your function code: conditions, actions, interactions

As an extension of the fail-early principle, a good practice is to structure all your functions as follows: first, check all the pre-conditions; then, make changes to your contract’s state; and finally, interact with other contracts.

Conditions, actions, interactions. Sticking to this function structure will save you lots of problems. Let’s see an example of a function using this pattern:

function auctionEnd() {
  // 1. Conditions
  if (now <= auctionStart + biddingTime)
    throw; // auction did not yet end
  if (ended)
    throw; // this function has already been called

  // 2. Effects
  ended = true;
  AuctionEnded(highestBidder, highestBid);

  // 3. Interaction
  if (!beneficiary.send(highestBid))
    throw;
  }
}

This is in line with the fail fast principle, as conditions are checked in the beginning. It also leaves potentially dangerous interactions with other contracts to the very end.
Be aware of platform limits

The EVM has a lot of hard limits on what our contracts can do. These are platform-level security considerations, but may threaten your particular contract’s security if you don’t know about them. Let’s take a look at the following innocent-looking employee bonus management code:

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (var i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

Read the code: it’s pretty straight-forward and seems correct. It hides 3 potential problems, though, based on platform limits.

The first problem is that the type of i will be uint8, because this is the smallest type that is required to hold the value 0. If the array has more than 255 elements, the loop will not terminate, resulting in gas depletion. Better use the explicit type uint for no surprises and higher limits. Avoid declaring variables using var if possible. Let’s fix that:

// STILL UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

The second thing you should consider is the gas limit. Gas is Ethereum’s mechanism to charge for network resources. Every function call that modifies state has a gas cost. Imagine calculateBonus calculates the bonus for each employee based on some complex computation like calculating the profit over many projects. This would spend a lot of gas, which could easily reach the transaction’s or block’s gas limit. If a transaction reaches the gas limit, all changes will be reverted but the fee is still paid. Be aware of variable gas costs when using loops. Let’s optimize the contract by separating the bonus calculation from the for loop. Please note that this still has the issue that as the employees array grows, the gas cost grows.

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  mapping(address => uint) bonuses;  
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation modifying the bonus...
    bonuses[employee] = bonus;
  }
}

Last, there is the call stack depth limit. The EVM’s call stack has a hard limit of 1024. That means that if the amount of nested calls reaches 1024, the contract will fail. An attacker can call a contract recursively 1023 times and then call our contract’s function, causing sends to silently fail because of this limit. PullPaymentCapable.sol was described above, and allows to easily implement pull payments. Inheriting from PullPaymentCapable and using asyncSend protects you from this.

Here’s a modified version of the code that fixes all these issues:

import './PullPaymentCapable.sol';

contract GoodArrayUse is PullPaymentCapable {
  address[] employees;
  mapping(address => uint) bonuses;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      asyncSend(employee, bonus);
    }
  }

  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation...
    bonuses[employee] = bonus;
  }
}

To sum up, be sure to remember about (1) limits in the types you’re using, (2) limits in the gas costs of your contract, and (3) the call stack depth limit.
Write tests

Writing tests is a lot of work, but will save you from regression problems. A regression bug appears when a previously correct component gets broken based on a recent change.

I’ll be writing a more extensive guide on testing soon, but if you’re curious you can check Truffle’s testing guide.
Fault tolerance and Automatic bug bounties

Thanks to Peter Borah for inspiration on these two ideas. Code reviews and security audits are not enough to be safe. Our code needs to be ready for the worst. In case there is a vulnerability in our smart contract, there should be a way for it to safely recover. Not only that, but we should try to find those vulnerabilities as early as possible. That’s where automatic bug bounties built into our contract can help.

Let’s take a look at this simple implementation of an automatic bug bounty for a hypothetical Token contract:

import './PullPaymentCapable.sol';
import './Token.sol';

contract Bounty is PullPaymentCapable {
  bool public claimed;
  mapping(address => address) public researchers;
  
  function() {
    if (claimed) throw;
  }
  
  function createTarget() returns(Token) {
    Token target = new Token(0);
    researchers[target] = msg.sender;
    return target;
  }
  
  function claim(Token target) {
    address researcher = researchers[target];
    if (researcher == 0) throw;
    
    // check Token contract invariants
    if (target.totalSupply() == target.balance) {
      throw;
    }
    asyncSend(researcher, this.balance);
    claimed = true;
  }
}

As before, we’re using PullPaymentCapable to make our outgoing payments safe. This Bounty contract allows researchers to create copies of the Token contract we want audited. Anyone can contribute to the bug bounty by sending transactions to the Bounty contract’s address. If any researcher manages to corrupt his copy of the Token contract, making some invariant break (for example, in this case, making the total supply of tokens different from the Token’s balance), he’ll get the bounty reward. Once the bounty is claimed, the contract won’t accept any more funds (that nameless function is called the contract’s fallback function, and is executed every time the contract is sent money directly).

As you can see, this has the nice property that it is a separate contract and requires no modification of our original Token contract. Here’s a full implementation available on GitHub for anyone to use.

As for fault tolerance, we will need to modify our original contract to add extra safety mechanisms. A simple idea is to allow a contract’s curator to freeze the contract as an emergency mechanism. Let’s see a way to implement this behavior via inheritance:

contract Stoppable {
  address public curator;
  bool public stopped;

  modifier stopInEmergency { if (!stopped) _ }
  modifier onlyInEmergency { if (stopped) _ }
  
  function Stoppable(address _curator) {
    if (_curator == 0) throw;
    curator = _curator;
  }
  
  function emergencyStop() external {
    if (msg.sender != curator) throw;
    stopped = true;
  }
}

Stoppable allows one to specify a curator address that can stop the contract. What does “stopping the contract” mean? That’s to be defined by the child contract inheriting from Stoppable by using the function modifiers stopInEmergency and onlyInEmergency. Let’s see an example:

import './PullPaymentCapable.sol';
import './Stoppable.sol';

contract StoppableBid is Stoppable, PullPaymentCapable {
  address public highestBidder;
  uint public highestBid;
  
  function StoppableBid(address _curator)
    Stoppable(_curator)
    PullPaymentCapable() {}
  
  function bid() external stopInEmergency {
    if (msg.value <= highestBid) throw;
    
    if (highestBidder != 0) {
      asyncSend(highestBidder, highestBid);
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdraw() onlyInEmergency {
    suicide(curator);
  }
}

In this toy example, the bid can now be stopped by a curator, defined when the contract is created. While the StoppableBid is in normal mode, only the bid function can be called. If something weird happens and the contract is in an inconsistent state, the curator can step in and activate the emergency state. This makes the bid function uncallable, and allows the function withdraw to work.

In this case, emergency mode would only allow the curator to destroy the contract and recover the funds, but in a real case, recovery logic could be more complex (for example returning funds to their owners). Here’s an implementation of Stoppable available on GitHub for anyone to use.
Limit the amount of funds deposited

Another way to protect our smart contracts from attacks is to limit their scope. Attackers will most probably target high-profile contracts managing millions of dollars. Not all smart contracts need to have such high stakes. Especially if we’re conducting experiments. In such cases, it might be useful to limit the amount of funds our contract accepts. This is as simple as a hard limit on the balance of the contract’s address.

Here’s a simplified example on how to do this:

contract LimitFunds {
  
  uint LIMIT = 5000;
  
  function() { throw; }
  
  function deposit() {
    if (this.balance > LIMIT) throw;
    ...
  }
}

The short fallback function will reject any direct payments to the contract. The deposit function will first check if the contract’s balance exceeds the desired limit, or throw an exception. More interesting things like dynamic or managed limits are easy to implement too.
Write simple and modular code

Security comes from a match between our intention and what our code actually allows to do. This is very hard to verify, especially if the code is huge and messy. That’s why it’s important to write simple and modular code.

This means, functions should be as short as possible, code dependencies should be reduced to the minimum, and files should be as small as possible, separating independent logic into modules, each with a single responsibility.

Naming is also one of the best ways to express our intention when coding. Think a lot about the names you chose, to make your code as clear as possible.

Let’s study an example of bad naming of Events. Look at this function from The DAO. I’m not going to copy the function code here because it’s very long.

The biggest problem is that it’s too long and complex. Try to keep your functions much shorter, say, up to 30 or 40 lines of code max. Ideally, you should be able to read functions and understand what they do in less than a minute. Another problem is the bad naming for the event Transfer in line 685. The name differs from a function called transfer by only 1 character! This is inviting confusion for everyone. In general, the recommended naming for events is that they should start with “Log”. In this case, a better name would be LogTransfer.

Remember, write your contracts as simple, modular, and well-named as possible. This will greatly facilitate others and yourself in auditing your code.
Don’t write all your code from scratch

Finally, as the old adage reads: “Don’t roll your own crypto”. I think it also applies to Smart Contract code. You’re dealing with money, your code and data is public, and you’re running in a new and experimental platform. The stakes are high and the chances to mess-up are everywhere.

These practices help secure our smart contracts. But ultimately, we should create better developer tools to build smart contracts. There are some interesting initiatives including better type systems, Serenity Abstractions, and the Rootstock platform.

There’s lots of good and secure code already written and frameworks are starting to appear. We’ve started to compile some of the best practices in this GitHub repo we called OpenZeppelin. Feel free to take a look and contribute with new code or security audits.
Wrapping up

To recap, the security patterns described in this article are:

    Fail as early and loudly as possible
    Favor pull over push payments
    Order your function code: conditions, actions, interactions
    Be aware of platform limits
    Write tests
    Fault tolerance and Automatic bug bounties
    Limit the amount of funds deposited
    Write simple and modular code
    Don’t write all your code from scratch

If you want to join the discussion about secure smart contract development patterns join us on slack. Let’s improve the smart contract development standards together!

To be up to date with our work in smart contract security, follow us on Medium and Twitter.
_______________________________________

See also: https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab#.xk3bv3cw8
_______________________________
<strong>Ethereum</strong><br>
Ethereum was able to successfully execute a hard fork called Byzantium. As part of this hard fork increased anonymity was provided through Zero-knowledge proofs, or zk-snark proofs. It also included more predictable gas charges which were becoming difficult to calculate with the increased number of ICOs. InfoQ previously covered this hard fork in the following <a href="https://www.infoq.com/news/2017/08/Ethereum-HardFork" target="_blank">article</a>.</p>
________________________
Ethereum ¿Opinion?: """
Bitcoin UTXO binary state (spent, unspent) gives no opportunity for multi-stage contracts or scripts
which keep any other interanl state beyond that. This makes it hard to make multi-stage options
contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary
for secure computational bounties). It also means that UTXO can only be used to build simple, one-off
contracts and not more complex "stateful" contracts such as decentralized organizations, and makes
meta-protocols difficult to implement. Binary state combined with value-blindness also mean that 
another important application, withdrawal limits, is impossible".
__________________________________

-->
</html>
