<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Ethereum Map (beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>
<a href="https://github.com/ethereum/wiki/wiki/White-Paper">White-Paper@Github</a>,
<a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper <a href="https://github.com/ethereum/yellowpaper">Git repo</a>
<a href="https://solidity.readthedocs.io/en/v0.5.0/resources.html">Solidity Resources</a>,
<a TODO href="https://github.com/pirapira/awesome-ethereum-virtual-machine">Ethereum VM</a>,
<a TODO href="https://github.com/ethereum/go-ethereum/tree/master/core/vm">Geth VM</a>,
<a TODO href="https://entethalliance.org/wp-content/uploads/2018/11/EEA_Off_Chain_Trusted_Compute_Specification_V0_5-1.pdf">EEA Off-chain Trusted Compute Spec</a>
<table style='width:100%'{>
<tbody>
<tr>
<td>
  Who is Who
<pre xxxsmall zoom>
- Vitalik Buterin, Ethereum Original Creator.

- Raul Jordan, Prysmatic labs: Sharding Protocol 
  minimal sharding protocol implementation:
- DApps and Solidity Development:
  - <a href="https://maraoz.com/">Manuel Araoz</a>: CTO&amp;co-founder at Zeppelin.
  - <a href="http://blog.aragon.one/author/luis/">Luis Cuende</a>: CEO and cofounder of Aragon One

  - Rob Hitchens, author of <a href="https://medium.com/@robhitchens/solidity-crud-part-1-824ffa69509a">Solidity CRUD</a>

  - <a href="https://www.b9lab.com/">b9lab</a> Quality Blockchain Education for everyone</a>
  - Xavier Lepretre, senior consultant at B9Lab

  - <a href="http://blog.notdot.net/">Nick Johnson</a>, Arachnid Labs ("string utils")
      <a href="http://blog.notdot.net/tag/damn-cool-algorithms">Damm Cool Algorithms</a>

  - <a href="https://ethereum.stackexchange.com/users/19510/smarx">Steve Marx</a> and Tood Proebsting:
    Authors of <a href="https://programtheblockchain.com/">programtheblockchain.com</a> with great tutorials about Payment Channels (<a href="https://programtheblockchain.com/posts/2018/12/10/introduction-to-ethereum-payment-channels-video/">1</a>, <a href="https://programtheblockchain.com/posts/2018/02/23/writing-a-simple-payment-channel/">2</a>, <a href="https://programtheblockchain.com/posts/2018/03/02/building-long-lived-payment-channels"/>3</a>
   

EEA:
  - Bill Allder: EEA Membership Director
  - Oksana Davis: EEA Chief Legal Counsel and Corporate Secretary
</pre>

  Who is Who (EEA/Quorum)
<pre xxxsmall zoom>
- Felix Shnir, Quorum Core, Developer Advocate               (J.P. Morgan)

- Patrick Nielsen, Quorum and Constellation's Lead Engineer  (J.P. Morgan)

- Brian Marchiony Head of CIB Marketing &amp; Communications (J.P. Morgan)

- Amber Baldet Program Lead, Blockchain Center of Excellence (J.P. Morgan)

- David Voell Engineering Lead, CIB Emerging Technologies    (J.P. Morgan)

</pre>




</td>
<td>
  External Links
<pre xxxsmall zoom>
- <a TODO href="https://github.com/ethereum/wiki/wiki/Design-Rationale">Design Rationale</a>
- <a href="https://theethereum.wiki/w/index.php/Main_Page">Ethereum Wiki</a>
- <a href="https://solidity.readthedocs.io/">Solidity</a>
- <a href="https://entethalliance.org/resources/">Enterprise Ethereum Alliance Resources</a>
- <a href="https://github.com/bkrem/awesome-solidity">Awesome Solidity</a>: 
  Curated list of libraries, auditing/secuirity tools, dev tools, security tutorial links,...
- <a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">Awesome EVM</a>
- <a href="https://ethereum.stackexchange.com/users/87/afri">"Afri" Ethereum FAQ answers on Stackoverflow</a>
</pre>
wei → ... ether → Units
<pre xxxsmall zoom>
wei                         :                                1 wei      <--- discussion around APIs ...
gwei(shannon|nanoether|nano):                    1.000.000.000 weis     <--- gas prices
szabo|microether|micro      :                            1.000 gweis
finney|milliether|milli     :                        1.000.000 gweis    <--- micropayments
ether                       :                    1.000.000.000 gweis    <--- main unit
kether(grand|einstein)      :                            1.000 ethers 
mether                      :                        1.000.000 ethers
gether                      :                    1.000.000.000 ethers
tether                      :                1.000.000.000.000 ethers
</pre>

<a href="https://en.wikipedia.org/wiki/Ethereum#Milestones">Pub. Network Versions</a>
<pre xxxsmall zoom>
Homestead → Metropolis → Serenity →

Homestead : January 2016, ~80% complete 
            block reward set to 5 ether

Metropolis Part 1,Byzantium     : "Ethereum" for the masses.
Metropolis Part 2,Constantinople: Planned. Lay the fundations of PoS(Casper consensus)
 
Serenity  : "last phase", one key principle: switch to proof of stake

<a href="https://www.trustnodes.com/2018/06/16/casper-sharding-merger-confirmed-constantinople-back-table">2018/06/17 Casper and sharding merger confirmed</a>

</pre>
</td>
<td colsep></td>
<td>
  EVM Summary
<pre xxxsmall zoom>
- EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.
- Persistent storage is quite expensive.
- The Solidity compiler makes interesting choices in order to minimize gas usage.

- To interact with a Smart Contract, you send it raw bytes.
- It does some computation, possibly changing its own state, 
  and then sends you raw bytes in return. 
- Method calling does not actually exist. It is a collective 
  illusion created by the ABI.
- The ABI is specified like a low-level format, but in function
  it's more like a serialization format for a cross-language RPC framework.
- We could draw analogies between the architectural tiers of DApp and Web App:
  - The blockchain is like the backing database
  - A contract is like a web service
  - A transaction is like a request
  - ABI is the data-interchange format, like Protocol Buffer


 EVM Events:
 - In the wild, there are three main uses for event logs:
   - As ersatz return values, because a transaction does not record a method's return values.
   - As a kind of cheaper alternative data storage, as long as the contract does not need access to it.
   - Events that DApp clients can subscribe to.
 - Event logging map to EVM logging primitives.

event Deposit( address indexed _from, bytes32 indexed _id, uint _value);

 - limitations:
   - There may be at most 3 indexed parameters.
   - If the type of an indexed parameter is larger than 32 bytes, 
     only the KECCAK256 digest of the data is stored.
 -  EVM Log Primitives
   - log0, log1, ..., log4 EVM instructions.
 - The EVM logging facility uses different terminologies than Solidity:
   "topics": There may be up to 4 topics exactly 32 bytes each
            Solidity consumes one topic for the event's signature so only 3 are available
   "data"  : Payload of the event. It may be arbitrary number of bytes

 - Bloom filters are used to speed up search-by-topic


</pre>

<a xsmall href="http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html">External/Contract Accounts</a> 
<pre xxxsmall zoom>
Account:
---------
address                   
wei balance               
                          
   - decrease: by using the private key to sign new TXs from this address.

┌──────────────────┐
│bytes[32] address │
├──────────────────┤
│wei       balance │ ← Only the owner of the (32 bytes) <b>secret</b>
│                  │   private key can decrease the balance by signing
│                  │   a new payment TX with its private key
├──────────────────┤
│Map&lt;256b,256b> │
│          storage │
└──────────────────┘

                ┌─────────────────────────────────────────────────┬──────────────────────────────────────────┐
                │   EXTERNALLY OWNED ACCOUNT                      │          CONTRACT ACCOUNTS               │
┌───────────────┼─────────────────────────────────────────────────┼──────────────────────────────────────────┤
│CREATION       │ Generate random 32bytes private key →           │ Create smart-contract source code →      │
│               │   Generate (512bytes?) Pub.Key from Priv.Key →  │ Generate bytecode by compiling source →  │
│               │     Generate 32bytes pub.address = hash(PubKey) │ Send "Contract Creation" TX for mining → │
│               │                                                 │ keep Contract address once "published" *1│
├───────────────┼─────────────────────────────────────────────────┼──────────────────────────────────────────┤
│CONTROLLED BY  │ Private Key: Only the (human) owner of the      │ BYTECODE                                 │
│               │ *secret* private key can decrease the balance   │                                          │
│               │ by signing a new payment TX                     │                                          │
├───────────────┼─────────────────────────────────────────────────┼──────────────────────────────────────────┤
│FEATURES       │ bytes[32] address                               │ bytes[32] address *1                     │
│               │                                                 │ Map&lt;256b,256b> storage *2             │
└───────────────┴─────────────────────────────────────────────────┴──────────────────────────────────────────┘
 *1: account.address in a contract is determined
     at the time the contract is created
     derived from:
     nonce = function(creator address, num.TXs sent)

 *2: account.storage: Persistent memory area 
     - It is not possible to enumerate storage from within a contract
     - It is comparatively costly to read and even more so, to modify storage
     - A contract can neither read nor write to any storage apart from its own
    </ul>
  </li>
  </ul>
NOTE: <b>External and Contract Accounts SHARED THE SAME ADDRESS SPACE.</b>
</pre>
</td>
<td>
  Message Calls
<pre xxxsmall zoom>
Message Calls
-------------
sender
target(can be==sender)
payload
ether
gas
return data
</pre>
  <ul xxxsmall zoom>
  <li>Contracts can user message calls to call other contracts or send Ether to
     non-contract accounts.<br/>
     Every transaction consists of a top-level message call which in turn can 
     create further message calls.<br/>
     Contracts can decide how much of its remaining gas should be sent with the
     inner message call and how much it wants to retain. If an out-of-gas 
     exception happens in the inner call (or any other exception), this will be
     signalled by an error value put onto the stack. In this case, only the gas
     sent together with the call is used up. In Solidity, the calling contract 
     causes a manual exception by default in such situations, so that exceptions
     "bubble up" the call stack.<br/>
     Calls depth is limited to 1024 (Loops must be used over recursive calls)<br/>
     After finished execution, contracts can return data stored at a 
     preallocated location in the caller’s memory.
  </li>
  <li>Delegatecall (See libraries): Special variant of a message call, is 
    identical to a message call apart from the fact that the code at the target
    address is executed in the context of the calling contract and msg.sender 
    and msg.value do not change their values.<br/>
    This means that a contract can dynamically load code from a different 
    address at runtime.<br/>
    Storage, current address and balance still refer to the calling contract, 
    only the code is taken from the called address.<br/>
    This makes it possible to implement the “library” feature in Solidity:
    Reusable library code that can be applied to a contract’s storage in order to e.g. implement a complex data structure.
  </li>
  </ul>
</td>  
<td>
  <span xsmall>(EVM) Memory:</span>
<pre xxxsmall zoom bgorange>
- A contract obtains a freshly cleared instance for each message call
- Memory is linear and can be addressed at byte level
- <b>Reads are limited to a width of 256 bits</b>
- <b>Writes can be either 8 bits or 256 bits wide</b>
- Memory is expanded by a word (256-bit), when accessing 
    (either reading or writing) a previously untouched memory word (ie.
    any offset within a word). At the time of expansion, the cost in gas 
    must be paid. Memory is more costly the larger it grows (it scales
    quadratically)
- calldata: Separate area of memory whe message call payload is placed
</pre>

   <span xsmall>EVM Stack:</span>
<pre xxxsmall zoom>
- EVM memory area list of 256bits up to 1024 elements used for computations
- The 16 topmost elements can be moved to the top or swaped wih the top element
- All other operations take the topmost one (or two, or more) elements and push
  the result onto the stack
- top elements can be moved to/from storage/memory, but deeper elements can
  be accessed without first removing elements on top of them.

- (EVM)full computational state: can be defined by the tuple:
  (block_state, transaction, message, code, memory, stack, pc, gas)
  block_state = global state = all accounts (balances + storage)

- selfdestruct(target): Destructor for contract @ address
  - Remaining Ethers are sent to target
  - storage &amp; code are removed from the blockchain state
</pre>

  <a TODO href="https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go">(EVM) Instructions</a>
<pre xxxsmall zoom>
func opAdd              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSub              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMul              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opDiv              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSdiv             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMod              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSmod             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opExp              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSignExtend       (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opNot              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opLt               (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opGt               (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSlt              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSgt              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opEq               (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opIszero           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opAnd              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opOr               (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opXor              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opByte             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opAddmod           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMulmod           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSHL              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSHR              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSAR              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSha3             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opAddress          (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opBalance          (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opOrigin           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCaller           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCallValue        (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCallDataLoad     (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCallDataSize     (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCallDataCopy     (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opReturnDataSize   (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opReturnDataCopy   (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opExtCodeSize      (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCodeSize         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCodeCopy         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opExtCodeCopy      (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opExtCodeHash      (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opGasprice         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opBlockhash        (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCoinbase         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opTimestamp        (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opNumber           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opDifficulty       (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opGasLimit         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opPop              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMload            (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMstore           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMstore8          (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSload            (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSstore           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opJump             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opJumpi            (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opJumpdest         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opPc               (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opMsize            (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opGas              (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCreate           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCreate2          (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCall             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opCallCode         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opDelegateCall     (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opStaticCall       (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opReturn           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opRevert           (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opStop             (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opSuicide          (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)

// following functions are used by the instruction jump  table
// make log instruction function
func makeLog(size int) executionFunc
    return func         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
func opPush1            (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
// make push instruction function
func makePush(size uint64, pushByteSize int) executionFunc
    return func         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
// make dup instruction function
func makeDup(size int64) executionFunc
    return func         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
// make swap instruction function
func makeSwap(size int64) executionFunc
    return func         (pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack) ([]byte, error)
</pre>


</td>  
</tr>
</table>

<table>
<tr>
<td>
  <b>Transactions</b>
<pre xxxsmall zoom>
Transaction
-------------
address sender
target
payload        "message" sent from src. account to a target (account or code)
wei ether

wei gasPrice
wei gas

return data
</pre>
  <ul xxxsmall zoom>
  <li>Note that a TX in blockchain is an intention to modify the state of the ddbb.
    It's up to the consensus algorithm to decide when and/or whether the TX will
    be accepted</li>
  <li><code>transaction.target := address | code | "zero-account"</code>
<pre {>
if target == code 
   => code is executed
      input data = transaction.payload 
if target == "zero.." 
   => step 1: new contract created
      step 2: transaccion.payload is executed 
      step 3: exec. output stored as contract.code
      (=> trans.payload == code factory of contract code)
</pre>
  </li>
  <li>transaction.ether: Price in Wei of one unit of gas, in which VM operations are priced.<br/>
- The product of gasPrice and gas represents the maximum amount of Wei we are willing to pay for executing the transaction. gasPrice is used by miners to rank transactions for inclusion in the blockchain. 
  </li>
  <li>transaction.gas: Its purpose is to limit the amount of work needed to execute the transaction 
      and to pay for this execution. <br/>
           transaction creator (sender?) chooses the gas to pay.<br/>
             - If execution gas < transaction.gas => Refund to sender<br/>
             - If execution gas > transaction.gas => out-of-gas exception triggered
                 (reverts all modifications made to the state in current call frame)
  </li>
  <li>nonce: increasing numeric value which is used to uniquely identify transactions.
      A nonce can only be used once and until a transaction is mined, it is possible
      to send multiple versions of a transaction with the same nonce, however, 
      once mined, any subsequent submissions will be rejected.
  </li>
  </ul>
  <b>block validation algorithm (Consensus)</b><br/>
  <ol xxxsmall zoom>
  <li>Check if the previous block referenced exists and is valid</li>
  <li>Check that the timestamp of the block is greater than that of the referenced previous
  block and less than 15 minutes into the future.</li>
  <li>Check that the block number, difficulty, transaction root, uncle root and gas limit 
  (various low-level Ethereum-specific concepts) are valid.</li>
  <li>Check that the proof of work on the block is valid</li>
  <li>Let S[0] be the STATE_ROOT of the previous block</li>
  <li>Let TX be the block's transaction list, with n transactions. For all "i" in 
  0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any applications returns an error, or
  if the total gas consumed in the block up until this point exceeds the GASLIMIT, 
  return an error</li>
  <li>Let S_FINAL be S[n], but adding the block reward paid to the miner</li>
  <li>Check if S_FINAL is the same as the STATE_ROOT. If it is, the block is valid;
      otherwise, it is not.</li>
  <li>Note: coinbase: In a mining node indicates the address where rewards will go.
        Must be set to an account owned by miner</li>
  </ol>
</td>
<td>
  <a href="https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3">TX Signing</a>
<pre xxxsmall zoom>
- https://github.com/ethereum/EIPs/issues/191


What are the v, r, s values for the TX's signature?
- r and s are outputs of an ECDSA signature
- v is the recovery id.
<a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">Bitcoin REF</a> 
  applies also to Ethereum. Ethereum makes further adjustments to v, as explained in 
<a href="https://github.com/ethereum/EIPs/issues/155">EIP 155</a>, to prevent replay attack.

ecrecover Solidity Global Crypto Funct:
ecrecover (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address): recover the address associated with the public key 
                     from elliptic curve signature or return zero on error

</pre>
</td>
<td>
  <span xsmall>TX Price Calc.</span>
<pre xxxsmall zoom>
- Price cost applies to public network and (optionally)
  to private/consortium networks.
- Notic private/consortium networks will still be constrained to
  gas limits per TX and/or block even if the gas price is ZERO.
  TXs will fail if the consume too much gas ("CPU" or storage)
  but users will not loose any ethers in this case.
REF:
- <a TODO href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees">[Design-Rational: Gas and fees]</a>
- <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">[Instruction cost]</a> 
The most expensive operations by far are storage usage:
- sstore costs 20000 gas for first write to a new position
- sstore costs  5000 gas for subsequent writes to an existing position
- sload  costs   500 gas
- Most instructions costs 3~10 gases.
- Gas costs are set somewhat arbitrarily, and could well change in 
  the future. As costs change, compilers would make different choices.

TX cost: <a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603">REF</a>
- 21000 paid for every transaction.
-     4 paid for every zero byte of data or code for a transaction.
-    68 paid for every non-zero byte of data or code for a transaction.

- Small negative numbers are mostly 1s, costing you quite a lot of gas.

Logging Gas Costs:  <a href="https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9">REF</a>
  - The gas costs for the logging primitives depends on how many topics you have and how much data you log:
    (constants are defined in protocol_params)

LogDataGas       uint64 = 8   // Per byte in a LOG operation's data
topicLogTopicGas uint64 = 375 // Per LOG 
LogGas           uint64 = 375 // Per LOG operation
MemoryGas        uint64 = 3    // Per byte of memory used

If you are passing in the log data as calldata to a TX,
you’ll need to pay for the transaction data too. The gas costs for calldata are:

TxDataZeroGas      uint64 = 4     // zero tx data abyte
TxDataNonZeroGas   uint64 = 68    // non-zero tx data byte

Assuming all 32 bytes are non-zero, this is still a lot cheaper than storage:

// cost of 32 bytes of log data
32 * 68 = 2176 // tx data cost
32 *  8 =  256 // log data cost
32 *  3 =   96 // memory usage cost
375 // log call cost
----
total (2176 + 256 + 96 + 375) ~14% of sstore for 32 bytes
Most of the gas cost is actually spent on transaction data, not for the log operation itself

The reason that a log operation is cheap is because the log data isn’t really 
stored in the blockchain. Logs, in principle, can be recalculated on the fly
as necessary.

Miners, in particular, can simply throw away the log data, because future 
calculations can't access past logs anyway.

The network as a whole does not bear the cost of logs. 
Only the API service nodes need to actually process, store, and index the logs.

So the cost structure of logging is just the minimal cost to prevent log spamming.

Extracted from stack-overflow:
   Q: """The price of ETH has gone from ~8 USD/ETH to ~90 ETH/USD in 6 months,
      but when I view transactions on the blockchain (example), I see that most
      people are still using the default gas price of 2e10 wei/gas. Shouldn't
      we be lowering the gas prices on our transactions to account for this 
      price change? 
      I have built a Dapp where low transaction fees are an important selling
      point. I intend to drop
      my gas price to 5e9 (a 75% reduction). Will my transactions still clear 
      in a timely fashion?"""
   A: """Absolutely. Everyone should. There's a great site here that will help
     you understand gas and gas prices.
     It's called Ethereum Gas Station: http://ethgasstation.info/
      They just recently made this post which explains something they call the
     Safe Gas Price:
     https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91"""


(Interesting "offtopic") See Wikipedia entries on:
  </li>
  </ul>
  <a href='http://ethgasstation.info/calculator.php'>eth gas station calc</a>
200€/ether:
Transaction gas price: 21000 gas/tx       32bytes Contract storage: 20000 gas
+----------+-----------------+--------+   +----------+-----------------+--------+
| gasprice | total gas price | total €|   | gasprice | total gas price | total €|
+----------+-----------------+--------+   +----------+-----------------+--------+
|  1gwei   | 21000 *  1gwei  | 0,0042 |   |  1gwei   | 21000 *  1gwei  | 0,0040 |
| 20gwei   | 21000 * 20gwei  | 0,0420 |   | 20gwei   | 21000 * 20gwei  | 0,0400 |
+----------+-----------------+--------+   +----------+-----------------+--------+

For a transaction updating 64bytes (32bytes from debitor account to 32bytes creditor account)
+----------+-----------+
| gasprice | total € *1|
+----------+-----------+
|  1gwei   |   0,0122  |
| 20gwei   |   0,2440  |
+----------+-----------+

Logs cost: 375 gas for a LOG operation + 8 gas per log data byte + 375 gas for each topic. 200€/eth:

+----------+-----------+----------+--------------------+------------
|log  size | num.topics| gasprice | total gas price*1  |     total €
+----------+-----------+----------+--------------------+------------
|1024bytes |     3     |   1gwei  |  9692 *  1gwei     | 0,0019384 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0011192 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0005596 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0002798 €
+----------+-----------+----------+--------------------+------------
|          |           |  20gwei  |  9692 * 20gwei     | 0,0387680 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0223840 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0111920 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0055960 €
+----------+-----------+----------+--------------------+------------

(375 gas/LOG * 1LOG ) + (8 gas/byte * 1024byte) + (375 gas/topic * 3 topic) = 375 + 8192 + 1125 = 9692
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 3 topic) = 375 + 4096 + 1125 = 5596
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 1 topic) = 375 + 2048 +  375 = 2798
(375 gas/LOG * 1LOG ) + (8 gas/byte *  128byte) + (375 gas/topic * 0 topic) = 375 + 1024        = 1399    
</pre>
</td>


<td>
  <li>Calls vs Transactions:</def>
<pre xxxsmall zoom>
        CALLS:                                               TRANSACTIONS

invoque a read-only smart-contract function          invoque a write smart-contract function 
and return a value, but nothing is mined or          that changes the global status in all nodes.
verified by the consensus. It can be executed        
on a local ethereum node and return fast             Each TX must  be verified by the consensus 
(synchronously).                                     before being accepted (only TXs in longest
                                                     chains, correct hashes, ...)
                                                       The (non-mined) TX must be propagated
                                                     until reaching some miner node in the network
                                                     that will add it to the lastest block on 
                                                     the chain (passing to "mined state").
                                                     - TX expends gases and CAN NOT return any
                                                     value (since it's not possible to known
                                                     in advance when the TX will be executed by
                                                     the network consensus or in the case of
                                                     public network whether it will be executed
                                                     at all).
                                                     - Clients sending a TX to the network need
                                                     to listen for asyncrhonous events to know
                                                     the result of the TX (or an error associated
                                                     to the TX)
   
</pre>

  <span xsmall>State transition func</span>
<pre xxxsmall zoom>
APPLY (S, TX) -> S'  ← S : initial global state
                     ← S': final   global state
 can be defined as follows:
- Check if incomming TX is well-formed (right number of values),
  signature is valid, and the nonce matches the nonce in the
  sender's account.  Return an error otherwise.
- Calculate the transaction fee as STAR_GAS * GAS_PRICE, and 
  determine the sending address from the signature. Subtract the
  fee from the sender's account balance and increment the 
  sender's nonce. If sender's balance &lt; fee, return an error.
- Initialize GAS = STARTGAS, and take off a certain quantity 
  of gas per byte to pay for the bytes in the transaction.
- Transfer the TX value from the sender's account to the
  receiving account.  If the receiving account does not yet
  exist, create if. If the receiving account is a contract,
  run the contract's code either to completion or until the
  execution runs out of gas.
- If the value transfer failed because the sender did not have
  enough money, or the code execution ran out of gas, revert 
  all state changes except the payment of the fees, and add 
  the fees to the miner's account
- Otherwise, refund the fees for all remaining gas to 
  the sender, and send the fees paid for gas consumed to the
  miner.
</pre>
  <span xsmall>Offline vs Online TX signing</span>
<pre xxxsmall zoom>
    OFFLINE TX SIGNING (RECOMENDED)           |    "ON-LINE" TX SIGNING (LESS SECURE, DISCOURAGED)
                                              | 
The "raw" TX must be signed first             | - An Ethereum node (geth, parity,...) will be used.
by an offline (js,python,hardware wallet,...) | - It forces to have the wallet on the client node and 
client using a private key ("wallet")         |   unlock the account. Unless the wallet is hardware
with or without connection to any ethereum    |   secured is usually less safe than client signature
network node.                                 |   (but offline clients can also be insecure or
The signed TX is then sent to the network.    |   hacked)
</pre>
</td>  
<td>
  <span bgorange>Events &amp; LOGS</span>
<pre xxxsmall zoom bgorange>
BEST PATTERNS:
- External clients must be able to restore current contract state
  by just reading events.
- Ethereum can return just a very limited information in each
  read-only query. (Up to 7 fields). That means that reports and
  data-analysis must be done on event logs.
- Contract/s state/s must be consulted only by code originated by
  a new transaction trying to update the current state.

- Logs: It is possible to store data in a specially indexed data structure 
  that maps all the way up to the block level.<br/>
  This feature called 'logs' is used to implement events.</li>
- Contracts *CAN NOT* access log data after it has been created, but they 
  can be efficiently accessed from outside the blockchain. <br/>
  Since some part of the log data is stored in bloom filters,
  it is possible to search for this data in an efficient and cryptographically 
  secure way, so network peers that do not download the whole blockchain 
  ("light clients") can still find these logs.</li>
- Logs were designed to be a form of storage that costs significantly 
  less gas than contract storage:
  Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes. 
  Up to 3 parameters can be indexed.

<b>Event Limits:</b>
- Up to 3 indexed fields.
- Up to 7 fields (indexed + non-indexed fields)
- The size limit of one event is a function of the block's gas limit, 
  ~ 3_145_192 (first seven digits of pi * 2)
  With a gas costs of 76 gas per byte limit is about 41kb per log event.
  REF: <a TODO href="http://jonathanpatrick.me/blog/ethereum-compressed-text"> Storing compressed text in Ethereum transaction logs</a>
  
<b>Solidity code:</b> 
event EventDepositLog(  
    uint256 indexed _market,  ← Up to 3 indexes
    address indexed _sender,    Strings, arrays can *NOT* be used in indexes 
    uint256 _amount,            (will be automatically replaced by its hash)
    uint256 _time);

<b>JS Client Log monitoring:</b>
var myEventMonitor = 
  myContract.MyEventNameLog(
     {_sender: userAddress },           // ← filter by idx sender
     {fromBlock: 0, toBlock: 'latest'}  // ← filter by block range*1
  );                                         if ommited observe
                                             "real-time" events

myEventMonitor.watch(                  // ← Start watching
  (err, result) => {
    if (err) { ...    return; }
    console.log(
         "_market:"+result.args._market
       + "_sender:"+result.args._sender );
  }
)
....
myEventMonitor.stopWatching()          // ← Stop watching
</pre>
</td>  
<td colsep></td>
<td>
  <a href="https://ens.domains/">Ether.Name Serv.</a> 
<pre xxxsmall zoom>
"""No more long addresses: ENS eliminates the need to copy - and worse,
   type - long hexadecimal addresses ...
   you'll be able to:
   - send money to 'aardvark.eth' instead of '0x4cbe58c50480...', 
   - interact with your favorite contract at 'mycontract.eth'
   - visit a Swarm-hosted site at 'swarmsite.eth'. """

<a TODO href="https://docs.ens.domains/en/latest/userguide.html">ENS User Guide</a>,
<a TODO href="https://github.com/ethereum/go-ethereum/tree/master/contracts/ens">Geth implementation</a>
<a href="https://github.com/ethereum/EIPs/issues/137">EIPs issue</a>

GOAL: resolve human-readable names to Ethereum addresses, Swarm/IPFS hashes, ....
      provide also metadata about names (contracts ABIs, whois info,...)</li>
- ENS operates on a system of <b orange>dot-separated hierarchial names called domains</b>, 
  with the owner of a domain having full control over the distribution of subdomains.

- Top-level domains (.eth, .test,...) owned by 'registrars' smart contracts
  Anyone may, by following the rules imposed by these registrar contracts, 
  obtain ownership of a second-level domain for their own use.

- Secure: ENS is built on smart contracts on the Ethereum blockchain, meaning
  it doesn't suffer from the insecurity of the DNS system.  You can be confident
  names you enter work the way their owner intended.

- Truly Distributed: ENS operates in a distributed fashion for both its infrastructure
  and governance. Anyone can register a .eth domain name for themselves by participating
  in an auction process, mediated by the blockchain.

<b>TERMINOLOGY</b>
  - domain     : complete, human-readable form of a name; eg, ‘vitalik.wallet.eth’
  - label      : a single component of a domain; eg, ‘vitalik’, ‘wallet’, or ‘eth’
  - label hash : keccak-256(label) eg, keccak256(‘eth’) =
                 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0
  - node       : namehash function output used to uniquely identify a name in ENS


<b>Ex. JS Client code to register</b> <a href="https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial">REF</a> 
  
| var name = "MyPersonalDemocracy"
| registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
| var democracy = eth.contract(daoCompiled.Democracy.info.abiDefinition).
|                 at(democracy.address);
| democracy.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})
| 
| (Wait for the previous transactions to be picked up and then)
| 
| registrar.setAddress.sendTransaction(name, democracy.address, true,{from: eth.accounts[0]});
</pre>

<span xsmall>Architecture</span>
<pre xxxsmall zoom>
DOMAIN            | REGISTRY CONTRACT                  | RESOLVER(S) INTERFACE
------            | -----------------                  | ---------------------
- owner (address) | - owned (sub)domains list          | translate name → address
- resolver        | ----------------                   +-------------------------
- time-to-live    | + issues subdomains to users  *1 
  for all records |   following logic in contract *1   | RECORD:
                  | + Set resolver+TTL for domain *1   | -------
                  | + Transfer ownership               | - type: (Ethereum address, Swarm content hash, ...)
                  | *1 Only owner of affected domain   |          New record types may be defined via EIP
                                                       |          with no need to make changes to the registry or resolvers
                                                       |
                                                       | - Namehash: 32-byte hash of name (compaq storage+privacy)
                                                       |             defined recursively to preserve the hierarchal nature
                                                       | ----------
                                                       | - Iface method/s to be implemented by resolver
                                                       |    in order to provide records of that kind.
</pre>
  MainNet/... Deployments
<pre xxxsmall zoom>
General-purpose resolver implementations are offered for users whose requirements are straightforward, 
such as serving an infrequently changed address for a name.

  MAINNET DEPLOYMENT: 0x314159265dd8dbb310642f98f50c066173c1259b
                      users may register names under the eth TLD using an auction based registrar.
  ROPSTEN 
  TESTNET DEPLOYMENT: 0x112234455c3a32fd11230c42e7bccd4a84e02010
                      users may register names under two top level domains:
                      .eth , auction based 
                      .test, allows anyone to claim an unused name for test purposes expiring after 28 days
  RINKEBY
  TESTNET DEPLOYMENT: 0xe7410170f87102df0055eb195163a03b7f2bff4a
                      .test supported
</pre>


  Ext. Links
  <ul xxxsmall zoom>
  <li><a href="https://github.com/ethereum/EIPs/issues/137">EIP137</a> - Ethereum Name Service</li>
  <li><a href="https://github.com/ethereum/EIPs/issues/162">EIP162</a> - Initial ENS Registrar Specification</li>
  <li><a href="https://www.npmjs.com/package/ethereum-ens">ethereum-ens</a> Javascript library</li>
  <li>Nick’s talk on ENS at DevCon 2: <a href="https://www.youtube.com/watch?v=pLDDbCZXvTE">https://www.youtube.com/watch?v=pLDDbCZXvTE</a></li>
  <li><a href="https://arachnid.github.io/devcon2/#/title">DevCon 2 talk slides</a></li>
  <li><a class="reference external" href="https://registrar.ens.domains">https://registrar.ens.domains</a></li>
  </ul>
</td>
</tr>
</table>
<br/>
Solidity Language
<a xsmall bggreen href='https://remix.ethereum.org/#'>[REMIX-IDE ONLINE]</a>,
<a xsmall bggreen href='https://ethfiddle.com/'      >[ethfiddle.com]</a>,
<a xsmall href='http://solidity.readthedocs.io/en/develop/'>[SOLIDITY]</a>,<a xsmall href="https://solidity.readthedocs.io/en/latest/solidity-in-depth.html" bgorange>[in-Depth]</a>@ReadTheDocs,<a xsmall href='https://github.com/ConsenSys/smart-contract-best-practices'>[BEST PRACTICES]</a>


<table>
<tr>
<td>
  <span xsmall>Grammar summary</span>
<pre  xxxsmall zoom>
REF: <a href='https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt'>https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt</a>
{
Elementary:
Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*
NumberUnit = ('wei' | 'szabo' | 'finney' | 'ether') |
             ('seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years')
(Notice: NumberUnit can NOT be applied to variables, only to literals:
   M wei;     // &lt;- wrong
   M * 1 wei; // &lt;- correct

ElementaryTypeName = 'address' /*20 byte*/| 'bool' | 'string' | 'var' 
     |  'int(8|16|24|32|...|256)' 
     | 'uint(8|16|24|32|...|256)' 
     | 'byte(s|1-32)'
     | 'fixed'  | 'fixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256 
     | 'ufixed' | 'ufixed(0|8|16|24|...|256)x(8|16|24|...|256)' &lt;- first+second&lt;=256
}

{
PrimaryExpression = Identifier | ('true' | 'false')  | (/*DecimalNumber*/ [0-9]+) | ...

Expression =
    ( Expression ('++' | '--') 
      | FunctionCall 
      | (/*IndexAccess*/ Expression '[' Expression? ']')
      | (/*MemberAccess*/ Expression '.' Identifier) 
      | '(' Expression ')' 
    )
  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
  | Expression '**' Expression
  | Expression ('*' | '/' | '%') Expression
  | Expression ('+' | '-') Expression
  | Expression ('&lt;&lt;' | '>>') Expression
  | Expression '&' Expression
  | Expression '^' Expression
  | Expression '|' Expression
  | Expression ('&lt;' | '>' | '&lt;=' | '>=') Expression
  | Expression ('==' | '!=') Expression
  | Expression '&&' Expression
  | Expression '||' Expression
  | Expression '?' Expression ':' Expression
  | Expression ('=' | '|=' | '^=' | '&=' | 
                '&lt;&lt;=' | '>>=' | '+=' |
                '-=' | '*=' | '/=' | '%=') Expression
  | Expression? (',' Expression)
  | PrimaryExpression
}

{
TypeNameList = '(' ( TypeName (',' TypeName )* )? ')'

FunctionTypeName = 'function' TypeNameList ( 'internal' | 'external' | 'constant' | 'payable' )*
                   ( 'returns' TypeNameList )?
TypeName =
     ElementaryTypeName 
   | /*UserDefined*/Identifier ( '.' Identifier )* 
   | ( 'mapping' '(' ElementaryTypeName '=>' TypeName ')' ) 
   | (TypeName '[' Expression? ']') 
   | FunctionTypeName


FunctionCall = ( PrimaryExpression | ( 'new' TypeName ) | TypeName ) 
               ( ( '.' Identifier ) | ( '[' Expression ']' ) )*
               '(' FunctionCallArguments ')'

FunctionDefinition = 'function' Identifier? ParameterList
                     ( FunctionCall | Identifier | 'constant'
                     | 'payable' | 'external' | 'public'
                     | 'internal' | 'private' )*
                     ( 'returns' ParameterList )? ( ';' | Block )

// semantic restriction: mappings & structs (recursively) containing mappings not allowed in argument lists
}


{
VariableDeclaration = TypeName (/*StorageLocation*/ ('memory' | 'storage'))? Identifier
VariableDefinition = ('var' (/*IdentifierList*/ '(' ( Identifier? ',' )* Identifier? ')') | VariableDeclaration) ( '=' Expression )?
SimpleStatement = VariableDefinition | Expression
}


{
Statement = 
   (  ('if' '(' Expression ')' Statement ( 'else' Statement )?) 
   | ('while' '(' Expression ')' Statement)
   | ('for' '(' (SimpleStatement)? ';' (Expression)? ';' (Expression)? ')' Statement)
   | ( /*block*/ '{' Statement* '}')
   | InlineAssemblyStatement 
   | ('do' Statement 'while' '(' Expression ')' ) 
   | /*place holder*/'_' 
   | 'continue' | 'break' | 'return' Expression?  |'throw' 
   | SimpleStatement )
   ';'
}


{ Contracts:
IndexedParameterList = '(' ( TypeName 'indexed'? Identifier? (',' TypeName 'indexed'? Identifier?)* )? ')'

ContractPart = 
    ( TypeName ( 'public' | 'internal' | 'private' )? Identifier ('=' Expression)? ';' )
  | ( 'using' Identifier 'for' ('*' | TypeName) ';' )
  | ( 'struct' Identifier '{' ( VariableDeclaration ';' (VariableDeclaration ';')* )? '}' ) 
  | ( 'modifier' Identifier ParameterList? Block )
  | ( 'event' Identifier IndexedParameterList 'anonymous'? ';' )
  | ( 'enum' Identifier '{' Identifier? (',' Identifier)* '}' )
  | FunctionDefinition

InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )* ')' )?

ContractDefinition = ( 'contract' | 'library' ) Identifier
                     ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                     '{' ContractPart* '}'
}
</pre>

  <span xsmall>GLOBALS</span>
<pre xxxsmall zoom>
<b>GLOBAL METHODS:</b>
block.blockhash(uint blockNumber) 
  returns (bytes32): 
  hash of the given block - only works for 256 most
  recent blocks excluding current

<b>GLOBAL VARS:</b><b orange>
msg.sender (address)    : sender of the message (current call)
tx.origin (address)     : sender of the transaction 
                          (full call chain)</b>
msg.sender vs tx.origin:<a href=https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin">REF</a>
"""
- With msg.sender the owner can be a contract.
- With tx.origin the owner can never be a contract.
  In a simple call chain A->B->C->D,  inside D msg.sender will be C, and tx.origin will be A.
  
- msg.sender is preferred for the flexibility it provides. 
  Furthermore, for Serenity, even though it's a while out, Vitalik
  recommends avoiding tx.origin: How do I make my DAPP "Serenity-Proof?"
- Carefully consider if you really ever need to use tx.origin.
  Remember, you may not be the only user of your contract. 
  Other people may want to use your contract and want to interact
   with it via a contract they've been written.

"""


block.coinbase (address): current block miner’s address
block.difficulty (uint) : current block difficulty
block.gaslimit (uint)   : current block gaslimit
block.number (uint)     : current block number
block.timestamp (uint)  : current block timestamp
msg.data (bytes)        : complete calldata
msg.gas (uint)          : remaining gas
msg.sig (bytes4)        : first four bytes of the calldata 
                          (i.e. function identifier)
msg.value (uint)        : number of wei sent with the message
now (uint)              : current block timestamp 
                          (alias for block.timestamp)
tx.gasprice (uint)      : gas price of the transaction



<b>GLOBAL Math.&amp;Crypto Functs</b>
addmod(uint x, uint y, uint k) 
  returns (uint): /* compute (x + y) % k */
mulmod(uint x, uint y, uint k)
  returns (uint): /* compute (x * y) % k */
keccak256(...)
  returns (bytes32): compute Ethereum-SHA-3 hash
                of the (tightly packed) arguments
sha3(...) 
  returns (bytes32): alias to keccak256()
sha256(...) 
  returns (bytes32): compute SHA-256 hash of the
                      (tightly packed) arguments
ripemd160(...) 
  returns (bytes20): compute RIPEMD-160 hash of 
  the (tightly packed) arguments
ecrecover
  (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address):
    recover the address associated with the public key 
    from elliptic curve signature or return zero on error
</pre>
  </li>
  </ul>
</td>
<td>
  <b TODO>FORMAL VERIFICATION</b>
<!--
FORMAL Verification
https://github.com/pirapira/eth-isabelle
https://github.com/pirapira/ethereum-formal-verification-overview
"Why3 Solidity
Why3 is a platform for deductive program verification. It provides a rich language for specification and programming, called WhyML, and relies on external theorem provers, both automated and interactive, to discharge verification conditions. (See the specific section below for the list of supported provers.) Why3 comes with a standard library of logical theories (integer and real arithmetic, Boolean operations, sets and maps, etc.) and basic programming data structures (arrays, queues, hash tables, etc.). A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism. WhyML is also used as an intermediate language for the verification of C, Java, or Ada programs. (See Projects using Why3 below.) Why3 can be easily extended with support for new theorem provers. Why3 can be used as a software library, through an OCaml API. 

"
"https://forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts

""""""We just merged a first pull request that allows Solidity contracts to be formally verified using a toolkit called why3.
This means that a computer creates and checks a mathematical proof of assertions about the behaviour of the contract.
Only a small subset of Solidity is supported for now, but that makes it already possible to verify a recursive binary search routine on arrays:
https://gist.github.com/chriseth/0c671e0dac08c3630f47""""""

""""""How to use it on the example
The solidity compiler (only solc at latest develop for now) can translate the source code into a different programming language which can be understood by why3 (the language is a dialect of ocaml). To do that, call it as ""solc \-\-formal -o /tmp/output_directory/ source.sol"". Furthermore, using special tags in the Solidity comments of the form ""///@why3 ..."" you can formulate assertions and requirements that can be understood by the why3 framework and will be literally inserted into the generated code.

After that, you can use ""why3 ide /tmp/output_directory/solidity.mlw"" to start a graphical version of the toolkit and perform the verification.
How to install why3
I am not aware of any binary packages, so you have to download the source from the website.
As why3 itself is only a frontend to the real workhorses, the provers, you need to install a prover. I tried ""alt-ergo"" and Z3 - the first is part of the ubuntu distribution, the second has binaries for most platforms.

After installing the prover (and making sure it is in the PATH), call ""why3 config \-\-detect"" and it should detect your prover. """""""
"Video Tutorial:
https://www.youtube.com/watch?v=Mzh4fyoaBJ0&feature=youtu.be&list=PL9oaY6Y4QxRZybj86eGItGVApxLXVIXHz"
https://gitter.im/ethereum/formal-methods
"https://en.wikipedia.org/wiki/Logical_harmony

Logical harmony, a name coined by Sir Michael Dummett, is a supposed constraint on the rules of inference (https://en.wikipedia.org/wiki/Rules_of_inference) that can be used in a given logical system(https://en.wikipedia.org/wiki/Logical_system)"
-->
  <a href="https://github.com/ConsenSys/mythril/wiki">Mythril</a>security analysis tool
<pre xxxsmall zoom>
  Mythril detects a range of security issues, including 
  integer underflows, owner-overwrite-to-Ether-withdrawal,
  and others. However, the analysis will not detect business
  logic issues and is not equivalent to formal verification.
</pre>

</td>

<td>
  <span xsmall bgorange>FUNCTIONS</span>
<pre xxxsmall zoom>
<b>modifiers</b> (Deprecated?)
<b green>modifier inState</b>(State _state)    { if (state != _state) throw;  _;  }
<b green>modifier require</b>(bool _condition) { if (!_condition) throw; _;       }


function confirmPurchase(<parameter_list types>)
    <b green>inState</b>(State.Created)          // precondition
    <b green>require</b>(msg.value == 2 * value) // precondition<b blue>
    // VISIBILITY MODIFIERS {
    [internal] ← only this contract and child ones
    [private]  ← only this contract
    [external] ← will only ever be called externally 
                 external <a href="https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices">is more efficient than public</a>
                 since it also avoid copying parameters twice
                 (very important with big arrays!!!)
    [public]   ← will also be called internally.
    // }</b><b orange>
    // MUTABILITY MODIFIERS {
    [payable]  /* allows funct to receive ether when called as:
                * myContractInstance.myPayableFunction.call. \
                *   value("ETH_TO_BE_SENT")("ADDITIONAL_DATA")
                * Ej:
                *   function deposit() payable {
                *     deposits[msg.sender] += msg.value;
                *   };
                */
    [pure]      /* does NOT modify the contract storage 
                 * and storage can NOT be accesed 
                 * (utility libraries, ...)*/
    [view] /* does NOT modify the contract storage 
              but storage can be accesed  ("getters")*/
    [constant] /* alias for pure */
    // }</b><b brown>
    [returns ('return types')]</b>
    { 
      // (function body)
      ... 
    }

Note:
     confirmPurchase(...) # Internal call 
this.confirmPurchase(...) # External call
</pre>

  <span xsmall>IMPORTS:</span>
<pre xxxsmall zoom>
import ""filename"";
import * as symbolName from ""filename"";
import {symbol1 as alias, symbol2} from ""filename"";
import ""filename"" as symbolName;

Frameworks like truffle will also automatically import from the "node_modules/" folder
where npm (Node package manager) installs dependencies.
</pre>


 Fallback function 
<pre xxxsmall zoom>
(called when no other function matches)
event EventFallback(address from, int256 amount);
...
function () payable {
  if (! this.owner.send(amount)) { throw ; }
  EventFallback(msg.sender, receiver, amount);
}; 

event EventFallback(address from, int256 amount);
...
function () payable {
  if (! this.owner.send(amount)) { throw ; }
  EventFallback(msg.sender, receiver, amount);
}; 
</pre>
</td>  
<td>
  <span xsmall>STRUCTS</span>
<a href="https://solidity.readthedocs.io/en/latest/structure-of-a-contract.html#struct-types">Struct</a>
<pre xxxsmall zoom>
struct Voter {
  uint weight;
  bool voted;
}

Voter v1 = Voter(1, flase);  
</pre>

<a href="https://solidity.readthedocs.io/en/latest/structure-of-a-contract.html#enum-types">enum</a> 
<pre xxxsmall zoom>
enum State { Created, Locked, Inactive } // ← Definition
State  s1 = State.Created                // ← Ussage
uint8  u1 = uint8 (State.Created)        // ← Explicit uintXX to enum
uint16 u2 = uint16(State.Created) 
State  s2 = State(u1)                    // ← uintXX to enum using enum constructor
                                              Will raise an assert exception if
                                              u1 is outside the State bounds.
</pre>

 <span xsmall>Ret.Structs in pub.funs</span>
<pre xxxsmall zoom>
<a xsmall TODO href="https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378">REF</a>
- Solidity (0.4.13, as of this writing), doesn't allow to return a struct from public functions.
  (allowed by experimental ABIv2)

- The alternative will be: 

 pragma solidity ^0.4.13;
 
 contract Project {
     struct Person {
         string name;
         uint funds;
     }
     
     mapping(address => Person) public people;
     // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     // assuming typical Truffle setup
     // | const Project = artifacts.require('./Project.sol');
     // | const project = await Project.deployed()
     // | const person  = await project.people('0xdeadbeef')
     // | console.log('person =', person);
     // | // person = [ 'Bryn', 123 ]
     // |             ^^^^^^^^^^^^^^^
     // | The compiler converts to a tuple that
     // | is returned as a JS array
     // | The getPerson generated by the compiler looks like:
     // | 
     // | function getPerson(address id) public
     // |     returns (string name, uint funds) {
     // |     Person memory p = people[id]; // copy into memory
     // |     return (p.name, p.funds);
     // | }
 }
</pre>
 
 <span xsmall>Ret.Struct-array in pub.funcs</span>
<pre xxxsmall zoom>

<b>RETURNING ARRAYS OF STRUCTS:</b>

pragma solidity ^0.4.13;

contract Project {
    struct Person {
        address addr;
        uint funds;
    }
    
    Person[] people;
    
    function getPeople(uint[] indexes) public
        returns (address[], uint[]) {
        //       ^^^^^^^^^^^^^^^^^
        //       One array for each struct field
        address[] memory addrs = new address[](indexes.length);
        uint[]    memory funds = new uint[](indexes.length);
        
        for (uint i = 0; i < indexes.length; i++) {
            Person storage person = people[indexes[i]];
            addrs[i] = person.addr;
            funds[i] = person.funds;
        }
        return (addrs, funds);
    }
}

Getting data back in this format is, admittedly, a pain to deal with on the frontend:

const Project = artifacts.require('./Project.sol')
const project = await Project.deployed()

const people = await project.getPeople([ 2, 5 ], { from: accounts[0] })

console.log('people =', people)
// this will print something like:
// people = [ ['0xdeadbeef', '0xabcdeff'], [123, 789] ]
//
// as you can see, we get back an array.  each element of this array
// represents a field in the struct type.  because we've returned
// many structs, each field has many values.  let's reassemble these
// into a more familiar (and more usable) format.

// we can figure out how many structs were returned by checking the
// length of any of the arrays that were returned.  they should all
// have the exact same length.
const numPeople = people[0].length

// for clarity's sake, let's define some constants so that we can see
// which field array we're accessing:
const FIELD_ADDR  = 0
const FIELD_FUNDS = 1

let peopleStructs = []
for (let i = 0; i < numPeople; i++) {
    const person = {
        addr:  people[FIELD_ADDR][i],
        funds: people[FIELD_FUNDS][i],
    }
    peopleStructs.push(person)
}

console.log('peopleStructs =', peopleStructs)
// this will print something like:
// peopleStructs = [
//     { addr: '0xdeadbeef', funds: 123 },
//     { addr: '0xabcdeff', funds: 789 }
// ]

</pre>
</td>

<td>  
  <a  bgorange href="https://solidity.readthedocs.io/en/v0.4.24/control-structures.html#error-handling-assert-require-revert-and-exceptions">ERROR CONTROL</a><br/>
<pre bgorange xxxsmall zoom>
Solidity uses state-reverting exceptions to handle errors:
 - Capturing ("catch-ing") Exceptions IS NOT (YET?) POSSIBLE (2018-06-11)!.
 - EVM rollbacks any stat change in current call and all its sub-calls
   including events pending to register.
   (there is no safe way to continue execution while warrantying atomicity
    and reproducibility of results)
 - TX is still mined and TXReceipt status flaged with "fail" error
   See <a href="https://etherscan.io/tx/0x9f00a37416a64735b02ab76da4477ea297bfd4923b1564c1b3579d542b3f4071">Example failed TX mined</a>

PROGRAMATICALLY TRIGGERING EXCEPTIONS: 
┌───────────────────────────────────────────────┬──────────────────────────────────────────────┬───────────────────────────────────────────────┐
│      assert                                   │     require                                  │   revert                                      │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ (programming error)                           │ (pre/post check in in/out-data)              │ (business logic exceptions)                   │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - Check for conditions and throw an exception │ - Check for conditions and throw an exception│ - replaces deprecated 'throw'                 │
│   if the condition is not met                 │   if the condition is not met                │ - can be used to flag an error and revert the │
│ - Should only be used to test for internal    │ - Should be used to ensure valid conditions, │   current call.                               │
│   errors, and to check invariants             │   such as inputs, or contract state variables│ - It is possible to provide a string message  │
│ - If used properly, analysis tools can        │   are met, or to validate return values from │   containing details about the error that will│
│   evaluate your contract to identify          │   calls to external contracts                │   be passed back to the caller.               │
│   the conditions and function calls which will│ - optionally a message-string can be provided│                                               │
│   reach a failing assert.                     │                                              │                                               │
│   Properly functioning code should never reach│                                              │                                               │
│   a failing assert statement                  │                                              │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - compiles to INVALID 0xfe instruction        │  - compiles to REVER 0xfd instruction        │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ assert( "my code-logic assertion")            │ require("required cond.", "messsage");       │  if ("not condtion for input") revert("....") │
└───────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────────┘

┌─────────┬────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────┐   ┌─────────────────────────────────────────────────────┐
│         │ assert-style exception                                 │ revert/require-style exception                       │   │low level ops (return false, no exception raised)    │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Condition│ - access array at index greater than array             │ - Calling throw (deprecated)                         │   │- create a contract using "new" but contract creation│
│that     │  length (or negative)                                  │ - Calling require evaluating to false                │   │  does not finish properly.                          │
│triggers │ - access fixed-length bytes"N" at a too large or       │ - call a function via a message call but it does not │   │- perform external function call targeting a contract│
│exception│   negative index                                       │   finish properly (i.e. it runs out of gas, has no   │   │  that contains no code                              │
│in the   │ - divide or modulo by zero (ex.: 5 / 0 , 23 % 0)       │   matching function, or throws an exception itself), │   │- contract receives Ether via public function        │
│at (EVM) │ - shift by a negative amount                           │   except when a low level operation call, send,      │   │  without payable modifier (including constructor    │
│runtime  │ - convert a value too big|negative into an enum type   │   delegatecall or callcode is used.                  │   │  or fallback                                        │
│         │ - call to zero-initialized variable of internal        │                                                      │   │- contract receives Ether via public getter function │
│         │   function type                                        │                                                      │   │- .transfer() fails                                  │
│         │ - call assert with an argument that evaluates to false │                                                      │   │                                                     │
│         │ - call function not matching any func. in contract     │                                                      │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Gas ussag│ Consume all gas available to the call                  │ - Do NOT consume any gas (v.Metrópolis+)             │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Propagati│ - Rethrown ("bubble up") in sub-calls                  │ - Rethrown ("bubble up") in sub-calls                │   │- return false *1                                    │
└─────────┴────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────┘   └─────────────────────────────────────────────────────┘
                                                                                                                                 *1 or true if called account is non-existent
                                                                                                                                    Existence must be checked prior to call

Solidity compiler automatically generate exceptions (assert or require/revert?) if:
 - If your contract receives Ether via a public function without payable modifier 
   (including the constructor and the fallback function)
 - If your contract receives Ether via a public getter function
 - If you call a zero-initialized variable of internal function type
 - If a addressInstance.transfer() fails</li>


The provided string in require/revert will be abi-encoded as if it were a call to a function Error(string).
For example:
   revert("Not enough Ether provided."); will cause the following hexadecimal data be set as error return data:

0x08c379a0                                                         // Function selector for Error(string)
0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
0x000000000000000000000000000000000000000000000000000000000000001a // String length
0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
</pre>
</td>

<td>
  <a xsmall href="https://solidity.readthedocs.io/en/v0.4.24/types.html#arrays">Fixed/Dynamic Arrays</a>
<pre xxxsmall zoom>
Syntax:

uint[100] memory fixedArray;     ← Fixed   Size Array declaration
          fixedArray[0] = 1; 
          fixedArray[1] = 2; 
          fixedArray.push(3);    ← <b red>Error. Not allowed for fixed size array</b>
          ...
uint[ ] memory  dynArray1 = unit[] ← Dynamic Size Array declaration 
          dynArray1.push(1)        ← <b red>Error. Not allowed for memory array</b>
          ...
uint[ ] storage dynArray2 = unit[] ← Dynamic Size Array declaration 
          dynArray2.push(1 )       ← <b green>OK</b>
          ...
var x          = uint[][5]      ← Fixed-(5)size-array of
                                  dynamic-uint-arrays  (var for type inference)
    x[2][1]                     ← second uint in third dyn-array


 ┌────────┬───────────────────────┬───────────────────┬──────────────────────┬────────────────────┐ 
 │        │ Admited type          │ Creation          │ Resize               │ Delete             │
 ├────────┼───────────────────────┼───────────────────┼──────────────────────┼────────────────────┤ 
 │Storage │ *any*                 │ (just declare it) │- set/reassign .length│ delete myArray;    │
 │Arrays  │                       │                   │- push(el)            │ myArray.length = 0;│
 ├────────┼───────────────────────┼───────────────────┼──────────────────────┼────────────────────┤ 
 │Memory  │ *any* but mapping     │ Use 'new'         │ Not allowed          │                    │
 │Arrays  │ (ABI comp. for        │ new uint[](7)     │(fix size determined  │                    │
 │        │  public/extern fun)   │ new bytes(len)    │ at runtime)          │                    │
 └────────┴───────────────────────┴───────────────────┴──────────────────────┴────────────────────┘ 
<b>Special arrays(tightly packed in calldata)</b 
bytes : byte[]

string: (UTF-8) similar to bytes
        -  does not YET allow length/index/push access
        Use use bytes(myString).length / bytes(myString)[7] = 'x' to
        access the low-byte-representation of myString 

- Array Literals expression (not immediately assigned to a variable)
  - type     : memory array of fixed length. 
  - base type: common type of array elements.
  ...
  calledFunction(<b orange>[uint(1), 2, 3]</b>);

<b>Limitations:</b>
  - arrays of arrays not (YET) allowed in external functions
  - (EVM limitation): dynamic content NOT allowed in external-function return-value 
    - Workaround: use large statically-sized arrays
  - Deleting an element in the array (delete myArray[idx1]) generates gaps over time
  - This can lead to unpredictable gas costs if a contract itself has to search 
    through those gaps.
</pre>
  <span TODO xsmall>Walk over Array</a>
<pre xxxsmall zoom>
WARN: <b>string[]  arrays not allowed in solidity</b>
bytes32[] storage public namesInUse;
namesInUse.push(1)
namesInUse.push(3)
           ^^^^
           push only allowed for storage arrays, not memory

for (uint i = 0; i < namesInUse.length; i++) {
   require(namesInUse[i] != username);
}
</pre>

  <a xsmall href="https://solidity.readthedocs.io/en/v0.4.24/types.html#mappings">Mappings</a>
<pre xxxsmall zoom>
Syntax:

   mapping(_KeyType => _ValueType) public myMapping; // ← Declatarion
           ^^^^^^^^
     almost any type except 
     mapping,dynamic array,
     contract,enum,struct

   myMapping[key1] = value1;                         // ← add/modify key
   delete myMapping[key1]                            // ← put myMapping[key] to virt.Zero


- Only allowed for state variables (or as storage reference types in internal functions)
- <b>are NOT iterable.</b>

  - Care must be taken to not leave orphaned data in the state database, 
    particularly after contract-self-destruction =>
    - code must manually clean mappings by deleting each key.
</pre>
  <span xsmall TODO bgorange>Walk over Mappings</TODO>
<pre xxxsmall zoom>
- Mappings are virtually initialized:
  - <b>every possible key exists mapped to zero-byte-repr</b>
  - keys are NOT stored in the map
    => Code needs the keys to discover/walk-over mappings.
  - values are stored at the state-memory address == sha3(key)

- Solution 1: Using aux. array to store keys.
  (memory gaps can arise when deleting the aux-key-array) 
 ┌───────────────────────────────────────────┬──────────────────────────────────────────┐
 │ETHEREUM CODE                              │ CLIENT CODE                              │
 ├───────────────────────────────────────────┼──────────────────────────────────────────┤
 │mapping (address => uint) public balances; │ for(i = 0; i < k.size(); i++) {          │
 │address[] public keyList   ;               │   someFunc( k.balances(k.keyList(i)) );  │
 │function size() public returns (uint) {    │ }                                        │
 │    return keyList.length;                 │ Note: k == contract instance             │
 │}                                          └──────────────────────────────────────────┤ 
 │WARN: delete keyList[idx] can leave gaps                                              │
 └──────────────────────────────────────────────────────────────────────────────────────┘
- Solution 2: Using Linked List Indexes
 ┌───────────────────────────────────────────┬──────────────────────────────────────────┐ 
 │ETHEREUM CODE                              │ CLIENT CODE                              │ 
 ├───────────────────────────────────────────┼──────────────────────────────────────────┤ 
 │mapping (address => address) ll;           │ var current = k.ll(0);                   │ 
 │mapping (address => uint) public balances; │ while (current) {                        │ 
 │function add(address _addr_as_idx) public  │     console.log( k.balances(current) );  │ 
 │{                                          │     current = k.ll(current);             │ 
 │    ll[_addr]  = ll[0x0];                  │ }                                        │ 
 │    ll[0x0]    = _addr;                    └──────────────────────────────────────────┤ 
 │    balances[_addr] = balance;                                                        │ 
 │}   ^^                                                                                │ 
 │ ll will grow as:                                                                     │ 
 │   STEP 1         → STEP 2         → STEP 3         → STEP 4 ...                      │ 
 │   0x      addr01 → 0x      addr02 → 0x      addr03 →                                 │ 
 │                  → addr02  addr01 → addr02  addr01 →                                 │ 
 │                  →                → addr03  addr02 →                                 │ 
 │                  →                → addr03  addr02 →                                 │ 
 │                                                                                      │ 
 │// Deleting: No gaps but require a search to find parent node                         │
 │function remove(address _addr) {                                                      │ 
 │      address parent;                                                                 │ 
 │      // Warning: unbounded gas loop                                                  │ 
 │      while (llIndex[parent] != _addr) parent = llIndex[parent];                      │ 
 │      llIndex[parent] = llIndex[ llIndex[parent]];                                    │ 
 │      delete llIndex[address];                                                        │ 
 │      delete balances[address];                                                       │ 
 │  }                                                                                   │ 
 └──────────────────────────────────────────────────────────────────────────────────────┘ 
- Solution 3: Using Double Linked List Indexes
   - search loops removes at the expense of extra storage slot per indexed element.
   - a nested bool mapping for bidirectional links where we interpret
      PREV == false and NEXT == true:
┌──────────────────────────────────────────────────────────────────────────────────────┐
│mapping(address => ( mapping(bool => address) ) dllIndex;                             │
│mapping(address => uint) balances;                                                    │
│function add(address _addr)                                                           │
│{                                                                                     │
│    // Link the new node                                                              │
│    dllIndex[_addr][PREV] = 0x0;                                                      │
│    dllIndex[_addr][NEXT] = dllIndex[0x0][NEXT];                                      │
│                                                                                      │
│    // Insert the new node                                                            │
│    dllIndex[dllIndex[0x0][NEXT]][PREV] = _addr;                                      │
│    dllIndex[0x0][NEXT] = _addr;                                                      │
│}                                                                                     │
│                                                                                      │
│function remove(address _addr)                                                        │
│{                                                                                     │
│    // Stitch the neighbours together                                                 │
│    dllIndex[ dllIndex[_addr][PREV] ][NEXT] = dllIndex[_addr][TRUE];                  │
│    dllIndex[ dllIndex[_addr][NEXT] ][PREV] = dllIndex[_addr][PREV];                  │
│                                                                                      │
│    // Delete state storage                                                           │
│    delete dllIndex[_addr][PREV];                                                     │
│    delete dllIndex[_addr][NEXT];                                                     │
│    delete balances[_addr];                                                           │
│}                                                                                     │
└──────────────────────────────────────────────────────────────────────────────────────┘
 - We now have a directly addressable and fully iterable storage structure, which is
   not just a Double Linked List but a Circular Double Linked List by default 
   with the head at 0x0. This gives us two very desirable properties for free...

 - FIFO and FILO Queues
    First In First Out (FIFO) and First In Last Out (FILO) queues are a very 
    common concept in computing. FIFO can be used for task queues while FILO 
    is also used for memory 'stacks'.

 - FIFO's can be used in any contracts that require atomic sequential order 
   processing. Here a new order is simply inserted previous to the head, 
   while the oldest order is simply taken from next to the head. No search 
   loops required.

 - If you think these structures might be useful, check out my Circular 
   Double Linked List Index Library which is used by my Intrinsically 
   Tradable Tokens (ITT) contract.

</pre>
</td>
<td>
  <a xsmall href="https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity">Well-solved storage patterns for Solidity?</a>
<pre xxxsmall zoom bgorange>
Q: Simple and appropriate data organization can challenge Solidity newcomers. 
  It wants us to organize everything in ways many of us aren’t accustomed to.
  Are there well-solved general patterns for routine on-chain data organization?

A: Here are some simple and useful patterns in increasing order of utility.
<b>Event logs are omitted for brevity. In practice, it's desirable to emit events for every important state change.</b>

<b>SIMPLE LIST USING ARRAY</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
  Reliably chronological order | No random access by Id          | pragma solidity ^0.4.6;
  Provides a count             | No assurance of uniqueness      | contract simpleList {
  Random access by Row Number  | No check for duplicates         |   struct EntityStruct {
  (not Id)                     | Uncontrolled growth of the list |     address entityAddress;
                               |                                 |        uint entityData;
                               |                                 |      }
                               |                                 |    
                               |                                 |      <b>EntityStruct[]</b> public entityStructs;
                               |                                 |    
                               |                                 |      function newEntity(address entityAddress, uint entityData) 
                               |                                 |          public returns(uint rowNumber) {
                               |                                 |        EntityStruct memory newEntity;
                               |                                 |        newEntity.entityAddress = entityAddress;
                               |                                 |        newEntity.entityData    = entityData;
                               |                                 |        return entityStructs.push(newEntity)-1;
                               |                                 |      }
                               |                                 |    
                               |                                 |      function getEntityCount() 
                               |                                 |          public constant returns(uint entityCount) {
                               |                                 |        return entityStructs.length;
                               |                                 |      }
                               |                                 |    }

<b>MAPPING WITH STRUCT</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
 -Random access by unique Id   |-Unable to enumerate the keys    | contract mappingWithStruct {
 -Assurance of Id Uniqueness   |-Unable to count the keys        |   struct EntityStruct {
 -Enclose arrays, mappings,    |-Needs a manual check to         |     uint entityData;
  structs within each "record" |-distinguish a default from      |     bool isEntity;
                               | an explicitly "all 0" record    |   }
                               |                                 | 
                               |                                 |   <b>mapping (address => EntityStruct)</b> 
                               |                                 |     public entityStructs;
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |      public constant returns(bool isIndeed) {
                               |                                 |      return entityStructs[entityAddress].isEntity;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(isEntity(entityAddress)) throw; 
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |        = entityData;
                               |                                 |     entityStructs[entityAddress].isEntity 
                               |                                 |        = true;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function deleteEntity(address entityAddress)
                               |                                 |     public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].isEntity = false;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }


<b>ARRAY OF STRUCTS WITH UNIQUE IDS</b>

  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by Row number  | - No random access by Id        | contract arrayWithUniqueIds {
- Assurance of Id uniqueness   | - Uncontrolled growth of        | 
- Enclose arrays, mappings     |   the list                      |   struct EntityStruct {
  and structs with each        |                                 |     address entityAddress;
  "record"                     |                                 |     uint entityData;
                               |                                 |   }
                               |                                 | 
                               |                                 |   EntityStruct[] public entityStructs;
                               |                                 |   mapping(address => bool) knownEntity;
                               |                                 | 
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |       public constant returns(bool isIndeed) {
                               |                                 |     return knownEntity[entityAddress];
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount() public constant
                               |                                 |        returns(uint entityCount) {
                               |                                 |     return entityStructs.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress, uint entityData)
                               |                                 |       public returns(uint rowNumber) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     EntityStruct memory newEntity;
                               |                                 |     newEntity.entityAddress = entityAddress;
                               |                                 |     newEntity.entityData = entityData;
                               |                                 |     knownEntity[entityAddress] = true;
                               |                                 |     return entityStructs.push(newEntity) - 1;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity(
                               |                                 |       uint rowNumber,
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData) public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     if(entityStructs[rowNumber].entityAddress 
                               |                                 |       != entityAddress) throw;
                               |                                 |     entityStructs[rowNumber].entityData 
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }

<b>MAPPED STRUCTS WITH INDEX</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by unique Id   | - Uncontrolled growth of        | contract MappedStructsWithIndex {
  or row number                |   the list                      | 
- Assurance of Id uniqueness   |                                 |   struct EntityStruct {
- Enclose arrays, mappings and |                                 |     uint entityData;
  structs within each "record" |                                 |     bool isEntity;
- List maintains order of      |                                 |   }
  declaration                  |                                 | 
- Count the records            |                                 |   mapping(address => EntityStruct)
- Enumerate the Ids            |                                 |       public entityStructs;
- "Soft" delete an item by     |                                 |   address[] public entityList;
  setting a boolean            |                                 | 
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |       public constant 
                               |                                 |       returns(bool isIndeed) {
                               |                                 |     return entityStructs[entityAddress].isEntity;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount() 
                               |                                 |       public constant 
                               |                                 |       returns(uint entityCount) {
                               |                                 |     return entityList.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData)
                               |                                 |        public returns(uint rowNumber) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |        = entityData;
                               |                                 |     entityStructs[entityAddress].isEntity 
                               |                                 |        = true;
                               |                                 |     return 
                               |                                 |       entityList.push(entityAddress) - 1;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }


<b>MAPPED STRUCTS WITH DELETE-ENABLED INDEX</b>
<a href="https://medium.com/@robhitchens/solidity-crud-part-2-ed8d8b4f74ec#.ekc22r5lf">REF@Medium Rob Hitchens</a>
<a href="https://bitbucket.org/rhitchens2/soliditycrud/src/83703dcaf4d0c4b0d6adc0377455c4f257aa29a7/contracts/?at=master">BitBucket Source Code</a>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by unique Id   | - Marginally increased code     | contract mappedWithUnorderedIndexAndDelete {
  or row number                |   complexity                    |   struct EntityStruct {
- Assurance of Id uniqueness   | - Marginally higher storage     |     uint entityData;
- Enclose arrays, mapping and  |   costs                         |     uint listPointer;
  structs within each "record" | - Key list is inherently        |   }
- Count the records            |   unordered                     | 
- Enumerate the ids            |                                 |   mapping(address => EntityStruct) public entityStructs;
- Logically control the size of|                                 |   address[] public entityList;
  the active list with delete  |                                 | 
  function                     |                                 |   function isEntity(address entityAddress) 
                               |                                 |       public constant returns(bool isIndeed) {
                               |                                 |     if(entityList.length == 0) return false;
                               |                                 |     return (
                               |                                 |       entityList[entityStructs[entityAddress].
                               |                                 |          listPointer] == entityAddress);
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount()
                               |                                 |       public constant 
                               |                                 |       returns(uint entityCount) {
                               |                                 |     return entityList.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress, 
                               |                                 |       uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |         = entityData;
                               |                                 |     entityStructs[entityAddress].listPointer 
                               |                                 |         = entityList.push(entityAddress) - 1;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity(
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData) 
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress]
                               |                                 |        .entityData = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function deleteEntity(address entityAddress)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     uint rowToDelete 
                               |                                 |       = entityStructs[entityAddress].listPointer;
                               |                                 |     address keyToMove 
                               |                                 |       = entityList[entityList.length-1];
                               |                                 |     entityList[rowToDelete] = keyToMove;
                               |                                 |     entityStructs[keyToMove].listPointer 
                               |                                 |       = rowToDelete;
                               |                                 |     entityList.length--;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 | }


if(bad) throw;
if(bad) revert();
require(!bad)
ethfiddle.com/PgDM-drAc9 
</pre>
</td>

<td colsep></td>
<td>
  STRINGS
<pre xxxsmall zoom>
CAN NOTs:                               |  CANs:
 - Can NOT be concatenated.             |  - Can be used as keys for mappings

<b>Comparing strings:</b>
   sha3(      "string1" ) == sha3("string2")  ← sha3("...") translates to sha3(bytes("..."))
   ^^^^
   remember: sha3 is an alias for keccak256    

<b>check if string is empty:</b>
<a TODO href="XXX">Check white-space paddings</a>
bool stringNotEmpty = bytes(myTestedString).length &gt; 0; // alt 1, check underlying bytes array length
                                            ^^^^^^^ 
                                length implemented for
                                bytes, not (yet) for string

bool stringNotEmpty = sha3 (myTestedString) != sha3("")    // alt 2, check sha3
</pre>
  bytes32 ←→ Strings:
<pre TODO xxxsmall zoom>
<a href="https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string">code@stackoverflow </a> doesn't look to work
</pre>

  STRING LIBRARIES:
  <ul xxxsmall zoom>
  <li><a href="https://github.com/Arachnid/solidity-stringutils">Arachnid StringUtils</a></li>
  </ul>
</td>
<td>
   Date/Time
<pre xxxsmall zoom>
// DateTime is stored as uint

// "<b orange>now</b>" returns the (uint) current block timestamp (alias for block.timestamp)

uint <b brown>timeOutWindow</b> = <b brown>_inputTimeOutWindow</b> <b orange>* 1 minutes || 30 days</b>;
uint <b brown>time_origin</b> = ...

function myTimeOutDependentFunction(...) returns (...) {
    ...
    if (<b orange>now</b> &gt; (<b brown>time_origin + timeOutWindow</b>) throw;
    ... Do something ...
}
</pre>
</td>

</tr>
</table>



<table>
<tr>



<td>
    <a href="https://openzeppelin.org/api/docs/access_Roles.html">OpenZeppelin (2.0) API</a>
<pre xxxsmall zoom>
ACCESS
    Roles: Library for managing addresses assigned to a Role.
ACCESS / ROLES
    CapperRole (Capper:"remate")
    MinterRole
    PauserRole
    SignerRole
CROWDSALE
    Crowdsale: 
        base contract for managing a token crowdsale, allowing investors to 
        purchase tokens with ether. This contract implements such functionality
        in its most fundamental form and can be extended to provide additional 
        functionality and/or custom behavior. The external interface represents 
        the basic interface for purchasing tokens, and conform the base architecture
        for crowdsales. They are *not* intended to be modified / overridden. The
        internal interface conforms the extensible and modifiable surface of 
        crowdsales. Override the methods to add functionality. Consider using 
        'super' where appropriate to concatenate behavior.
CROWDSALE / DISTRIBUTION
    FinalizableCrowdsale
        Crowdsale with a one-off finalization action, where one can do extra work after finishing
    PostDeliveryCrowdsale
        Crowdsale that locks tokens from withdrawal until it ends.
    RefundableCrowdsale
        Extension of Crowdsale contract that adds a funding goal, and the 
        possibility of users getting a refund if goal is not met. WARNING: note 
        that if you allow tokens to be traded before the goal is met, then an 
        attack is possible in which the attacker purchases tokens from the crowdsale 
        and when they sees that the goal is unlikely to be met, they sell their 
        tokens (possibly at a discount). The attacker will be refunded when the 
        crowdsale is finalized, and the users that purchased from them will be left 
        with worthless tokens. There are many possible ways to avoid this, like 
        making the the crowdsale inherit from PostDeliveryCrowdsale, or imposing 
        restrictions on token trading until the crowdsale is finalized. This is being 
        discussed in https://github.com/OpenZeppelin/openzeppelin-solidity/issues/877 
        This contract will be updated when we agree on a general solution for this 
        problem.
CROWDSALE / EMISSION
    AllowanceCrowdsale
        Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.
    MintedCrowdsale
        Crowdsale contract whose tokens are minted in each purchase. Token 
        ownership should be transferred to MintedCrowdsale for minting.
CROWDSALE / PRICE
    IncreasingPriceCrowdsale
        Crowdsale contract that increases the price of tokens linearly in time. Note 
        that what should be provided to the constructor is the initial and final 
        _rates_, that is, the amount of tokens per wei contributed. Thus, the initial 
        rate must be greater than the final rate.
CROWDSALE / VALIDATION
    CappedCrowdsale
        Crowdsale with a limit for total contributions.
    IndividuallyCappedCrowdsale
        Crowdsale with per-beneficiary caps.
    TimedCrowdsale
        Crowdsale accepting contributions only within a time frame.
CRYPTOGRAPHY
    ECDSA
    MerkleProof
DRAFTS
    Counter
        Provides an incrementing uint256 id acquired by the `Counter#next` 
        getter. Use this for issuing ERC721 ids or keeping track of request ids, 
        anything you want, really. * Include with `using Counter for Counter.Counter
        ;`, Does not allow an Id of 0, which is popularly used to signify a null 
        state in solidity.
    ERC20Migrator
    SignatureBouncer
    TokenVesting
DRAFTS / ERC1046
    ERC20TokenMetadata
    ERC20WithMetadata
INTROSPECTION
    ERC165
    ERC165Checker
    IERC165
LIFECYCLE
    Pausable
 MATH
    Math
    SafeMath
 OWNERSHIP
    Ownable
    Secondary
PAYMENT
    PaymentSplitter
    PullPayment
PAYMENT / ESCROW
    ConditionalEscrow
    Escrow
    RefundEscrow
TOKEN / ERC20
    ERC20
    ERC20Burnable
    ERC20Capped
    ERC20Detailed
    ERC20Mintable
    ERC20Pausable
    IERC20
    SafeERC20
    TokenTimelock
TOKEN / ERC721
    ERC721
    ERC721Burnable
    ERC721Enumerable
    ERC721Full
    ERC721Holder
    ERC721Metadata
    ERC721MetadataMintable
    ERC721Mintable
    ERC721Pausable
    IERC721
    IERC721Enumerable
    IERC721Full
    IERC721Metadata
    IERC721Receiver
UTILS
    Address
    Arrays
    ReentrancyGuard
</pre>
</td>

<td>
  <a TODO href="https://hack.aragon.org/docs/aragonos-intro.html">AragonOS</a>
<pre xxxsmall zoom>
aragonOS provides the following functionality:
- DAO: Decentralized Autonomous Organization

- Upgreadability: Smart contracts can be upgraded to a newer version. Example: fixing a bug or adding a feature.
- Permission control: By using the auth() and authP() modifiers you can protect functionality such that they're only accessible by other apps or entities if given permission. This completely abstracts the authentication logic from an app, allowing you to focus on your app's business logic. Example: protecting a vault so only the organization's Voting app can initiate an action to transfer funds.
- Forwarders: aragonOS apps can communicate with each other by sending their intent to perform an action to other apps. Example: withdrawing funds from a vault only on the passing of a vote and the expiring of a time-lock.

All the above makes it very simple for aragonOS apps to incorporate governance. You just need to add a voting app, configure permissions the right way, and away you go!
</pre>
  <a TODO href="https://hack.aragon.org/docs/apm.html">Upgradeability</a>
<pre xxxsmall zoom>
- As a DAO, each aragonPM registry includes a number of installed applications, including one APMRegistry, one ENSSubdomainRegistrar, and many Repo instances.
</pre>


  <a TODO href="https://github.com/aragon/aragon-apps">Aragon Apps</a>
<pre xxxsmall zoom>
This repository contains the following apps:
 - Vault       : Securely owns and manages tokens on behalf of a DAO.
 - Finance     : Send payments and manage expenses with budgeting.
 - Voting      : Create votes that execute actions on behalf of token holders.
 - Token Manager: Manages organization tokens.

Under development:
 -  Payroll    : Manages employees' payrolls.
</pre>


</td>

<td>
  <a href='https://github.com/ConsenSys/smart-contract-best-practices'>Best Practices</a>
  Simple Coin
<pre  xxxsmall zoom>
pragma solidity ^0.4.0;                                              (JS) Client ussage:
contract /*Simple*/Coin {                                            
                                                                     Coin.Sent().watch(
  address public minter; // public => readable ""outside""            {},
                                                                      '',
  // state variable. Permanently stored in contract storage           function (error, result) {
  mapping ( address => uint) public balances;                           if (!error) {
                                                                          console.log(""Coin transfer: "" + result.args.amount +
  event EventSent( address from, address to, uint amount);                  "" coins were sent from "" + result.args.from +
                                                                            "" to "" + result.args.to + ""."");
  // This is the constructor whose code is run only                    
  // when the contract is created.                                        console.log(""Balances now:\n"" +
                                                                            ""Sender: "" + Coin.balances.call(result.args.from) +
  function Coin() { minter = msg.sender; }                                  ""Receiver: "" + Coin.balances.call(result.args.to));
                                                                        }
  function mint( address receiver, uint amount) {                    }
    if (msg.sender != minter) return ;                    
    balances[receiver] += amount;                         
  }                                                       
                                                          
  function send( address receiver, uint amount) {                 
    if (balances[msg.sender] &lt; amount) return ;
      balances[msg.sender] -= amount;
      balances[receiver] += amount;
      EventSent(msg.sender, receiver, amount);
  }

  function arithmetics(uint _a, uint _b)
    // returns 2-tuple 
    returns (uint o_sum, uint o_product) {
    // alt return (o_sum, o_product) -
    o_sum = _a + _b;
    o_product = _a * _b;
  }
}
</pre>
  <hr xxxsmall />
  <a href='https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md'>ERC20 Coin</a>
<pre xxxsmall zoom>
  Standard interface to Fungible Assets Contracts that different wallets will understand out-of-the-box
  <a href='https://theethereum.wiki/w/index.php/ERC20_Token_Standard'>ERC20 @ Ethereum WiKi</a>
  <a href='https://edcon.io/ppt/two/Dmitry%20Khovratovich_Secure%20Token%20Development%20and%20Deployment_EDCON.pdf'>Problems with the Standard</a>
  <a href='https://tokenmarket.net/what-is/ethereum-token-wallets/'>ERC20 compliant wallets</a>
</pre>
</td>
<td>
  <a href='https://erc725alliance.org/'>Identity</a><br/>
  <a TODO href="https://erc725alliance.org/">ERC-725 Identity Std</a>
<pre xxxsmall zoom>
- What is ERC 725?
  ERC 725 is a proposed standard for blockchain-based identity 
  authored by Fabian Vogelsteller, creator of ERC 20 and Web3.js. ERC 
  725 describes proxy smart contracts that can be controlled by 
  multiple keys and other smart contracts. ERC 735 is an associated 
  standard to add and remove claims to an ERC 725 identity smart 
  contract. These identity smart contracts can describe humans, groups
  , objects, and machines. ERC 725 lives on the Ethereum 
  blockchain.


- Why ERC 725?
  ERC 725 allows for self-sovereign identity. Users should be able to 
  own and manage their identity instead of ceding ownership of 
  identity to centralized organizations. We have seen the negative 
  effects of having centralized identity with damaging leaks and 
  unfair selling of user data and identity. An open, portable 
  standard for identities will enable decentralized reputation, 
  governance, and more. Users will be able to take their identity 
  across different Dapps and platforms that support this standard.
</pre>
</td>
<td>
<a href='https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol'>Minimum Signature.Num.</a>
<pre xxxsmall zoom>
Inheritable "property" contract:
<b>enables methods to be protected by requiring the acquiescence of either a
   single, or, crucially, each of a number of, designated owners.</b>
// REF: <a href="https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol">Wallet.sol gist</a>
// @authors: Gav Wood <g@ethdev.com>
contract multiowned {
    struct PendingState { uint yetNeeded; uint ownersDone; uint index; }
    mapping(bytes32 /* operation_hash */ => PendingState) <b orange>mapPendingOps</b>; // ongoing ops
    uint public minimum_required; // minimum owners confirmations for same operation
   
    mapping(address => uint /*<b brown>bit idx</b>*/) <b brown>mapOwner2Idx</b>; // <b>allow reverse lookup</b>
    bytes32[] m_pendingIndex;

    modifier onlyOwner { if (<b brown>mapOwner2Idx</b>[msg.sender] == 0) throw ; _ }

       /* same operation hash must be signed/accepted by a minimum number 
        * of the set of owners (specified in the constructor) before execution */
<b>    modifier  <b blue>onlyMany/*¡¡SIGNATURE!!*/Owners</b>(bytes32 _operation_hash) {
        if (!<b blue>confirmAndCheck</b>(_operation_hash)) throw ;  _ }</b>

<b>    constructor(address[] _owners /* "who" can confirm */,
           uint minimum_required /*minimum. confirmations*/) {</b>
        <b brown>mapOwner2Idx</b>[msg.sender] = 1;
        for (uint i = 0; i &lt; _owners.length; ++i) 
            { <b brown>mapOwner2Idx</b>[_owners[i]] = 2 + i; }
        minimum_required = minimum_required;
    }

    function <b>hasConfirmed(bytes32 _operation_hash, address _owner)</b> constant returns (bool) {
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        uint ownerIndex = <b brown>mapOwner2Idx</b>[_owner];
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine bit to set
        return (pending.ownersDone &<b green>ownerIdxBit</b> == 0) ? false : true;
    }

    function <b blue>confirmAndCheck</b>(bytes32 _operation_hash) internal returns (bool) {
        uint ownerIndex = <b brown>mapOwner2Idx</b>[msg.sender]; // get idx for msg.sender
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        if (pending.yetNeeded == 0) {
            pending.yetNeeded = minimum_required; // reset confirmations needed
            pending.ownersDone = 0; // reset owners confirmed to none (bitmap→0)
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation_hash;
        }
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine the bit to set
        if (pending.ownersDone & <b green>ownerIdxBit</b> == 0) {
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1 /* enough confirmations. reset→run*/) {
                delete m_pendingIndex[<b orange>mapPendingOps</b>[_operation_hash].index];
                delete <b orange>mapPendingOps</b>[_operation_hash];
                return true;
            } else {
                pending.yetNeeded--;
                pending.ownersDone |= <b green>ownerIdxBit</b>;
                return false;
            }
        }
    }
}
</pre>
<a href='https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial'>Voting</a>
<pre xxxsmall zoom>
contract Voting {
  uint       public <b orange>MIN_QUORUM</b>  ;
  uint       public <b orange>DEBATING_PERIOD</b> ;
  address    public <b green>FOUNDER</b>        ;
  Proposal[] public proposals      ;
  uint       public numProposals   ;
  
  struct <b blue>Vote     { int UpOrDown; address voter; }</b>
  struct Proposal {
    <b blue>Vote[]  votes</b>      ; mapping (address => bool) voted;
    bytes32 data        ; string  description;
    uint    creationDate; bool    active     ;
    boolean result;
  }
  
  constructor(uint _minimumQuorum, uint _debating_period) {
    <b green>FOUNDER</b>          = msg.sender;  
    <b orange>MIN_QUORUM</b>      = _minimumQuorum || 10;
    <b orange>DEBATING_PERIOD</b> = _debating_period * 1 minutes || 30 days;
  }

  function newProposal(bytes32 _data, string _descrip) returns (uint <b yellow>proposalID</b>) {
      <b yellow>proposalID</b>     = proposals.length++;
      Proposal p     = proposals[<b yellow>proposalID</b>];
      p.data         = _data;
      p.description  = _descrip  ;    p.creationDate = now;
      p.active       = true      ;    numProposals   = <b yellow>proposalID</b>+1;
  }
  
  function vote(uint _<b yellow>proposalID</b>, int _UpOrDown /*+1|-1*/) returns (uint <b brown>voteID</b>){
      if (_UpOrDown < -1 && _UpOrDown > 1 ) revert("UpOrDown is not valid") ;
      Proposal p = proposals[_<b yellow>proposalID</b>];
      if (p.voted[msg.sender] == true) return;
      <b brown>voteID</b> = p.<b blue>votes</b>.length++;
      p.<b blue>votes[<b brown>voteID</b>] = /*new*/Vote({UpOrDown: _UpOrDown, voter: msg.sender})</b>;
      p.voted[msg.sender] = true;
  }
  
  function executeProposal(uint _<b yellow>proposalID</b>) returns (int <b brown>result</b>) {
      Proposal proposal = proposals[_<b yellow>proposalID</b>];
      if (/*timeout?*/ now &gt; (proposal.creationDate + <b orange>DEBATING_PERIOD</b>) &amp;&amp; proposal.active){   
          uint quorum = 0;
          for (uint i = 0; i &lt;  proposal.<b blue>votes</b>.length; ++i) {
              Vote v = proposal.<b blue>votes</b>[i];
              quorum += 1;
              <b brown>result</b> += v.UpOrDown;
          }
          if (quorum &gt; <b orange>MIN_QUORUM</b>) {
              proposal.active = false;
              proposal.result = result &gt;=0 ? true : false;
          }
      }
  }
}
</pre>
</td>
</tr>
</table>

Libraries
<table>
<tr>
<td>
 About Libraries: <a href="https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736">REF</a>
<pre xxxsmall zoom>
Library benefits:
  - saving substantial amounts of gas 
  - can make for a more secure environment (if reused libraries are audited).

- In Solidity, a library is a different type of contract
  (library myLib {...} vs contract myContract {...}) ,
  doesn't have any storage and cannot hold ether:
  - It doesn't allow payable functions and cannot have a
    fallback function, enforced by the compiler.

- It can be seen as a sort of a singleton in the EVM:
  a piece of code that can be called from any contract
  without the need to deploy it again.

- It can also be seen as implicit base contracts of
   the contracts that use them

- EVM DELEGATECALL instruction is used to call the function,
  causing the calling context to be passed to the library,
  as if it was code running in the contract itself. 
  
  context kept by library:
  | this       <- address of the contract invoquing the library not the
  |               library context
  | msg.sender <- sender address sing
  | msg.value
  | msg.sig
  | msg.data
  | msg.gas

 - Library <b>linking</b> happens at the bytecode level (compile
   phase) and not at storage level so once setted it's lined 
   for always:

   When contract A is compiled, it leaves a <b orange>placeholder</b> for
   the library address in this way:

    0073<b orange>__</b>C<b orange>_____________________________________</b>630dbe671f
        <b orange>  </b>C<b orange>                                     </b>  ^^^^^^^
        <b orange>  </b>C<b orange>                                     </b>  0dbe671f is the function
        <b orange>  </b>C<b orange>                                     </b>  signature for a()

    * At compile time (before deploying the contract) the placeholder must be
      replaced with the address of the deployed library in the blockchain.


PROBLEM With Events sent by Libraries:
  Only problem is, right now (March 2017), the contract ABI does
  not reflect the events that the libraries it uses may emit.
   This confuses clients such as web3, that won't be able to
  decode what event was called or figure out how to decode its
  arguments.

HACK:  defining the event both in the contract and the library 
  will trick clients into thinking that it was actually the
  main contract who sent the event and not the library.
</pre>
  <a href="https://github.com/bkrem/awesome-solidity#libraries">Awesome Sol.Libs</a>
</td>
<td colsep>Zeppelin</td>
<td>
  <a TODO href="https://github.com/OpenZeppelin/">OpenZeppelin</a>
<pre xxxsmall zoom>
TODO: Summary of "important" libraries
</pre>
</td>
<td>
  ZeppelinOS ("Upgradable Contracts")
<pre xxxsmall zoom>
REFS:
- <a href="https://blog.zeppelinos.org/getting-started-with-zeppelinos/">Introduction @ Zepellin Blog</a>

ZeppelinOS "zos" is a command line tool to makes writing upgradeable contracts extremely easy, abstracting away the complexities of upgradeability.
 It is based on proxy libraries as explained <a TODO href="https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd">[here]</a> 

WARN: Upgradeability can NOT be applied to already-deployed contracts.

<b>zos install</b>
$ npm install --global zos

<b>zos ussage</b>
$ mkdir zos-demo && cd zos-demo
$ npm init -y
$ zos init zos-demo  # create the zos.json config. file
                                  ^^^^^^^^             
                              config file that makes zos
                              aware of your smart contract 
                              architecture.

$ npm install --save zos-lib # A "contracts" folder is created

$ vim contracts/CounterContract.sol
 pragma solidity ^0.4.21;
 import "zos-lib/contracts/migrations/Migratable.sol";

 | contract CounterContract is Migratable {
 |
 |   uint256 public counter;
 |
 |   // <b>initialize replaces constructor in upgradable contract</b>
 |   // guaranting that the new contract version can only be initialized once.
 |   function <b orange>initialize</b>(uint256 _counter)   
 |     // isInitializer takes the name of contract and version ID
 |     <b>isInitializer("CounterContract", "0")</b> public {
 |     counter = _counter;
 |   }
 |
 |   function increment() public {
 |     counter += 1; 
 |   }
 | }
 | 
 Note: If you do use a constructor in an upgradeable smart contract, 
       everything you set in the constructor will be ignored.


<b>Testing</b>
("npm install --save ganache-cli" if not already done)
$ npx ganache-cli --port 9545 

$ zos add CounterContract  # ← STEP 1: Add smart contract to zos
$ zos push --network local # ← STEP 2: push it to the local network:

$ zos create CounterContract \ # create&amp;initialize upgradeable instance
      --init <b orange>initialize</b> \
      --args 42 \     ← must match the <b orange>initialize</b> method.
      --network local
→ ... 
→ ... <b green>CounterContract proxy: <address></b>  ← address to use for instance
→ ...                                                  (safe somewhere safely!)

$ npx truffle console --network=local  # ← enter truffle interactive console
  truffle> counterContract = CounterContract.deployed()    # Alt 1:
  truffle> counterContract = CounterContract.at("address") # Alt 2:
  truffle> counterContract.increment()                     # Call public method
  truffle> counterContract.counter().then(counter => counter.toNumber()) # Fetch value
  → 43
  truffle> .exit

<b>Upgrade deployed contract</b>   
  (add incrementByTwo and history map)

    pragma solidity ^0.4.21;
    import "zos-lib/contracts/migrations/Migratable.sol";

    contract CounterContract is Migratable {
     uint256 public counter;
 +  mapping(uint256 => address) public history;
    ...

 +  function incrementByTwo() public {
 +     counter += 2;
 +     history[counter] = msg.sender;
 +   }
    }
<b bgred>WARN: When writing new versions of your contract, you must preserve all variables that
      appear in previous versions of your smart contract in the same order.
      You should only make additive changes. You can find more details in the advanced topics page.</b>

$ zos push --network local                    # ← Push new version.
$ zos update CounterContract --network local  # ← update CounterContract to new version

<b>Test new version</b>
$ npx truffle console --network=local to access the truffle console.
   truffle> counterContract = CounterContract.deployed() # alt 1
   truffle> counterContract = CounterContract.at("address")
   truffle> counterContract.incrementByTwo() 
   truffle> counterContract.counter().then(counter => counter.toNumber())
   → 45  
   truffle> counterContract.history(45)
   → 0x....  

<b>
Note: If at any point you’ve stopped Ganache and need to restart this process all over,
make sure you delete zos.local.json file as well. This isn’t a problem for other networks,
x since typically networks don’t get wiped out :)</b>

See also:
<a TODO href="https://blog.zeppelinos.org/getting-started-with-zeppelinos/">Getting Started with Z.OS</a>
<a TODO href="https://docs.zeppelinos.org/docs/advanced.html#deploying-to-mainnet">Deployning to mainnet</a>
<a TODO href="https://docs.zeppelinos.org/docs/basil.html">Advanced Tutorial</a>
<a TODO href="https://docs.zeppelinos.org/docs/crafty.html">Advanced example (Crafty)</a>
</pre>

  <a TODO href="https://blog.aragon.one/advanced-solidity-code-deployment-techniques-dc032665f434">Advanced deployment (@Aragon)</a>
</td>
<td colsep></td>

<td>
 <a TODO href="https://github.com/modular-network/ethereum-libraries">Modular-Network Libs</a>
<pre xxxsmall zoom>
- ArrayUtilsLib   
- BasicMathLib
- CrowdsaleLib
- LinkedListLib
- StringUtilsLib
- TokenLib
- VestingLib
- WalletLib
</pre>
</td>
<td>
  Deprecated libs:
<pre xxxsmall zoom>
<a TODO href="https://github.com/ethereum/dapp-bin/tree/master/library">Dapp-bin</a>
Amongst others contains 
   linkedList.sol and iterable_mapping.sol but it's not maintained since Mid-2017
</pre>
</td>

<td>
  <a TODO href="https://github.com/Arachnid/solidity-stringutils">Arachnid StringUtils</a>
<pre xxxsmall zoom>
</pre>
</td>

</tr>
</table>
<br/>
  Development Tools <a href='http://ethereum.stackexchange.com/questions/269/what-exactly-is-an-ethereum-client-and-what-clients-are-there/335'>[REF@Stackoverflow]</a>
<table>
<tr>
<td> 
   Non Classified
<pre xxxsmall zoom>
  <a TODO href='https://github.com/ethpm/ethpm-js'>https://github.com/ethpm/ethpm-js</a>
      Javascript library for publishing and consuming Ethereum packages,
      provides utilities for publishing and consuming Ethereum packages based
      on the Ethereum Package Manager specification. It is meant to be integrated
      directly into development tools to support their use of the Ethereum Package
      Management ecosystem.

  <a TODO href='https://yakindu.github.io/solidity-ide/'>Yakindu Solidity IDE (Eclipse based)</a>

  
  <a href="https://etherscan.io/pushTx">https://etherscan.io/pushTx</a>
      Send raw-transactions
  <a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">tmux:</a> General (BSD/Linux/UNIX) tool for multiplexing terminals and create long-running
      sessions that persists ssh disconnections.
      - It allows for example to have an terminal with vim editing solidity files,
        another one editing JS files, another one with the truffle debugger,  
        the geth console, ...
      - Sessions will persists until the PC/server is restarted. We can disconnect
        and reconnect to the same session repeatedly. The terminal layout will be
        saved. 
      - It also allow different users to share the session and terminals and is
        very efficient in terms of bandwidth (when compared to VNC or RDesktop),
        since there are not graphics involved.
</pre>
</td>
<td colsep></td>
<td colsep>Javascript</td>
<td>
<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">JS API<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">:
<pre xxxsmall zoom>
eth_accounts                                           eth_getTransactionCount
eth_blockNumber                                        eth_getTransactionReceipt
eth_call                                               eth_hashrate
eth_coinbase                                           eth_mining
eth_compileSolidity                                    eth_newBlockFilter
eth_estimateGas                                        eth_newFilter (includes log/event filters)
eth_gasPrice                                           eth_sendTransaction
eth_getBalance                                         eth_sendRawTransaction
eth_getBlockByNumber                                   eth_sign
eth_getBlockByHash                                     eth_syncing
eth_getCode (only supports block number “latest”)      eth_uninstallFilter
eth_getCompilers                                       net_listening
eth_getFilterChanges                                   net_peerCount
eth_getFilterLogs                                      net_version
eth_getLogs                                            miner_start
eth_getStorageAt                                       miner_stop
eth_getTransactionByHash                               rpc_modules
eth_getTransactionByBlockHashAndIndex                  web3_clientVersion
eth_getTransactionByBlockNumberAndIndex                web3_sha3
</pre>
</td>

<td>
  <a xsmall TODO href="https://www.truffleframework.com/">Truffle Framework</a>
  <hr xxxsmall />
   new bare Project
<pre xxxsmall zoom>
$ mkdir fibonacci
$ cd fibonacci
$ <b>truffle init</b>  # ← Create a bare truffle project:
$ vim Smart-Contract contracts/Fibonacci.sol:
    | pragma solidity ^0.4.22;
    | contract Fibonacci {
    |     // fibseries declaration outside function 
    |     //   => saved in storage (vs memory) 
    |     //    => triggers TX when modified 
    |     uint[] fibseries; 
    |     // n = how many in the series to return
    |     function generateFib(uint n) public {
    |         // set 1st and 2nd entries
    |         fibseries.push(1);
    |         fibseries.push(1);
    |
    |         // generate subsequent entries
    |         for (uint i=2; i < n ; i++) {
    |             fibseries.push(fibseries[i-1] +
    |                            fibseries[i-2]);
    |         }
    |     }
    | }
$ vim migrations/2_deploy_contracts.js:
WARN: ¡¡¡do not touch 1_initial_migration.js!!!
    | var Fibonacci = artifacts.require("Fibonacci");

    | module.exports = function(deployer) {
    |   deployer.deploy(Fibonacci);
    | };
$ vim truffle-config.js:
    | module.exports = {
    |   networks: {
    |     development: {
    |       host: "127.0.0.1",  ← test geth/ganache/... IP 
    |       port: 7545,         ← test geth/ganache/... port
    |       network_id: "*"
    |     }
    |   }
    | };
$ <b>truffle compile</b>
(compiles /contracts/*.sol → build/contracts/*.json )
JS clients apps can then use the contract with code similar to:
import metacoin_artifacts from '../../build/contracts/MetaCoin.json'

Migrate to default network defined in truffle.js (localhost:8545)
(Ussually this correspond to the testrpc daemon)
$ <b>truffle migrate</b>
$ vim test/TestFibonacci.js
$ <b>truffle test</b>

$ <b>truffle deploy</b> <span TODO>Deploy to ""real""/""test"" network</span>
                        # sends contract to the Ethe. network. Will also update
                        # contracts.json adding the {""address"":...""} for the
                        #deployed contract

</pre>
   Truffle Solidity Debugger
<pre xxxsmall zoom>
  <a href="https://truffleframework.com/tutorials/debugger-variable-inspection">REF</a>
$ truffle console  # ← Will fail in test node is NOT running
truffle(development)> <b>compile</b>
→ Compiling .\contracts\Fibonacci.sol...
→ Compiling .\contracts\Migrations.sol...
→ Writing artifacts to .\build\contracts
→ ...
( Check for errors)
truffle(development)> <b>migrate</b>
→ Using network 'development'.
→ ...
→ Running migration: 1_initial_migration.js
→ ...
→ Running migration: 2_deploy_contracts.js
→ ...
→ ...
→ ...
→ ...
(Check in geth logs|ganache console that TXs have been mined)

truffle(development)> <b>Fibonacci.deployed()
                         .then(instance => instance.generateFib(10))</b>
                               ^^^^^^^^
                               JS "proxy" to 
                             newly deployed contract 
→ { tx: '<span bgorange>0xf47f...41c</span>',
→   receipt:
→    { transactionHash: '<span bgorange>0xf47f0...1c41c</span>',
→      transactionIndex: 0,
→      blockHash: '0x88d45cb84d1f26....49a2ed',
→      blockNumber: 5,
→      gasUsed: 298373,
→      cumulativeGasUsed: 298373,
→      contractAddress: null,
→      logs: [],
→      status: '0x01',
→      logsBloom: '0x000....0000' },
→   logs: [] 
→ }

truffle(development)> console.dir(instance) 
→ ...
truffle(development)> <b>debug</b> <span bgorange>0xf47f0...1c41c</span>
→ Gathering transaction data...
→ Addresses affected:                                     
→  0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci 
→ 
→ Commands:
→ (enter) last command entered (step next)
→ (o) step over, (i) step into, (u) step out, (n) step next
→ (;) step instruction, (p) print instruction, (h) print this help, (q) quit
→ (b) toggle breakpoint, (c) continue until breakpoint
→ (+) add watch expression (`+:<expr>`), (-) remove watch expression (-:<expr>)
→ (?) list existing watch expressions
→ (v) print variables and values, (:) evaluate expression - see `v`
→ 
→ Fibonacci.sol:
→                             
→ 1: pragma solidity ^0.4.22;
→ 2:
→ 3: contract Fibonacci {
→    ^^^^^^^^^^^^^^^^^^^^
debug(development:0xf47f01da...)> <b>n</b>
→ 7:   // n = how many in the series to return
→ 8:   function generateFib(uint n) public {
→      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
→ 
(Move until reaching the for-loop)
debug(development:0xf47f01da...)> <b>v</b>
→         i: 0
→         n: 10
→ fibseries: []
debug(development:0xf47f01da...)> <b>+:{ i, fibseries }</b> ← watch vars (show after instruction)
                                  <b>                  </b>   -:i to unwatch
debug(development:0xf47f01da...)> <b>o</b>  ← Repeat until filling the array
→ ...
→ fibseries: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 
</pre>

  Recompile/Update
<pre xxxsmall zoom>
truffle(development)> <b>compile --all</b>
                              ^^^^^
                              force recompile all
                              of the contracts.
→ ...
truffle(development)> <b>migrate --reset</b>
→ ...
truffle(development)> <b>Fibonacci.deployed().then(function(instance){return instance.generateFib(10);});</b>
→ ...
</pre>
</td>
<td>
  <a TODO xsmall href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/events.js#L118-L143">Truffle: Testing events</a> 
<pre xxxsmall zoom>
var assert = require("chai").assert;
var util = require("./util");

describe("Events", function() {
  var Example;
  var accounts;
  var web3;
  var providerOptions = { vmErrorsOnRPCResponse: false };

  <b>before</b>(async function() {
    this.timeout(10000);
    Example = await util.createExample();
    return util.setUpProvider(Example, providerOptions).then(result => {
      web3 = result.web3;
      accounts = result.accounts;
    });
  });

  it('should expose the "on" handler / format event correctly', function(done) {
    Example.new(1).then(example => {
      const event = example.ExampleEvent();

      event.on("data", function(data) {
        assert.equal("ExampleEvent", data.event);
        assert.equal(accounts[0], data.args._from);
        assert.equal(8, data.args.num); // 8 is a magic number inside Example.sol
        this.removeAllListeners();
        done();
      });

      example.triggerEvent();
    });
  });

  it('should expose the "once" handler', function(done) {
    Example.new(1).then(example => {
      const event = example.ExampleEvent();

      event.once("data", function(data) {
        assert.equal("ExampleEvent", data.event);
        assert.equal(accounts[0], data.args._from);
        assert.equal(8, data.args.num); // 8 is a magic number inside Example.sol
        this.removeAllListeners();
        done();
      });

      example.triggerEvent();
    });
  });

  it("should be possible to listen for events with a callback", function(done) {
    const callback = (err, data) => {
      assert.equal("ExampleEvent", data.event);
      assert.equal(accounts[0], data.args._from);
      assert.equal(8, data.args.num);
      done();
    };

    Example.new(1).then(example => {
      example.ExampleEvent(callback);
      example.triggerEvent();
    });
  });

  it("event emitter should fire repeatedly (without duplicates)", async function() {
    let emitter;
    let counter = 0;
    const example = await Example.new(1);

    example.ExampleEvent().on("data", function() {
      emitter = this;
      counter++;
    });

    await example.triggerEventWithArgument(1);
    await example.triggerEventWithArgument(2);
    await example.triggerEventWithArgument(3);

    assert(counter === 3, "emitter should have fired repeatedly");
    emitter.removeAllListeners();
  });

  it("event callback should fire repeatedly (without duplicates)", async function() {
    let counter = 0;
    let duplicate = false;
    const example = await Example.new(1);

    example.ExampleEvent(function(err, res) {
      if (res === false) duplicate = true;
      counter++;
    });
    await example.triggerEventWithArgument(1);
    await example.triggerEventWithArgument(2);
    await example.triggerEventWithArgument(3);

    assert(counter === 3, "callback should have been called repeatedly");
    assert(duplicate === false, "must not fire duplicates as false result");
  });

  it("should listen for `allEvents`", async function() {
    let emitter;
    const events = [];
    const eventNames = [];
    const signatures = ["ExampleEvent", "SpecialEvent"];
    const example = await Example.new(1);

    example.allEvents().on("data", function(data) {
      events.push(data);
      data.event && eventNames.push(data.event);
      emitter = this;
    });

    await example.triggerEvent();
    await example.triggerSpecialEvent();

    assert(
      eventNames.includes(signatures[0]),
      `Expected to hear ${signatures[0]}`
    );
    assert(
      eventNames.includes(signatures[1]),
      `Expected to hear ${signatures[1]}`
    );

    // Make sure we're formattingfor backwards compatibility
    assert.equal(events[0].args._from, accounts[0]);
    assert.equal(events[0].args.num, 8);

    emitter.removeAllListeners();
  });

  it("should `getPastEvents`", async function() {
    const signatures = ["ExampleEvent", "SpecialEvent"];
    const example = await Example.new(1);
    const options = { fromBlock: 0, toBlock: "latest" };

    await example.triggerEvent();
    await example.triggerEvent();

    await example.triggerSpecialEvent();
    await example.triggerSpecialEvent();

    const exampleEvent = await example.getPastEvents("ExampleEvent", options);
    const specialEvent = await example.getPastEvents("SpecialEvent", options);

    assert(exampleEvent.length === 2);
    assert(exampleEvent[0].event === signatures[0]);
    assert(exampleEvent[1].event === signatures[0]);

    // Make sure we're formatting for backwards compatibility
    assert.equal(exampleEvent[0].args._from, accounts[0]);
    assert.equal(exampleEvent[0].args.num, 8);

    assert(specialEvent.length === 2);
    assert(specialEvent[0].event === signatures[1]);
    assert(specialEvent[1].event === signatures[1]);
  });

  // Event signature is:
  // NumberEvent(int numA, int indexed numB, address addrC, uint numD, uint);
  it("should reformat numbers in events to BN by default", function(done) {
    Example.new(1).then(example => {
      const event = example.NumberEvent();

      event.once("data", function(data) {
        const args = data.args;

        assert(web3.utils.isBN(args[0])); // int named
        assert(web3.utils.isBN(args[1])); // int named, indexed

        assert(!web3.utils.isBN(args[2])); // Address

        assert(web3.utils.isBN(args[3])); // uint named
        assert(web3.utils.isBN(args[4])); // uint unnamed

        assert(web3.utils.isBN(args.numA));
        assert(web3.utils.isBN(args.numB));

        assert(!web3.utils.isBN(args.addressC));

        assert(web3.utils.isBN(args.numD));

        assert(args.numA.toNumber() === 5);
        assert(args.numD.toNumber() === 55);

        this.removeAllListeners();
        done();
      });

      example.triggerNumberEvent(5, 7, accounts[0], 55, 77);
    });
  });
});
</pre>
<a xsmall TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/">Truffle tests</a>
<pre xxxsmall zoom>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/errors.js"         >test:errors.js          </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/abiV2.js"          >test:abiV2.js           </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/cloning.js"        >test:cloning.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/customoptions.js"  >test:customoptions.js   </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/deploy.js"         >test:deploy.js          </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/deprecated_keys.js">test:deprecated_keys.js </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/linking.js"        >test:linking.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/methods.js"        >test:methods.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/networkObject.js"  >test:networkObject.js   </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/networks.js"       >test:networks.js        </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/separation.js"     >test:separation.js      </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/util.js"           >test:util.js            </a>
</pre>


</td>


<td colsep></td>
<td colsep>JAVA</td>
<td>
  <a href="https://docs.web3j.io/">Web3J</a><br/>
<pre xxxsmall zoom>
<a href="https://docs.web3j.io/getting_started.html">pom / gradle dependencies</a>
<a href="https://github.com/web3j/sample-project-gradle/blob/master/src/main/java/org/web3j/sample/Application.java">Example app</a>
<a href="https://docs.web3j.io/infura.html">Using infura</a>


SYNC. REQUESTS                        | CompletableFuture (Future ON ANDROID): | RXJAVA OBSERVABLE:
Web3ClientVersion web3ClientVersion = | Web3ClientVersion web3ClientVersion =  | web3.web3ClientVersion()
    web3.web3ClientVersion()          |     web3.web3ClientVersion()           |     .observable().subscribe(x -&gt; {
    .send().getWeb3ClientVersion();   |     .sendAsync().get();                |     String clientVersion = 
                                      |                  ^blocking             |         x.getWeb3ClientVersion();
                                      |                                        | });


TRANSACT WITH A SMART CONTRACT WRAPPER:       | CALL A SMART CONTRACT WRAPPER:
----------------------------------------------+---------------------------------------------
(changes status in blockchain, needs mining)  | (local query, no mining needed)
TransactionReceipt transactionReceipt =       | Type result = 
   contract.someMethod(                       |    contract.someMethod(<param1>, ...).send();
     "param1", ...).send();                   |
                                              | The "someMethod" in *.sol contract needs to be 
                                              | marked as "view". Otherwise the java wrapper
                                              | will generate code for new TXs returning
                                              | a TX receipt
</pre>
FILTERS
<pre xxxsmall zoom>
Subscribe for "new-blocks" events:                  | Subscribe for "new-TXs" events:                  | Subscribe for "new pending-TX" events: 
----------------------------------------------------+--------------------------------------------------+----------------------------------------
Subscription subscription =                         | Subscription subscription =                      | Subscription subscription = 
  web3j.blockObservable(false).subscribe(block -> { |   web3j.transactionObservable().subscribe(tx -> {|    web3j.pendingTransactionObservable().
    ...                        ^                    |       ...                                        |      subscribe(tx -> { ...  });
  });                          |                    |   });
                               |
                            Optionally:
  catchUpToLatestAndSubscribeToNewBlocksObservable(
        <startBlockNumber>, <fullTxObjects>)
        .subscribe(block -> {
            ...
});

<b>subscription.unsubscribe(); //when no longer required </b>
</pre>

<pre xxxsmall zoom>
<b>TOPIC FILTERS:</b> <b red>not supported on Infura</b>

EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
        DefaultBlockParameterName.LATEST, <contract-address>)
             .addSingleTopic(...)|.addOptionalTopics(..., ...)|...;
web3j.ethLogObservable(filter).subscribe(log -> {
    ...
});
</pre>
</td>


<td colsep></td>
<td colsep>C#</td>
<td>
  <a xsmall TODO href="https://nethereum.readthedocs.io/en/latest/">Nethereum</a><br/>
<pre xxxsmall zoom>
PRE-SETUP
$ <b>dotnet add package Nethereum.Web3</b>

<b>Sending Ethers</b>
using System;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Hex.HexTypes;
using Nethereum.HdWallet;

bool useSoftWallet = true // ← false => Use HW Wallet
if (useSoftWallet) {
  // Alt 1: Use <b>private key/Software wallet</b> to init web3 instance.
  var account = new Account(
      "0x... 32 bytes- private key in Hex format ");
  
  var web3 = new Web3(account);
} else {
  // Alt 2: Use <b>HW Wallet</b> to init web3 instance
  string Words = "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal";
                  string Password = "password";
  var wallet = new Wallet(Words, Password);
  var account = wallet.GetAccount(0);
  var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";
  var web3 = new Web3(account);
}
var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";

var TXManager = web3.Eth.GetEtherTransferService();
var TX = await TXManager
    .TransferEtherAndWaitForReceiptAsync(
       toAddress, Web3.Convert.ToWei(1));
 // alt: Specify gas amount
 // .TransferEtherAndWaitForReceiptAsync(
 //    toAddress, Web3.Convert.ToWei(1), 2);
</pre>

<a xsmall TODO href="https://nethereum.readthedocs.io/en/latest/nugets/">Nuget packages</a>
<pre xxxsmall zoom>
- Standalone packages targeting Netstandard 1.1, net451, Netstandard 2.0, Netcoreapp 2.1
  and where possible net351 to support Unity3d. 
 (Nethereum.Portable deprecated)
Windows:                                Windows/Mac/Linux users
PM > Install-Package Nethereum.Web3     dotnet add package Nethereum.Web3 
<b>Main Libraries</b>
Project Source                    Description
Nethereum.Web3                    Web3-RPC, contract inter./deployment/TX, en/de-coding, event filters
Nethereum.Unity  
Nethereum.Geth                    Geth support for Admin, Debug, Miner
Nethereum.Quorum 
Nethereum.Parity                  Parity  non-generic RPC API support
<b>Core Libraries</b>

Project Source                  Description
Nethereum.ABI                   Encoding/decoding of ABI Types, functions, events of Ethereum contracts
Nethereum.EVM                   Ethereum Virtual Machine API
Nethereum.Hex                   HexTypes for encoding and decoding String|BigInteger...
Nethereum.RPC                   
Nethereum.JsonRpc.Client        
Nethereum.JsonRpc.RpcClient     
Nethereum JsonRpc IpcClient     
Nethereum.RLP                   RLP encoding and decoding
Nethereum.KeyStore              Keystore generation|en/de-cryption (Web3 Secret Storage definition)
Nethereum.Signer                Nethereum signer library to sign and verify messages,
                                RLP and transactions using an Ethereum account private key
Nethereum.Contracts             Core library to interact via RPC with Smart contracts
Nethereum.IntegrationTesting    Integration testing module
Nethereum.HDWallet              Generates an HD tree of Ethereum compatible addresses from
                                a randomly generated seed phrase (using BIP32 and BIP39)

<b>Smart contract API Libraries</b>
Project Source                  Description
Nethereum.StandardTokenEIP20    Nethereum.StandardTokenEIP20 Service 
Nethereum.Uport                 Uport registry library
Nethereum.ENS                   Ethereum Name service library
<b>Utilities</b>
Nethereum.Generator.Console     collection of cli utilities to interact with Ethereum/account management
<b>Training modules</b>
Project                         Description
Nethereum.Workbooks             Xamarin Workbook tutorials including executable code
Nethereum.Tutorials             Tutorials to run on VS Studio
<b>Code templates</b>
Source                          Description
Keystore generator              Keystore file generator
Faucet                          Web application template for an Ether faucet
Nethereum Flappy                The source code files for the Unity3d game integrating with Ethereum
Nethereum Game Sample           Sample game demonstrating how to integrate Nethereum with UrhoSharp's
                                SamplyGame to build a cross-platform game interacting with Ethereum
Nethereum UI wallet sample      Cross platform wallet example using Nethereum, Xamarin.Forms and MvvmCross, 
                                targeting: Android, iOS, Windows Mobile, Desktop (windows 10 uwp), IoT
                                with the Raspberry PI and Xbox.
</pre>
</td>

<td colsep></td>
<td colsep></td>

<td>
    <span xsmall TODO>Dev.Troubleshooting</span>
<pre xxxsmall zoom>
<b>solc *bin output is empty, but there are no compilation warnings:</b>
PROBLEM:
    Next code compiles "OK" using
    SOLC INPUT               |  SOLC OUTPUT
    -------------------------|--------------------
    pragma solidity ^0.4.8;  |  A.bin  6060604...
    contract A {             |  B.bin  6060604...
      uint public a1;        |
    }                        |
                             |
    contract B <b>is A</b> { |
      uint8 public b1;       |
    }                        |

  <b red>Adding any constructor to the A contract, and keeping same B 
  generates erroneus empty B.bin</b>

SOLUTION:
   solc compiler consider the class abstract and does not generate any
   bin due to some of the following reasons:
    - B will need to provide parent A constructor with a parameter
      contract B is A {
        uint8 public b1;
      
        <b blue>constructor(address _a) A(_a) { // or A(0x00112...)
           ...
        }</b>
      }
   
    - B does NOT implementsall mehtods of declared interfaces or base clases


<b>Problem: Transaction with same hash already imported  error:</b>
<a href="https://ethereum.stackexchange.com/questions/9055/cant-broadcast-ethereum-transaction-whats-wrong-with-this-transaction">REF.1</a>, <a href="https://gitter.im/web3j/web3j?at=58d1e9ce5917e26076be161c">REF 2.web3j Gitter</a>
Solution: This means that the same transaction is sent twice with onley the nonce different.
 Probably it's a client error.
</pre>
</td>

</tr>
</table>
  DevOps
<table>
<tr>
<td>
   <a TODO href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#network-formation">RLPx: Crypto.Net.&amp;Transport Proto.</a>

<pre xxxsmall zoom>
each node is expected to maintain a static private key which is saved and 
restored between sessions.  It is recommended that the private key can only 
be reset manually, for example, by deleting a file or database entry.

There are two kinds of connections which can be established.  A node can connect to:
  - a known peer which has previously been connected to 
    and from which a corresponding session token is available for
    authenticating the requested connection
  - a new peer
</pre>
</td>
<td colsep>Geth</td>
<td>
  <a TODO href="XXX">Geth Configuration</a>
<pre xxxsmall zoom>
</pre>
  <a TODO href="XXX">Geth Architecture</a>
<pre xxxsmall zoom>

<a href="http://leveldb.org/">LevelDB</a> (key/value) storage backend.
  - entries stored lexicographically sorted by keys.
    (sorting comes-in very useful for querying)
  - Arbitrary byte arrays:
    keys and values are treated as simple arrays of bytes,
    so content can be anything from ASCII strings to binary blobs.
  - Compressed storage:
    Google’s Snappy compression library (optional) dependency,
    highly optimized for fast compression (vs high compress ratio)
  - Ex ussage:
    var level = require('level')
    var db = level('./db', { valueEncoding: 'json' })
    
    db.put('key', { example: true }, function (err) {
      if (err) throw err
    
      db.get('key', function (err, value) {
        if (err) throw err
        console.log(value)
      })
    })"

</pre>

</td>
<td>
  <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">Geth Console</a>
<pre xxxsmall zoom>
Interactive mode:
  $ get (--preload "scripts/myScript1.js,scripts/myScript2.js" attach # Attach to local running process
Non-interactive mode:
  $ get --exec "eth.blockNumber" attach
  $ geth --exec 'loadScript("/tmp/checkbalances.js")' attach http://123.123.123.123:8545

---------------------
Examples:
EXAMINE TRANSACTION:
$ TX_ID='0xaebaf7e8207c417f6bb7920f3820e5220738d6825b6f577e3c3d0736d3c95b49'
$ web3.eth.getTransaction(TX_ID, 
    function(e, r) {
       if (e) { console.log(e); return; }
       res = r; 
    } );
$ res
---------------------
CHECKING ACCOUNT BALANCES
$ cat /Users/username/gethload.js
function checkAllBalances() {
  var totalBal = 0;
  for (var acctNum in eth.accounts) {
    var acct = eth.accounts[acctNum];
    var acctBal = web3.fromWei(eth.getBalance(acct), "ether");
    totalBal += parseFloat(acctBal);
    console.log("  eth.accounts[" + acctNum + "]:" + acct 
              + "  balance: " + acctBal + " ether");
  }
  console.log("  Total balance: " + totalBal + " ether");
};
---------------------
&gt; loadScript("/Users/username/gethload.js")
&gt; checkAllBalances();
  eth.accounts[0]: 0xd1ade25ccd3d550a7eb532ac759cac7be09c2719 	balance: 63.11848 ether
  eth.accounts[1]: 0xda65665fc30803cb1fb7e6d86691e20b1826dee0 	balance: 0 ether
  eth.accounts[2]: 0xe470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32 	balance: 1 ether
</pre>

 Geth Console Troubleshooting
<pre xxxsmall zoom>
<a href="https://web3js.readthedocs.io/en/1.0/index.html">Full 1.0 API</a>
console.dir(eth) does NOT work but all that needed is enter the object name in the prompt

> eth                                                                         > web3
→ {                                                                           → {
→   accounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],                 →   admin: {
→   blockNumber: 5,                                                           →     datadir: "/home/vagrant/singleNodeNetwork/qdata/dd1",<b>
→   coinbase: "0xed9d02e382b34818e88b88a309c7fe71e65f419d",                   →     nodeInfo: {
→   compile: {                                                                →       enode: "enode://ac6b1096....9373ef@[::]:21000?discport=0",
→     lll: function(),                                                        →       id: "ac6b1096ca56b9f6d00....373ef",
→     serpent: function(),                                                    →       ip: "::",
→     solidity: function()                                                    →       listenAddr: "[::]:21000",
→   },                                                                        →       name: "Geth/v1.7.2-stable-94e1e31e/linux-amd64/go1.9.5",
→   defaultAccount: undefined,                                                →       ports: { discovery: 0, listener: 21000 },
→   defaultBlock: "latest",                                                   →       protocols: { eth: {...} }
→   gasPrice: 0,                                                              →     },</b>
→   hashrate: 0,                                                              →     peers: [],
→   mining: false,                                                            →     ...
→   pendingTransactions: [],                                                  →   },
→   protocolVersion: "0x3e",                                                  →   ...
→   syncing: false,                                                           →   debug: { ...  },
→   call: function(),                                                         →   eth: {
→   contract: function(abi),                                                  →     accounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],
→   estimateGas: function(),                                                  →     blockNumber: 5,
→   filter: function(options, callback, filterCreationErrorCallback),         →     coinbase: "0xed9d02e382b34818e88b88a309c7fe71e65f419d",
→   getAccounts: function(callback),                                          →     ...
→   getBalance: function(),                                                   →     gasPrice: 0,
→   getBlock: function(),                                                     →     hashrate: 0,
→   getBlockNumber: function(callback),                                       →     pendingTransactions: [],
→   getBlockTransactionCount: function(),                                     →     syncing: false,
→   getBlockUncleCount: function(),                                           →     call: function(),
→   getCode: function(),                                                      →     getAccounts: function(callback),
→   getCoinbase: function(callback),                                          →     getBalance: function(),
→   getCompilers: function(),                                                 →     getBlock: function(),
→   getGasPrice: function(callback),                                          →     getBlockNumber: function(callback),
→   getHashrate: function(callback),                                          →     getBlockTransactionCount: function(),
→   getMining: function(callback),                                            →     ...
→   getPendingTransactions: function(callback),                               →     getStorageAt: function(),
→   getProtocolVersion: function(callback),                                   →     getTransaction: function(),
→   getRawTransaction: function(),                                            →     getTransactionCount: function(),
→   getRawTransactionFromBlock: function(),                                   →     getTransactionFromBlock: function(),
→   getStorageAt: function(),                                                 →     getTransactionReceipt: function(),
→   getSyncing: function(callback),                                           →     ...
→   getTransaction: function(),                                               →   },
→   getTransactionCount: function(),                                          →   isIBAN: undefined,
→   getTransactionFromBlock: function(),                                      →   miner: {  ...  },
→   getTransactionReceipt: function(),                                        →   net: { ...  },
→   getUncle: function(),                                                     →   personal: {
→   getWork: function(),                                                      →     listAccounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],
→   iban: function(iban),                                                     →     listWallets: [{
→   icapNamereg: function(),                                                  →         accounts: [...],
→   isSyncing: function(callback),                                            →         status: "Unlocked",
→   namereg: function(),                                                      →         url: "keystore:///.../keystore/key1"
→   resend: function(),                                                       →     }],
→   sendIBANTransaction: function(),                                          →     ...
→   sendRawTransaction: function(),                                           →   },
→   sendTransaction: function(),                                              →   ..
→   sign: function(),                                                         →   shh: { ...  },
→   signTransaction: function(),                                              →   txpool: { ... },
→   submitTransaction: function(),                                            → }
→   submitWork: function()
→ }
</pre>
</td>
<td>
  Disk Space
<pre xxxsmall zoom>
<a href="https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs/826#826">REF</a>
Last Update: May 14th, 2018 / Block ~ 5_600_000
Geth (Go) 1.8.3 Ubuntu 16.4 LTS,  VPS + SSD | Parity (Rust)
--------------------------------------------+--------------------------------------------
Client / Mode    | Block Number |Disk Space | Client / Mode      |Block Number|Disk Space
=================|==============|========== | ===================|============|==========
geth light       | 5_600_000    |363M       | parity light       |5_600_000   | 89M
geth fast full   | 5_600_000    |142G       | parity warp fast   |5_600_000   | 82G
geth full full   | ?_???_??? [1]|239G + [1] | parity full fast   |5_600_000   | 78G
geth full archive| 4_980_000 [2]|671G       | parity full archive|5_600_000   |1.1T
                                            |                                      
[1] disk was full, I wasn't able to repeat  |
    this sync mode                          |
[2] I didn't manage to fully sync           |
    within 6 weeks, unfortunately.          |
--------------------------------------------+--------------------------------------------
</pre>
</td>
<td colsep> </td>
<td colsep>Pantheon</td>
<td>
<a xsmall TODO href="https://docs.pantheon.pegasys.tech/en/stable/">Pantheon</a>
<pre xxxsmall zoom>
What is Pantheon?

Pantheon is an open-source Ethereum client developed under the Apache 2.0 
license and written in Java. It runs on the Ethereum public network, private 
networks, and test networks such as Rinkeby, Ropsten, and Görli. Pantheon 
implements Proof of Work (Ethash) and Proof of Authority (Clique) consensus 
mechanisms.

You can use Pantheon to develop enterprise applications requiring secure, 
high-performance transaction processing in a private network.

Our roadmap includes Pantheon with privacy features, alternative consensus 
mechanisms, and other enterprise features.
</pre>


</td>


</tr>
</table>
<br/> 
  Enterprise Integration (connect to external IT systems)
<table>
<tr>
<td>
   Integration with Apache Camel ESB: <a href="https://github.com/bibryam/camel-web3j">Connector@GitHub</a>,
   <a href="https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43">REF</a>
<pre xxxsmall zoom bgorange>
REF: https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43
____________________________________________________________________________________________

<b>APPLICATIONS</b>

  DAPPS            +------------------+  +-----------------------------+
                   |   Applications   |  |  Explorers, Monitoring & BI |
                   +------------------+  +-----------------------------+

  INFRA CONTRACTS  +--------+  +----+*4 +----------+    +--------+  +------------+
  & STANDARS       |IDENTITY|  |RBAC|   |NETWORK   |    |TOKEN   |  |ETHEREUM    |
                   +--------+  +----+   |GOVERNANCE|    |STANDARS|  |NAME SERVICE|
                                        +----------+    +--------+  +------------+
____________________________________________________________________________________________

<b>TOOLING</b>

  Permisions &     +-------+2  +--------------+2     +---+3   +-----------------------------+3
  Credentials      |WALLETS|   |KEY MANAGEMENT|      |HSM|    |PERMISSIONING/AUTHENTICATION |
                   +-------+   +--------------+      +---+    +-----------------------------+

  INTEGRATION&     +-----------+2                    +--------------------------+3 +--------+3
  DEPLOYMENT       |INTEGRATION|                     |ENTERPRISE MANAGEMENT SYS.|  |ORACLES |
  TOOLS            |LIBRARIES  |                     +--------------------------+  +--------+
                   +-----------+                              

                   +--------+2   +-----------+2
  CLIENT           |JSON|RPC|    |INTER-CHAIN|
  INTERFACES       +--------+    +-----------+
____________________________________________________________________________________________

<b>PRIVACY</b>
                  +--------+2    +--------------------+3  +-------------------+3
                  |ON|CHAIN|     |PRIVATE|TRANSACTIONS|   |OFF+CHAIN          |
                  +--------+     +--------------------+   |(TRUSTED EXECUTION)|
                                                          +-------------------+   
____________________________________________________________________________________________

<b>SCALING</b>
                  +-----------------+2       +------------------+2
                  |ON+CHAIN(LAYER 2)|        |OFF+CHAIN(COMPUTE)|
                  +-----------------+        +------------------+

____________________________________________________________________________________________
<b>CORE BLOCKCHAIN</b>

  STORAGE/LEDGER  +------------+      +--------+      +---------+2       +-------------+3
                  |ON+CHAIN    |      |ON+CHAIN|      |OFF+CHAIN|        |ON+CHAIN     |
                  |PUBLIC STATE|      |STORAGE |      |STORAGE  |        |PRIVATE STATE|
                  +------------+      +--------+      +---------+        +-------------+

  EXECUTION       +---+         +-----+2     +-----------+2      +----------+3
                  |EVM|         |SYNC |      |PRECOMPILED|       |TRUSTED   |
                  +---+         +-----+      | CONTACTS  |       | EXECUTION|
                                             +-----------+       +----------+

  CONSENSUS       +---------+             +---------+3
                  |PUBLIC   |             |PRIVATE  |
                  |CONSENSUS|             |CONSENSUS|
                  +---------+             +---------+
____________________________________________________________________________________________
<b>NETWORK</b>

   NETWORK         +------+2         +---------------+3
   PROTOCOL        |DEVP2P|          |ENTERPRISE P2P |
                   +------+          +---------------+

1: Yellow Paper
2: Public     Ethereum
3: Enterprise Ethereum
4: Solidity libraries like Zeppelin allows for RBAC
   fine-grained access into the on-chain smart-contracts
   Standard RBAC in EEA/Quorum expected for mid/late 2019
   
</pre>
  Example Oracle
<pre xxxsmall zoom>
@Override
public void configure() throws Exception {
    from("web3j://http://127.0.0.1:7545?operation=ETH_LOG_OBSERVABLE&topics=" + topics)
        .to("log:com.ofbizian.CallbackGetBTCCap?level=INFO&showAll=true")

        .setHeader(OPERATION, constant(ETH_SEND_TRANSACTION))
        .setHeader(FROM_ADDRESS, constant("0xc8CDceCE5d006dAB638029EBCf6Dd666efF5A952"))
        .setHeader(TO_ADDRESS, constant("0x484982345fD584a0a16deC5F9ba330f6383af3d9"))
        .process(new Processor() {
            public void process(Exchange exchange) throws Exception {
                int random = rand.nextInt(50);
                Function function = new Function("setBTCCap", Arrays.<Type>asList(
                        new Uint(BigInteger.valueOf(btcPrice))), Collections.<TypeReference<?>>emptyList());
                exchange.getIn().setHeader(DATA, FunctionEncoder.encode(function));
            }
        })
        .to("web3j://http://127.0.0.1:7545");
}
</pre>


</td>
<td>
  <span TODO>EXTERNAL STORAGE (IPFS, Maidsafe, SWARN,...)</span>
<!--
TODO: Compare with alternative Storage "providers": IPFS , Maidsafe, Storj
- IPFS is just a protocol like http. It is unmotivated (don't have tokens).
- Eris is permissioned blockchain thing and use IPFS underneath.
- Storj, SAFE Network, Sia and Filecoin: motivated storage networks with different underlying protocols and design decisions.
- Swarm is an organizational idea. A philosophical structure.
  ""serverless hosting incentivised peer-to-peer storage and content distribution""
  ""From the end user's perspective, Swarm is not that different from WWW,
    except that uploads are not to a specific server. The objective is to peer-to-peer
    storage and serving solution that is DDOS-resistant, zero-downtime, fault-tolerant
    and censorship-resistant as well as self-sustaining due to a built-in incentive
    system which uses peer to peer accounting and allows trading resources for payment.
    Swarm is designed to deeply integrate with the devp2p multiprotocol network layer
    of Ethereum as well as with the Ethereum blockchain for domain name resolution, 
    service payments and content availability insurance. """"""

""""""Two major features of swarm that sets it apart from other decentralised distributed storage solutions (bittorent, zeronet, IPFS) are 'upload and disappear' and the incentive system. The former refers to fact that Swarm does not only serve content, but it also provides a cloud storage service. Unlike related systems, you do not only publish the fact you host content, but there is a genuine sense in which you can just upload stuff to the swarm and potentially disappear (drop off as a node, disconnect or just operate without storage entirely) right away. Swarm aspires to be the generic storage and delivery service catering for all usecases ranging from serving low latency realtime interactive web applications as well as acting as guaranteed persistent storage for rarely used content. The incentive system makes sure that participating nodes following their rational self interest nontheless converge on an emergent swarm behaviour that is beneficial for the entire system as well as economically self-sustaining. In particular, it allows nodes in the network to pool their bandwidth and storage resources in the most efficient way to collectively provide services. """""""
here are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account.
-->

  </p>

  <hr xxxsmall />
  <a TODO href="http://ethereumj.io/blog/2015/09/09/friendly-ether-bot/">External Inputs (Oracles)</a>
  <a href="https://azure.microsoft.com/en-us/blog/cryptletsdd/">MS.Bletchley Cryplets</a>
</td>
<td>
 <a href="https://github.com/ethereum/wiki/wiki/Whisper">Whisper</a> Dapp Protocol
<pre xxxsmall zoom>

- communication protocol to communicate DApps with each other
  for off-chain Data.

USE CASE:
    DApps that need to publish small amounts of information to each other and 
have the publication last some substantial amount of time. For example, a 
currency exchange DApp may use it to record an offer to sell some currency at 
a particular rate on an exchange. In this case, it may last anything between 
tens of minutes and days. The offer wouldn't be binding, merely a hint to get 
a potential deal started.

    DApps that need to signal to each other in order to ultimately 
collaborate on a transaction. For example, a currency exchange DApp may use 
it to coordinate an offer prior to creating one (or two, depending on how the 
exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general 
communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network 
traffic analysis) comms to two correspondents that know nothing of each other 
but a hash. This could be a DApp for a whistleblower to communicate to a 
known journalist exchange some small amount of verifiable material and 
arrange between themselves for some other protocol (Swarm, perhaps) to handle 
the bulk transfer.
</pre>

  <span TODO>Whisper Alternatives: </span>
<pre xxxsmall zoom>
"Message Contract" and "Telehash"
</pre>
</td>
<td>
 <a href="https://github.com/Arachnid/etherquery">EtherQuery</a>
<pre xxxsmall zoom>

Custom ethereum client that uploads blockchain data to BigQuery

</pre>
</td>
</tr>
</table>
<br/>

<br/>
  Quorum
<a href="https://go-quorum.slack.com/">Slack Chat</a> , 
<a href="https://github.com/jpmorganchase/quorum/wiki">WiKi</a> ,
<a href="https://github.com/jpmorganchase/quorum/tree/master/docs">GitHub/jpmorganchase/quorum</a>,
<a href="https://hub.docker.com/u/quorumengineering/">Official Docker Images</a>

<table>
<tr>
<td>
  <a href="https://github.com/jpmorganchase/quorum">Quorum Ethereum Extensions</a>
<pre xxxsmall zoom>
 - Transaction and contract privacy
 - Multiple voting-based consensus mechanisms
 - Network/Peer permissions management
 - Higher performance
</pre>

<a href="https://github.com/blk-io/quorum-examples">5nodesRTGS</a> example: 
<pre xxxsmall zoom>
  Starts up a set of 5 nodes that simulates a Real-time Gross
  Setlement environment with 3 banks, one regulator (typically
  a central bank) and an observer that cannot access the private data.
</pre>

  External Links:
  <ul xxxsmall zoom>
  <li><a href='https://github.com/jpmorganchase/quorum/tree/master/docs'>docs@GitHub</a> Whitepaper (PDF), Design, Privacy, Running, API</li>
  <li><a href="https://github.com/jpmorganchase/quorum/releases">Releases</a></li>
  <li><a href='https://github.com/jpmorganchase/quorum/wiki'>Wiki@GitHub</a></li>
  <li><a href='https://www.jpmorgan.com/country/ES/en/Quorum'>J.P.Morgan Quorum Home Page</a></li>
  <li TODO><a href='https://github.com/jpmorganchase/quorum-examples/tree/master/examples/7nodes'>7nodes Example</a>
    configures 7 nodes, each with their own PrivateTransactionManager
  </li>
  <li><a TODO href="https://github.com/jpmorganchase/quorum/blob/master/docs/api.md">Quorum API</a></li>
  <li><a href="https://github.com/jpmorganchase/quorum/wiki/Product-Roadmap">Roadmap</a></li>
  </ul>
Quorum Contract Design Considerations
<pre xxxsmall zoom>
- Private contracts cannot update public contracts.
  (not all participants will be able to execute a private contract,
  and so if that contract can update a public contract, then each
  participant will end up with a different state for the public contract.
- Once a contract has been made public, it can't later be made private.
  You DO need to delete from the blockchain and create a new private contract
</pre>
  <span TODO xsmall>Supported Consensus</span>
<pre TODO xxxsmall zoom>
- POA :
- RAFT:
- IBFT: (Istambul) Bizantine Fault Tolerant
</pre>


</td>
<td>
  Architecture
  <hr xxxsmall />
  TX Manager
<pre xxxsmall zoom>
  - Quorum’s Transaction Manager is responsible for Transaction privacy. 
     It stores and allows access to encrypted transaction data, exchanges encrypted
     payloads with other participant's Transaction Managers but does not have 
     access to any sensitive private keys. It utilizes the Enclave for 
     cryptographic functionality (although the Enclave can optionally be 
     hosted by the Transaction Manager itself.)

  - """To send a private transaction, a PrivateTransactionManager must be 
     configured. This is the service which transfers private payloads to 
     their intended recipients, performing encryption and related operations 
     in the process."""
  - The Transaction Manager is restful/stateless and can be load balanced easily.

<a href='https://github.com/jpmorganchase/quorum/wiki/Transaction-Processing'>Transaction Processing</a>
  - 'Public Transactions' and 'Private Transactions' are a notional concept 
    only and Quorum does not introduce new Transaction Types, but rather, the 
    Ethereum Transaction Model has been extended to include an optional 
    '<b orange>privateFor</b>' parameter (the population of which results in a Transaction 
    being treated as private by Quorum) and the Transaction Type has a new 
    IsPrivate method to identify such Transactions.
  - <b orange>privateFor</b> can take multiple addresses in a comma separated list.
  - Private Transactions payload is only visible to the network
    participants specified in the <b orange>privateFor</b> parameter of the TX. 
  - Quorum Node sets the Transaction_Signature.V = 37 or 38 
    (as opposed to 27 or 28)

  - prior to propagate the TX to the rest of the network,
    mining/sender node replaces the original TX-Payload with
    a the hash of the encrypted Payload that received from the
    secure enclave implementation (Crux, Constellation,..).
    Participants involved in the <b orange>privateFor</b> TX
    will have the encrypted payload associated to the hash
    within their secure enclave.

  Example priv.TX A←→B:<span bgorange>
Party A and B belongs to TX AB, whilst C doesn't
Party A → A.Node: TX + payload 
                TX.<b orange>privateFor</b> [ pub.key A, pub.keyB]
A.Node → A TX Manager: Request to store TX payload
A_TX_Manager → Enclave: - Validate sender with A priv.key

Enclave → Enclave:  performs TX conversion (encrypt payload)
                    - generating [sym.key, random Nonce]
                    - encrypting TX.payload+Nonce with sym.key
                    - generate hash  SHA3-512 (encrypted payload)
                    - iterate through TX recipients [A, B] encrypting 
                      sym.key with recipient's pub.key (PGP encryption)
A_TX_Manager ← Enclave: encrypted payload, SHA3-512 hash, encrypted keys
A_TX_Manager → A_TX_Manager: store encrypted payload, encrypted sym.key
                             (using hash as index)
A_TX_Manager → B_TX_Manager: (via HTTPS) hash, encrypted (payload, sym.key) 
A_TX_Manager ← B_TX_Manager: Ack 
A.Node ←  A_TX_Manager: SHA3-512 (encrypted payload) 
A.Node →  A.Node: - Replace TX.payload with TX.sha3-512
                  - changes TX.V to 37 or 38 (indicates other nodes that 
                    hash represents priv.TX)
A_TX_Manager → Network:  (Ethereum P2P protocol) TX encrypted payload
Network → Network: +block containing TX AB
Network → Node N: block containing TX AB
Node N → Node N: Try validate TX in block
                 - Recognise TX.V is 37 or 38 
Node N → Node N TX_Manager: Do nodes holds private TX?
Node N ← Node N TX_Manager: YES  (continue validation) 
                         or "NotARecipient" (skip to next TX in block)
A,B Node → A,B enclave: TX payload
           A,B enclave: 1. validates signature
                        2. decrypts sym.key  private key that is held
                           in The Enclave, decrypts the Transaction Payload using
                           the now-revealed symmetric key and returns the decrypted
                           payload to the Transaction Manager.
A,B TX_Manager → A,B EVM: send decrypted payload 
A,B EVM → A,B EVM: contract code execution
                   Update Quorum Node's Private StateDB only. 
                   NOTE: code discarded once executed.
</pre>
  Secure Enclave
<pre xxxsmall zoom>
 - Distributed Ledger protocols typically leverage cryptographic techniques 
   for transaction authenticity, participant authentication, and historical 
   data preservation (i.e. through a chain of cryptographically hashed data
   .) In order to achieve a separation of concerns, as well as to provide 
   performance improvements through parallelization of certain crypto-
   operations, much of the cryptographic work including symmetric key 
   generation and data encryption/decryption is delegated to the Enclave.
 - The Enclave works hand in hand with the Transaction Manager to 
   strengthen privacy by managing the encryption/decryption in an isolated 
   way. It holds private keys and is essentially a “virtual HSM” isolated 
   from other components.
 - Different implementations of the enclave exists:
   - Constellation: Original, writen in Haskell
   - Crux         : Golang based, compatible with Constellation
</pre>
<img xxxsmall zoom src="https://raw.githubusercontent.com/jpmorganchase/quorum-docs/master/images/QuorumTransactionProcessing.JPG" />
</td>
<td>
  <a TODO xsmall href="https://github.com/jpmorganchase/tessera">Tessera</a> (EE TX Manager)
<pre xxxsmall zoom>
- Enterprise Implementation of Quorum's transaction manager
- stateless Java system that is used to enable the encryption, 
  decryption, and distribution of private transactions for Quorum.

Each Tessera node:
  - Generates and maintains a number of private/public key pairs
  - Self manages and discovers all nodes in the network (i.e. their
    public keys) by connecting to as few as one other node
  - Provides Private and Public API interfaces for communication:
    Private API - This is used for communication with Quorum
    Public  API - This is used for communication between Tessera
                  peer nodes
  - Provides two way SSL using TLS certificates and various trust
    models like Trust On First Use (TOFU), whitelist, certificate 
    authority, etc.
  - Supports IP whitelist
  - Connects to any SQL DB which supports the JDBC client

<a TODO href="https://github.com/jpmorganchase/tessera/wiki/Interface-&-API">Tessera Wiki</a>
</pre>


</td>
<td>
  <a xsmall href='https://github.com/jpmorganchase/constellation'>Constellation secure enclave</a>,
<pre xxxsmall zoom>
  - <a href='https://github.com/jpmorganchase/quorum/blob/master/docs/privacy.md'>REF: Privacy.md, Quorum+Constellation</a>
  - self-managing, peer-to-peer network of "key server+PGP+MTAs" nodes
  - Constellation is not blockchain-specific, and potentially applicable
     in many other types of applications
  - Constellation's current primary application is to implement the 
    "privacy engine" for Quorum Private transactions (TX with a flag indicating 
    its pretended privacy and the addressable identifier )
  - Hosts a number of Private/Public key pair Curve25519 - NaCl-
  - Automatically discovers other nodes on the network after synchronizing 
    with as little as one other host.
  - Synchronizes a directory of public keys mapped to recipient hosts with 
    other nodes on the network.
  - Exposes public API allowing other nodes to send encrypted bytestrings to 
    your node, and to synchronize, retrieving information about the nodes 
    that your node knows about.
  - Exposes a private API which:
    - Allows you to send a bytestring to one or more public keys, returning 
      a content-addressable identifier. This bytestring is encrypted 
      transparently and efficiently (at symmetric encryption speeds) before 
      being transmitted over the wire to the correct recipient nodes (and only 
      those nodes.) The identifier is a hash digest of the encrypted payload 
      that every receipient node receives. Each recipient node also receives a 
      small blob encrypted for their public key which contains the Master Key 
      for the encrypted payload.
    - Allows you to receive a decrypted bytestring based on an identifier. 
      Payloads which your node has sent or received can be decrypted and retrieved 
      in this way.

    - Exposes methods for deletion, resynchronization, and other management functions.

  - Supports a number of storage backends including LevelDB, BerkeleyDB, SQLite,
    and Directory/Maildir-style file storage suitable for use with any FUSE 
    adapter, e.g. for AWS S3.

  - Uses mutually-authenticated TLS with modern settings and various trust 
    models including hybrid CA/tofu (default), tofu (think OpenSSH), and 
    whitelist (only some set of public keys can connect.)

  - Supports access controls like an IP whitelist.
</pre>

  Constellation Installation
<pre xxxsmall zoom>
Pre-Install supporting libraries:
  Ubuntu : $ apt-get install libdb-dev libleveldb-dev libsodium-dev zlib1g-dev libtinfo-dev
  Red Hat: $ dnf install libdb-devel leveldb-devel libsodium-devel zlib-devel ncurses-devel
  MacOS  : $ brew install berkeley-db leveldb libsodium

Install
  Alt 1: Precompiled binaries:
  <a href="https://github.com/jpmorganchase/constellation/releases">Release download</a>
  
  Alt 2: from source
    - First time only: Install Stack:
      Linux: $ curl -sSL https://get.haskellstack.org/ | sh
      MacOS: $ brew install Haskell-stack
    - First time only: run stack setup to install GHC, the Glasgow Haskell Compiler
    - Run stack install

Post-install: Generating key pair "node":
  $  constellation-node --generatekeys=node # generated keys can be locked with passwd
</pre>

Running
<pre xxxsmall zoom>
- can be run as stand-alone daemon via constellation-node, or 
  imported as a Haskell library, allowing to implement custom
  storage and encryption logic.

$ constellation-node "path_to_config_file" # or use ENV.VAR
# More info at <a href="https://github.com/jpmorganchase/quorum/blob/master/private/constellation/node.go">quorum/private/constellation/node.go</a>
</pre>

Configuration File Format
<pre xxxsmall zoom>
<a href="https://github.com/jpmorganchase/constellation/blob/master/sample.conf">REF</a>
url = "http://127.0.0.1:9001/"
port = 9001
workdir = "data"
socket = "constellation.ipc"
othernodes = ["http://127.0.0.1:9000/"]
publickeys = ["foo.pub"]
privatekeys = ["foo.key"]
alwayssendto = []
storage = "dir:storage"
verbosity = 1
tls = "strict"
tlsservercert = "tls-server-cert.pem"
tlsserverchain = []
tlsserverkey = "tls-server-key.pem"
tlsservertrust = "tofu"
tlsknownclients = "tls-known-clients"
tlsclientcert = "tls-client-cert.pem"
tlsclientchain = []
tlsclientkey = "tls-client-key.pem"
tlsclienttrust = "ca-or-tofu"
tlsknownservers = "tls-known-servers"</pre>
</pre>
</td>
<td>
  <span xsmall>
  <a href="https://medium.com/web3labs/announcing-crux-a-secure-enclave-for-quorum-61afbfdb79e4">Crux secure enclave</a>
  </span>
<pre xxxsmall zoom>
- dropin Constellation replacement
- secure enclave  written in Golang (Constellation is written in Haskell)
- <a href="https://github.com/blk-io/quorum-examples">7 nodes example deployment with Crux</a>
- LevelDB used as storage (same as geth). 
  BerkeleyDB bindings available for compatibility with
  existing Constellation instance.

<b>Build</b>
$ git clone https://github.com/blk-io/crux.git
$ cd crux
$ make setup && make
$ ./bin/crux

<b>Pre-setup</b>
generate new keys using:
$ crux <b>--generate-keys</b> myKey

<b>Ussage</b>
run it like: (almost identical to Constellation node):
$ crux --url=http://127.0.0.1:9001/ \          | crux --help reference:
       --port=9001 --workdir=crux \            |     crux.config              Optional config file
       --publickeys=tm.pub \                   |     --alwayssendto string    public key List  for nodes to send all transactions to
       --privatekeys=tm.key \                  |     --berkeleydb             switch to Berkeley DB for compatibility with Constellation data store [experimental]
       --othernodes=https://127.0.0.1:9001/    |     --generate-keys string   Generate a new keypair
                                               |     --othernodes string      "Boot nodes" used to discover the network
                                               |     --port int               The local port to listen on (default -1)
                                               |     --privatekeys string     Private keys hosted by this node
                                               |     --publickeys string      Public keys hosted by this node
                                               |     --socket string          IPC socket to create for access to the Private API (default "crux.ipc")
                                               |     --storage string         Database storage file name (default "crux.db")
                                               |     --url string             The URL to advertise to other nodes (reachable by them)
                                               |     --verbosity int          Verbosity level of logs (default 1)
                                               |     --workdir string         The folder to put stuff in (default: .) (default ".")
</pre>
</td>

<td>
  <a TODO href='https://github.com/jpmorganchase/quorum/wiki/Getting-Set-Up'>Getting-Set-Up</a>
<pre xxxsmall zoom>
- Using Quorum requires installing, configuring 
  and running 'Quorum Node' + 'Constellation server'
- Manually set up Quorum: 
  - key generation :
  - genesis block  :
  - constellation configuration:
</pre>

  <a xsmall TODO href="https://github.com/jpmorganchase/quorum/wiki/Getting-Set-Up">Source Build:</a> 
<pre xxxsmall zoom>
$ git clone https://github.com/jpmorganchase/quorum.git
$ cd quorum
$ make all # Binaries output: ./build/bin
$ make test
</pre>
  <a xsmall TODO href="https://github.com/jpmorganchase/quorum/wiki/Getting-Set-Up">source2(docker)image:</a> 
<pre xxxsmall zoom>
Build (just first time + updates):
$ git clone https://github.com/agriessel/quorum-docker
$ cd quorum-docker
$ docker build -t quorum .

Run
$ docker run -ti --name quoruminstance quorum bash
</pre>

  Initialize 7 Nodes, start/stop
<pre xxxsmall zoom>
root@7cb755d39893:/# cd /quorum-examples/examples/7nodes/
root@7cb755d39893:/quorum-examples/examples/7nodes# ./init.sh
root@7cb755d39893:/quorum-examples/examples/7nodes# ./start.sh
root@7cb755d39893:/quorum-examples/examples/7nodes# ./stop.sh
</pre>
  <a TODO href="https://github.com/jpmorganchase/quorum/blob/master/docs/running.md">Running Quorum</a>
  <hr xxxsmall />
  <a TODO href='https://github.com/jpmorganchase/quorum/wiki/Using-Quorum'  >Using Quorum</a><br/>


  (Optional) Setup Bootnode
<pre xxxsmall zoom>
Bootnode: Node that all other nodes will first connect to find other peers
generate the key (just once, first time)
$ bootnode <b orange>-genkey tmp_file.txt</b> # ← will start bootnode with enode address and
                                     generate a key inside a "tmp_file.txt" file

(In order to later restart bootnode with same key (== same enode url):
$ bootnode <b orange>-nodekey tmp_file.txt</b>
or 
$ bootnode <b orange>-nodekeyhex 77bd...e510</b> (# ← Key from tmp_file.txt)
</pre>
</td>

</tr>
</table>

<table>
<tr>
<td>
  <a href="https://github.com/ethereum/EIPs/issues/650">(EIP) Istanbul BFT Consensus</a>
<pre xxxsmall zoom>
Deeply inspired by<a href="https://github.com/ethereum/EIPs/issues/225">Clique POA (Probe of Authority)</a>, also inspired by Hyperledger's SBFT, Tendermint, HydraChain, and NCCU BFT.

----------------------------------------------------------------------------------------
Validator  : Block validation participant.
Proposer   : A block validation participant that is chosen
             to propose block in a consensus round.
Round      : Consensus round. A round starts with the proposer creating
             a block proposal and ends with a block commitment or round change.
Proposal   : New block generation proposal which is undergoing consensus processing
Sequence   : Sequence number of a proposal. A sequence number should be greater than
             all previous sequence numbers. Currently each proposed block height is its
             associated sequence number.
Backlog    : The storage to keep future consensus messages due to the async nature of the
             network.
Round state: Consensus messages of a specific sequence and round, including pre-prepare
             message, prepare message, and commit message.
Consensus
      proof: The commitment signatures of a block that can prove the block has gone
             through the consensus process.
Snapshot   : The validator voting state from last epoch
----------------------------------------------------------------------------------------

-- VALIDATION ROUND LOOP ---
[validators] → [validators]: enter validator.state "NEW ROUND"
[validators] → [validators]: pick one (round-robin by default or sticky) as the proposer
proposer → proposer : propose new block proposal 
proposer → network  : broadast block-proposal + PRE-PREPARE
network  → [validators]: "forward" block-proposal + PRE-PREPARE
[validators] → [validators]: enter validator.state PRE-PREPARED 
[validators] → network: broadcast PREPARE message
                        (make sure all validators are working on the
                         same sequence and the same round)
network → [validators]: forward PREPARE
[validators] → [validators]: Wait until (2F + 1) PREPARE messages are received
                             then enter validator.state "PREPARED"
[validators] → network: broadcasts "COMMIT" message.
                        (inform peers that validator accepts proposed block
                        and is going to insert the block to the chain)
[validators] → [validators]: wait for 2F + 1 of COMMIT messages 
                             enter validator.state "COMMITTED" 
                             insert the block to the chain
                             enter validator.state "FINAL COMMITTED" 
[validators] → [validators]: wait for 2F + 1 of "ROUND CHANGE" messages 
----------------------------------------------------------------------------------------
Validator list voting (From Clique EIP):

</pre>

Running Istanbul BFT validators&amp;nodes: 
<pre xxxsmall zoom>
(similar to running the official node in a private chain)

Initialize the data folder as (First time only): 
$ geth  --datadir "/eth" init "/eth/genesis.json"

Start-up validators:
    $ geth --datadir "/eth" --mine --minerthreads 1 --syncmode "full"

Start-up regular nodes:
    $ geth --datadir "/eth"


ISTANBUL OPTIONS:
  --istanbul.requesttimeout value  round in milliseconds (default: 10000)
  --istanbul.blockperiod value     Default min.difference between two consecutive
                                   block's timestamps in seconds (default: 1)
</pre>

NODEKEY AND VALIDATOR:
<pre xxxsmall zoom>
To be a validator, a node needs to meet the following conditions:
- Its account (nodekey-derived) address MUST be listed in extraData's validators section
- validator nodekey is used as priv.key to sign consensus messages
</pre>

genesis.json
<pre xxxsmall zoom>
- config field is required, and the pbft subfield must present. Ex:

{
  "config": {
    "chainId": 2016,
    "istanbul": { "epoch": 30000, "policy" 0 }
  },
  "timestamp": "0x0",
  "parentHash": "0x000...000",
  "extraData": "0x0000...000f89af85494475...aad0312b84100000...0c0",
  "gasLimit": "0x47e7c4",
  "mixhash": "0x6374...6e6365",
  "coinbase": "0x333...33333",
  "nonce": "0x0",
  "difficulity": "0x0",
  "alloc": {}
}

<a href="https://github.com/getamis/Istanbul-tools">istanbul-tools repo</a> contains some extraData tools to help developers to manually generate genesis.json

Encoding:
Before encoding you need to define a toml file with vanity and validators fields
to define proposer vanity and validator set. Please refer to example.toml for
the example. The output would be a hex string which can be put into extraData 
field directly.  Command:
  $ istanbul encode --config ./config.toml

Decoding:
Use --extradata option to give the extraData hex string. The output would show
the following if presents: vanity, validator set, seal, and committed seal.  Command:

  $ istanbul decode --extradata <EXTRA_DATA_HEX_STRING>
</pre>

Background
<pre xxxsmall zoom>
The idea of implementing a byzantine fault tolerance (BFT) consensus came 
from the challenges we faced while building blockchain solutions for banks. 
We chose ethereum as the baseline protocol mostly because of its smart 
contract capability. However, the built-in consensus, proof of work or ethash
, is not the ideal choice when settlement finality and minimum latency is required.

Banking systems tend to form a private chain or consortium chain to run their 
applications. PBFT is ideal for these settings. These environments require a 
higher degree of manageability and higher throughput. In terms of scalability
, validator scalability is not required. Many of the decentralization 
benefits of PoW in public chains become drawbacks in a private/consortium 
chain. On the other hand, designated validators in a PBFT environment maps 
well to private/consortium chains.
</pre>
</td>
<td colsep></td>

<td>
  EEA Ethereum Network Protocol Sublayer (enodes, ...)
<pre xxxsmall zoom>
- Nodes MUST be identified and advertised using the 
  Ethereum <a href="https://github.com/ethereum/wiki/wiki/enode-url-format">enode URL format</a>
- Implementations SHOULD use the <a href="https://github.com/ethereum/wiki/wiki/%C3%90%CE%9EVp2p-Wire-Protocol">DEVp2p Wire Protocol</a>
  for messaging between nodes to establish and maintain a 
  communications channel for use by higher layer protocols.

- These higher layer protocols are known as capability protocols

- The <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol">Ethereum-Wire-Protocol</a> defines the capability 
  protocols for messaging between Ethereum client nodes to 
  exchange status, including block and TX info.

- messages are sent and received over an already 
  established DEVp2p connection between nodes. 

- Implementations SHOULD support, at a minimum, 
  Ethereum-Wire-Protocols eth/62 and eth/63

- Implementations MAY add new protocols or extend 
  existing Ethereum protocols

- To minimize the number of point -to-point connections 
  needed between private nodes , some private nodes 
  SHOULD be capable of relaying private TX data to
  multiple other private nodes.
</pre>
</td>

<td>
   <a href="https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md">Raft-based consensus</a>
<pre xxxsmall zoom>
$ geth --raft 
NON  BYZANTINE FAULT TOLERANCE with next advantages:
  - faster blocktimes (milliseconds vs seconds)
  - absence of forking
  - Compared with QuorumChain, does NOT "unnecessarily" create empty blocks

+-----------+----------------+-------------------------------------------------+
|Transport  | Ethereum p2p   |  Raft (over HTTP)                               |
|Layer      |                |                                                 |
+-----------+----------------+-------------------------------------------------+
|DATA TYPE  | communicate TXs|  communicate full blocks                        | 
+-----------+----------------+-------------------------------------------------+
|config     |                | Minting blocks frequency:  &lt;= 50ms ,         |
|params     |                |    (--raftblocktime (millisecs)                 |
|           |                | --raftport newTCPPort default to 50400 )        |
|           |                |                                                 |
|           |                |  static-nodes.json: required                    |
|           |                |  - initial list of nodes in the cluster         |
|           |                |  - order *MUST BE EQUALS ACROSS PEERS*          |
|           |                |                                                 |
|           |                | - ID URIs must include a raftport querystring   |
|           |                |   param specifying the raft port for each peer: |
|           |                |   e.g.                                          |
|           |                |    enode://abcd@127.0.0.1:30400?raftport=50400  |
+-----------+----------------+-------------------------------------------------+

removing a node from the cluster from the JS console:
# raft.removePeer(raftIdx)
                  ^
                  "1-indexed" index in the static peer list

Attaching a node to the cluster from the JS console:

# raft.addPeer("enode://abcd@127.0.0.1:30400?raftport=50400")
Then (outside the JS console) start the new geth node with the
flag --raftjoinexisting RAFTID in addition to --raft
</pre>
</td>  
<td colsep> </td>  
<td>
  JS client <code>privateFor</code> example
<pre xxxsmall zoom >
"privateFor": indicates the list of constellation (vs Ethereum) public keys
              of TX recipient. If not empty the TX will be private.
web3.eth.defaultAccount = eth.accounts[0];
var simpleSource = 'contract simplestorage { ... }'
var simpleCompiled = web3.eth.compile.solidity(simpleSource);
var simpleRoot = Object.keys(simpleCompiled)[0];
var simpleContract = web3.eth.contract(
    simpleCompiled[simpleRoot].info.abiDefinition);
var simple = simpleContract.new(42, 
    {from:web3.eth.accounts[0],
     data: simpleCompiled[simpleRoot].code,
     gas: 300000,
     privateFor: ["ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc="]
    }, function(e, contract) {
      if (e) { throw("err creating contract", e); }
      if (!contract.address) {
        console.log(contract.transactionHash + " mining...");
        return;
      }
      console.log("Contract Address: " + contract.address);
    });
</pre>
  

</td>
</tr>
</table>


</body>
<!--
TODO_START:
_____________________________
Geth Key Handling:
<pre xxxsmall zoom>
- Keys are stored under <DATADIR>/keystore(backup regularly)
- keyfiles format(2017-05): UTC--<created_at UTC ISO8601>-<address hex>

geth account [arguments...]
geth account help <subcommand>
    subcommand:
    - new   : create new accounts. Will ask for password/passphrase and
              return its public address.
    - list  : list all existing accounts. 
              (Example Output)
              > Account #0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b}
              > Account #1: {c385233b188811c9f355d4caec14df86d6248235}
              > ...
    - import: import a private key into a new account
              $ geth --datadir /someOtherEthDataDir  account import ./key.prv
              > The new account will be encrypted with a passphrase.
              > Please enter a passphrase now.
              > Passphrase:
              > Repeat Passphrase:
              > Address: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
              > export (unencrypted format >>NOT<< supported)
    - update: migrate to newest key format. account will be saved in newest version
              in encrypted format.  you are prompted for passphrase to unlock
              old-format account wallet and another to save updated file
              (can also be used to change file/wallet password)
              $ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b
              > Unlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b | Attempt 1/3
              > Passphrase:
              > 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b
              > Account 'a94f5374fce5edbc8e2a8697c15331677e6ebf0b' unlocked.
              > Please give a new password. Do not forget this password.
              > Passphrase:
              > Repeat Passphrase:
              > 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b

    - ??????: change password

using account NON-interactively (not connected to a geth node):

   Ex. unlock account wallet for one session: 
   $ geth --unlock <hex_formated_comma_separated_account_list> 
   Example:
   $ geth --unlock primary --rpccorsdomain localhost --verbosity 6 2>> geth.log 
   $ KEYLIST="0x407d73d8a49eeb85d32cf465507dd71d507100c1"
   $ KEYLIST="${KEYLIST},0,5"
   $ KEYLIST="${KEYLIST},e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32"
   $ geth --unlock "${KEYLIST}"
</pre>

_______________________________________________________

______________________________________________

{
"Alt 2: npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use
"
}


{ INSTALL SOLIDITY COMPILER (solc)    
Alt 1   "npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use"   
Alt 2   "PPAs for Ubuntu. For the latest stable version.
Solidity Documentation, Release 0.4.8-develop
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc

If you want to use the cutting edge developer version:
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc"  
}
_____________________________________
LexiFi's Modeling Language for Finance

Screenshot

Developed by the company LexiFi, the Modeling Language for Finance (MLFi) is the first formal language that accurately describes the most sophisticated capital market, credit, and investment products. MLFi is implemented as an extension of OCaml.

MLFi users derive two important benefits from a functional programming approach. First, the declarative formalism of functional programming languages is well suited for specifying complex data structures and algorithms. Second, functional programming languages have strong list processing capabilities. Lists play a central role in finance where they are used extensively to define contract event and payment schedules.

In addition, MLFi provides crucial business integration capabilities inherited from OCaml and related tools and libraries. This enables users, for example, to interoperate with C and Java programs, manipulate XML schemas and documents, and interface with SQL databases.

Data models and object models aiming to encapsulate the definitions and behavior of financial instruments were developed by the banking industry over the past two decades, but face inherent limitations that OCaml helped overcome.

LexiFi's approach to modeling complex financial contracts received an academic award in 2000, and the MLFi implementation was elected “Software Product of the Year 2001” by the magazine Risk, the leading financial trading and risk management publication. MLFi-based solutions are gaining growing acceptance throughout Europe and are contributing to spread the use of OCaml in the financial services industry
___________________________
The ASTRÉE Static Analyzer

David Monniaux (CNRS), member of the ASTRÉE project, says: “ASTRÉE is a static analyzer based on abstract interpretation that aims at proving the absence of runtime errors in safety-critical software written in a subset of the C programming language.”

“Automatically analyzing programs for exactly checking properties such as the absence of runtime errors is impossible in general, for mathematical reasons. Static analysis by abstract interpretation works around this impossibility and proves program properties by over-approximating the possible behaviors of the program: it is possible to design pessimistic approximations that, in practice, allow proving the desired property on a wide range of software.”

“So far, ASTRÉE has proved the absence of runtime errors in the primary control software of the Airbus A340 family. This would be impossible by software testing, for testing only considers a limited subset of the test cases, while abstract interpretation considers a superset of all possible outcomes of the system.”

“ASTRÉE is written in OCaml and is about 44000 lines long (plus external libraries). We needed a language with good performance (speed and memory usage) on reasonable equipment, easy support for advanced data structures, and type and memory safety. OCaml also allows for modular, clear and compact source code and makes it easy to work with recursive structures such as syntax trees.”

____________________________________________
https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall
Difference between CALL, CALLCODE and DELEGATECALL
   
CALL and CALLCODE take the same number of operands (in the execution stack).
For the exception flag being pushed on top of the stack: 0 means exception, 1 means successful execution.
CALL is easy to understand, but I could not digest the subtle difference between CALL & CALLCODE. It is stated in the yellow paper that for

CALLCODE: This means that the recipient is in fact the same account as at present, simply that the code is overwritten.

What does it mean by the code is overwritten? Does that mean I can ask the contract to execute some external code? It would be helpful if anyone can provide me an example to differentiate between the two.

EDIT: DELEGATECALL was added in Homestead what is the difference?
Response:
DELEGATECALL basically says that I'm a contract and I'm allowing (delegating) you to do whatever you want to my storage. DELEGATECALL is a security risk for the sending contract which needs to trust that the receiving contract will treat the storage well.

DELEGATECALL was a new opcode that was a bug fix for CALLCODE which did not preserve msg.sender and msg.value. If Alice invokes Bob who does DELEGATECALL to Charlie, the msg.sender in the DELEGATECALL is Alice (whereas if CALLCODE was used the msg.sender would be Bob).
Details

When D does CALL on E, the code runs in the context of E: the storage of E is used.

When D does CALLCODE on E, the code runs in the context of D. So imagine that the code of E is in D. Whenever the code writes to storage, it writes to the storage of account D, instead of E.

contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3("setN(uint256)")), _n); // E's storage is set, D is not modified 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }
}

contract E {
  uint public n;
  address public sender;

  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    // msg.sender is D if invoked by D's callcodeSetN. None of E's storage is updated
    // msg.sender is C if invoked by C.foo(). None of E's storage is updated

    // the value of "this" is D, when invoked by either D's callcodeSetN or C.foo()
  }
}

contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}

When D does CALLCODE on E, msg.sender inside E is D as commented in the code above.

When an account C invokes D, and D does DELEGATECALL on E, msg.sender inside E is C. That is, E has the same msg.sender and msg.value as D.

____________________________________________

    <hr/>
    Libraries: similar to contracts, but their purpose is that
    they are deployed only once at a specific address and their code is reused
    using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. 
    In comparison to contracts:
    <ul>
      <li>No state variables</li>
      <li>Cannot inherit nor be inherited</li>
      <li>Cannot recieve Ether</li>
    </ul>
____________________________________________

'Ethereum client' refers to any node able to parse and verify the blockchain, its smart contracts ... .
 It also provides (JSON-RPC?) interfaces to create transactions and mining"
____________________________________________

Third party non-official clients:

parity (Rust client): https://github.com/ethcore/parity

ethereumj Java client: https://github.com/ethereum/ethereumj

ethereumjs-vm: https://github.com/ethereumjs/ethereumjs-vm

node-blockchain-server: https://github.com/ethereumjs/node-blockchain-server

____________________________________________
____________________________________________
http://martin.swende.se/blog/EVM-Assembly-trick.html#
"""I recently discovered a method to do generic proxying of Ethereum calls. Skip further down for nitty gritty details, I’ll start this off with some basics.
The problem

Sometimes, it’s convenient to build contract factories. For example, say you want to implement crowdsourcing, or auctions, or games, or DAOs. In those cases, instead of having one “Mother” auction which keeps track of active auctions (which, in turn keep track of bidders, offers and items), it makes sense to implement each auction/crowdfund/game/DAO as it’s own contract.

One problem is that these contracts are quite heavy; creating them may be very expensive and the creation of several may be limited by block gas limits. To counter this, the library-model can be used instead: """
____________________________

<a href='http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers'>Function modifiers</a>

_________________________
Security Considerations:
http://solidity.readthedocs.io/en/develop/security-considerations.html#security-considerations
________________________
The Ethereum Package Registry
   https://www.ethpm.com/
 A package index for Ethereum smart contract packages.

The Ethereum Package Registry is a package index for Ethereum smart contract packages. The registry is based on the ERC190 Smart Contract Packaging Specification.

"""Dear Ethereum,

We need to talk. You're not the easiest platform to work with. Don't get me wrong, you have some great qualities but it's time to grow up and start acting a bit more... mature

Since we care about you and really want you to succeed we made you something that should help. It's called a package index.

I know change can be a little scary but we're sure that once you try it you'll love it. Developers are going to like you more. Their bosses may even stop seeing you as the dangerous kid teaching their devs bad habits like copy/pasting code.

Please give it a try. We really do want the best for you.

Piper & Tim
"""
___________________
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids
List of Chain ID's:
CHAIN_ID    Chain(s)
1   Ethereum mainnet
2   Morden (disused), Expanse mainnet
3   Ropsten
4   Rinkeby
30  Rootstock mainnet
31  Rootstock testnet
42  Kovan
61  Ethereum Classic mainnet
62  Ethereum Classic testnet
1337    Geth private chains (default)
_____________________________
https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88
_____________________________
- create links to interesting sites:
http://www.digitalchamber.org/smart-contract-alliance.html 
http://ethereum.stackexchange.com/
https://www.google.es/?q=smart+contract+formal+verification
_____________________________
formal verification for Smart Contracts ( https://chriseth.github.io/notes/talks/formal_devcon2/#/ ,  http://www.cs.umd.edu/~aseem/solidetherplas.pdf , 
https://www.google.es/?q=smart+contract+formal+verification )

______________________
APP: Ethereum atomic Swaps
   https://github.com/AltCoinExchange/ethatomicswap
  created by https://www.altcoin.io, "A truly decentralized cryptocurrency exchange. Powered by Atomic Swaps."
______________________
1 Log per TX (NO compactado):
Cost  TX:    21000 gas/TX    * 1TX       = 21000
Coste evento:  375 gas/LOG   * 1LOG      =   375
Coste Topic:   375 gas/topic * 3topic    =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes =  1240
                                          ------
                                 TOTAL     23740 gas   = 23740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.228  Eu

5 Logs per TX (compactado):
Cost  TX:    21000 gas/TX    * 1TX        = 21000
Coste evento:  375 gas/LOG   * 1LOG       =   375
Coste Topic:   375 gas/topic * 3topic     =  1125
Coste byte/logs: 8 gas/byte  * 1500 bytes = 12400
                                           ------
                                  TOTAL     34900 gas  = 34900 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.33504 Eu (0.07 Eu 1Log)


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
                                               ------
                                      TOTAL    101000 gas  = 101000 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.9696 Eu


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
Coste evento:  375 gas/LOG   * 1LOG           =   375
Coste Topic:   375 gas/topic * 3topic         =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes      =  1240
                                               ------
                                      TOTAL    103740 gas  = 103740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.995904 Eu
-------------------------------------------------
________________________________
https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#.gbg2nh4o5

Onward with Ethereum Smart Contract Security

If you’re new to Ethereum development, I recommend you read our Hitchhiker’s Guide to Smart Contracts in Ethereum before proceeding.

Learning Ethereum Smart Contract security is a very hard endeavor. There are few good guides and compilations, such as Consensys’ Smart Contracts 
Best Practices, or the Solidity Documentation Security Considerations. But the concepts are very hard to remember and internalize without writing your own code.

I’ll attempt a slightly different approach. I’ll explain some recommended strategies to improve smart contract security and show code examples where not
 following them results in problems. I’ll also show you code samples you can use to protect your smart contracts. Hopefully, this will help create a muscle
 memory of things to avoid, which will trigger mental warnings when writing actual code.

Without further ado, let’s dive into the best practices:
Fail as early and loudly as possible

A simple yet powerful programming good practice is to make your code fail as promptly as possible. And be loud about it. Let’s see an example of a function
 that behaves timidly:

// UNSAFE CODE, DO NOT USE!

contract BadFailEarly {
  uint constant DEFAULT_SALARY = 50000;
  mapping(string => uint) nameToSalary;

  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length != 0 && nameToSalary[name] != 0) {
      return nameToSalary[name];
    } else {
      return DEFAULT_SALARY;
    }
  }
}

We want to avoid a contract failing silently, or continuing execution in an unstable or inconsistent state. The function getSalary is checking for conditions 
before returning the stored salary, which is a good thing. The problem is, in case those conditions are not met, a default value is returned. This could hide 
an error from the caller. This is an extreme case, but this kind of programming is very common, and normally arises from fear of errors breaking our app.
Truth is, the sooner we fail, the easier it will be to find the problem. If we hide errors, they can propagate to other parts of the code and cause inconsistencies
 which are difficult to trace. A more correct approach would be:

contract GoodFailEarly {
  mapping(string => uint) nameToSalary;
  
  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length == 0) throw;    
    if (nameToSalary[name] == 0) throw;
    
    return nameToSalary[name];
  }
}

This version also shows another desirable programming pattern which is separating preconditions and making each fail separately. Note that some of these
 checks (especially those depending on internal state) can be implemented via Function Modifiers.
Favor pull over push payments

Every Ether transfer implies potential code execution. The receiving address can implement a fallback function that can throw an error. Thus, we should never 
trust that a send call will execute without error. A solution: our contracts should favor pull over push for payments. Take a look at this innocent looking code for 
a bidding function:

// UNSAFE CODE, DO NOT USE!

contract BadPushPayments {
  address highestBidder;
  uint highestBid;
 
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0) {
      // return bid to previous winner
      if (!highestBidder.send(highestBid)) {
        throw;
      }
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
}

Note that the contract calls the send function and checks its return value, which seems reasonable. But it calls send in the middle of a function, which is unsafe. Why? Remember that, as stated above, send can trigger the execution of code in another contract.

Imagine someone bids from an address which simply throws an error every time someone sends money to it. What happens when someone else tries to outbid that? The send call will always fail, bubbling up and making bid throw an exception. A function call that ends in error leaves the state unchanged (any changes made are rolled back). That means nobody else can bid, and the contract is broken.

The easiest solution is to separate payments into a different function, and have users request (pull) funds independently of the rest of the contract logic:

contract GoodPullPayments {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  
  function bid() external {
    if (msg.value < highestBid) throw;
    
    if (highestBidder != 0) {
      refunds[highestBidder] += highestBid;
    }
    
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdrawBid() external {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund)) {
      refunds[msg.sender] = refund;
    }
  }
}

This time, we use a mapping to store refund values for each outbid bidder, and provide a function to withdraw their funds. In case of a problem in the send call, only that bidder is affected. This is a simple pattern that solves many other problems (such as reentrancy), so remember: when sending ether, favor pull over push payments.

I’ve implemented a contract you can inherit from to easily use this pattern. Here’s an example showing how to use it.
Order your function code: conditions, actions, interactions

As an extension of the fail-early principle, a good practice is to structure all your functions as follows: first, check all the pre-conditions; then, make changes to your contract’s state; and finally, interact with other contracts.

Conditions, actions, interactions. Sticking to this function structure will save you lots of problems. Let’s see an example of a function using this pattern:

function auctionEnd() {
  // 1. Conditions
  if (now <= auctionStart + biddingTime)
    throw; // auction did not yet end
  if (ended)
    throw; // this function has already been called

  // 2. Effects
  ended = true;
  AuctionEnded(highestBidder, highestBid);

  // 3. Interaction
  if (!beneficiary.send(highestBid))
    throw;
  }
}

This is in line with the fail fast principle, as conditions are checked in the beginning. It also leaves potentially dangerous interactions with other contracts to the very end.
Be aware of platform limits

The EVM has a lot of hard limits on what our contracts can do. These are platform-level security considerations, but may threaten your particular contract’s security if you don’t know about them. Let’s take a look at the following innocent-looking employee bonus management code:

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (var i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

Read the code: it’s pretty straight-forward and seems correct. It hides 3 potential problems, though, based on platform limits.

The first problem is that the type of i will be uint8, because this is the smallest type that is required to hold the value 0. If the array has more than 255 elements, the loop will not terminate, resulting in gas depletion. Better use the explicit type uint for no surprises and higher limits. Avoid declaring variables using var if possible. Let’s fix that:

const Project = artifacts.require('./Project.sol')
const project = await Project.deployed()

const people = await project.getPeople([ 2, 5 ], { from: accounts[0] })

console.log('people =', people)
// this will print something like:
// people = [ ['0xdeadbeef', '0xabcdeff'], [123, 789] ]
//
// as you can see, we get back an array.  each element of this array
// represents a field in the struct type.  because we've returned
// many structs, each field has many values.  let's reassemble these
// into a more familiar (and more usable) format.

// we can figure out how many structs were returned by checking the
// length of any of the arrays that were returned.  they should all
// have the exact same length.
const numPeople = people[0].length

// for clarity's sake, let's define some constants so that we can see
// which field array we're accessing:
const FIELD_ADDR  = 0
const FIELD_FUNDS = 1

let peopleStructs = []
for (let i = 0; i < numPeople; i++) {
    const person = {
        addr:  people[FIELD_ADDR][i],
        funds: people[FIELD_FUNDS][i],
    }
    peopleStructs.push(person)
}

console.log('peopleStructs =', peopleStructs)
// this will print something like:
// peopleStructs = [
//     { addr: '0xdeadbeef', funds: 123 },
//     { addr: '0xabcdeff', funds: 789 }
// ]



The second thing you should consider is the gas limit. Gas is Ethereum’s mechanism to charge for network resources. Every function call that modifies state has a gas cost. Imagine calculateBonus calculates the bonus for each employee based on some complex computation like calculating the profit over many projects. This would spend a lot of gas, which could easily reach the transaction’s or block’s gas limit. If a transaction reaches the gas limit, all changes will be reverted but the fee is still paid. Be aware of variable gas costs when using loops. Let’s optimize the contract by separating the bonus calculation from the for loop. Please note that this still has the issue that as the employees array grows, the gas cost grows.

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  mapping(address => uint) bonuses;  
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation modifying the bonus...
    bonuses[employee] = bonus;
  }
}

Last, there is the call stack depth limit. The EVM’s call stack has a hard limit of 1024. That means that if the amount of nested calls reaches 1024, the contract will fail. An attacker can call a contract recursively 1023 times and then call our contract’s function, causing sends to silently fail because of this limit. PullPaymentCapable.sol was described above, and allows to easily implement pull payments. Inheriting from PullPaymentCapable and using asyncSend protects you from this.

Here’s a modified version of the code that fixes all these issues:

import './PullPaymentCapable.sol';

contract GoodArrayUse is PullPaymentCapable {
  address[] employees;
  mapping(address => uint) bonuses;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      asyncSend(employee, bonus);
    }
  }

  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation...
    bonuses[employee] = bonus;
  }
}

To sum up, be sure to remember about (1) limits in the types you’re using, (2) limits in the gas costs of your contract, and (3) the call stack depth limit.
Write tests

Writing tests is a lot of work, but will save you from regression problems. A regression bug appears when a previously correct component gets broken based on a recent change.

I’ll be writing a more extensive guide on testing soon, but if you’re curious you can check Truffle’s testing guide.
Fault tolerance and Automatic bug bounties

Thanks to Peter Borah for inspiration on these two ideas. Code reviews and security audits are not enough to be safe. Our code needs to be ready for the worst. In case there is a vulnerability in our smart contract, there should be a way for it to safely recover. Not only that, but we should try to find those vulnerabilities as early as possible. That’s where automatic bug bounties built into our contract can help.

Let’s take a look at this simple implementation of an automatic bug bounty for a hypothetical Token contract:

import './PullPaymentCapable.sol';
import './Token.sol';

contract Bounty is PullPaymentCapable {
  bool public claimed;
  mapping(address => address) public researchers;
  
  function() {
    if (claimed) throw;
  }
  
  function createTarget() returns(Token) {
    Token target = new Token(0);
    researchers[target] = msg.sender;
    return target;
  }
  
  function claim(Token target) {
    address researcher = researchers[target];
    if (researcher == 0) throw;
    
    // check Token contract invariants
    if (target.totalSupply() == target.balance) {
      throw;
    }
    asyncSend(researcher, this.balance);
    claimed = true;
  }
}

As before, we’re using PullPaymentCapable to make our outgoing payments safe. This Bounty contract allows researchers to create copies of the Token contract we want audited. Anyone can contribute to the bug bounty by sending transactions to the Bounty contract’s address. If any researcher manages to corrupt his copy of the Token contract, making some invariant break (for example, in this case, making the total supply of tokens different from the Token’s balance), he’ll get the bounty reward. Once the bounty is claimed, the contract won’t accept any more funds (that nameless function is called the contract’s fallback function, and is executed every time the contract is sent money directly).

As you can see, this has the nice property that it is a separate contract and requires no modification of our original Token contract. Here’s a full implementation available on GitHub for anyone to use.

As for fault tolerance, we will need to modify our original contract to add extra safety mechanisms. A simple idea is to allow a contract’s curator to freeze the contract as an emergency mechanism. Let’s see a way to implement this behavior via inheritance:

contract Stoppable {
  address public curator;
  bool public stopped;

  modifier stopInEmergency { if (!stopped) _ }
  modifier onlyInEmergency { if (stopped) _ }
  
  function Stoppable(address _curator) {
    if (_curator == 0) throw;
    curator = _curator;
  }
  
  function emergencyStop() external {
    if (msg.sender != curator) throw;
    stopped = true;
  }
}

Stoppable allows one to specify a curator address that can stop the contract. What does “stopping the contract” mean? That’s to be defined by the child contract inheriting from Stoppable by using the function modifiers stopInEmergency and onlyInEmergency. Let’s see an example:

import './PullPaymentCapable.sol';
import './Stoppable.sol';

contract StoppableBid is Stoppable, PullPaymentCapable {
  address public highestBidder;
  uint public highestBid;
  
  function StoppableBid(address _curator)
    Stoppable(_curator)
    PullPaymentCapable() {}
  
  function bid() external stopInEmergency {
    if (msg.value <= highestBid) throw;
    
    if (highestBidder != 0) {
      asyncSend(highestBidder, highestBid);
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdraw() onlyInEmergency {
    suicide(curator);
  }
}

In this toy example, the bid can now be stopped by a curator, defined when the contract is created. While the StoppableBid is in normal mode, only the bid function can be called. If something weird happens and the contract is in an inconsistent state, the curator can step in and activate the emergency state. This makes the bid function uncallable, and allows the function withdraw to work.

In this case, emergency mode would only allow the curator to destroy the contract and recover the funds, but in a real case, recovery logic could be more complex (for example returning funds to their owners). Here’s an implementation of Stoppable available on GitHub for anyone to use.
Limit the amount of funds deposited

Another way to protect our smart contracts from attacks is to limit their scope. Attackers will most probably target high-profile contracts managing millions of dollars. Not all smart contracts need to have such high stakes. Especially if we’re conducting experiments. In such cases, it might be useful to limit the amount of funds our contract accepts. This is as simple as a hard limit on the balance of the contract’s address.

Here’s a simplified example on how to do this:

contract LimitFunds {
  
  uint LIMIT = 5000;
  
  function() { throw; }
  
  function deposit() {
    if (this.balance > LIMIT) throw;
    ...
  }
}

The short fallback function will reject any direct payments to the contract. The deposit function will first check if the contract’s balance exceeds the desired limit, or throw an exception. More interesting things like dynamic or managed limits are easy to implement too.
Write simple and modular code

Security comes from a match between our intention and what our code actually allows to do. This is very hard to verify, especially if the code is huge and messy. That’s why it’s important to write simple and modular code.

This means, functions should be as short as possible, code dependencies should be reduced to the minimum, and files should be as small as possible, separating independent logic into modules, each with a single responsibility.

Naming is also one of the best ways to express our intention when coding. Think a lot about the names you chose, to make your code as clear as possible.

Let’s study an example of bad naming of Events. Look at this function from The DAO. I’m not going to copy the function code here because it’s very long.

The biggest problem is that it’s too long and complex. Try to keep your functions much shorter, say, up to 30 or 40 lines of code max. Ideally, you should be able to read functions and understand what they do in less than a minute. Another problem is the bad naming for the event Transfer in line 685. The name differs from a function called transfer by only 1 character! This is inviting confusion for everyone. In general, the recommended naming for events is that they should start with “Log”. In this case, a better name would be LogTransfer.

Remember, write your contracts as simple, modular, and well-named as possible. This will greatly facilitate others and yourself in auditing your code.
Don’t write all your code from scratch

Finally, as the old adage reads: “Don’t roll your own crypto”. I think it also applies to Smart Contract code. You’re dealing with money, your code and data is public, and you’re running in a new and experimental platform. The stakes are high and the chances to mess-up are everywhere.

These practices help secure our smart contracts. But ultimately, we should create better developer tools to build smart contracts. There are some interesting initiatives including better type systems, Serenity Abstractions, and the Rootstock platform.

There’s lots of good and secure code already written and frameworks are starting to appear. We’ve started to compile some of the best practices in this GitHub repo we called OpenZeppelin. Feel free to take a look and contribute with new code or security audits.
Wrapping up

To recap, the security patterns described in this article are:

    Fail as early and loudly as possible
    Favor pull over push payments
    Order your function code: conditions, actions, interactions
    Be aware of platform limits
    Write tests
    Fault tolerance and Automatic bug bounties
    Limit the amount of funds deposited
    Write simple and modular code
    Don’t write all your code from scratch

If you want to join the discussion about secure smart contract development patterns join us on slack. Let’s improve the smart contract development standards together!

To be up to date with our work in smart contract security, follow us on Medium and Twitter.
_______________________________________

See also: https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab#.xk3bv3cw8
_______________________________
<strong>Ethereum</strong><br>
Ethereum was able to successfully execute a hard fork called Byzantium. As part of this hard fork increased anonymity was provided through Zero-knowledge proofs, or zk-snark proofs. It also included more predictable gas charges which were becoming difficult to calculate with the increased number of ICOs. InfoQ previously covered this hard fork in the following <a href="https://www.infoq.com/news/2017/08/Ethereum-HardFork" target="_blank">article</a>.</p>
________________________
Ethereum ¿Opinion?: """
Bitcoin UTXO binary state (spent, unspent) gives no opportunity for multi-stage contracts or scripts
which keep any other interanl state beyond that. This makes it hard to make multi-stage options
contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary
for secure computational bounties). It also means that UTXO can only be used to build simple, one-off
contracts and not more complex "stateful" contracts such as decentralized organizations, and makes
meta-protocols difficult to implement. Binary state combined with value-blindness also mean that 
another important application, withdrawal limits, is impossible".
__________________________________
  <a href='https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/' TODO>How to build server less applications for Mist</a>
________________________
throw vs revert
_________________
https://github.com/ethereum/wiki/wiki/Whisper
In a nutshell whisper is a communication protocol for DApps to communicate with each other.
Use case

    DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.

    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.
_______________________________
https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c

_______________________________
_______________________________

____________________________

_______________________________
Solidity: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1
__________________
Solidity: https://coursetro.com/posts/code/102/Solidity-Mappings-&-Structs-Tutorial
_____________
https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
Through technical evaluations of tools like Plasma and formats of obtaining consensus in Casper, it is apparent that database management tools like MapReduce and Abstract Rewrite Systems will be implemented in Ethereum. In Plasma, MapReduce is an integral part of assembling the coordination of an account based system and a bitmap-UTXO commitment structure of a multichain setup.
...
Plasma shares quite a bit of influence from a heavily cryptoeconomic incentive structure focused platform called Truebit which was designed to increase the offchain computational capabilities of the Ethereum network. By architecting the Truebit system around a verification game in which Solvers of the overall consensus mechanism can be challenged by Verifiers which obtain a reward if they identify a nefarious counterparty, an internal cryptoeconomic ?checks and balances? of the system is created to incentive a dominant strategy of behaving fairly. As Plasma through the influence of TrueBit is focused on creating a multichain interoperability network, the internal enforcement of the system is paramount toward achieving information and consensus fidelity.
...
Ethereum Casper Proof of Stake

An example of cryptoeconomic incentive layers can also be seen in Ethereum?s transition to a proof of stake consensus mechanism via implementations of Casper. While proof of work has its own internalized game theoretical incentive structure to dissuade participants from commandeering the network, the transition to proof of stake has even further internal structures for disincentivizing participants from equivocating or trying to create alternative instances of the blockchain when encountering forks. The staking protocol creates a Byzantine Fault Tolerant environment where Ether would be bonded into the consensus mechanism. What this means is that individuals would be bound by a fidelity bond to behave honorably within the system.
....
Cosmos and Tendermint

Cosmos is also building an ecosystem that relies on the Tendermint consensus mechanism that relies heavily upon Byzantine Fault Tolerance algorithms. The platform depends on validators that have similar roles as miners in the bitcoin network. The validators have staking tokens called Atoms which are used to secure the network via a proof of stake mechanism that relies upon the trust generated by the bonded validators. The interplay between the players in the ecosystem is also indicative of a game theoretical structure where validators can lose their tokens or the tokens delegated to them if discovered to be violating the protocol. Due to this bonded deposit design of stakeholders within this system, the consensus mechanism allows for an incentivization mechanism that secures the network. This security design allows for the proper functioning of the Application Blockchain Interface (ABCI), the Inter-Blockchain Communication protocol (IBC) as well as the varying interactions between the Cosmos hub and zones.
....
_______________

https://plasma.io/plasma.pdf
The orchestrated transaction processing paradigm using the interplay between rootchains, plasma chains, and child chains through a combination of fraud-proof mechanism designs and fidelity bond incentive structures help satisfy dynamics between the block-withholding and mass withdrawal surfaces. It also allows for further cryptoeconomic structures to be filled using mechanisms from systems like Casper or Truebit for mirroring concepts used in erasure coding in terms of the data availability problem that is prevalent in the space. For a multichain architecture, Ethereum would be able to combine the database coordination and throughput capabilities of a distributed database system with the public chain compatible capabilities of an actual blockchain.
______________________
__________________________________________
http://fc17.ifca.ai/wtsc/Defining%20the%20Ethereum%20Virtual%20Machine%20for%20Interactive%20Theorem%20Provers.pdf
__________________________________________
https://github.com/pirapira?utf8=%E2%9C%93&tab=repositories&q=&type=source&language=  
 ( Lot of interesting repos related to Ethereum)

_________________
selfdestruct(address recipient):
  destroy current contract
  send its funds to recipient 
________________________________

_____________________
https://entethalliance.org/enterprise-ethereum-alliance-advances-web-3-0-era-public-release-enterprise-ethereum-architecture-stack/
 The Enterprise Ethereum Alliance (EEA), with over 500 members, today unveiled the next phase of its Enterprise Ethereum specification strategy, with the public release of its Enterprise Ethereum Architecture Stack. This stack defines the building blocks needed to drive the Web 3.0 era of decentralized, connective intelligence ? the next generation of Enterprise Ethereum applications that, like the Internet, will work anywhere, and are capable of facilitating smart contracts without intermediaries. The stack, available as a free public document to download, incorporates components developed by the Ethereum Foundation.
_________________________
https://entethalliance.org/resources/
_________________________
Signing transactions Flow:
 - Identify the next available nonce for the sender account
 - Create the RawTransaction object
 - Encode the RawTransaction object using Recursive Length Prefix encoding
 - Sign the RawTransaction object
 - Send the RawTransaction object to a node for processing

The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.
_______________________
Tooling:
https://github.com/adridadou/eth-contract-api

 EthereumJ native API or how to call contracts easily and with type safety http://www.davidroon.com/ethcontractapi/
____________________________
ERC223: Safer ERC20 token standard:
https://github.com/ethereum/EIPs/issues/223
____________________________
https://github.com/paritytech/parity/issues/6342___________________________
____________________________
https://github.com/oraclize/ethereum-examples
http://www.oraclize.it/
_______________________________
Solidity Arrays vs Linked-lists:
https://ethereum.stackexchange.com/questions/51399/deleting-index-of-an-array-in-terms-of-optimization-for-looping
_______________________________
Consensys techs:
Balanc3             TravelBlocks                                 Linnia
Cellarius           Waterloo                                     Catalyst and Hub Account Manager
ConsenSys Academy   Panvala                                      Meridio
Plasma              Gitcoin                                      MetaMask
Gitcoin             Infura                                       N0d.capital
Token Foundry       Kaleido                                      Nethereum
Viant               Applied Researcher: Sharding                 Numia
uPort               Applied Researcher: Sidechains (PegaSys)     OpenLaw
Trustology          Quantitative/Qualitative Researcher          PegaSys
TruSet              Senior Design Researcher - Ujo Music















Ujo: Ethereum blockchain-based open music industry peer-to-peer platform built by ConsenSys.
Ujo aims to increase transparency and efficiency in the music industry through an automated,
decentralised rights management and payments system upon which any music service or
application can be built. Creators and rights holders register works and their stakes in those
works in smart contracts on the blockchain. Payments are delivered automatically and
instantly based on that information using the self-enforcing smart contract technology. Artists
may also publish policies for how their music may be used, facilitating an open marketplace in
which anybody can innovate a new business model, app or service as long as they meet the
terms of those policies.
__________________________________________
https://aleth.io:

https://media.consensys.net/alethio-lighting-up-the-blockchain-with-real-time-stats-a80bb30576db
Alethio’s analytics platform helps users visualize, interpret, and react to blockchain data in real time.


"""Though Ethereum has become a household name, what’s actually happening on the
 network remains a mystery for many. Current blockchain explorers provide little
 clarity into the evolving ecosystem. They are often geared towards developers
 and leave average users in the dark. At the same time, seasoned and committed 
users, from individuals to enterprises, still don’t have the resources they need
 to really make sense of the blockchain — whether that’s accessing real time 
block data, analyzing the application layer, detecting anomalies, or monitoring
 the statistical signals that translate to larger KPIs.

At Alethio, we take issue with this. For Ethereum to realize its true potential, users’ interactions with the blockchain should be fully transparent and understandable. As Ethereum grows in size and complexity, we believe the tools that inform user’s decisions, large or small, should evolve as well."""
_______________________
https://io.builders/blog/our-first-month-tools-languages-and-developments/
  Our first month: Tools, languages and developments
  Madrid, Spain
  Friday, June 1, 2018

  Time goes fast, and 5 weeks have passed since our 
  official Team start. We don't have everybody on board 
  but we have started with some developments. These are 
  the tools we are using:
  <ul>
  <li>Intellij IDEA and Atom as IDE</li>
  <li>Gitlab as CI. It allows us to create pipelines from 
  day one, natively integrated in our source code. With 
  its powerful docker based platform we are able to 
  compile, pass specific linters, test and audit the 
  security of our builds. 
  <a href="https://github.com/IoBuilders/solidity-test-and-security-pipeline/tree/master" target="_blank">Checkout out pipeline</a>.
  Our vision is to have full coverage and automatically 
  audited code, to be 100% sure that our smart contracts are safe from well known bugs and follow good practices.</li>
  <li>React Native for mobile development</li>
  <li>NodeJs, Java, Groovy and GO for backend development</li>
  <li><a href="https://www.jpmorgan.com/global/Quorum" target="_blank">Quorum</a> as the DLT</li>
  <li>Solidity 0.4.24</li>
  <li><a href="https://github.com/sc-forks/solidity-coverage" target="_blank">Solidity Coverage</a> as test coverage tool</li>
  <li><a href="http://truffleframework.com/" target="_blank">Truffle framework</a>: Lifecycle for solidity.</li>
  <li><a href="http://truffleframework.com/ganache/" target="_blank">Ganache</a>: Light node of Ethereum for testing purpose.</li>
  <li><a href="https://github.com/duaraghav8/Solium" target="_blank">Solium</a>: Linter &amp; security static analysis.</li>
  </ul>  
   
  Besides this, we have used <a href="https://www.gv.com/sprint/">Design Sprint</a> by Google Ventures,
  to discover and analize the customer journey, functional 
  approach of our first venture and develop/test it with 
  a prototype with real users. Hypothesis validation is on going!
  Thanks for Reading! Keep Posted!!!
  “With confidence, you have won before you have started.” —Marcus Garvey 
__________________________

_________________________
https://github.com/quantnetwork/eth-contract-metadata
_________________________
https://solidity.readthedocs.io/en/latest/050-breaking-changes.html
_________________________
https://yakindu.github.io/solidity-ide/
_________________________
Apache Camel + Ethereum JSON/RPC  protocol:
https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43
________________________
https://openzeppelin.org/api/docs/ownership_rbac_RBAC.html
________________________
Timestamp in Ethereum:
https://ethereum.stackexchange.com/questions/7853/is-the-block-timestamp-value-in-solidity-seconds-or-milliseconds
https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp
________________________
https://ethereum.stackexchange.com/questions/18461/how-can-dapps-work-on-smartphones

Status is a good start to develop a Ethereum mobile dapp.

    Status is an open source messaging platform and mobile browser to interact with decentralized applications that run on the Ethereum Network.

    Decentralized Apps at your fingertips: With Status your mobile device becomes a light client node on the Ethereum Network, enabling you to access Ethereum’s entire ecosystem from anywhere.

    Smarter private messaging: Status is more than a messenger. Send payments and smart contracts to friends from within chats, and enjoy encrypted messaging by default, using a peer-to-peer protocol that doesn’t rely on centralized servers.

Status app (Ethereum Mobile gateway) is currently in alpha and can be tested on Android and iPhone.

Please find below a quick tutorial how to deploy a dapp on Status.Let's imagine you have a dapp (ReactNative, Ionic, ...) running on {DAPP_URL}

    Download Status on your phone and configure an account

    Install status-dev-cli npm i -g status-dev-cli

    In status console, enter /debug. That will give you your device IP address {DEVICE_IP}

    From your machine, make sure you can see you device and status: status-dev-cli scan (status must be running)

    Last step, consist in registering the dapp in status: status-dev-cli add "{\"whisper-identity\": \"my-dapp\", \"dapp-url\": \"{DAPP_URL}\", \"name\": \"MyDAPP\"}" --ip {DEVICE_IP}

You can now refresh you status app and you will see appear MyDapp in the list. The browser will launch you dapp and it can interact (web3) with the Ethereum blockchain and smart contracts.

By default, status run on the testnet network. You can switch to another node (private, testrpc or mainnet) with the following command status-dev-cli switch-node {NODE_URL} --ip {DEVICE_IP}

Documentation: Here

Some examples: Me and other devs have recently attended to the Status hackaton. This blog post (Winners Announcement) will illustrate some of the projects developed in a one-week period.
___________________________
Pantheon: Ethereum Java Client for the "Enterprise" with private TXs
https://pegasys.tech/enterprise/
_________________________
https://www.augur.net/
_________________________
https://ethereum.stackexchange.com/questions/267/why-dont-ethereum-addresses-have-checksums
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
  ICAP: Inter Exchange Client Address Protocol (ICAP) compatible 
        with IBAN account formatting.
        https://github.com/ethereum/wiki/wiki/Inter-exchange-Client-Address-Protocol-(ICAP)
_____________________
https://github.com/machinomy/contracts/blob/master/contracts/Unidirectional.sol

Machinomy simple Channels on Ethereum contract
_____________________
https://www.codementor.io/sambhav2612/setting-up-a-dao-contract-for-meetup-groups-k6jvjpvnr
_____________________
https://github.com/status-im/geth_exporter
geth metrics exporter for Prometheus
______________________________
https://legalconsortium.org/apply/
______________________________
https://solidity.readthedocs.io/en/v0.5.0/style-guide.html
______________________________
- Who-is-Who:
  https://github.com/juanfranblanco?tab=following

Quorum TODO_Start: {{{
_____________________________________________________
<p>See the <a href="https://github.com/jpmorganchase/quorum/blob/master/docs/api.md#privacy-apis">Quorum API</a> page for details on the <code>sendTransaction</code> call, which includes some modifications to the standard Ethereum call.</p>
    <li>
      <p>Developing Smart Contracts with Solidity</p>
      <p>Smart Contracts can be public or private to one or more network participants.  
      <p>Public  Transactions/Smart Contracts: Send an Ethereum Transaction to the network (TX.to         = "empty" creates a Contract)</p>
      <p>Private Transactions/Smart Contracts: Send an Ethereum Transaction to the network setting TX.privateFor = participant(s) public_key_list</p>
      <p>Example JSON message:
       <pre>
{ 
  "jsonrpc":"2.0",
  "method":"eth_sendTransaction",
  "params":[
    {
     "from": $FROM_AC,
     "to": $TO_AC, 
     "data": $CODEHASH,
     "privateFor": ["$PUBKEY1,PUBKEY2"]
    }
  ],
  "id":$ID
} 
       </pre>
      </p>
_________________________________
Youtube Video: Raspeberry Pi java sending telemetry data to quorum.
https://www.youtube.com/watch?v=64kMWxTaXw8
___________________________________________________


## Permissioned Network
Node Permissioning is a feature that controls which nodes can connect to a given node and also to which nodes this node can dial out to. Currently, it is managed at individual node level by the command line flag `--permissioned` while starting the node.

If the `--permissioned` node is present, the node looks for a file named `<data-dir>/permissioned-nodes.json`. This file contains the list of enodes that this node can connect to and also accepts connections only from those nodes. In other words, if permissioning is enabled, only the nodes that are listed in this file become part of the network. It is an error to enable `--permissioned` but not have the `permissioned-nodes.json` file. If the flag is given, but no nodes are present in this file, then this node can neither connect to any node or accept any incoming connections.

The `permissioned-nodes.json` follows following pattern (similar to `static-nodes.json`):

```json
[
  "enode://enodehash1@ip1:port1",
  "enode://enodehash2@ip2:port2",
  "enode://enodehash3@ip3:port3",
]
```

Sample file:

```json
[
  "enode://6598638ac5b15ee386210156a43f565fa8c48592489d3e66ac774eac759db9eb52866898cf0c5e597a1595d9e60e1a19c84f77df489324e2f3a967207c047470@127.0.0.1:30300",
]
```

In the current release, every node has its own copy of `permissioned-nodes.json`. In a future release, the permissioned nodes list will be moved to a smart contract, thereby keeping the list on chain and one global list of nodes that connect to the network.
___________________
Quorum Enterprise Toolkit:
Quorum Core +
  - remporting DB & adapters
  - Entitlements Framework
  - Certificate Authority
  - SAML/OAuth Integration
  - Data Archival/Pruning
  - Quorum API (RESTful)
  - Blockchain Explorer
  - Node Manager
  - Monitoring Capabilities
____________________________________
<td>
  Layers of Privacy 
<pre xxxsmall zoom>
<a href="https://media.consensys.net/busting-the-myth-of-private-blockchains-9ae0ed058b0d">[REF@media.consensys.net]</a>
- In reality, privacy is not a property of any blockchain. 
  Rather, there are layers of privacy that can be applied to any blockchain, 
  even public chains, allowing for private or “shielded” transactions on a 
  public blockchain. This allows companies to benefit from the decentralized 
  security of a public blockchain while concealing private information.

- Layers of Privacy with Enterprise Blockchains
  Privacy and confidentiality are essential for enterprise solutions. 
  Enterprises have a number of concerns when considering blockchain 
  implementations:

  - Access: who has permissions to read and/or write?
  - Visibility: to whom are transactions broadcasted?
  - Storage: how is data stored?
  - Execution: who has the right to start, stop, or restart a process?

- A private blockchain is only as secure as the permissioning and 
  security controls around the network. As these “private” networks gain more 
  participants, enforcing controls around access and visibility becomes more 
  difficult. For example, the way that Fabric ensures transaction privacy 
  between different parties within a consortium is through the concept of 
  channels. A channels is essentially a single protected route between two 
  parties. This means you need a channel for each party pair and must maintain 
  all of this infrastructure as the system evolves, making it more complicated 
  to manage.

- Layered Privacy:
  -  Permissioning 
     layer  : permissioning or credentials layer of tooling which 
              involves who has access to information and how that is
              controlled and authenticated.
  -  Privacy
       layer: maintaining the confidentiality of the participants,
              data, and terms.
              Even within a single layer, there’s multiple sublayers
              where privacy can be kept on-chain, off-chain, and through
              private transactions. 
              - Privacy of  
                participants: ensure participants remain anonymous to one
                              another as well as to those outside of the
                              network with on-chain cryptographic mechanisms 
                              like ring signatures, stealth addresses, mixing,
                              or storage of private data off-chain.
              - Privacy of 
                        data: keep transactions, balances, smart contracts,
                              and other data encrypted on or off chain, with
                              cryptographic tools like zero-knowledge proofs
                              and zk-SNARKS, Pedersen commitments, or off-chain
                              privacy layers like TEEs.
              - Privacy of
                       terms: keep terms of contracts between two parties private 
                                    with range proofs or Pedersen commitments.

- <b>Private blockchains do not give you privacy by default</b>. There is a distinction
  between permissioned networks and private transaction managers. Really, the only
  privacy that private blockchains do provide by default are that the 
  participants and contracts cannot be viewed by non-participants. Rather, 
  privacy layers must be built on any blockchain and can be built into both 
  public and private chains, or, with a combination of the two (such as 
  Ethereum and Quorum).

- <b>Layer 2 of the EEA client specification V2</b>
- many options for Private Transactions available providing various layers of privacy.
  - Pantheon: the protocol by  PegaSys, the engineering team at ConsenSys.
    Enterprise Ethereum client in Java.
  - Privacy layers for public/permissioned networks in progress:
    - zk-SNARKS and zero-knowledge proofs: hide transaction attributes like balances.
    - ring signatures and hashes: provide layers of privacy for
                      participants, data, and/or terms.
    - off-chain solutions: store private data and perform high-throughput transactions.

  - Project Ubin:
    - Shielded public transactions that are validated by the whole
      network but whose amount (and/or asset type,...) are shielded.
    - collaborative Ethereum project between ConsenSys and the 
      Monetary Authority of Singapore to create an interbank payment network.
    - In Project Ubin, a consortium of financial institutions used 
      zero-knowledge proofs to enable the transfer of digital assets on a
      distributed ledger without revealing information about the balances
      or transaction amounts.

  - Project Khokha (South African Reserve Bank "PoC"): Pedersen Commitments
    - Pedersen commitments are also additively homomorphic, which means that
      for a balance update, network participants can validate that the correct
      update has happened without knowing the opening balance, the closing balance,
      or the transfer amount.
    - Pedersen commitments and Folklore range proofs to process the typical
      daily volume of payments for the SARB with full confidentiality and 
      finality in less than two hours. These commitment schemes proved to be
      much quicker to validate than the zero-knowledge proofs.
    - Adhara has been exploring substituting range proofs with bullet proofs,
      which are much smaller and quicker to validate. Very simply, instead
      of writing the balances and the transaction amounts in the clear as in
      a normal ERC20 contract, nodes write a proof or a Pedersen commitment
      of the balance.
  - Public-First + Privacy Layers = Future-Proof
    - Business networks need resilience, interoperability, permissioning,
      and privacy to succeed.

   These requirements, however, are out of scope for proprietary distributed ledgers, let alone traditional database technologies. The Ethereum blockchain’s granular privacy layers and public-first approach make it a powerful enterprise solution for organizations that need the flexibility of an in-house platform and that want the global reach to participate in economies of scale.

Visit our Enterprise Ethereum homepage to connect with ConsenSys Solutions and learn more about how Ethereum can future-proof your organization. Stay tuned for Part 5 of this series, “The Enterprise Ethereum Infrastructure, Tool, and Application Stack.”

Disclaimer: The views expressed by the authors and contributors above do not necessarily represent the views of Consensys AG. ConsenSys is a decentralized community with ConsenSys Media being a platform for members to freely express their diverse ideas and perspectives. To learn more about ConsenSys and Ethereum, please visit our website.
Thanks to John Wolpert.

    BlockchainEthereumEnterprise TechnologyTechnologyBusiness

Go to the profile of ConsenSys
ConsenSys

A blockchain venture production studio building decentralized applications on Ethereum. Go to www.consensys.net and subscribe to our newsletter.
ConsenSys Media
ConsenSys Media

News, insights, and education on all things decentralization from leaders in the blockchain industry
</pre>
</td>
_________________
https://media.consensys.net/j-p-morgan-is-using-ethereum-to-launch-a-digital-u-s-dollar-heres-what-it-means-for-blockchain-64f0fe3e55bc?_hsenc=p2ANqtz-_G8oE25VrDDhDoGzsYJvAyJIsx8tTX8dRxqT6JFbZyn0ymF1UEmtrKqtZCCB0S24Aih9M6WMSTP3881SUa2PapCU2JD65yE0UEw1ya-ep6KMccBqs&_hsmi=69989245
______________
https://twitter.com/goquorum
https://github.com/jpmorganchase/
Quorum Slack:
<a href="https://clh7rniov2.execute-api.us-east-1.amazonaws.com/Express/">Quoram Slack</a>

______________________
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
____________________
<td>
<a xsmall TODO href="https://solidity.readthedocs.io/en/latest/types.html?highlight=push">Callbacks</a>
pragma solidity >=0.4.22 <0.6.0;

contract Oracle {
  struct Request {
    bytes data;
    function(uint) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes memory data, <b orange>function(uint) external callback</b>) public {
    requests.push(Request(data, callback));
    emit NewRequest(requests.length - 1);
  }
  function reply(uint requestID, uint response) public {
    // Here goes the check that the reply comes from a trusted source
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); // known contract
  uint exchangeRate;
  function buySomething() public {
    oracle.query("USD", this.oracleResponse);
  }
  function oracleResponse(uint response) public {
    require(
        msg.sender == address(oracle),
        "Only oracle can call this."
    );
    exchangeRate = response;
  }
} 
</td>
_______________________________
<td>
<a xsmall TODO href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3-Secret-Storage-Definition</a>
</td>
_________________________
https://info.binance.com/en/research/marketresearch/img/BinanceResearch-JPMCoin.pdf
_____________________________________
http://blog.notdot.net/2012/08/Damn-Cool-Algorithms-Homomorphic-Hashing
___________________________
https://github.com/trufflesuite/ganache-cli/issues/154
opics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:

[] "anything"
[A] "A in first position (and anything after)"
[null, B] "anything in first position AND B in second position (and anything after)"
[A, B] "A in first position AND B in second position (and anything after)"
[[A, B], [A, B]] "(A OR B) in first position AND (A OR B) in second position (and anything after)"
}}}
_________________________________
https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4
Migrating your Truffle project to Web3 v1.0 (2019-07-13)
_________________
Deed Token: Non fungible token, formilized in ERC-721:
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
______________________________
 
  <span xsmall>TXs in Solidity:</span>
<pre xxxsmall zoom>
addressInstance.balance (uint256): balance in Wei
addressInstance.transfer(uint256 amount): 
    msg.sender →(amount in wei) → addressInstance
    throws on failure 

addressInstance.send(uint256 amount): returns (bool):
    msg.sender ->(amount in wei) ->addressInstance
    returns true/false, does NOT throw an exception

- In addressInstance.transfer (or send), if addressInstance
  is a contract address, its code (more specifically: its fallback function, if present) 
  will be executed together with the transfer call. This is a limitation of the EVM and
  cannot be prevented. <br/>
  If that execution runs out of gas or fails in any way, the Ether transfer will be
  reverted and the current contract will stop with an exception.
</pre>
_____________________
Solidity top questions by votes in ethereum.stackexchange.com:
https://ethereum.stackexchange.com/questions/tagged/solidity?sort=votes&pageSize=15
_____________________
Ethereum Ontologies:
https://media.consensys.net/ethon-introducing-semantic-ethereum-15f1f0696986
-->
</html>
