<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Ethereum Map (beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>
<a href="https://github.com/ethereum/wiki/wiki/White-Paper">White-Paper@Github</a>,
<a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper <a href="https://github.com/ethereum/yellowpaper">Git repo</a>
<a href="https://solidity.readthedocs.io/en/v0.5.0/resources.html">Solidity Resources</a>,
<a TODO href="https://github.com/pirapira/awesome-ethereum-virtual-machine">Ethereum VM</a>,
<a TODO href="https://github.com/ethereum/go-ethereum/tree/master/core/vm">Geth VM</a>,
<table style='width:100%'{>
<tbody>
<tr>
<td>
<pre xxxsmall zoom>
<span xsmall>External</span>
<span xsmall> Links</span>
    @[https://github.com/ethereum/wiki/wiki/Design-Rationale]
    @[https://theethereum.wiki/w/index.php/Main_Page]
    @[https://solidity.readthedocs.io/]
    @[https://ethereum-magicians.org]
    - Solidity top questions@ethereum.stackexchange.com
    @[https://ethereum.stackexchange.com/questions/tagged/solidity?sort=votes&pageSize=15]
    - Enterprise Ethereum Alliance Resources:
    @[https://entethalliance.org/resources/]
    - Curated list of libraries, auditing/secuirity tools, dev tools, security tutorial links,...
    @[https://github.com/bkrem/awesome-solidity]
    - Multipurspose Eth. Ontology
    @[https://media.consensys.net/ethon-introducing-semantic-ethereum-15f1f0696986]
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Who is Who</span>
      
    <a TODO href="https://medium.com/ethex-market/who-are-the-core-devs-of-ethereum-part-i-beb342aaaff0">Who Are The Core Devs of Ethereum? (Part I)</a> 

    - Vitalik Buterin, Ethereum Original Creator.

    - Raul Jordan, Prysmatic labs: Sharding Protocol 
      minimal sharding protocol implementation:
    - DApps and Solidity Development:
      - <a href="https://maraoz.com/">Manuel Araoz</a>: CTO&amp;co-founder at Zeppelin.
      - <a href="http://blog.aragon.one/author/luis/">Luis Cuende</a>: CEO and cofounder of Aragon One

      - Rob Hitchens, author of <a href="https://medium.com/@robhitchens/solidity-crud-part-1-824ffa69509a">Solidity CRUD</a>

      - <a href="https://www.b9lab.com/">b9lab</a> Quality Blockchain Education for everyone</a>
      - Xavier Lepretre, senior consultant at B9Lab

      - <a href="http://blog.notdot.net/">Nick Johnson</a>, Arachnid Labs ("string utils")
          <a href="http://blog.notdot.net/tag/damn-cool-algorithms">Damm Cool Algorithms</a>

      - <a href="https://ethereum.stackexchange.com/users/19510/smarx">Steve Marx</a> and Tood Proebsting:
        Authors of <a href="https://programtheblockchain.com/">programtheblockchain.com</a> with great tutorials about Payment Channels (<a href="https://programtheblockchain.com/posts/2018/12/10/introduction-to-ethereum-payment-channels-video/">1</a>, <a href="https://programtheblockchain.com/posts/2018/02/23/writing-a-simple-payment-channel/">2</a>, <a href="https://programtheblockchain.com/posts/2018/03/02/building-long-lived-payment-channels"/>3</a>

    EEA:
      - Bill Allder: EEA Membership Director
      - Oksana Davis: EEA Chief Legal Counsel and Corporate Secretary

    StackExchange Top users:
    - "Afri" Ethereum FAQ answers on Stackoverflow
      (hidden user from the Parity Team)
      Lastest activity: 2018-08-21
    @[https://ethereum.stackexchange.com/users/87/afri]

    <span xsmall>Companies</span>
- <a href="https://consensys.net/">Consensys</a>:

  - <a href="https://pegasys.tech/">Pegasys</a>: Consensys Company with
    55+ team dedicated to enterprise grade blockchain at ConsenSys. 
    focused on privacy, permissioning, scalability, and other
    features to make Ethereum production-ready.  
    Developers of Pantheon

- <a href="https://kaleido.io/">Kelido.io</a>: SaaS Ethereum/Quorum in AWS, Azure, ...
  - <a href="https://marketplace.kaleido.io/">Marketplace</a>
    - APP+INTEGRATION GATEWAY   : 
    - PUBLIC ETHEREUM TETHER    : Pin state proofs from your private chain to public Ether. networks
    - ETHER POOL                : Enable token economy use-cases without developing your own token
    - BLOCK EXPLORER            : Get more insights through real-time+historical snapshots of your blockchain
    - IDENTITY REGISTRY         : Bind verified digital certificates to org Ether. addresses via on-chain registry
    - IPFS FILE STORE           : Securely store data through a censorship resistant file sharing protocol
    - IDENTITY MASKING HD WALLET: Submit TXs anonymously, mask your identity+manage accounts

- OpenLaw: Create, store and exec legal agreements

- <a href="https://viant.io/">Viant.io</a>: Model Business processes, track assets+build supply chains faster

- <a href="https://www.jpmorgan.com/global/Quorum">(JP Morgan) Quorum:</a>
   - Felix Shnir, Quorum Core, Developer Advocate               (J.P. Morgan)
   - Patrick Nielsen, Quorum and Constellation's Lead Engineer  (J.P. Morgan)
   - Brian Marchiony Head of CIB Marketing &amp; Communications (J.P. Morgan)
   - Amber Baldet Program Lead, Blockchain Center of Excellence (J.P. Morgan)
   - David Voell Engineering Lead, CIB Emerging Technologies    (J.P. Morgan)

- <a href="https://chain.link/">chain.link</a> 
  - smart contracts connected to real world data, events and payments.
  - Chainlink network provides reliable tamper-proof inputs and outputs
    for complex smart contracts on any blockchain. 

</pre>
</td>
<td>
<pre bgorange xxxsmall zoom>
<span xsmall>wei,ether,..</span>
<span xsmall>Units</span>
wei                         :                                1 wei     ← discussion around APIs ...
gwei(shannon|nanoether|nano):                    1.000.000.000 weis    ← gas prices
szabo|microether|micro      :                            1.000 gweis
finney|milliether|milli     :                        1.000.000 gweis   ← micropayments
ether                       :                    1.000.000.000 gweis   ← main unit
kether(grand|einstein)      :                            1.000 ethers 
mether                      :                        1.000.000 ethers
gether                      :                    1.000.000.000 ethers
tether                      :                1.000.000.000.000 ethers
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Network</span>
<span xsmall>Versions</span>
@[https://en.wikipedia.org/wiki/Ethereum#Milestones]
*Public Ethereum Network versions*
Homestead → Metropolis → Serenity →

Homestead : January 2016, ~80% complete 
            block reward set to 5 ether

Metropolis Part 1,Byzantium     : "Ethereum" for the masses.
Metropolis Part 2,Constantinople: Planned. Lay the fundations of PoS(Casper consensus)
 
Serenity  : "last phase", one key principle: switch to proof of stake

<a href="https://www.trustnodes.com/2018/06/16/casper-sharding-merger-confirmed-constantinople-back-table">2018/06/17 Casper and sharding merger confirmed</a>
</pre>
</td>
<td colsep></td>
<td>
<pre xxxsmall zoom>
<span xsmall>Accounts</span>
@[http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html]
 *Account*  ← same address space both for contract and normal accounts
┌──────────────────┐           ┌──────────────────────────────────────┬───────────────────────────────────────┐
│bytes[32]*address*│           │   EXTERNALLY OWNED ACCOUNT           │          CONTRACT ACCOUNTS            │
├──────────────────┤┌──────────┼──────────────────────────────────────┼───────────────────────────────────────┤
│wei      *balance*││CREATION  │→ Generate random 32bytes private key │→Create smart-contract source code  *1 │
├──────────────────┤│          │→ Generate Pub.Key from Priv.Key      │→Generate bytecode by compiling source │
│Map˂256b,256b˃    ││          │→ Generate public address as:         │→Send "Contract Creation" TX for mining│
│         *storage*││          │  bytes[32] pub.addr = hash(pub.addr) │→keep Contract address once "published"│
└──────────────────┘│          │                                      │ (determined from nonce)               │
                    ├──────────┼──────────────────────────────────────┼───────────────────────────────────────┤
                    │CONTROLLED│Private Key: Only the (human) owner of│ BYTECODE                              │
                    │BY        │the *secret* private key can decrease │                                       │
                    │          │the balance by signing a new TX       │                                       │
                    ├──────────┼──────────────────────────────────────┼───────────────────────────────────────┤
                    │FEATURES  │ bytes[32] address                    │ bytes[32] address *1                  │
                    │          │                                      │ Map˂256b,256b˃ storage *2             │
                    └──────────┴──────────────────────────────────────┴───────────────────────────────────────┘
 *2: account.storage: Persistent memory area 
     - It is not possible to enumerate storage from within a contract
     - It is comparatively costly to read and even more so, to modify storage
       in the context of an (update state) TX. (It's still free of cost during
       external query calls).
     - A contract can neither read nor write to any storage apart from its own
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Message Calls</span>
Message Calls
-------------
sender
target(can be==sender)
payload
ether
gas
return data
- Contracts can user message calls to call other contracts or send Ether to
 non-contract accounts.
 Every transaction consists of a top-level message call which in turn can 
 create further message calls.
 Contracts can decide how much of its remaining gas should be sent with the
 inner message call and how much it wants to retain. If an out-of-gas 
 exception happens in the inner call (or any other exception), this will be
 signalled by an error value put onto the stack. In this case, only the gas
 sent together with the call is used up. In Solidity, the calling contract 
 causes a manual exception by default in such situations, so that exceptions
 "bubble up" the call stack.
 Calls depth is limited to 1024 (Loops must be used over recursive calls)<br/>
 After finished execution, contracts can return data stored at a 
 preallocated location in the caller’s memory.

- Delegatecall (See libraries): Special variant of a message call, is 
 identical to a message call apart from the fact that the code at the target
 address is executed in the context of the calling contract and msg.sender 
 and msg.value do not change their values.
 This means that a contract can dynamically load code from a different 
 address at runtime.
- Storage, current address and balance still refer to the calling contract, 
  only the code is taken from the called address.
  This makes it possible to implement the “library” feature in Solidity:
  Reusable library code that can be applied to a contract’s storage in order 
  to e.g. implement a complex data structure.
</pre>
</td>  
<td>
<pre xxxsmall zoom>
  <span xsmall>EVM Summary</span>
- TODO: EVM Illustrated
  @[https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf]
- TODO: Awesome EVM list:
@[https://github.com/pirapira/awesome-ethereum-virtual-machine]

 *Opcodes:*
@[https://github.com/crytic/evm-opcodes]
- EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.
- Persistent storage is quite expensive.
- The Solidity compiler makes interesting choices in order to minimize gas usage.

- To interact with a Smart Contract, you send it raw bytes.
- It does some computation, possibly changing its own state, 
  and then sends you raw bytes in return. 
- Method calling does not actually exist. It is a collective 
  illusion created by the ABI.
- The ABI is specified like a low-level format, but in function
  it's more like a serialization format for a cross-language RPC framework.
- We could draw analogies between the architectural tiers of DApp and Web App:
  - The blockchain is like the backing database
  - A contract is like a web service
  - A transaction is like a request
  - ABI is the data-interchange format, like Protocol Buffer


*EVM Events:*
 - In the wild, there are three main uses for event logs:
   - As ersatz return values, because a transaction does not record a method's return values.
   - As a kind of cheaper alternative data storage, as long as the contract does not need access to it.
   - Events that DApp clients can subscribe to.
 - Event logging map to EVM logging primitives.
   event Deposit( address indexed _from, bytes32 indexed _id, uint _value);
 -*Event limitations*:
   - There may be at most 3 indexed parameters.
   - If the type of an indexed parameter is larger than 32 bytes, 
     only the KECCAK256 digest of the data is stored.
 -  EVM Log Primitives
   - log0, log1, ..., log4 EVM instructions.
 - The EVM logging facility uses different terminologies than Solidity:
   "topics": There may be up to 4 topics exactly 32 bytes each
            Solidity consumes one topic for the event's signature so only 3 are available
   "data"  : Payload of the event. It may be arbitrary number of bytes

 - Bloom filters are used to speed up search-by-topic

*EVM Memory:
- A contract obtains a freshly cleared instance for each message call
- Memory is linear and can be addressed at byte level
- <b>Reads are limited to a width of 256 bits</b>
- <b>Writes can be either 8 bits or 256 bits wide</b>
- Memory is expanded by a word (256-bit), when accessing 
    (either reading or writing) a previously untouched memory word (ie.
    any offset within a word). At the time of expansion, the cost in gas 
    must be paid. Memory is more costly the larger it grows (it scales
    quadratically)
- calldata: Separate area of memory whe message call payload is placed

*EVM Stack:*
- EVM memory area list of 256bits up to 1024 elements used for computations
- The 16 topmost elements can be moved to the top or swaped wih the top element
- All other operations take the topmost one (or two, or more) elements and push
  the result onto the stack
- top elements can be moved to/from storage/memory, but deeper elements can
  be accessed without first removing elements on top of them.

- (EVM)full computational state: can be defined by the tuple:
  (block_state, transaction, message, code, memory, stack, pc, gas)
  block_state = global state = all accounts (balances + storage)

- selfdestruct(target): Destructor for contract @ address
  - Remaining Ethers are sent to target
  - storage &amp; code are removed from the blockchain state
<span xsmall>Instructions</span>
@[https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go]
The all take  (in to go VM implementation) next parameters:
(pc *uint64, i*EVMInterpreter, c*Contract, mem*Memory, stack *Stack)
and return ([]byte, error)
 1 opAdd        11 opLt      21 opAddmod  31 opCallValue      41 opExtCodeHash 51 opMstore   61 opCreate      
 2 opSub        12 opGt      22 opMulmod  32 opCallDataLoad   42 opGasprice    52 opMstore8  62 opCreate2     
 3 opMul        13 opSlt     23 opSHL     33 opCallDataSize   43 opBlockhash   53 opSload    63 opCall        
 4 opDiv        14 opSgt     24 opSHR     34 opCallDataCopy   44 opCoinbase    54 opSstore   64 opCallCode    
 5 opSdiv       15 opEq      25 opSAR     35 opReturnDataSize 45 opTimestamp   55 opJump     65 opDelegateCall
 6 opMod        16 opIszero  26 opSha3    36 opReturnDataCopy 46 opNumber      56 opJumpi    66 opStaticCall  
 7 opSmod       17 opAnd     27 opAddress 37 opExtCodeSize    47 opDifficulty  57 opJumpdest 67 opReturn      
 8 opExp        18 opOr      28 opBalance 38 opCodeSize       48 opGasLimit    58 opPc       68 opRevert      
 9 opSignExtend 19 opXor     29 opOrigin  39 opCodeCopy       49 opPop         59 opMsize    69 opStop        
10 opNot        20 opByte    30 opCaller  40 opExtCodeCopy    50 opMload       60 opGas      70 opSuicide     
     
*following functions are used by the instruction jump  table */
// make log instruction function
makeLog(size int)
opPush1
makePush(size uint64, pushByteSize int)
makeDup(size int64)  // make dup instruction function
makeSwap(size int64) // make swap instruction function
</pre>
</td>  
<td>  
<pre xxxsmall zoom>
<span xsmall TODO>ABI Spec</span>
Full reference:@[https://solidity.readthedocs.io/en/latest/abi-spec.html/]

- The encoding is not self describing and thus requires a schema in order to decode.
- Interface functions of a contract are strongly typed
  (known at compilation time and static)
- All contracts will have the interface definitions of any contracts they call available at compile-time.
- Data is encoded according to its type

˂b˃FUNCTION SELECTOR:˂/b˃
- Keccak-256(hash-of-function-signature)[0,1,2,3]
                     ^------+---------^  ^^^^^^^
                            |            first 4 bytes of keccak256
                            |
                   - canonical expression of the 
                     basic prototype without data
                     location specifier :=
                     funct.name with the parenthesised
                     list of parameter types split by a
                     single comma (spaces removed).
                   - Return type is *NOT* part of sign.
                     → No overriding by return type allowed.
                     (this help to keep function call 
                      resolution context-independent)

˂b˃ARGUMENT (and return value) ENCODING:˂/b˃
- Starting from fifth byte

- <b>ELEMENTARY TYPES</b>:
  - uint˂M˃ : unsigned                integer type of 8,16,24,...256 bits,
  -  int˂M˃ : two's complement signed integer type of 8,16,24,...256 bits,
  - address : typed uint160 (function selector uses address not uint160)
  - bool    : typed uint8 restricted to values 0, 1.
  -  fixed˂M˃x˂N˃: "M / (10 ** N)" value signed fixed-point decimal number 
                   M bits from 8,16,...256
                   N bits from 0,8,...80
  - ufixed˂M˃x˂N˃: unsigned variant of fixed˂M˃x˂N˃.
  - fixed,   : synonyms for fixed128x18, ufixed128x18 respectively.
    ufixed  
  - bytes˂M˃: binary type of M bytes, 0 ˂ M ˂= 32.
  - function: an address (20 bytes) followed by a function selector (4 bytes). 
              Encoded identical to bytes24.

- <b>(fixed-size) array</b>:
  ˂type˃[M]: a fixed-length array of M elements, M ˃= 0, of the given type.

- <b>non-fixed-size types exist</b>:
  - bytes   : dynamic sized byte sequence
  - string  : dynamic sized unicode string assumed to be UTF-8 encoded
  - ˂type˃[]: a variable-length array of elements of the given type

- <b>tuple:</b> (or tuples of tuples, arrays of tuples,...)
  - (T1,T2,...,Tn): tuple consisting of the types T1, …, Tn, n ˃= 0

- <b>Mapping Solidity to ABI types:</b>
Solidity     ABI Type 
contract     address
enum         smallest uint type large enough to hold all values
struct       tuple

<b>Formal Specification of the Encoding</b>
- We distinguish two types:
  - static : encoded in-place.
  - dynamic: encoded at a separately allocated location after the current block.
             - bytes 
             - string
             - T[] for any T
             - T[k] for any dynamic T and any k ˃= 0
             - (T1,...,Tk) if Ti is dynamic for some 1 ˂= i ˂= k

- Definitions: 
  - len(a) :  (uint256) number of bytes in a binary string a
  - enc    :  actual encoding binary string:
              ABI_type_Value → enc(ABI_type_Value)
                               ^^^^^^^^^^^^^^^^^^^
                           len(enc(ABI_type_Value)) depends on:
                               - ABI_type_Value if type of ABI_type_Value is dynamic.
                               - ABI_type       if type of ABI_type_Value is  static.

<b>Examples</b>

Given the contract:

pragma solidity ˃=0.4.16 ˂0.7.0;

contract Foo {
  function bar(bytes3[2] memory) public pure {}
  function baz(uint32 x, bool y) public pure returns (bool r) { r = x ˃ 32 || y; }
  function sam(bytes memory, bool, uint[] memory) public pure {}
}

Function call to FooInstance.baz(69, true)
                                                            0xcdcd77c0: the Method ID. 4 bytes of Keccak("baz(uint32,bool)")
    0x0000000000000000000000000000000000000000000000000000000000000045: uint32 "   69-value" left-padded
    0x0000000000000000000000000000000000000000000000000000000000000001: uint32 " true-value" left-padded

Function return:
    0x0000000000000000000000000000000000000000000000000000000000000000: uint32 "false-value" left-padded


Function call to FooInstance.bar("abc", "def")
                                                            0xfce353f6: the Method ID. 4 bytes of Keccak("bar(bytes3[2])")
    0x6162630000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned
    0x6465660000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned

Function call to FooInstance.dave("dave", true and [1,2,3])
                                                            0xa5643bf2: the Method ID. 4 bytes of Keccak(sam(bytes,bool,uint256[]))
    0x0000000000000000000000000000000000000000000000000000000000000060: location of data-part of  first *dynamic-type* parameter
                                                                        measured in bytes from the start of the arguments block.
    0x0000000000000000000000000000000000000000000000000000000000000001: boolean true
    0x00000000000000000000000000000000000000000000000000000000000000a0: location of data-part of  first   *third-type* parameter
                                                                        measured in bytes from the start of the arguments block.
                                                                        first dynamic-argument:
    0x0000000000000000000000000000000000000000000000000000000000000004: length of the byte array in elements
    0x6461766500000000000000000000000000000000000000000000000000000000: contents of the first argument
                                                                        second dynamic-argument:
    0x0000000000000000000000000000000000000000000000000000000000000003: length of the array in element
    0x0000000000000000000000000000000000000000000000000000000000000001: - first entry
    0x0000000000000000000000000000000000000000000000000000000000000002: - second entry
    0x0000000000000000000000000000000000000000000000000000000000000003: - third entry


<b>Events ABI Encoding</b>
- Log entries provide the contract's address,
- Up to four topics 
- some arbitrary length binary data.
 
Given an event name and series of event parameters, we split them into two sub-series:
 - indexed     parameters: used in Keccak-event-signature to form the topics of the log entry.
 - non-indexed parameters: byte array of the event.

In effect, a log entry using this ABI is described as:
 - contract_address (emiting the event)

 - topics[0]: keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")") 

 - topics[n]: abi_encode(EVENT_INDEXED_ARGS[n - 1])
                         ^^^^^^^^^^^^^^^^^^        
                       EVENT_ARGS that are indexed

 - data     : ABI encoding of EVENT_NON_INDEXED_ARGS 
             

- if type-byte-length ˂= 32 → value padded/sign-extended          to 32 bytes is included 
- if type-byte-length ˃  32 → Keccak hash of a special in-place encoded value is included<b>
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                   
                         - This allows applications to efficiently query for keyccak(value) of dynamic-length types
                           but leaves applications unable to decode indexed values they have not queried for
                         - Use the same dynamic value repeated in index and non-index event fields for full functionallity.</b>
</pre>
</td>   
<td>
<pre xxxsmall zoom>
<span xsmall>*Transactions*</span>
Transaction
-------------
address sender
target
payload        "message" sent from src. account to a target (account or code)
wei ether

wei gasPrice
wei gas

return data


- Note that a TX in blockchain is an intention to modify the state of the ddbb.
  It's up to the consensus algorithm to decide when and/or whether the TX will
  be accepted:
  transaction.target := address | code | "zero-account"

if target == code 
   → code is executed
      input data = transaction.payload 
if target == "zero.." 
   → step 1: new contract created
     step 2: transaccion.payload is executed 
     step 3: exec. output stored as contract.code
     (→ trans.payload == code factory of contract code)

- transaction.ether: Price in Wei of one unit of gas, in which VM operations are priced.
- The product of gasPrice and gas represents the maximum amount of Wei we are 
  willing to pay for executing the transaction. gasPrice is used by miners to 
  rank transactions for inclusion in the blockchain. 

- transaction.gas: Its purpose is to limit the amount of work needed to execute the transaction 
  and to pay for this execution.
- transaction creator (sender?) chooses the gas to pay.
    - If execution gas < transaction.gas => Refund to sender
    - If execution gas > transaction.gas => out-of-gas exception triggered
        (reverts all modifications made to the state in current call frame)

- nonce: increasing numeric value which is used to uniquely identify transactions.
  A nonce can only be used once and until a transaction is mined, it is possible
  to send multiple versions of a transaction with the same nonce, however, 
  once mined, any subsequent submissions will be rejected.
  A repeated nonce can be used to overwrite a pending TX.

<b>block validation algorithm (Consensus)</b>
- Check if the previous block referenced exists and is valid
- Check that the timestamp of the block is greater than that of the referenced previous
  block and less than 15 minutes into the future.
- Check that the block number, difficulty, transaction root, uncle root and gas limit 
  (various low-level Ethereum-specific concepts) are valid.
- Check that the proof of work on the block is valid
- Let S[0] be the STATE_ROOT of the previous block
- Let TX be the block's transaction list, with n transactions. For all "i" in 
  0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any applications returns an error, or
  if the total gas consumed in the block up until this point exceeds the GASLIMIT, 
  return an error
- Let S_FINAL be S[n], but adding the block reward paid to the miner
- Check if S_FINAL is the same as the STATE_ROOT. If it is, the block is valid;
      otherwise, it is not.
- Note: coinbase: In a mining node indicates the address where rewards will go.
  Must be set to an account owned by miner

<span xsmall>TX Signing</span>
REF:
@[https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3]
@[https://github.com/ethereum/EIPs/issues/191]

What are the v, r, s values for the TX's signature?
- r and s are outputs of an ECDSA signature
- v is the recovery id.
<a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">Bitcoin REF</a> 
  applies also to Ethereum. Ethereum makes further adjustments to v, as explained in 
<a href="https://github.com/ethereum/EIPs/issues/155">EIP 155</a>, to prevent replay attack.

ecrecover Solidity Global Crypto Funct:
ecrecover (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address): recover the address associated with the public key 
                     from elliptic curve signature or return zero on error

</pre>
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>

<td>
<pre xxxsmall zoom>
<span xsmall>Gas Price</span>
<span xsmall>TX Price</span>
- Gas (defined in the [Ethereum-Yellow-Paper]) is a virtual pricing
  mechanism for transactions andsmart contracts that is implemented 
  by Ethereum to protect against Denial of Service attacks and
  resource-consumption attacks by compromised, malfunctioning or 
  malicious nodes.
  (Enterprise Ethereum provides additional tools to reduce security
   risks, such as more granular permissions foractions in a network).
  REF:
  Gas rationale:
  @[https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees]
  Instruction cost
  @[https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30]"
- Price cost applies to public network and (optionally)
  to private/consortium networks.
- Notic private/consortium networks will still be constrained to
  gas limits per TX and/or block even if the gas price is ZERO.
  TXs will fail if the consume too much gas ("CPU" or storage)
  but users will not loose any ethers in this case.
The most expensive operations by far are storage usage:
- sstore costs 20000 gas for first write to a new position
- sstore costs  5000 gas for subsequent writes to an existing position
- sload  costs   500 gas
- Most instructions costs 3~10 gases.
- Gas costs are set somewhat arbitrarily, and could well change in 
  the future. As costs change, compilers would make different choices.

TX cost: <a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603">REF</a>
- 21000 paid for every transaction.
-     4 paid for every zero byte of data or code for a transaction.
-    68 paid for every non-zero byte of data or code for a transaction.

- Small negative numbers are mostly 1s, costing you quite a lot of gas.

Logging Gas Costs:  <a href="https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9">REF</a>
  - The gas costs for the logging primitives depends on how many topics you have and how much data you log:
    (constants are defined in protocol_params)

LogDataGas       uint64 = 8   // Per byte in a LOG operation's data
topicLogTopicGas uint64 = 375 // Per LOG 
LogGas           uint64 = 375 // Per LOG operation
MemoryGas        uint64 = 3    // Per byte of memory used

If you are passing in the log data as calldata to a TX,
you’ll need to pay for the transaction data too. The gas costs for calldata are:

TxDataZeroGas      uint64 = 4     // zero tx data abyte
TxDataNonZeroGas   uint64 = 68    // non-zero tx data byte

Assuming all 32 bytes are non-zero, this is still a lot cheaper than storage:

// cost of 32 bytes of log data
32 * 68 = 2176 // tx data cost
32 *  8 =  256 // log data cost
32 *  3 =   96 // memory usage cost
375 // log call cost
----
total (2176 + 256 + 96 + 375) ~14% of sstore for 32 bytes
Most of the gas cost is actually spent on transaction data, not for the log operation itself

The reason that a log operation is cheap is because the log data isn’t really 
stored in the blockchain. Logs, in principle, can be recalculated on the fly
as necessary.

Miners, in particular, can simply throw away the log data, because future 
calculations can't access past logs anyway.

The network as a whole does not bear the cost of logs. 
Only the API service nodes need to actually process, store, and index the logs.

So the cost structure of logging is just the minimal cost to prevent log spamming.

Extracted from stack-overflow:
   Q: """The price of ETH has gone from ~8 USD/ETH to ~90 ETH/USD in 6 months,
      but when I view transactions on the blockchain (example), I see that most
      people are still using the default gas price of 2e10 wei/gas. Shouldn't
      we be lowering the gas prices on our transactions to account for this 
      price change? 
      I have built a Dapp where low transaction fees are an important selling
      point. I intend to drop
      my gas price to 5e9 (a 75% reduction). Will my transactions still clear 
      in a timely fashion?"""
   A: """Absolutely. Everyone should. There's a great site here that will help
     you understand gas and gas prices.
     It's called Ethereum Gas Station: http://ethgasstation.info/
      They just recently made this post which explains something they call the
     Safe Gas Price:
     https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91"""


(Interesting "offtopic") See Wikipedia entries on:
  </li>
  </ul>
<pre xxxsmall zoom>
<a href='http://ethgasstation.info/calculator.php'>eth gas station calc</a>
Gas (defined in the [Ethereum-Yellow-Paper]) is a virtual pricing mechanism for transactions andsmart contracts that is implemented by Ethereum to protect against Denial of Service attacks andresource-consumption attacks by compromised, malfunctioning or malicious nodes. EnterpriseEthereum provides additional tools to reduce security risks, such as more granular permissions foractions in a network.
200€/ether:
Transaction gas price: 21000 gas/tx       32bytes Contract storage: 20000 gas
+----------+-----------------+--------+   +----------+-----------------+--------+
| gasprice | total gas price | total €|   | gasprice | total gas price | total €|
+----------+-----------------+--------+   +----------+-----------------+--------+
|  1gwei   | 21000 *  1gwei  | 0,0042 |   |  1gwei   | 21000 *  1gwei  | 0,0040 |
| 20gwei   | 21000 * 20gwei  | 0,0420 |   | 20gwei   | 21000 * 20gwei  | 0,0400 |
+----------+-----------------+--------+   +----------+-----------------+--------+

For a transaction updating 64bytes (32bytes from debitor account to 32bytes creditor account)
+----------+-----------+
| gasprice | total € *1|
+----------+-----------+
|  1gwei   |   0,0122  |
| 20gwei   |   0,2440  |
+----------+-----------+

Logs cost: 375 gas for a LOG operation + 8 gas per log data byte + 375 gas for each topic. 200€/eth:

+----------+-----------+----------+--------------------+------------
|log  size | num.topics| gasprice | total gas price*1  |     total €
+----------+-----------+----------+--------------------+------------
|1024bytes |     3     |   1gwei  |  9692 *  1gwei     | 0,0019384 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0011192 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0005596 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0002798 €
+----------+-----------+----------+--------------------+------------
|          |           |  20gwei  |  9692 * 20gwei     | 0,0387680 €
| 512bytes |     3     |   1gwei  |  5596 *  1gwei     | 0,0223840 €
| 256bytes |     1     |   1gwei  |  2798 *  1gwei     | 0,0111920 €
| 128bytes |     0     |   1gwei  |  1399 *  1gwei     | 0,0055960 €
+----------+-----------+----------+--------------------+------------

(375 gas/LOG * 1LOG ) + (8 gas/byte * 1024byte) + (375 gas/topic * 3 topic) = 375 + 8192 + 1125 = 9692
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 3 topic) = 375 + 4096 + 1125 = 5596
(375 gas/LOG * 1LOG ) + (8 gas/byte *  512byte) + (375 gas/topic * 1 topic) = 375 + 2048 +  375 = 2798
(375 gas/LOG * 1LOG ) + (8 gas/byte *  128byte) + (375 gas/topic * 0 topic) = 375 + 1024        = 1399    
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall>Calls vs TXs </span>
        CALLS:                                               TRANSACTIONS

invoque a read-only smart-contract function          invoque a write smart-contract function 
and return a value, but nothing is mined or          that changes the global status in all nodes.
verified by the consensus. It can be executed        
on a local ethereum node and return fast             Each TX must  be verified by the consensus 
(synchronously).                                     before being accepted (only TXs in longest
                                                     chains, correct hashes, ...)
                                                       The (non-mined) TX must be propagated
                                                     until reaching some miner node in the network
                                                     that will add it to the lastest block on 
                                                     the chain (passing to "mined state").
                                                     - TX expends gases and CAN NOT return any
                                                     value (since it's not possible to known
                                                     in advance when the TX will be executed by
                                                     the network consensus or in the case of
                                                     public network whether it will be executed
                                                     at all).
                                                     - Clients sending a TX to the network need
                                                     to listen for asyncrhonous events to know
                                                     the result of the TX (or an error associated
                                                     to the TX)
   
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>State transition fun</span>
APPLY (S, TX) → S'  ← S : initial global state
                    ← S': final   global state
 can be defined as follows:
- Check if incomming TX is well-formed (right number of values),
  signature is valid, and the nonce matches the nonce in the
  sender's account.  Return an error otherwise.
- Calculate the transaction fee as STAR_GAS * GAS_PRICE, and 
  determine the sending address from the signature. Subtract the
  fee from the sender's account balance and increment the 
  sender's nonce. If sender's balance &lt; fee, return an error.
- Initialize GAS = STARTGAS, and take off a certain quantity 
  of gas per byte to pay for the bytes in the transaction.
- Transfer the TX value from the sender's account to the
  receiving account.  If the receiving account does not yet
  exist, create if. If the receiving account is a contract,
  run the contract's code either to completion or until the
  execution runs out of gas.
- If the value transfer failed because the sender did not have
  enough money, or the code execution ran out of gas, revert 
  all state changes except the payment of the fees, and add 
  the fees to the miner's account
- Otherwise, refund the fees for all remaining gas to 
  the sender, and send the fees paid for gas consumed to the
  miner.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Offline vs</span>
<span xsmall> Online TX</span>
<span xsmall>  TX sign.</span>
    OFFLINE TX SIGNING (RECOMENDED)           |    "ON-LINE" TX SIGNING (LESS SECURE, DISCOURAGED)
                                              | 
The "raw" TX must be signed first             | - An Ethereum node (geth, parity,...) will be used.
by an offline (js,python,hardware wallet,...) | - It forces to have the wallet on the client node and 
client using a private key ("wallet")         |   unlock the account. Unless the wallet is hardware
with or without connection to any ethereum    |   secured is usually less safe than client signature
network node.                                 |   (but offline clients can also be insecure or
The signed TX is then sent to the network.    |   hacked)
</pre>
</td>  
<td>
<pre xxxsmall zoom>
<span xsmall bgorange>Events &amp; LOGS</span>
BEST PATTERNS:
- External clients must be able to restore current contract state
  by just reading events.
- Ethereum can return just a very limited information in each
  read-only query. (Up to 7 fields). That means that reports and
  data-analysis must be done on event logs.
- Contract/s state/s must be consulted only by code originated by
  a new transaction trying to update the current state.

- Logs: It is possible to store data in a specially indexed data structure 
  that maps all the way up to the block level.<br/>
  This feature called 'logs' is used to implement events.</li>
- Contracts *CAN NOT* access log data after it has been created, but they 
  can be efficiently accessed from outside the blockchain. <br/>
  Since some part of the log data is stored in bloom filters,
  it is possible to search for this data in an efficient and cryptographically 
  secure way, so network peers that do not download the whole blockchain 
  ("light clients") can still find these logs.</li>
- Logs were designed to be a form of storage that costs significantly 
  less gas than contract storage:
  Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes. 
  Up to 3 parameters can be indexed.

<b>Event Limits:</b>
- Up to 3 indexed fields.
- Up to 7 fields (indexed + non-indexed fields)
- The size limit of one event is a function of the block's gas limit, 
  ~ 3_145_192 (first seven digits of pi * 2)
  With a gas costs of 76 gas per byte limit is about 41kb per log event.
  REF: <a TODO href="http://jonathanpatrick.me/blog/ethereum-compressed-text"> Storing compressed text in Ethereum transaction logs</a>
  
<b>Solidity code:</b> 
event EventDepositLog(  
    uint256 indexed _market,  ← Up to 3 indexes
    address indexed _sender,    Strings, arrays can *NOT* be used in indexes 
    uint256 _amount,            (will be automatically replaced by its hash)
    uint256 _time);

<b>JS Client Log monitoring:</b>
var myEventMonitor = 
  myContract.MyEventNameLog(
     {_sender: userAddress },           // ← filter by idx sender
     {fromBlock: 0, toBlock: 'latest'}  // ← filter by block range*1
  );                                         if ommited observe
                                             "real-time" events

myEventMonitor.watch(                  // ← Start watching
  (err, result) => {
    if (err) { ...    return; }
    console.log(
         "_market:"+result.args._market
       + "_sender:"+result.args._sender );
  }
)
....
myEventMonitor.stopWatching()          // ← Stop watching
</pre>
</td>  
<td colsep></td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>Ethereum Name Service</span>
@[https://ens.domains/]
"""No more long addresses: ENS eliminates the need to copy - and worse,
   type - long hexadecimal addresses ...
   you'll be able to:
   - send money to 'aardvark.eth' instead of '0x4cbe58c50480...', 
   - interact with your favorite contract at 'mycontract.eth'
   - visit a Swarm-hosted site at 'swarmsite.eth'. """

<b>Ext. Links</b>              
- <a TODO href="https://github.com/ethereum/EIPs/issues/137">EIP137</a> - Ethereum Name Service
- <a TODO href="https://github.com/ethereum/EIPs/issues/137">EIP137 issues</a>
- <a TODO href="https://github.com/ethereum/EIPs/issues/162">EIP162</a> - Initial ENS Registrar Specification
- <a TODO href="https://www.npmjs.com/package/ethereum-ens">ethereum-ens</a> Javascript library
  Nick’s talk on ENS at DevCon 2: <a href="https://www.youtube.com/watch?v=pLDDbCZXvTE">https://www.youtube.com/watch?v=pLDDbCZXvTE</a>
- <a TODO href="https://arachnid.github.io/devcon2/#/title">DevCon 2 talk slides</a>
- <a TODO href="https://registrar.ens.domains">https://registrar.ens.domains</a>
- <a TODO href="https://docs.ens.domains/en/latest/userguide.html">ENS User Guide</a>,
- <a TODO href="https://github.com/ethereum/go-ethereum/tree/master/contracts/ens">Geth implementation</a>

GOAL: resolve human-readable names to Ethereum addresses, Swarm/IPFS hashes, ....
      provide also metadata about names (contracts ABIs, whois info,...)</li>
- ENS operates on a system of <b orange>dot-separated hierarchial names called domains</b>, 
  with the owner of a domain having full control over the distribution of subdomains.

- Top-level domains (.eth, .test,...) owned by 'registrars' smart contracts
  Anyone may, by following the rules imposed by these registrar contracts, 
  obtain ownership of a second-level domain for their own use.

- Secure: ENS is built on smart contracts on the Ethereum blockchain, meaning
  it doesn't suffer from the insecurity of the DNS system.  You can be confident
  names you enter work the way their owner intended.

- Truly Distributed: ENS operates in a distributed fashion for both its infrastructure
  and governance. Anyone can register a .eth domain name for themselves by participating
  in an auction process, mediated by the blockchain.

<b>TERMINOLOGY</b>
  - domain     : complete, human-readable form of a name; eg, ‘vitalik.wallet.eth’
  - label      : a single component of a domain; eg, ‘vitalik’, ‘wallet’, or ‘eth’
  - label hash : keccak-256(label) eg, keccak256(‘eth’) =
                 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0
  - node       : namehash function output used to uniquely identify a name in ENS


<b>Ex. JS Client code to register</b> <a href="https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial">REF</a> 
  
| var name = "MyPersonalDemocracy"
| registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
| var democracy = eth.contract(daoCompiled.Democracy.info.abiDefinition).
|                 at(democracy.address);
| democracy.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})
| 
| (Wait for the previous transactions to be picked up and then)
| 
| registrar.setAddress.sendTransaction(name, democracy.address, true,{from: eth.accounts[0]});

<span xsmall>Architecture</span>
DOMAIN            | REGISTRY CONTRACT                  | RESOLVER(S) INTERFACE
------            | -----------------                  | ---------------------
- owner (address) | - owned (sub)domains list          | translate name → address
- resolver        | ----------------                   +-------------------------
- time-to-live    | + issues subdomains to users  *1 
  for all records |   following logic in contract *1   | RECORD:
                  | + Set resolver+TTL for domain *1   | -------
                  | + Transfer ownership               | - type: (Ethereum address, Swarm content hash, ...)
                  | *1 Only owner of affected domain   |          New record types may be defined via EIP
                                                       |          with no need to make changes to the registry or resolvers
                                                       |
                                                       | - Namehash: 32-byte hash of name (compaq storage+privacy)
                                                       |             defined recursively to preserve the hierarchal nature
                                                       | ----------
                                                       | - Iface method/s to be implemented by resolver
                                                       |    in order to provide records of that kind.

*MainNet/... Deployments*
General-purpose resolver implementations are offered for users whose requirements are straightforward, 
such as serving an infrequently changed address for a name.

  MAINNET DEPLOYMENT: 0x314159265dd8dbb310642f98f50c066173c1259b
                      users may register names under the eth TLD using an auction based registrar.
  ROPSTEN 
  TESTNET DEPLOYMENT: 0x112234455c3a32fd11230c42e7bccd4a84e02010
                      users may register names under two top level domains:
                      .eth , auction based 
                      .test, allows anyone to claim an unused name for test purposes expiring after 28 days
  RINKEBY
  TESTNET DEPLOYMENT: 0xe7410170f87102df0055eb195163a03b7f2bff4a
                      .test supported
</pre>

</td>
</tr>
</table>

<hr xsmall />
<table>
<tr>
<td title>
Solidity<br/>
<a xsmall bggreen href='https://remix.ethereum.org/#'>[REMIX-IDE]</a><br/>
<a xsmall bggreen href='https://ethfiddle.com/'      >[ethfiddle.com]</a><br/>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>External Links</span>
@[https://remix.ethereum.org/#]   Online IDE 
@[https://ethfiddle.com/]
@[https://solidity.readthedocs.io/en/develop/]
@[https://solidity.readthedocs.io/en/latest/solidity-in-depth.html]
@[https://github.com/ConsenSys/smart-contract-best-practices']
</pre>
</td>
<td>
<pre  xxxsmall zoom>
<span xsmall>Grammar</span>
<span xsmall>summary</span>
REF: <a href='https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt'>https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt</a>
SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*

// Pragma actually parses anything up to the trailing ';' to be fully forward-compatible.
PragmaDirective = 'pragma' Identifier ([^;]+) ';'

ImportDirective = 'import' StringLiteral ('as' Identifier)? ';'
        | 'import' ('*' | Identifier) ('as' Identifier)? 'from' StringLiteral ';'
        | 'import' '{' Identifier ('as' Identifier)? ( ',' Identifier ('as' Identifier)? )* '}' 'from' StringLiteral ';'

ContractDefinition = ( 'contract' | 'library' | 'interface' ) Identifier
                     ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                     '{' ContractPart* '}'

ContractPart = StateVariableDeclaration | UsingForDeclaration
             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition

InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )* ')' )?

StateVariableDeclaration = TypeName ( 'public' | 'internal' | 'private' | 'constant' )* Identifier ('=' Expression)? ';'
UsingForDeclaration = 'using' Identifier 'for' ('*' | TypeName) ';'
StructDefinition = 'struct' Identifier '{'
                     ( VariableDeclaration ';' (VariableDeclaration ';')* ) '}'

ModifierDefinition = 'modifier' Identifier ParameterList? Block
ModifierInvocation = Identifier ( '(' ExpressionList? ')' )?

FunctionDefinition = 'function' Identifier? ParameterList
                     ( ModifierInvocation | StateMutability | 'external' | 'public' | 'internal' | 'private' )*
                     ( 'returns' ParameterList )? ( ';' | Block )
EventDefinition = 'event' Identifier EventParameterList 'anonymous'? ';'

EnumValue = Identifier
EnumDefinition = 'enum' Identifier '{' EnumValue? (',' EnumValue)* '}'

ParameterList = '(' ( Parameter (',' Parameter)* )? ')'
Parameter = TypeName StorageLocation? Identifier?

EventParameterList = '(' ( EventParameter (',' EventParameter )* )? ')'
EventParameter = TypeName 'indexed'? Identifier?

FunctionTypeParameterList = '(' ( FunctionTypeParameter (',' FunctionTypeParameter )* )? ')'
FunctionTypeParameter = TypeName StorageLocation?

// semantic restriction: mappings and structs (recursively) containing mappings
// are not allowed in argument lists
VariableDeclaration = TypeName StorageLocation? Identifier

TypeName = ElementaryTypeName
         | UserDefinedTypeName
         | Mapping
         | ArrayTypeName
         | FunctionTypeName
         | ( 'address' 'payable' )

UserDefinedTypeName = Identifier ( '.' Identifier )*

Mapping = 'mapping' '(' ElementaryTypeName '=>' TypeName ')'
ArrayTypeName = TypeName '[' Expression? ']'
FunctionTypeName = 'function' FunctionTypeParameterList ( 'internal' | 'external' | StateMutability )*
                   ( 'returns' FunctionTypeParameterList )?
StorageLocation = 'memory' | 'storage' | 'calldata'
StateMutability = 'pure' | 'view' | 'payable'

Block = '{' Statement* '}'
Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |
            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |
              Throw | EmitStatement | SimpleStatement ) ';'

ExpressionStatement = Expression
IfStatement = 'if' '(' Expression ')' Statement ( 'else' Statement )?
WhileStatement = 'while' '(' Expression ')' Statement
PlaceholderStatement = '_'
SimpleStatement = VariableDefinition | ExpressionStatement
ForStatement = 'for' '(' (SimpleStatement)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
InlineAssemblyStatement = 'assembly' StringLiteral? AssemblyBlock
DoWhileStatement = 'do' Statement 'while' '(' Expression ')'
Continue = 'continue'
Break = 'break'
Return = 'return' Expression?
Throw = 'throw'
EmitStatement = 'emit' FunctionCall
VariableDefinition = (VariableDeclaration | '(' VariableDeclaration? (',' VariableDeclaration? )* ')' ) ( '=' Expression )?

// Precedence by order (see github.com/ethereum/solidity/pull/732)
Expression
  = Expression ('++' | '--')
  | NewExpression
  | IndexAccess
  | MemberAccess
  | FunctionCall
  | '(' Expression ')'
  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
  | Expression '**' Expression
  | Expression ('*' | '/' | '%') Expression
  | Expression ('+' | '-') Expression
  | Expression ('<<' | '>>') Expression
  | Expression '&amp;' Expression
  | Expression '^' Expression
  | Expression '|' Expression
  | Expression ('<' | '>' | '<=' | '>=') Expression
  | Expression ('==' | '!=') Expression
  | Expression '&amp;&amp;' Expression
  | Expression '||' Expression
  | Expression '?' Expression ':' Expression
  | Expression ('=' | '|=' | '^=' | '&amp;=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
  | PrimaryExpression

PrimaryExpression = BooleanLiteral
                  | NumberLiteral
                  | HexLiteral
                  | StringLiteral
                  | TupleExpression
                  | Identifier
                  | ElementaryTypeNameExpression

ExpressionList = Expression ( ',' Expression )*
NameValueList = Identifier ':' Expression ( ',' Identifier ':' Expression )*

FunctionCall = Expression '(' FunctionCallArguments ')'
FunctionCallArguments = '{' NameValueList? '}'
                      | ExpressionList?

NewExpression = 'new' TypeName
MemberAccess = Expression '.' Identifier
IndexAccess = Expression '[' Expression? ']'

BooleanLiteral = 'true' | 'false'
NumberLiteral = ( HexNumber | DecimalNumber ) (' ' NumberUnit)?
NumberUnit = 'wei' | 'szabo' | 'finney' | 'ether'
           | 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years'
HexLiteral = 'hex' ('"' ([0-9a-fA-F]{2})* '"' | '\'' ([0-9a-fA-F]{2})* '\'')
StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'
Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*

HexNumber = '0x' [0-9a-fA-F]+
DecimalNumber = [0-9]+ ( '.' [0-9]* )? ( [eE] [0-9]+ )?

TupleExpression = '(' ( Expression? ( ',' Expression? )*  )? ')'
                | '[' ( Expression  ( ',' Expression  )*  )? ']'

ElementaryTypeNameExpression = ElementaryTypeName

ElementaryTypeName = 'address' | 'bool' | 'string' | Int | Uint | Byte | Fixed | Ufixed

Int = 'int' | 'int8' | 'int16' | 'int24' | 'int32' | 'int40' | 'int48' | 'int56' | 'int64' | 'int72' | 'int80' | 'int88' | 'int96' | 'int104' | 'int112' | 'int120' | 'int128' | 'int136' | 'int144' | 'int152' | 'int160' | 'int168' | 'int176' | 'int184' | 'int192' | 'int200' | 'int208' | 'int216' | 'int224' | 'int232' | 'int240' | 'int248' | 'int256'

Uint = 'uint' | 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint40' | 'uint48' | 'uint56' | 'uint64' | 'uint72' | 'uint80' | 'uint88' | 'uint96' | 'uint104' | 'uint112' | 'uint120' | 'uint128' | 'uint136' | 'uint144' | 'uint152' | 'uint160' | 'uint168' | 'uint176' | 'uint184' | 'uint192' | 'uint200' | 'uint208' | 'uint216' | 'uint224' | 'uint232' | 'uint240' | 'uint248' | 'uint256'

Byte = 'byte' | 'bytes' | 'bytes1' | 'bytes2' | 'bytes3' | 'bytes4' | 'bytes5' | 'bytes6' | 'bytes7' | 'bytes8' | 'bytes9' | 'bytes10' | 'bytes11' | 'bytes12' | 'bytes13' | 'bytes14' | 'bytes15' | 'bytes16' | 'bytes17' | 'bytes18' | 'bytes19' | 'bytes20' | 'bytes21' | 'bytes22' | 'bytes23' | 'bytes24' | 'bytes25' | 'bytes26' | 'bytes27' | 'bytes28' | 'bytes29' | 'bytes30' | 'bytes31' | 'bytes32'

Fixed = 'fixed' | ( 'fixed' [0-9]+ 'x' [0-9]+ )

Ufixed = 'ufixed' | ( 'ufixed' [0-9]+ 'x' [0-9]+ )


AssemblyBlock = '{' AssemblyStatement* '}'

AssemblyStatement = AssemblyBlock
                  | AssemblyFunctionDefinition
                  | AssemblyVariableDeclaration
                  | AssemblyAssignment
                  | AssemblyIf
                  | AssemblyExpression
                  | AssemblySwitch
                  | AssemblyForLoop
                  | AssemblyBreakContinue
AssemblyFunctionDefinition =
    'function' Identifier '(' AssemblyIdentifierList? ')'
    ( '->' AssemblyIdentifierList )? AssemblyBlock
AssemblyVariableDeclaration = 'let' AssemblyIdentifierList ( ':=' AssemblyExpression )?
AssemblyAssignment = AssemblyIdentifierList ':=' AssemblyExpression
AssemblyExpression = AssemblyFunctionCall | Identifier | Literal
AssemblyIf = 'if' AssemblyExpression AssemblyBlock
AssemblySwitch = 'switch' AssemblyExpression ( Case+ AssemblyDefault? | AssemblyDefault )
AssemblyCase = 'case' Literal AssemblyBlock
AssemblyDefault = 'default' AssemblyBlock
AssemblyForLoop = 'for' AssemblyBlock AssemblyExpression AssemblyBlock AssemblyBlock
AssemblyBreakContinue = 'break' | 'continue'
AssemblyFunctionCall = Identifier '(' ( AssemblyExpression ( ',' AssemblyExpression )* )? ')'

AssemblyIdentifierList = Identifier ( ',' Identifier )*%</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>GLOBALS</span>
<b>GLOBAL METHODS:</b>
block.blockhash(uint blockNumber) 
  returns (bytes32): 
  hash of the given block - only works for 256 most
  recent blocks excluding current

<b>GLOBAL VARS:</b><b orange>
msg.sender (address)    : sender of the message (current call)
tx.origin (address)     : sender of the transaction 
                          (full call chain)</b>
msg.sender vs tx.origin:<a href=https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin">REF</a>
"""
- With msg.sender the owner can be a contract.
- With tx.origin the owner can never be a contract.
  In a simple call chain A->B->C->D,  inside D msg.sender will be C, and tx.origin will be A.
  
- msg.sender is preferred for the flexibility it provides. 
  Furthermore, for Serenity, even though it's a while out, Vitalik
  recommends avoiding tx.origin: How do I make my DAPP "Serenity-Proof?"
- Carefully consider if you really ever need to use tx.origin.
  Remember, you may not be the only user of your contract. 
  Other people may want to use your contract and want to interact
   with it via a contract they've been written.

"""


block.coinbase (address): current block miner’s address
block.difficulty (uint) : current block difficulty
block.gaslimit (uint)   : current block gaslimit
block.number (uint)     : current block number
block.timestamp (uint)  : current block timestamp
msg.data (bytes)        : complete calldata
msg.gas (uint)          : remaining gas
msg.sig (bytes4)        : first four bytes of the calldata 
                          (i.e. function identifier)
msg.value (uint)        : number of wei sent with the message
now (uint)              : current block timestamp 
                          (alias for block.timestamp)
tx.gasprice (uint)      : gas price of the transaction



<b>GLOBAL Math.&amp;Crypto Functs</b>
addmod(uint x, uint y, uint k) 
  returns (uint): /* compute (x + y) % k */
mulmod(uint x, uint y, uint k)
  returns (uint): /* compute (x * y) % k */
keccak256(...)
  returns (bytes32): compute Ethereum-SHA-3 hash
                of the (tightly packed) arguments
  - See also <a href="https://ethereum.stackexchange.com/questions/10173/different-hash-values-for-keccak256-functions">keccak256 in web3js</a>
sha3(...) 
  returns (bytes32): alias to keccak256()
sha256(...) 
  returns (bytes32): compute SHA-256 hash of the
                      (tightly packed) arguments
ripemd160(...) 
  returns (bytes20): compute RIPEMD-160 hash of 
  the (tightly packed) arguments
ecrecover
  (bytes32 hash, uint8 v, bytes32 r, bytes32 s)
  returns (address):
    recover the address associated with the public key 
    from elliptic curve signature or return zero on error
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Strings</span>
CAN NOTs:                               |  CANs:
 - Can NOT be concatenated.             |  - Can be used as keys for mappings

<b>Comparing strings:</b>
   sha3(      "string1" ) == sha3("string2")  ← sha3("...") translates to sha3(bytes("..."))
   ^^^^
   remember: sha3 is an alias for keccak256    

<b>check if string is empty:</b>
<a TODO href="XXX">Check white-space paddings</a>
bool stringNotEmpty = bytes(myTestedString).length &gt; 0; // alt 1, check underlying bytes array length
                                            ^^^^^^^ 
                                length implemented for
                                bytes, not (yet) for string

bool stringNotEmpty = sha3 (myTestedString) != sha3("")    // alt 2, check sha3

<b>bytes32 ←→ Strings:</b>
<a href="https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string">code@stackoverflow </a> doesn't look to work

<b>STRING LIBRARIES:</b>
<a TODO href="https://github.com/Arachnid/solidity-stringutils">Arachnid StringUtils</a>
</pre>

<pre xxxsmall zoom>
<span xsmall>Date/Time</span>
// DateTime is stored as uint

// "<b orange>now</b>" returns the (uint) current block timestamp (alias for block.timestamp)

uint <b brown>timeOutWindow</b> = <b brown>_inputTimeOutWindow</b> <b orange>* 1 minutes || 30 days</b>;
uint <b brown>time_origin</b>   = <x      >                   </x> <x       ></x>;
     <x      >           </x>     <x      >                   </x> <x       >^^^^^^^^^^^^^^^^^^^^^^^</x>;
     <x      >           </x>     <x      >                   </x> <x       >1 minutes == 60 seconds</x>;
     <x      >           </x>     <x      >                   </x> <x       >1 hours == 60 minutes  </x>;
     <x      >           </x>     <x      >                   </x> <x       >1 days == 24 hours     </x>;
     <x      >           </x>     <x      >                   </x> <x       >1 weeks == 7 days      </x>;

function myTimeOutDependentFunction(...) returns (...) {
    ...
    if (<b orange>now</b> &gt; (<b brown>time_origin + timeOutWindow</b>) throw;
    ... Do something ...
}
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall bgorange>FUNCTIONS</span>
<b>modifiers</b> (Deprecated?)
<b green>modifier inState</b>(State _state)    { if (state != _state) throw;  _;  }
<b green>modifier require</b>(bool _condition) { if (!_condition) throw; _;       }


function confirmPurchase(<parameter_list types>)
    <b green>inState</b>(State.Created)          // precondition
    <b green>require</b>(msg.value == 2 * value) // precondition<b blue>
    // VISIBILITY MODIFIERS {
    [internal] ← only this contract and child ones
    [private]  ← only this contract
    [external] ← will only ever be called externally 
                 external <a href="https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices">is more efficient than public</a>
                 since it also avoid copying parameters twice
                 (very important with big arrays!!!)
    [public]   ← will also be called internally.
    // }</b><b orange>
    // MUTABILITY MODIFIERS {
    [payable]  /* allows funct to receive ether when called as:
                * myContractInstance.myPayableFunction.call. \
                *   value("ETH_TO_BE_SENT")("ADDITIONAL_DATA")
                * Ej:
                *   function deposit() payable {
                *     deposits[msg.sender] += msg.value;
                *   };
                */
    [pure]      /* does NOT modify the contract storage 
                 * and storage can NOT be accesed 
                 * (utility libraries, ...)*/
    [view] /* does NOT modify the contract storage 
              but storage can be accesed  ("getters")*/
    [constant] /* alias for pure */
    // }</b><b brown>
    [returns ('return types')]</b>
    { 
      // (function body)
      ... 
    }

Note:
     confirmPurchase(...) # Internal call 
this.confirmPurchase(...) # External call
</pre>

<pre xxxsmall zoom>
<span xsmall>IMPORTS:</span>
import ""filename"";
import * as symbolName from ""filename"";
import {symbol1 as alias, symbol2} from ""filename"";
import ""filename"" as symbolName;

Frameworks like truffle will also automatically import from the "node_modules/" folder
where npm (Node package manager) installs dependencies.

<span xsmall>Fallback fn.</span> 
(called when no other function matches)
event EventFallback(address from, int256 amount);
...
function () payable {
  if (! this.owner.send(amount)) { throw ; }
  EventFallback(msg.sender, receiver, amount);
}; 

event EventFallback(address from, int256 amount);
...
function () payable {
  if (! this.owner.send(amount)) { throw ; }
  EventFallback(msg.sender, receiver, amount);
}; 
</pre>
</td>  
<td colsep></td>  
<td>
<pre xxxsmall zoom>
<span xsmall>STRUCTS</span>
@[https://solidity.readthedocs.io/en/latest/structure-of-a-contract.html#struct-types]
struct Voter {
  uint weight;
  bool voted;
}

Voter v1 = Voter(1, flase);  


<span xsmall>Returning</span>
<span xsmall>Structs</span>
- REF:
@[https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378]
- Solidity (0.4.13, as of this writing), doesn't allow 
  to return a struct from public functions.
  (allowed by experimental ABIv2)

*RETURNING ARRAYS OF STRUCTS:                                     │ *JS Client code:*
                                                                  │  """Getting data back in this format is, admittedly, a pain to
 pragma solidity ^0.4.13;                                         │  deal with on the frontend:"""
                                                                  │
 contract Project {                                               │ const people = await project.*getPeople*([ 2, 5 ])
     struct Person {                                              │       ^^^^^^                                       
       g*address addr*;                                           │     [                                              
       b*uint funds*;                                             │      ['0xdeadbeef', '0xabcdeff'], // ← g*addrs* 
     }                                                            │      [        100 ,        789 ]  // ← b*funds* 
                                                                  │     ]                                              
     Person[] people;                                             │                                                    
                                                                  │       ^^^^^^^^^^^ ,  ^^^^^^^^^^^                   
     function*getPeople*(uint[] indexes) public                   │       - struct1 - ,  - struct2 -                   
         returns (g*address[]*, b*uint[]*) {                      │                                                    
         //       ^^^^^^^^^^^^^^^^^                               │ constg*FIELD_ADDR *= 0                             
         //       One array for each struct field                 │ constb*FIELD_FUNDS*= 1                             
       g*address[] memory addrs = new address[](indexes.length);* │                                                    
       b*uint[]    memory funds = new uint[](indexes.length);*    │ let peopleStructs = []                             
                                                                  │ for (let i = 0; i ˂ numPeople; i++) {          
         for (uint i = 0; i ˂ indexes.length; i++) {              │     const person = {                               
             Person storage person = people[indexes[i]];          │         addr:  people[FIELD_ADDR][i],              
             addrs[i] = person.addr;                              │         funds: people[FIELD_FUNDS][i],             
             funds[i] = person.funds;                             │     }                                              
         }                                                        │     peopleStructs.push(person)                     
         return (addrs, funds);                                   │ }                                                  
     }                                                            │  
 }                                                                │
</pre>
<pre xxxsmall zoom>
<a xsmall href="https://solidity.readthedocs.io/en/latest/structure-of-a-contract.html#enum-types">enum</a>
enum State { Created, Locked, Inactive } // ← Definition
State  s1 = State.Created                // ← Ussage
uint8  u1 = uint8 (State.Created)        // ← Explicit uintXX to enum
uint16 u2 = uint16(State.Created) 
State  s2 = State(u1)                    // ← uintXX to enum using enum constructor
                                              Will raise an assert exception if
                                              u1 is outside the State bounds.
</pre>
</td>


<td colsep></td>
<td>  
<pre bgorange xxxsmall zoom>
<span xsmall>ERROR</span>
<span xsmall>CONTROL</span>
@[https://solidity.readthedocs.io/en/v0.4.24/control-structures.html#error-handling-assert-require-revert-and-exceptions]
Solidity uses state-reverting exceptions to handle errors:
 - Capturing ("catch-ing") Exceptions IS NOT (YET?) POSSIBLE (2018-06-11)!.
 - EVM rollbacks any stat change in current call and all its sub-calls
   including events pending to register.
   (there is no safe way to continue execution while warrantying atomicity
    and reproducibility of results)
 - TX is still mined and TXReceipt status flaged with "fail" error
   See <a href="https://etherscan.io/tx/0x9f00a37416a64735b02ab76da4477ea297bfd4923b1564c1b3579d542b3f4071">Example failed TX mined</a>

PROGRAMATICALLY TRIGGERING EXCEPTIONS: 
┌───────────────────────────────────────────────┬──────────────────────────────────────────────┬───────────────────────────────────────────────┐
│      assert                                   │     require                                  │   revert                                      │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ (programming error)                           │ (pre/post check in in/out-data)              │ (business logic exceptions)                   │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - Check for conditions and throw an exception │ - Check for conditions and throw an exception│ - replaces deprecated 'throw'                 │
│   if the condition is not met                 │   if the condition is not met                │ - can be used to flag an error and revert the │
│ - Should only be used to test for internal    │ - Should be used to ensure valid conditions, │   current call.                               │
│   errors, and to check invariants             │   such as inputs, or contract state variables│ - It is possible to provide a string message  │
│ - If used properly, analysis tools can        │   are met, or to validate return values from │   containing details about the error that will│
│   evaluate your contract to identify          │   calls to external contracts                │   be passed back to the caller.               │
│   the conditions and function calls which will│ - optionally a message-string can be provided│                                               │
│   reach a failing assert.                     │                                              │                                               │
│   Properly functioning code should never reach│                                              │                                               │
│   a failing assert statement                  │                                              │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ - compiles to INVALID 0xfe instruction        │  - compiles to REVER 0xfd instruction        │                                               │
├───────────────────────────────────────────────┼──────────────────────────────────────────────┼───────────────────────────────────────────────┤
│ assert( "my code-logic assertion")            │ require("required cond.", "messsage");       │  if ("not condtion for input") revert("....") │
└───────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────────┘

┌─────────┬────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────┐   ┌─────────────────────────────────────────────────────┐
│         │ assert-style exception                                 │ revert/require-style exception                       │   │low level ops (return false, no exception raised)    │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Condition│ - access array at index greater than array             │ - Calling throw (deprecated)                         │   │- create a contract using "new" but contract creation│
│that     │  length (or negative)                                  │ - Calling require evaluating to false                │   │  does not finish properly.                          │
│triggers │ - access fixed-length bytes"N" at a too large or       │ - call a function via a message call but it does not │   │- perform external function call targeting a contract│
│exception│   negative index                                       │   finish properly (i.e. it runs out of gas, has no   │   │  that contains no code                              │
│in the   │ - divide or modulo by zero (ex.: 5 / 0 , 23 % 0)       │   matching function, or throws an exception itself), │   │- contract receives Ether via public function        │
│at (EVM) │ - shift by a negative amount                           │   except when a low level operation call, send,      │   │  without payable modifier (including constructor    │
│runtime  │ - convert a value too big|negative into an enum type   │   delegatecall or callcode is used.                  │   │  or fallback                                        │
│         │ - call to zero-initialized variable of internal        │                                                      │   │- contract receives Ether via public getter function │
│         │   function type                                        │                                                      │   │- .transfer() fails                                  │
│         │ - call assert with an argument that evaluates to false │                                                      │   │                                                     │
│         │ - call function not matching any func. in contract     │                                                      │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Gas ussag│ Consume all gas available to the call                  │ - Do NOT consume any gas (v.Metrópolis+)             │   │                                                     │
├─────────┼────────────────────────────────────────────────────────│──────────────────────────────────────────────────────│   │─────────────────────────────────────────────────────│
│Propagati│ - Rethrown ("bubble up") in sub-calls                  │ - Rethrown ("bubble up") in sub-calls                │   │- return false *1                                    │
└─────────┴────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────┘   └─────────────────────────────────────────────────────┘
                                                                                                                                 *1 or true if called account is non-existent
                                                                                                                                    Existence must be checked prior to call

Solidity compiler automatically generate exceptions (assert or require/revert?) if:
 - If your contract receives Ether via a public function without payable modifier 
   (including the constructor and the fallback function)
 - If your contract receives Ether via a public getter function
 - If you call a zero-initialized variable of internal function type
 - If a addressInstance.transfer() fails</li>


The provided string in require/revert will be abi-encoded as if it were a call to a function Error(string).
For example:
   revert("Not enough Ether provided."); will cause the following hexadecimal data be set as error return data:

0x08c379a0                                                         // Function selector for Error(string)
0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
0x000000000000000000000000000000000000000000000000000000000000001a // String length
0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall>Arrays</span>
@[https://solidity.readthedocs.io/en/v0.4.24/types.html#arrays
Syntax:

uint[100] memory fixedArray;     ← Fixed   Size Array declaration
          fixedArray[0] = 1; 
          fixedArray[1] = 2; 
          fixedArray.push(3);    ← <b red>Error. Not allowed for fixed size array</b>
          ...
uint[ ] memory  dynArray1 = unit[] ← Dynamic Size Array declaration 
          dynArray1.push(1)        ← <b red>Error. Not allowed for memory array</b>
          ...
uint[ ] storage dynArray2 = unit[] ← Dynamic Size Array declaration 
          dynArray2.push(1 )       ← <b green>OK</b>
          ...
var x          = uint[][5]      ← Fixed-(5)size-array of
                                  dynamic-uint-arrays  (var for type inference)
    x[2][1]                     ← second uint in third dyn-array


 ┌────────┬───────────────────────┬───────────────────┬──────────────────────┬────────────────────┐ 
 │        │ Admited type          │ Creation          │ Resize               │ Delete             │
 ├────────┼───────────────────────┼───────────────────┼──────────────────────┼────────────────────┤ 
 │Storage │ *any*                 │ (just declare it) │- set/reassign .length│ delete myArray;    │
 │Arrays  │                       │                   │- push(el)            │ myArray.length = 0;│
 ├────────┼───────────────────────┼───────────────────┼──────────────────────┼────────────────────┤ 
 │Memory  │ *any* but mapping     │ Use 'new'         │ Not allowed          │                    │
 │Arrays  │ (ABI comp. for        │ new uint[](7)     │(fix size determined  │                    │
 │        │  public/extern fun)   │ new bytes(len)    │ at runtime)          │                    │
 └────────┴───────────────────────┴───────────────────┴──────────────────────┴────────────────────┘ 
<b>Special arrays(tightly packed in calldata)</b 
bytes : byte[]

string: (UTF-8) similar to bytes
        -  does not YET allow length/index/push access
        Use use bytes(myString).length / bytes(myString)[7] = 'x' to
        access the low-byte-representation of myString 

- Array Literals expression (not immediately assigned to a variable)
  - type     : memory array of fixed length. 
  - base type: common type of array elements.
  ...
  calledFunction(<b orange>[uint(1), 2, 3]</b>);

<b>Limitations:</b>
  - arrays of arrays not (YET) allowed in external functions
  - (EVM limitation): dynamic content NOT allowed in external-function return-value 
    - Workaround: use large statically-sized arrays
  - Deleting an element in the array (delete myArray[idx1]) generates gaps over time
  - This can lead to unpredictable gas costs if a contract itself has to search 
    through those gaps.

<span xsmall>Walk over</span>
WARN: <b>string[]  arrays not allowed in solidity</b>
bytes32[] storage public namesInUse;
uint arrayLength = namesInUse.push(1); // Returns 1
     arrayLength = namesInUse.push(3); //   "     2
           ^^^^
           push only allowed for storage arrays, not memory
assert(arrayLength == namesInUse.length);
for (uint i = 0; i < namesInUse.length; i++) {
   require(namesInUse[i] != username);
}
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>Linked List</span>
@[https://github.com/vittominacori/solidity-linked-list]
</pre>
</td>

<td>
<pre xxxsmall zoom>
<a xsmall href="https://solidity.readthedocs.io/en/v0.4.24/types.html#mappings">Mappings</a>
Syntax:

   mapping(_KeyType => _ValueType) public myMapping; // ← Declatarion
           ^^^^^^^^
     almost any type except 
     mapping,dynamic array,
     contract,enum,struct

   myMapping[key1] = value1;                         // ← add/modify key
   delete myMapping[key1]                            // ← put myMapping[key] to virt.Zero


- Only allowed for state variables (or as storage reference types in internal functions)
- <b>are NOT iterable.</b>

  - Care must be taken to not leave orphaned data in the state database, 
    particularly after contract-self-destruction =>
    - code must manually clean mappings by deleting each key.

<span xsmall TODO>Walk over</span>
- Mappings are virtually initialized:
  - <b>every possible key exists mapped to zero-byte-repr</b>
  - keys are NOT stored in the map
    => Code needs the keys to discover/walk-over mappings.
  - values are stored at the state-memory address == sha3(key)

- Solution 1: Using aux. array to store keys.
  (memory gaps can arise when deleting the aux-key-array) 
 ┌───────────────────────────────────────────┬──────────────────────────────────────────┐
 │ETHEREUM CODE                              │ CLIENT CODE                              │
 ├───────────────────────────────────────────┼──────────────────────────────────────────┤
 │mapping (address => uint) public balances; │ for(i = 0; i < k.size(); i++) {          │
 │address[] public keyList   ;               │   someFunc( k.balances(k.keyList(i)) );  │
 │function size() public returns (uint) {    │ }                                        │
 │    return keyList.length;                 │ Note: k == contract instance             │
 │}                                          └──────────────────────────────────────────┤ 
 │WARN: delete keyList[idx] can leave gaps                                              │
 └──────────────────────────────────────────────────────────────────────────────────────┘
- Solution 2: Using Linked List Indexes
 ┌───────────────────────────────────────────┬──────────────────────────────────────────┐ 
 │ETHEREUM CODE                              │ CLIENT CODE                              │ 
 ├───────────────────────────────────────────┼──────────────────────────────────────────┤ 
 │mapping (address => address) ll;           │ var current = k.ll(0);                   │ 
 │mapping (address => uint) public balances; │ while (current) {                        │ 
 │function add(address _addr_as_idx) public  │     console.log( k.balances(current) );  │ 
 │{                                          │     current = k.ll(current);             │ 
 │    ll[_addr]  = ll[0x0];                  │ }                                        │ 
 │    ll[0x0]    = _addr;                    └──────────────────────────────────────────┤ 
 │    balances[_addr] = balance;                                                        │ 
 │}   ^^                                                                                │ 
 │ ll will grow as:                                                                     │ 
 │   STEP 1         → STEP 2         → STEP 3         → STEP 4 ...                      │ 
 │   0x      addr01 → 0x      addr02 → 0x      addr03 →                                 │ 
 │                  → addr02  addr01 → addr02  addr01 →                                 │ 
 │                  →                → addr03  addr02 →                                 │ 
 │                  →                → addr03  addr02 →                                 │ 
 │                                                                                      │ 
 │// Deleting: No gaps but require a search to find parent node                         │
 │function remove(address _addr) {                                                      │ 
 │      address parent;                                                                 │ 
 │      // Warning: unbounded gas loop                                                  │ 
 │      while (llIndex[parent] != _addr) parent = llIndex[parent];                      │ 
 │      llIndex[parent] = llIndex[ llIndex[parent]];                                    │ 
 │      delete llIndex[address];                                                        │ 
 │      delete balances[address];                                                       │ 
 │  }                                                                                   │ 
 └──────────────────────────────────────────────────────────────────────────────────────┘ 
- Solution 3: Using Double Linked List Indexes
   - search loops removes at the expense of extra storage slot per indexed element.
   - a nested bool mapping for bidirectional links where we interpret
      PREV == false and NEXT == true:
┌──────────────────────────────────────────────────────────────────────────────────────┐
│mapping(address => ( mapping(bool => address) ) dllIndex;                             │
│mapping(address => uint) balances;                                                    │
│function add(address _addr)                                                           │
│{                                                                                     │
│    // Link the new node                                                              │
│    dllIndex[_addr][PREV] = 0x0;                                                      │
│    dllIndex[_addr][NEXT] = dllIndex[0x0][NEXT];                                      │
│                                                                                      │
│    // Insert the new node                                                            │
│    dllIndex[dllIndex[0x0][NEXT]][PREV] = _addr;                                      │
│    dllIndex[0x0][NEXT] = _addr;                                                      │
│}                                                                                     │
│                                                                                      │
│function remove(address _addr)                                                        │
│{                                                                                     │
│    // Stitch the neighbours together                                                 │
│    dllIndex[ dllIndex[_addr][PREV] ][NEXT] = dllIndex[_addr][TRUE];                  │
│    dllIndex[ dllIndex[_addr][NEXT] ][PREV] = dllIndex[_addr][PREV];                  │
│                                                                                      │
│    // Delete state storage                                                           │
│    delete dllIndex[_addr][PREV];                                                     │
│    delete dllIndex[_addr][NEXT];                                                     │
│    delete balances[_addr];                                                           │
│}                                                                                     │
└──────────────────────────────────────────────────────────────────────────────────────┘
 - We now have a directly addressable and fully iterable storage structure, which is
   not just a Double Linked List but a Circular Double Linked List by default 
   with the head at 0x0. This gives us two very desirable properties for free...

 - FIFO and FILO Queues
    First In First Out (FIFO) and First In Last Out (FILO) queues are a very 
    common concept in computing. FIFO can be used for task queues while FILO 
    is also used for memory 'stacks'.

 - FIFO's can be used in any contracts that require atomic sequential order 
   processing. Here a new order is simply inserted previous to the head, 
   while the oldest order is simply taken from next to the head. No search 
   loops required.

 - If you think these structures might be useful, check out my Circular 
   Double Linked List Index Library which is used by my Intrinsically 
   Tradable Tokens (ITT) contract.

</pre>
</td>
<td>
<pre xxxsmall zoom bgorange>
<span xsmall>storage</span>
<span xsmall> patterns</span>
@[https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity]
Q: Simple and appropriate data organization can challenge Solidity newcomers. 
  It wants us to organize everything in ways many of us aren’t accustomed to.
  Are there well-solved general patterns for routine on-chain data organization?

A: Here are some simple and useful patterns in increasing order of utility.
<b>Event logs are omitted for brevity. In practice, it's desirable to emit events for every important state change.</b>

<b>SIMPLE LIST USING ARRAY</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
  Reliably chronological order | No random access by Id          | pragma solidity ^0.4.6;
  Provides a count             | No assurance of uniqueness      | contract simpleList {
  Random access by Row Number  | No check for duplicates         |   struct EntityStruct {
  (not Id)                     | Uncontrolled growth of the list |     address entityAddress;
                               |                                 |        uint entityData;
                               |                                 |      }
                               |                                 |    
                               |                                 |      <b>EntityStruct[]</b> public entityStructs;
                               |                                 |    
                               |                                 |      function newEntity(address entityAddress, uint entityData) 
                               |                                 |          public returns(uint rowNumber) {
                               |                                 |        EntityStruct memory newEntity;
                               |                                 |        newEntity.entityAddress = entityAddress;
                               |                                 |        newEntity.entityData    = entityData;
                               |                                 |        return entityStructs.push(newEntity)-1;
                               |                                 |      }
                               |                                 |    
                               |                                 |      function getEntityCount() 
                               |                                 |          public constant returns(uint entityCount) {
                               |                                 |        return entityStructs.length;
                               |                                 |      }
                               |                                 |    }

<b>MAPPING WITH STRUCT</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
 -Random access by unique Id   |-Unable to enumerate the keys    | contract mappingWithStruct {
 -Assurance of Id Uniqueness   |-Unable to count the keys        |   struct EntityStruct {
 -Enclose arrays, mappings,    |-Needs a manual check to         |     uint entityData;
  structs within each "record" |-distinguish a default from      |     bool isEntity;
                               | an explicitly "all 0" record    |   }
                               |                                 | 
                               |                                 |   <b>mapping (address => EntityStruct)</b> 
                               |                                 |     public entityStructs;
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |      public constant returns(bool isIndeed) {
                               |                                 |      return entityStructs[entityAddress].isEntity;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(isEntity(entityAddress)) throw; 
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |        = entityData;
                               |                                 |     entityStructs[entityAddress].isEntity 
                               |                                 |        = true;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function deleteEntity(address entityAddress)
                               |                                 |     public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].isEntity = false;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }


<b>ARRAY OF STRUCTS WITH UNIQUE IDS</b>

  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by Row number  | - No random access by Id        | contract arrayWithUniqueIds {
- Assurance of Id uniqueness   | - Uncontrolled growth of        | 
- Enclose arrays, mappings     |   the list                      |   struct EntityStruct {
  and structs with each        |                                 |     address entityAddress;
  "record"                     |                                 |     uint entityData;
                               |                                 |   }
                               |                                 | 
                               |                                 |   EntityStruct[] public entityStructs;
                               |                                 |   mapping(address => bool) knownEntity;
                               |                                 | 
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |       public constant returns(bool isIndeed) {
                               |                                 |     return knownEntity[entityAddress];
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount() public constant
                               |                                 |        returns(uint entityCount) {
                               |                                 |     return entityStructs.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress, uint entityData)
                               |                                 |       public returns(uint rowNumber) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     EntityStruct memory newEntity;
                               |                                 |     newEntity.entityAddress = entityAddress;
                               |                                 |     newEntity.entityData = entityData;
                               |                                 |     knownEntity[entityAddress] = true;
                               |                                 |     return entityStructs.push(newEntity) - 1;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity(
                               |                                 |       uint rowNumber,
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData) public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     if(entityStructs[rowNumber].entityAddress 
                               |                                 |       != entityAddress) throw;
                               |                                 |     entityStructs[rowNumber].entityData 
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }

<b>MAPPED STRUCTS WITH INDEX</b>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by unique Id   | - Uncontrolled growth of        | contract MappedStructsWithIndex {
  or row number                |   the list                      | 
- Assurance of Id uniqueness   |                                 |   struct EntityStruct {
- Enclose arrays, mappings and |                                 |     uint entityData;
  structs within each "record" |                                 |     bool isEntity;
- List maintains order of      |                                 |   }
  declaration                  |                                 | 
- Count the records            |                                 |   mapping(address => EntityStruct)
- Enumerate the Ids            |                                 |       public entityStructs;
- "Soft" delete an item by     |                                 |   address[] public entityList;
  setting a boolean            |                                 | 
                               |                                 |   function isEntity(address entityAddress)
                               |                                 |       public constant 
                               |                                 |       returns(bool isIndeed) {
                               |                                 |     return entityStructs[entityAddress].isEntity;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount() 
                               |                                 |       public constant 
                               |                                 |       returns(uint entityCount) {
                               |                                 |     return entityList.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData)
                               |                                 |        public returns(uint rowNumber) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |        = entityData;
                               |                                 |     entityStructs[entityAddress].isEntity 
                               |                                 |        = true;
                               |                                 |     return 
                               |                                 |       entityList.push(entityAddress) - 1;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity
                               |                                 |       (address entityAddress, uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData
                               |                                 |       = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | }


<b>MAPPED STRUCTS WITH DELETE-ENABLED INDEX</b>
<a href="https://medium.com/@robhitchens/solidity-crud-part-2-ed8d8b4f74ec#.ekc22r5lf">REF@Medium Rob Hitchens</a>
<a href="https://bitbucket.org/rhitchens2/soliditycrud/src/83703dcaf4d0c4b0d6adc0377455c4f257aa29a7/contracts/?at=master">BitBucket Source Code</a>
  STRENGTHS                    | WEAKNESSES                      | EXAMPLE:
- Random access by unique Id   | - Marginally increased code     | contract mappedWithUnorderedIndexAndDelete {
  or row number                |   complexity                    |   struct EntityStruct {
- Assurance of Id uniqueness   | - Marginally higher storage     |     uint entityData;
- Enclose arrays, mapping and  |   costs                         |     uint listPointer;
  structs within each "record" | - Key list is inherently        |   }
- Count the records            |   unordered                     | 
- Enumerate the ids            |                                 |   mapping(address => EntityStruct) public entityStructs;
- Logically control the size of|                                 |   address[] public entityList;
  the active list with delete  |                                 | 
  function                     |                                 |   function isEntity(address entityAddress) 
                               |                                 |       public constant returns(bool isIndeed) {
                               |                                 |     if(entityList.length == 0) return false;
                               |                                 |     return (
                               |                                 |       entityList[entityStructs[entityAddress].
                               |                                 |          listPointer] == entityAddress);
                               |                                 |   }
                               |                                 | 
                               |                                 |   function getEntityCount()
                               |                                 |       public constant 
                               |                                 |       returns(uint entityCount) {
                               |                                 |     return entityList.length;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function newEntity(
                               |                                 |       address entityAddress, 
                               |                                 |       uint entityData)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress].entityData 
                               |                                 |         = entityData;
                               |                                 |     entityStructs[entityAddress].listPointer 
                               |                                 |         = entityList.push(entityAddress) - 1;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function updateEntity(
                               |                                 |       address entityAddress,
                               |                                 |       uint entityData) 
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     entityStructs[entityAddress]
                               |                                 |        .entityData = entityData;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 |   function deleteEntity(address entityAddress)
                               |                                 |       public returns(bool success) {
                               |                                 |     if(!isEntity(entityAddress)) throw;
                               |                                 |     uint rowToDelete 
                               |                                 |       = entityStructs[entityAddress].listPointer;
                               |                                 |     address keyToMove 
                               |                                 |       = entityList[entityList.length-1];
                               |                                 |     entityList[rowToDelete] = keyToMove;
                               |                                 |     entityStructs[keyToMove].listPointer 
                               |                                 |       = rowToDelete;
                               |                                 |     entityList.length--;
                               |                                 |     return true;
                               |                                 |   }
                               |                                 | 
                               |                                 | }


if(bad) throw;
if(bad) revert();
require(!bad)
ethfiddle.com/PgDM-drAc9 
</pre>
</td>


</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title>
    Quality<br/>
    Assurance
</td>
<td>
<pre xxxsmall zoom>
<b TODO xsmall>QA: FORMAL PROBES</b>
FORMAL Verification
https://github.com/pirapira/eth-isabelle
https://github.com/pirapira/ethereum-formal-verification-overview
Why3 Solidity
Why3 is a platform for deductive program verification. It provides a rich 
language for specification and programming, called WhyML, and relies on 
external theorem provers, both automated and interactive, to discharge 
verification conditions. (See the specific section below for the list of 
supported provers.) Why3 comes with a standard library of logical theories (
integer and real arithmetic, Boolean operations, sets and maps, etc.) and 
basic programming data structures (arrays, queues, hash tables, etc.). A user 
can write WhyML programs directly and get correct-by-construction OCaml 
programs through an automated extraction mechanism. WhyML is also used as an 
intermediate language for the verification of C, Java, or Ada programs. (See 
Projects using Why3 below.) Why3 can be easily extended with support for new 
theorem provers. Why3 can be used as a software library, through an OCaml API. 

https://forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts

"""
   We just merged a first pull request that allows Solidity contracts to be 
   formally verified using a toolkit called why3.
   This means that a computer creates and checks a mathematical proof of 
   assertions about the behaviour of the contract.
   Only a small subset of Solidity is supported for now, but that makes it 
   already possible to verify a recursive binary search routine on arrays:
   https://gist.github.com/chriseth/0c671e0dac08c3630f47
"""

"""
   How to use it on the example
   The solidity compiler (only solc at latest develop for now) can translate the 
   source code into a different programming language which can be understood by 
   why3 (the language is a dialect of ocaml). To do that, call it as ""solc \-\-
   formal -o /tmp/output_directory/ source.sol"". Furthermore, using special 
   tags in the Solidity comments of the form ""///@why3 ..."" you can formulate 
   assertions and requirements that can be understood by the why3 framework and 
   will be literally inserted into the generated code.


   start a graphical version of the toolkit and perform the verification.
   
   How to install why3
   I am not aware of any binary packages, so you have to download the source 
   from the website.  As why3 itself is only a frontend to the real workhorses, 
   the provers, you need to install a prover. I tried ""alt-ergo"" and Z3 - the 
   first is part of the ubuntu distribution, the second has binaries for most 
   platforms.
   
   After installing the prover (and making sure it is in the PATH), call ""why3 
   config \-\-detect"" and it should detect your prover. """""""
   
   Video Tutorial:
   https://www.youtube.com/watch?v=Mzh4fyoaBJ0&feature=youtu.be&list=PL9oaY6Y4QxRZybj86eGItGVApxLXVIXHz
   https://gitter.im/ethereum/formal-methods
   "https://en.wikipedia.org/wiki/Logical_harmony
   
   Logical harmony, a name coined by Sir Michael Dummett, is a supposed 
   constraint on the rules of inference (https://en.wikipedia.org/wiki/
   Rules_of_inference) that can be used in a given logical system(https://en.
   wikipedia.org/wiki/Logical_system)

See also:
<a TODO href="http://fc17.ifca.ai/wtsc/Defining%20the%20Ethereum%20Virtual%20Machine%20for%20Interactive%20Theorem%20Provers.pdf">Virt.Machine for interactive Theorem Provers</a> 
</pre>

 
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/ConsenSys/mythril/wiki">QA: Mythril</a>
  Mythril detects a range of security issues, including 
  integer underflows, owner-overwrite-to-Ether-withdrawal,
  and others. However, the analysis will not detect business
  logic issues and is not equivalent to formal verification.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://consensys.github.io/smart-contract-best-practices/security_tools/">Sec.Tool Index (Consensys)</a>(@Consensys) 
<b>Visualization</b>
 - <a TODO href="https://github.com/ConsenSys/surya">Sūrya</a> tool for smart contract systems,
    offering a number of visual outputs and information about the contracts' structure. 
    Also supports querying the function call graph.
 - <a TODO href="https://github.com/raineorshine/solgraph">Solgraph</a> generates a DOT graph
   that visualizes function control flow of a Solidity contract and highlights potential 
   security vulnerabilities.
 - <a TODO href="https://github.com/ethereum/evmlab">EVM Lab</a>: Rich tool package to interact
    with the EVM. Includes a VM, Etherchain API, and a trace-viewer.
 - <a TODO href="https://github.com/fergarrui/ethereum-graph-debugger">ethereum-graph-debugger</a> 
    A graphical EVM debugger. Displays the entire program control flow graph.

<b>STATIC AND DYNAMIC ANALYSIS</b>
  - <a href="https://github.com/ConsenSys/truffle-security">Truffle Security</a> - Security extension for Truffle based on <a href="https://mythx.io">MythX</a>.</li>
  - <a href="https://github.com/b-mueller/sabre">Sabre</a> - Minimum viable MythX client written in JavaScript.</li>
  - <a href="https://github.com/dmuhs/PythX">PythX</a> - MythX Python library and CLI tool.</li>
  - <a href="https://github.com/ConsenSys/mythril-classic">Mythril Classic</a> - Swiss army knife for smart contract security.</li>
  - <a href="https://github.com/trailofbits/slither">Slither</a> - Static analysis framework with detectors for many common Solidity issues. It has taint and value tracking capabilities and is written in Python.</li>
  - <a href="https://github.com/trailofbits/echidna">Echidna</a> - The only available fuzzer for Ethereum software. Uses property testing to generate malicious inputs that break smart contracts.</li>
  - <a href="https://github.com/trailofbits/manticore">Manticore</a> - Dynamic binary analysis tool with <a href="https://asciinema.org/a/haJU2cl0R0Q3jB9wd733LVosL">EVM support</a>.</li>
  - <a href="https://github.com/melonproject/oyente">Oyente</a> - Analyze Ethereum code to find common vulnerabilities, based on this <a href="http://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf">paper</a>.</li>
  - <a href="https://securify.chainsecurity.com/">Securify</a> - Fully automated online static analyzer for smart contracts, providing a security report based on vulnerability patterns. </li>
  - <a href="https://tool.smartdec.net">SmartCheck</a> - Static analysis of Solidity source code for security vulnerabilities and best practices.</li>
  - <a href="https://github.com/quoscient/octopus">Octopus</a> - Security Analysis tool for Blockchain Smart Contracts with support of EVM and (e)WASM.</li>

<b>WEAKNESS OSSCLASSIFCATION &amp; TEST CASES</b>
 - <a href="https://github.com/SmartContractSecurity/SWC-registry/">SWC-registry</a> - SWC definitions and a large repository of crafted and real-world 
   samples of vulnerable smart contracts. </li>
 - <a href="https://smartcontractsecurity.github.io/SWC-registry/">SWC Pages</a> - The SWC-registry repo published on Github Pages
</ul>

<b>TEST COVERAGE:</b>
- <a href="https://github.com/sc-forks/solidity-coverage">solidity-coverage</a> - Code coverage for Solidity testing

<b>LINTERS:</b>
 - <a href="https://github.com/federicobond/solcheck">Solcheck</a>
   A linter for Solidity code written in JS and heavily inspired by eslint.
 - <a href="https://github.com/weifund/solint">Solint</a>
   Solidity linting that helps you enforce consistent conventions and avoid errors in your Solidity smart-contracts.
 - <a href="https://github.com/duaraghav8/Solium">Solium</a>
   Yet another Solidity linting.
 - <a href="https://github.com/protofire/solhint">Solhint</a>
   A linter for Solidity that provides both Security and Style Guide validations.
</pre>
</td>


<td>
<pre xxxsmall zoom>
<span xsmall>Security Best Practices</span>
@[https://consensys.github.io/smart-contract-best-practices/]
</pre>
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>
<td>
<pre xxxsmall zoom>
<span xsmall TODO>Token</span>
<span xsmall     > taxonomy</span>
@[https://entethalliance.org/token-taxonomy-initiative/]
</pre>
</td>
<td>
<pre xxxsmall zoom>
  <a xsmall href='https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md'>ERC20 Token</a>
  Standard interface to Fungible Assets Contracts that different wallets will understand out-of-the-box
  <a href='https://theethereum.wiki/w/index.php/ERC20_Token_Standard'>ERC20 @ Ethereum WiKi</a>
  <a href='https://edcon.io/ppt/two/Dmitry%20Khovratovich_Secure%20Token%20Development%20and%20Deployment_EDCON.pdf'>Problems with the Standard</a>
  <a href='https://tokenmarket.net/what-is/ethereum-token-wallets/'>ERC20 compliant wallets</a>
</pre>
<pre xxxsmall zoom>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/ethereum/EIPs/issues/223">ERC-223</a> 
ERC20 token standard is leading to money losses for end users. 
The main problem is lack of possibility to handle incoming ERC20 transactions, 
that were performed via transfer function of ERC20 token.

If you send 100 ETH to a contract that is not intended to work with Ether, 
then it will reject a transaction and nothing bad will happen. If you will 
send 100 ERC20 tokens to a contract that is not intended to work with ERC20 
tokens, then it will not reject tokens because it cant recognize an incoming 
transaction. As the result, your tokens will get stuck at the contracts 
balance.
</pre>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-621.md">ERC-621</a> 
ERC 621

ERC-621 is an extension of the ERC-20 token standard. It adds two additional 
functions, increaseSupplyanddecreaseSupply. This can increase and decrease 
the token supply in circulation. ERC-20 only allows a single token issuance 
event. This restricts the supply to a certain amount which can’t be changed. 
ERC-621 proposes that totalSupply can be modified
</pre>
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>ERC-1155</span>
A standard interface for contracts that manage multiple token types. A single 
deployed contract may include any combination of fungible tokens, non-
fungible tokens, or other configurations (for example, semi-fungible 
tokens)
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>ERC-721 token:</span>
<span xsmall>Non fungible</span>
@[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md]
- "Deed" token
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-827.md">ERC-827</a> 
A extension of the standard interface ERC20 for tokens with methods 
that allows the execution of calls inside transfer and approvals.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href='https://erc725alliance.org/'>Identity</a><br/>
ERC-725 Identity Std: TODO:
@[https://erc725alliance.org/]
- What is ERC 725?
  ERC 725 is a proposed standard for blockchain-based identity 
  authored by Fabian Vogelsteller, creator of ERC 20 and Web3.js. ERC 
  725 describes proxy smart contracts that can be controlled by 
  multiple keys and other smart contracts. ERC 735 is an associated 
  standard to add and remove claims to an ERC 725 identity smart 
  contract. These identity smart contracts can describe humans, groups
  , objects, and machines. ERC 725 lives on the Ethereum 
  blockchain.


- Why ERC 725?
  ERC 725 allows for self-sovereign identity. Users should be able to 
  own and manage their identity instead of ceding ownership of 
  identity to centralized organizations. We have seen the negative 
  effects of having centralized identity with damaging leaks and 
  unfair selling of user data and identity. An open, portable 
  standard for identities will enable decentralized reputation, 
  governance, and more. Users will be able to take their identity 
  across different Dapps and platforms that support this standard.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href='https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol'>Ex:Minimum Signa.Num.</a>
Inheritable "property" contract:
<b>enables methods to be protected by requiring the acquiescence of either a
   single, or, crucially, each of a number of, designated owners.</b>
// REF: <a href="https://gist.githubusercontent.com/mingderwang/33994fddda49a45671e093b321912cbd/raw/eeec75f34f1b311d88337f2e0ce6d8fa58ed175a/wallet.sol">Wallet.sol gist</a>
// @authors: Gav Wood <g@ethdev.com>
contract multiowned {
    struct PendingState { uint yetNeeded; uint ownersDone; uint index; }
    mapping(bytes32 /* operation_hash */ => PendingState) <b orange>mapPendingOps</b>; // ongoing ops
    uint public minimum_required; // minimum owners confirmations for same operation
   
    mapping(address => uint /*<b brown>bit idx</b>*/) <b brown>mapOwner2Idx</b>; // <b>allow reverse lookup</b>
    bytes32[] m_pendingIndex;

    modifier onlyOwner { if (<b brown>mapOwner2Idx</b>[msg.sender] == 0) throw ; _ }

       /* same operation hash must be signed/accepted by a minimum number 
        * of the set of owners (specified in the constructor) before execution */
<b>    modifier  <b blue>onlyMany/*¡¡SIGNATURE!!*/Owners</b>(bytes32 _operation_hash) {
        if (!<b blue>confirmAndCheck</b>(_operation_hash)) throw ;  _ }</b>

<b>    constructor(address[] _owners /* "who" can confirm */,
           uint minimum_required /*minimum. confirmations*/) {</b>
        <b brown>mapOwner2Idx</b>[msg.sender] = 1;
        for (uint i = 0; i &lt; _owners.length; ++i) 
            { <b brown>mapOwner2Idx</b>[_owners[i]] = 2 + i; }
        minimum_required = minimum_required;
    }

    function <b>hasConfirmed(bytes32 _operation_hash, address _owner)</b> constant returns (bool) {
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        uint ownerIndex = <b brown>mapOwner2Idx</b>[_owner];
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine bit to set
        return (pending.ownersDone &<b green>ownerIdxBit</b> == 0) ? false : true;
    }

    function <b blue>confirmAndCheck</b>(bytes32 _operation_hash) internal returns (bool) {
        uint ownerIndex = <b brown>mapOwner2Idx</b>[msg.sender]; // get idx for msg.sender
        var pending = <b orange>mapPendingOps</b>[_operation_hash];
        if (pending.yetNeeded == 0) {
            pending.yetNeeded = minimum_required; // reset confirmations needed
            pending.ownersDone = 0; // reset owners confirmed to none (bitmap→0)
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation_hash;
        }
        uint <b green>ownerIdxBit</b> = 2**ownerIndex; // determine the bit to set
        if (pending.ownersDone & <b green>ownerIdxBit</b> == 0) {
            // ok - check if count is enough to go ahead.
            if (pending.yetNeeded <= 1 /* enough confirmations. reset→run*/) {
                delete m_pendingIndex[<b orange>mapPendingOps</b>[_operation_hash].index];
                delete <b orange>mapPendingOps</b>[_operation_hash];
                return true;
            } else {
                pending.yetNeeded--;
                pending.ownersDone |= <b green>ownerIdxBit</b>;
                return false;
            }
        }
    }
}
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href='https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial'>Voting</a>
contract Voting {
  uint       public <b orange>MIN_QUORUM</b>  ;
  uint       public <b orange>DEBATING_PERIOD</b> ;
  address    public <b green>FOUNDER</b>        ;
  Proposal[] public proposals      ;
  uint       public numProposals   ;
  
  struct <b blue>Vote     { int UpOrDown; address voter; }</b>
  struct Proposal {
    <b blue>Vote[]  votes</b>      ; mapping (address => bool) voted;
    bytes32 data        ; string  description;
    uint    creationDate; bool    active     ;
    boolean result;
  }
  
  constructor(uint _minimumQuorum, uint _debating_period) {
    <b green>FOUNDER</b>          = msg.sender;  
    <b orange>MIN_QUORUM</b>      = _minimumQuorum || 10;
    <b orange>DEBATING_PERIOD</b> = _debating_period * 1 minutes || 30 days;
  }

  function newProposal(bytes32 _data, string _descrip) returns (uint <b yellow>proposalID</b>) {
      <b yellow>proposalID</b>     = proposals.length++;
      Proposal p     = proposals[<b yellow>proposalID</b>];
      p.data         = _data;
      p.description  = _descrip  ;    p.creationDate = now;
      p.active       = true      ;    numProposals   = <b yellow>proposalID</b>+1;
  }
  
  function vote(uint _<b yellow>proposalID</b>, int _UpOrDown /*+1|-1*/) returns (uint <b brown>voteID</b>){
      if (_UpOrDown < -1 && _UpOrDown > 1 ) revert("UpOrDown is not valid") ;
      Proposal p = proposals[_<b yellow>proposalID</b>];
      if (p.voted[msg.sender] == true) return;
      <b brown>voteID</b> = p.<b blue>votes</b>.length++;
      p.<b blue>votes[<b brown>voteID</b>] = /*new*/Vote({UpOrDown: _UpOrDown, voter: msg.sender})</b>;
      p.voted[msg.sender] = true;
  }
  
  function executeProposal(uint _<b yellow>proposalID</b>) returns (int <b brown>result</b>) {
      Proposal proposal = proposals[_<b yellow>proposalID</b>];
      if (/*timeout?*/ now &gt; (proposal.creationDate + <b orange>DEBATING_PERIOD</b>) &amp;&amp; proposal.active){   
          uint quorum = 0;
          for (uint i = 0; i &lt;  proposal.<b blue>votes</b>.length; ++i) {
              Vote v = proposal.<b blue>votes</b>[i];
              quorum += 1;
              <b brown>result</b> += v.UpOrDown;
          }
          if (quorum &gt; <b orange>MIN_QUORUM</b>) {
              proposal.active = false;
              proposal.result = result &gt;=0 ? true : false;
          }
      }
  }
}
</pre>
</td>
</tr>
</table>

<hr xsmall />
<table>
<tr>
<td title>Libraries</td>
<td>
<pre xxxsmall zoom>
<span xsmall>About Libraries:</span>
@[https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736]
Library benefits:
  - saving substantial amounts of gas 
  - can make for a more secure environment (if reused libraries are audited).

- In Solidity, a library is a different type of contract
  (library myLib {...} vs contract myContract {...}) ,
  doesn't have any storage and cannot hold ether:
  - It doesn't allow payable functions and cannot have a
    fallback function, enforced by the compiler.

- It can be seen as a sort of a singleton in the EVM:
  a piece of code that can be called from any contract
  without the need to deploy it again.

- It can also be seen as implicit base contracts of
   the contracts that use them

- EVM DELEGATECALL instruction is used to call the function,
  causing the calling context to be passed to the library,
  as if it was code running in the contract itself. 
  
  context kept by library:
  | this       <- address of the contract invoquing the library not the
  |               library context
  | msg.sender <- sender address sing
  | msg.value
  | msg.sig
  | msg.data
  | msg.gas

 - Library <b>linking</b> happens at the bytecode level (compile
   phase) and not at storage level so once setted it's lined 
   for always:

   When contract A is compiled, it leaves a <b orange>placeholder</b> for
   the library address in this way:

    0073<b orange>__</b>C<b orange>_____________________________________</b>630dbe671f
        <b orange>  </b>C<b orange>                                     </b>  ^^^^^^^
        <b orange>  </b>C<b orange>                                     </b>  0dbe671f is the function
        <b orange>  </b>C<b orange>                                     </b>  signature for a()

    * At compile time (before deploying the contract) the placeholder must be
      replaced with the address of the deployed library in the blockchain.


PROBLEM With Events sent by Libraries:
  Only problem is, right now (March 2017), the contract ABI does
  not reflect the events that the libraries it uses may emit.
   This confuses clients such as web3, that won't be able to
  decode what event was called or figure out how to decode its
  arguments.

HACK:  defining the event both in the contract and the library 
  will trick clients into thinking that it was actually the
  main contract who sent the event and not the library.

See also:
<a TODO href="https://github.com/bkrem/awesome-solidity#libraries">Awesome Sol.Libs</a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://www.contract-library.com/">contract-library.com</a> 
- Decompiles most smart contracts deployed on the mainnet to a high level representation.
</pre>
</td>

<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/OpenZeppelin/">Open Zeppelin</a>
- <span TODO>Summary of "important" libraries</span>

- <a href="https://openzeppelin.org/api/docs/access_Roles.html">OpenZeppelin (2.0) API</a>
</td>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>ZeppelinOS "Upgradable Contracts" </span>
REFS:
- <a href="https://blog.zeppelinos.org/getting-started-with-zeppelinos/">Introduction @ Zepellin Blog</a>

ZeppelinOS "zos" is a command line tool to makes writing upgradeable contracts extremely easy, abstracting away the complexities of upgradeability.
 It is based on proxy libraries as explained <a TODO href="https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd">[here]</a> 

WARN: Upgradeability can NOT be applied to already-deployed contracts.

<b>zos install</b>
$ npm install --global zos

<b>zos ussage</b>
$ mkdir zos-demo && cd zos-demo
$ npm init -y
$ zos init zos-demo  # create the zos.json config. file
                                  ^^^^^^^^             
                              config file that makes zos
                              aware of your smart contract 
                              architecture.

$ npm install --save zos-lib # A "contracts" folder is created

$ vim contracts/CounterContract.sol
 pragma solidity ^0.4.21;
 import "zos-lib/contracts/migrations/Migratable.sol";

 | contract CounterContract is Migratable {
 |
 |   uint256 public counter;
 |
 |   // <b>initialize replaces constructor in upgradable contract</b>
 |   // guaranting that the new contract version can only be initialized once.
 |   function <b orange>initialize</b>(uint256 _counter)   
 |     // isInitializer takes the name of contract and version ID
 |     <b>isInitializer("CounterContract", "0")</b> public {
 |     counter = _counter;
 |   }
 |
 |   function increment() public {
 |     counter += 1; 
 |   }
 | }
 | 
 Note: If you do use a constructor in an upgradeable smart contract, 
       everything you set in the constructor will be ignored.


<b>Testing</b>
("npm install --save ganache-cli" if not already done)
$ npx ganache-cli --port 9545 

$ zos add CounterContract  # ← STEP 1: Add smart contract to zos
$ zos push --network local # ← STEP 2: push it to the local network:

$ zos create CounterContract \ # create&amp;initialize upgradeable instance
      --init <b orange>initialize</b> \
      --args 42 \     ← must match the <b orange>initialize</b> method.
      --network local
→ ... 
→ ... <b green>CounterContract proxy: <address></b>  ← address to use for instance
→ ...                                                  (safe somewhere safely!)

$ npx truffle console --network=local  # ← enter truffle interactive console
  truffle> counterContract = CounterContract.deployed()    # Alt 1:
  truffle> counterContract = CounterContract.at("address") # Alt 2:
  truffle> counterContract.increment()                     # Call public method
  truffle> counterContract.counter().then(counter => counter.toNumber()) # Fetch value
  → 43
  truffle> .exit

<b>Upgrade deployed contract</b>   
  (add incrementByTwo and history map)

    pragma solidity ^0.4.21;
    import "zos-lib/contracts/migrations/Migratable.sol";

    contract CounterContract is Migratable {
     uint256 public counter;
 +  mapping(uint256 => address) public history;
    ...

 +  function incrementByTwo() public {
 +     counter += 2;
 +     history[counter] = msg.sender;
 +   }
    }
<b bgred>WARN: When writing new versions of your contract, you must preserve all variables that
      appear in previous versions of your smart contract in the same order.
      You should only make additive changes. You can find more details in the advanced topics page.</b>

$ zos push --network local                    # ← Push new version.
$ zos update CounterContract --network local  # ← update CounterContract to new version

<b>Test new version</b>
$ npx truffle console --network=local to access the truffle console.
   truffle> counterContract = CounterContract.deployed() # alt 1
   truffle> counterContract = CounterContract.at("address")
   truffle> counterContract.incrementByTwo() 
   truffle> counterContract.counter().then(counter => counter.toNumber())
   → 45  
   truffle> counterContract.history(45)
   → 0x....  

<b>
Note: If at any point you’ve stopped Ganache and need to restart this process all over,
make sure you delete zos.local.json file as well. This isn’t a problem for other networks,
x since typically networks don’t get wiped out :)</b>
<span xsmall>ZOS TODO</span> 
<a TODO href="https://blog.zeppelinos.org/getting-started-with-zeppelinos/">Getting Started with Z.OS</a>
<a TODO href="https://docs.zeppelinos.org/docs/advanced.html#deploying-to-mainnet">Mainnet Deploy</a>
<a TODO href="https://docs.zeppelinos.org/docs/basil.html">Advanced Tutorial</a>
<a TODO href="https://docs.zeppelinos.org/docs/crafty.html">Advanced example (Crafty)</a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://blog.aragon.one/advanced-solidity-code-deployment-techniques-dc032665f434">Advanced deployment (@Aragon)</a>
<a xsmall TODO href="https://hack.aragon.org/docs/aragonos-intro.html">AragonOS</a>
aragonOS provides the following functionality:
- DAO: Decentralized Autonomous Organization

- Upgreadability: Smart contracts can be upgraded to a newer version. Example: fixing a bug or adding a feature.
- Permission control: By using the auth() and authP() modifiers you can protect functionality such that they're only accessible by other apps or entities if given permission. This completely abstracts the authentication logic from an app, allowing you to focus on your app's business logic. Example: protecting a vault so only the organization's Voting app can initiate an action to transfer funds.
- Forwarders: aragonOS apps can communicate with each other by sending their intent to perform an action to other apps. Example: withdrawing funds from a vault only on the passing of a vote and the expiring of a time-lock.

All the above makes it very simple for aragonOS apps to incorporate governance. You just need to add a voting app, configure permissions the right way, and away you go!
<a xsmall TODO href="https://hack.aragon.org/docs/apm.html">Upgradeability</a>
- As a DAO, each aragonPM registry includes a number of installed applications, including one APMRegistry, one ENSSubdomainRegistrar, and many Repo instances.
<a xsmall TODO href="https://github.com/aragon/aragon-apps">Aragon Apps</a>
This repository contains the following apps:
 - Vault       : Securely owns and manages tokens on behalf of a DAO.
 - Finance     : Send payments and manage expenses with budgeting.
 - Voting      : Create votes that execute actions on behalf of token holders.
 - Token Manager: Manages organization tokens.

Under development:
 -  Payroll    : Manages employees' payrolls.
</pre>
</td>

<td colsep></td>

<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/modular-network/ethereum-libraries">Modular-Network Libs</a>
- ArrayUtilsLib   
- BasicMathLib
- CrowdsaleLib
- LinkedListLib
- StringUtilsLib
- TokenLib
- VestingLib
- WalletLib
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Deprecated libs:</span>
<a TODO href="https://github.com/ethereum/dapp-bin/tree/master/library">Dapp-bin</a>
Amongst others contains 
   linkedList.sol and iterable_mapping.sol but it's not maintained since Mid-2017
</pre>
</td>

</tr>
</table>

<hr xsmall />
<b bggreen>
  Development Tools 
  <a href='http://ethereum.stackexchange.com/questions/269/what-exactly-is-an-ethereum-client-and-what-clients-are-there/335'>[REF@Stackoverflow]</a>,
  <a href="https://www.reddit.com/r/ethdev/comments/9jw839/long_list_of_ethereum_developer_tools_frameworks/">[REF@Reddit]</a>
</b>
<table>
<tr>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://docs.0xcert.org/">0xcert.org</a> 
 The 0xcert Framework is a JavaScript library that provides a complete set of 
tools for building powerful decentralized applications (dapps). 
 It enables management, digital representation, and ownership verification of 
unique assets such as certificates, artworks, and collectibles. 
</pre>
</td>
<td colsep>JS</td>
<td>
<pre xxxsmall zoom>
<span xsmall>JS API</span>
@[https://github.com/ethereum/wiki/wiki/JavaScript-API]
- See also: etherlime (web3js alt)
@[https://medium.com/limechain/etherlime-framework-8cbb270944d6]

eth_accounts                                           eth_getTransactionCount
eth_blockNumber                                        eth_getTransactionReceipt
eth_call                                               eth_hashrate
eth_coinbase                                           eth_mining
eth_compileSolidity                                    eth_newBlockFilter
eth_estimateGas                                        eth_newFilter (includes log/event filters)
eth_gasPrice                                           eth_sendTransaction
eth_getBalance                                         eth_sendRawTransaction
eth_getBlockByNumber                                   eth_sign
eth_getBlockByHash                                     eth_syncing
eth_getCode (only supports block number “latest”)      eth_uninstallFilter
eth_getCompilers                                       net_listening
eth_getFilterChanges                                   net_peerCount
eth_getFilterLogs                                      net_version
eth_getLogs                                            miner_start
eth_getStorageAt                                       miner_stop
eth_getTransactionByHash                               rpc_modules
eth_getTransactionByBlockHashAndIndex                  web3_clientVersion
eth_getTransactionByBlockNumberAndIndex                web3_sha3
</pre>
</td>
<td colsep> </td>
<td title>Truffle</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://www.truffleframework.com/">Truffle "Full Journey"</a>
<b>new bare Project</b>
   
$ mkdir fibonacci
$ cd fibonacci
$ <b>truffle init</b>  # ← Create a bare truffle project:
$ vim Smart-Contract contracts/Fibonacci.sol:
    | pragma solidity ^0.4.22;
    | contract Fibonacci {
    |     // fibseries declaration outside function 
    |     //   => saved in storage (vs memory) 
    |     //    => triggers TX when modified 
    |     uint[] fibseries; 
    |     // n = how many in the series to return
    |     function generateFib(uint n) public {
    |         // set 1st and 2nd entries
    |         fibseries.push(1);
    |         fibseries.push(1);
    |
    |         // generate subsequent entries
    |         for (uint i=2; i &lt; n ; i++) {
    |             fibseries.push(fibseries[i-1] +
    |                            fibseries[i-2]);
    |         }
    |     }
    | }
$ vim migrations/2_deploy_contracts.js:
WARN: ¡¡¡do not touch 1_initial_migration.js!!!
    | var Fibonacci = artifacts.require("Fibonacci");

    | module.exports = function(deployer) {
    |   deployer.deploy(Fibonacci);
    | };
$ vim truffle-config.js:
    | module.exports = {
    |   networks: {
    |     development: {
    |       host: "127.0.0.1",  ← test geth/ganache/... IP 
    |       port: 7545,         ← test geth/ganache/... port
    |       network_id: "*"
    |     }
    |   }
    | };
$ <b>truffle compile</b>
(compiles /contracts/*.sol → build/contracts/*.json )
JS clients apps can then use the contract with code similar to:
import metacoin_artifacts from '../../build/contracts/MetaCoin.json'

Migrate to default network defined in truffle.js (localhost:8545)
(Ussually this correspond to the testrpc daemon)
$ <b>truffle migrate</b>
$ vim test/TestFibonacci.js
$ <b>truffle test</b>

$ <b>truffle deploy</b> <span TODO>Deploy to ""real""/""test"" network</span>
                        # sends contract to the Ethe. network. Will also update
                        # contracts.json adding the {""address"":...""} for the
                        #deployed contract
*run multiline script*
<a href="https://ethereum.stackexchange.com/questions/36549/how-to-run-a-multiline-script-in-truffle-console">REF</a>
*STEP 1:* Write script to 'myScript.js' file. 
*STEP 2:* Use require or exec like:
truffle(dev)→*require*('./myScript.js')  ← alt 1:
truffle(dev)→*exec* './myScript.js'      ← alt 2:
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Debug Session</span>
  <a href="https://truffleframework.com/tutorials/debugger-variable-inspection">REF</a>
$ truffle console  # ← Will fail in test node is NOT running
truffle(development)> <b>compile</b>
→ Compiling .\contracts\Fibonacci.sol...
→ Compiling .\contracts\Migrations.sol...
→ Writing artifacts to .\build\contracts
→ ...
( Check for errors)
truffle(development)> <b>migrate</b>
→ Using network 'development'.
→ ...
→ Running migration: 1_initial_migration.js
→ ...
→ Running migration: 2_deploy_contracts.js
→ ...
→ ...
→ ...
→ ...
(Check in geth logs|ganache console that TXs have been mined)

truffle(development)> <b>Fibonacci.deployed()
                         .then(instance => instance.generateFib(10))</b>
                               ^^^^^^^^
                               JS "proxy" to 
                             newly deployed contract 
→ { tx: '<span bgorange>0xf47f...41c</span>',
→   receipt:
→    { transactionHash: '<span bgorange>0xf47f0...1c41c</span>',
→      transactionIndex: 0,
→      blockHash: '0x88d45cb84d1f26....49a2ed',
→      blockNumber: 5,
→      gasUsed: 298373,
→      cumulativeGasUsed: 298373,
→      contractAddress: null,
→      logs: [],
→      status: '0x01',
→      logsBloom: '0x000....0000' },
→   logs: [] 
→ }

truffle(development)> console.dir(instance) 
→ ...
truffle(development)> <b>debug</b> <span bgorange>0xf47f0...1c41c</span>
→ Gathering transaction data...
→ Addresses affected:                                     
→  0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci 
→ 
→ Commands:
→ (enter) last command entered (step next)
→ (o) step over, (i) step into, (u) step out, (n) step next
→ (;) step instruction, (p) print instruction, (h) print this help, (q) quit
→ (b) toggle breakpoint, (c) continue until breakpoint
→ (+) add watch expression (`+:<expr>`), (-) remove watch expression (-:<expr>)
→ (?) list existing watch expressions
→ (v) print variables and values, (:) evaluate expression - see `v`
→ 
→ Fibonacci.sol:
→                             
→ 1: pragma solidity ^0.4.22;
→ 2:
→ 3: contract Fibonacci {
→    ^^^^^^^^^^^^^^^^^^^^
debug(development:0xf47f01da...)> <b>n</b>
→ 7:   // n = how many in the series to return
→ 8:   function generateFib(uint n) public {
→      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
→ 
(Move until reaching the for-loop)
debug(development:0xf47f01da...)> <b>v</b>
→         i: 0
→         n: 10
→ fibseries: []
debug(development:0xf47f01da...)> <b>+:{ i, fibseries }</b> ← watch vars (show after instruction)
                                  <b>                  </b>   -:i to unwatch
debug(development:0xf47f01da...)> <b>o</b>  ← Repeat until filling the array
→ ...
→ fibseries: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Recompile-Update</span>
truffle(development)> <b>compile --all</b>
                              ^^^^^
                              force recompile all
                              of the contracts.
→ ...
truffle(development)> <b>migrate --reset</b>
→ ...
truffle(development)> <b>Fibonacci.deployed().then(function(instance){return instance.generateFib(10);});</b>
→ ...
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/trufflesuite/truffle/tree/develop/packages">npm pkgs list</a> 
truffle-artifactor :   
truffle-blockchain-utils
truffle-box
truffle-code-utils
truffle-compile-vyper
truffle-compile
truffle-config
truffle-contract-schema
truffle-contract-sources
truffle-contract
truffle-core
truffle-debug-utils
truffle-debugger
truffle-decode-utils
truffle-decoder
truffle-deployer
truffle-error
truffle-expect
truffle-external-compile
truffle-hdwallet-provider
truffle-interface-adapter
truffle-legacy-system
truffle-migrate
truffle-provider
truffle-provisioner
truffle-reporters
truffle-require
truffle-resolver
truffle-sawtooth-seth-provider
truffle-solidity-loader
truffle-solidity-utils
truffle-workflow-compile
truffle
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a TODO xsmall href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/events.js#L118-L143">Testing events</a> 
var assert = require("chai").assert;
var util = require("./util");
describe("Events", function() {
  var Example;
  var accounts;
  var web3;
  var providerOptions = { vmErrorsOnRPCResponse: false };
 *before*(async function() {
    this.timeout(10000);
    Example = await util.createExample();
    return util.setUpProvider(Example, providerOptions).then(result => {
      web3 = result.web3;
      accounts = result.accounts;
    });
  });
  it('should expose the "on" handler / format event correctly', function(done) {
    Example.new(1).then(example => {
      const event = example.ExampleEvent();
      event.on("data", function(data) {
        assert.equal("ExampleEvent", data.event);
        assert.equal(accounts[0], data.args._from);
        assert.equal(8, data.args.num); // 8 is a magic number inside Example.sol
        this.removeAllListeners();
        done();
      });
      example.triggerEvent();
    });
  });
  it('should expose the "once" handler', function(done) {
    Example.new(1).then(example => {
      const event = example.ExampleEvent();
      event.once("data", function(data) {
        assert.equal("ExampleEvent", data.event);
        assert.equal(accounts[0], data.args._from);
        assert.equal(8, data.args.num); // 8 is a magic number inside Example.sol
        this.removeAllListeners();
        done();
      });
      example.triggerEvent();
    });
  });
  it("should be possible to listen for events with a callback", function(done) {
    const callback = (err, data) => {
      assert.equal("ExampleEvent", data.event);
      assert.equal(accounts[0], data.args._from);
      assert.equal(8, data.args.num);
      done();
    };
    Example.new(1).then(example => {
      example.ExampleEvent(callback);
      example.triggerEvent();
    });
  });
  it("event emitter should fire repeatedly (without duplicates)", async function() {
    let emitter;
    let counter = 0;
    const example = await Example.new(1);
    example.ExampleEvent().on("data", function() {
      emitter = this;
      counter++;
    });
    await example.triggerEventWithArgument(1);
    await example.triggerEventWithArgument(2);
    await example.triggerEventWithArgument(3);
    assert(counter === 3, "emitter should have fired repeatedly");
    emitter.removeAllListeners();
  });
  it("event callback should fire repeatedly (without duplicates)", async function() {
    let counter = 0;
    let duplicate = false;
    const example = await Example.new(1);
    example.ExampleEvent(function(err, res) {
      if (res === false) duplicate = true;
      counter++;
    });
    await example.triggerEventWithArgument(1);
    await example.triggerEventWithArgument(2);
    await example.triggerEventWithArgument(3);
    assert(counter === 3, "callback should have been called repeatedly");
    assert(duplicate === false, "must not fire duplicates as false result");
  });
  it("should listen for `allEvents`", async function() {
    let emitter;
    const events = [], eventNames = [], signatures = ["ExampleEvent", "SpecialEvent"];
    const example = await Example.new(1);
    example.allEvents().on("data", function(data) {
      events.push(data);
      data.event && eventNames.push(data.event);
      emitter = this;
    });
    await example.triggerEvent();
    await example.triggerSpecialEvent();
    assert(
      eventNames.includes(signatures[0]),
      `Expected to hear ${signatures[0]}`
    );
    assert(
      eventNames.includes(signatures[1]),
      `Expected to hear ${signatures[1]}`
    );
    // Make sure we're formattingfor backwards compatibility
    assert.equal(events[0].args._from, accounts[0]);
    assert.equal(events[0].args.num, 8);
    emitter.removeAllListeners();
  });
  it("should `getPastEvents`", async function() {
    const signatures = ["ExampleEvent", "SpecialEvent"];
    const example = await Example.new(1);
    const options = { fromBlock: 0, toBlock: "latest" };
    await example.triggerEvent();
    await example.triggerEvent();
    await example.triggerSpecialEvent();
    await example.triggerSpecialEvent();
    const exampleEvent = await example.getPastEvents("ExampleEvent", options);
    const specialEvent = await example.getPastEvents("SpecialEvent", options);
    assert(exampleEvent.length === 2);
    assert(exampleEvent[0].event === signatures[0]);
    assert(exampleEvent[1].event === signatures[0]);
    // Make sure we're formatting for backwards compatibility
    assert.equal(exampleEvent[0].args._from, accounts[0]);
    assert.equal(exampleEvent[0].args.num, 8);
    assert(specialEvent.length === 2);
    assert(specialEvent[0].event === signatures[1]);
    assert(specialEvent[1].event === signatures[1]);
  });
  // Event signature is:
  // NumberEvent(int numA, int indexed numB, address addrC, uint numD, uint);
  it("should reformat numbers in events to BN by default", function(done) {
    Example.new(1).then(example => {
      const event = example.NumberEvent();
      event.once("data", function(data) {
        const args = data.args;
        assert(web3.utils.isBN(args[0])); // int named
        assert(web3.utils.isBN(args[1])); // int named, indexed
        ...
        assert(web3.utils.isBN(args.numA));
        assert(web3.utils.isBN(args.numB));
        assert(!web3.utils.isBN(args.addressC));
        assert(web3.utils.isBN(args.numD));
        assert(args.numA.toNumber() === 5);
        assert(args.numD.toNumber() === 55);
        this.removeAllListeners();
        done();
      });
      example.triggerNumberEvent(5, 7, accounts[0], 55, 77);
    });
  });
});
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/errors.js"         >test:errors.js          </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/abiV2.js"          >test:abiV2.js           </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/cloning.js"        >test:cloning.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/customoptions.js"  >test:customoptions.js   </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/deploy.js"         >test:deploy.js          </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/deprecated_keys.js">test:deprecated_keys.js </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/linking.js"        >test:linking.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/methods.js"        >test:methods.js         </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/networkObject.js"  >test:networkObject.js   </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/networks.js"       >test:networks.js        </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/separation.js"     >test:separation.js      </a>
<a TODO href="https://github.com/trufflesuite/truffle/blob/next/packages/truffle-contract/test/util.js"           >test:util.js            </a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>truf.security</span> 
@[https://github.com/ConsenSys/truffle-security]
- MythX Security Analysis Plugin for Truffle Framework
- adds automated smart contract security analysis to the
  Truffle framework.
- Compatible with Truffle 4.0 or higher.
</pre>


</td>

<td colsep></td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://metamask.github.io/metamask-docs/">MetaMask Plugin</a> 
- browser extension enabling browsing Ethereum blockchain enabled websites.
- MetaMask was created out of the needs of creating more secure and usable 
  Ethereum-based web sites. In particular, it handles account management 
  and connecting the user to the blockchain.
- Allows users to manage accounts and their keys in a variety of ways,
  including hardware wallets, while isolating them from the site context.
  (vs storing the user keys on a single central server, or even in local storage)

<a TODO href="./API_Reference/Ethereum_Provider">injected provider</a>
<a TODO href="./API_Reference/JSON_RPC_API">JSON RPC API</a>
<a TODO href="./API_Reference/Experimental_APIs">Other supported APIs</a>
</pre>
</td>

</tr>
</table>
<table>
<tr>
<td title>JAVA</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://docs.web3j.io/">Web3J</a><br/>
<a href="https://docs.web3j.io/getting_started.html">pom / gradle dependencies</a>
<a href="https://github.com/web3j/sample-project-gradle/blob/master/src/main/java/org/web3j/sample/Application.java">Example app</a>
<a href="https://docs.web3j.io/infura.html">Using infura</a>


SYNC. REQUESTS                        | CompletableFuture (Future ON ANDROID): | RXJAVA OBSERVABLE:
Web3ClientVersion web3ClientVersion = | Web3ClientVersion web3ClientVersion =  | web3.web3ClientVersion()
    web3.web3ClientVersion()          |     web3.web3ClientVersion()           |     .observable().subscribe(x -&gt; {
    .send().getWeb3ClientVersion();   |     .sendAsync().get();                |     String clientVersion = 
                                      |                  ^blocking             |         x.getWeb3ClientVersion();
                                      |                                        | });


TRANSACT WITH A SMART CONTRACT WRAPPER:       | CALL A SMART CONTRACT WRAPPER:
----------------------------------------------+---------------------------------------------
(changes status in blockchain, needs mining)  | (local query, no mining needed)
TransactionReceipt transactionReceipt =       | Type result = 
   contract.someMethod(                       |    contract.someMethod(<param1>, ...).send();
     "param1", ...).send();                   |
                                              | The "someMethod" in *.sol contract needs to be 
                                              | marked as "view". Otherwise the java wrapper
                                              | will generate code for new TXs returning
                                              | a TX receipt
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Web3J FILTERS</span>
Subscribe for "new-blocks" events:                  | Subscribe for "new-TXs" events:                  | Subscribe for "new pending-TX" events: 
----------------------------------------------------+--------------------------------------------------+----------------------------------------
Subscription subscription =                         | Subscription subscription =                      | Subscription subscription = 
  web3j.blockObservable(false).subscribe(block -> { |   web3j.transactionObservable().subscribe(tx -> {|    web3j.pendingTransactionObservable().
    ...                        ^                    |       ...                                        |      subscribe(tx -> { ...  });
  });                          |                    |   });
                               |
                            Optionally:
  catchUpToLatestAndSubscribeToNewBlocksObservable(
        <startBlockNumber>, <fullTxObjects>)
        .subscribe(block -> {
            ...
});

<b>subscription.unsubscribe(); //when no longer required </b>

<b>TOPIC FILTERS:</b> <b red>not supported on Infura</b>

EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
        DefaultBlockParameterName.LATEST, <contract-address>)
             .addSingleTopic(...)|.addOptionalTopics(..., ...)|...;
web3j.ethLogObservable(filter).subscribe(log -> {
    ...
});
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/esaulpaugh/headlong">Headlong</a> 
- A Contract ABI and Recursive Length Prefix library in Java for use on the Ethereum network

Contract ABI and Recursive Length Prefix made easy in Java (or Android). 
Everything heavily optimized for maximum throughput (ABI function call encoding
 <b>up to 500x faster than a popular competitor</b> and one function creation plus one 
encode is up to 60x faster ("f(uint,uint32[],bytes10,bytes)", openjdk 11.0.1)).

</pre>
</td>
<td colsep></td>
<td colsep>C#</td>
<td>
<pre xxxsmall zoom>
  <a xsmall TODO href="https://nethereum.readthedocs.io/en/latest/">Nethereum</a><br/>
PRE-SETUP
$ <b>dotnet add package Nethereum.Web3</b>

<b>Sending Ethers</b>
using System;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Hex.HexTypes;
using Nethereum.HdWallet;

bool useSoftWallet = true // ← false => Use HW Wallet
if (useSoftWallet) {
  // Alt 1: Use <b>private key/Software wallet</b> to init web3 instance.
  var account = new Account(
      "0x... 32 bytes- private key in Hex format ");
  
  var web3 = new Web3(account);
} else {
  // Alt 2: Use <b>HW Wallet</b> to init web3 instance
  string Words = "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal";
                  string Password = "password";
  var wallet = new Wallet(Words, Password);
  var account = wallet.GetAccount(0);
  var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";
  var web3 = new Web3(account);
}
var toAddress = "0x13f022d72158410433cbd66f5dd8bf6d2d129924";

var TXManager = web3.Eth.GetEtherTransferService();
var TX = await TXManager
    .TransferEtherAndWaitForReceiptAsync(
       toAddress, Web3.Convert.ToWei(1));
 // alt: Specify gas amount
 // .TransferEtherAndWaitForReceiptAsync(
 //    toAddress, Web3.Convert.ToWei(1), 2);
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://nethereum.readthedocs.io/en/latest/nethereum-events-gettingstarted/">Handling Events</a> 
- Events ("emit" in solidity code) write data to the transaction receipt logs.

...
var  transactionReceipt = await transferHandler.SendRequestAndWaitForReceiptAsync(contractAddress, transfer);
var transferEventOutput = transactionReceipt.DecodeAllEvents<TransferEventDTO>();

Contract Filters and Event Logs

- get all changes of the logs (providing a filter message)
- or create filters and retrieve changes which apply to our filter message periodically.

TO ACCESS THE LOGS:
 - CREATE A TRANSFER EVENT HANDLER FOR OUR CONTRACT ADDRESS 
 - CREATE AN EVENT DEFINITION.(TransferEventDTO).

var <b orange>transferEventHandler</b> = web3.Eth.GetEvent<TransferEventDTO>(contractAddress /* null to retreive all signature-matching-events from any contract */ );  
    ^^^^^^^^^^^^^^^^^^^^
var emptyFilter01 = <b orange>transferEventHandler</b>.CreateFilterInput(); // By default from block cero to current block

var allTransferEventsForContract = await <b orange>transferEventHandler</b>.GetAllChanges(emptyFilter01); 

var <b blue>fromToIndexFilterInput01</b> = <b orange>transferEventHandler</b>.CreateFilterInput<string, string>(account.Address, receiverAddress2);
var <b blue>    toIndexFilterInput01</b> = <b orange>transferEventHandler</b>.CreateFilterInput<string, string>(null, receiverAddress2);
var <b blue>toManyIndexFilterInput01</b> = <b orange>transferEventHandler</b>.CreateFilterInput(null, new []{receiverAddress2, receiverAddress});
var allEventsFromTo  = await <b orange>transferEventHandler</b>.GetAllChanges(<b blue>fromToIndexFilterInput01</b>);
var allEventsTo      = await <b orange>transferEventHandler</b>.GetAllChanges(<b blue>    toIndexFilterInput01</b>);
var allEventsToMany  = await <b orange>transferEventHandler</b>.GetAllChanges(<b blue>toManyIndexFilterInput01</b>);

var <b green>fromToIndextFilterID</b> = await <b orange>transferEventHandler</b>.CreateFilterAsync(fromToIndexFilterInput01);
var allNewEventsFromTo   = await <b orange>transferEventHandler</b>.GetFilterChanges(<b green>fromToIndextFilterID</b>);
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://nethereum.readthedocs.io/en/latest/nugets/">Nuget packages</a>
- Standalone packages targeting Netstandard 1.1, net451, Netstandard 2.0, Netcoreapp 2.1
  and where possible net351 to support Unity3d. 
 (Nethereum.Portable deprecated)
Windows:                                Windows/Mac/Linux users
PM > Install-Package Nethereum.Web3     dotnet add package Nethereum.Web3 
<b>Main Libraries</b>
Project Source                    Description
Nethereum.Web3                    Web3-RPC, contract inter./deployment/TX, en/de-coding, event filters
Nethereum.Unity  
Nethereum.Geth                    Geth support for Admin, Debug, Miner
Nethereum.Quorum 
Nethereum.Parity                  Parity  non-generic RPC API support
<b>Core Libraries</b>

Project Source                  Description
Nethereum.ABI                   Encoding/decoding of ABI Types, functions, events of Ethereum contracts
Nethereum.EVM                   Ethereum Virtual Machine API
Nethereum.Hex                   HexTypes for encoding and decoding String|BigInteger...
Nethereum.RPC                   
Nethereum.JsonRpc.Client        
Nethereum.JsonRpc.RpcClient     
Nethereum JsonRpc IpcClient     
Nethereum.RLP                   RLP encoding and decoding
Nethereum.KeyStore              Keystore generation|en/de-cryption (Web3 Secret Storage definition)
Nethereum.Signer                Nethereum signer library to sign and verify messages,
                                RLP and transactions using an Ethereum account private key
Nethereum.Contracts             Core library to interact via RPC with Smart contracts
Nethereum.IntegrationTesting    Integration testing module
Nethereum.HDWallet              Generates an HD tree of Ethereum compatible addresses from
                                a randomly generated seed phrase (using BIP32 and BIP39)

<b>Smart contract API Libraries</b>
Project Source                  Description
Nethereum.StandardTokenEIP20    Nethereum.StandardTokenEIP20 Service 
Nethereum.Uport                 Uport registry library
Nethereum.ENS                   Ethereum Name service library
<b>Utilities</b>
Nethereum.Generator.Console     collection of cli utilities to interact with Ethereum/account management
<b>Training modules</b>
Project                         Description
Nethereum.Workbooks             Xamarin Workbook tutorials including executable code
Nethereum.Tutorials             Tutorials to run on VS Studio
<b>Code templates</b>
Source                          Description
Keystore generator              Keystore file generator
Faucet                          Web application template for an Ether faucet
Nethereum Flappy                The source code files for the Unity3d game integrating with Ethereum
Nethereum Game Sample           Sample game demonstrating how to integrate Nethereum with UrhoSharp's
                                SamplyGame to build a cross-platform game interacting with Ethereum
Nethereum UI wallet sample      Cross platform wallet example using Nethereum, Xamarin.Forms and MvvmCross, 
                                targeting: Android, iOS, Windows Mobile, Desktop (windows 10 uwp), IoT
                                with the Raspberry PI and Xbox.
</pre>
</td>
<td title>Py<br/>thon</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://eth-brownie.readthedocs.io/en/latest/">Brownie</a> 
</pre>
<a xsmall TODO href="https://github.com/HyperLink-Technology/brownie">[Github]</a> 
<pre xxxsmall zoom>
- simple python framework for testing, deploying and interacting 
  with ethereum smart contracts.
</pre>
</td>


<td colsep></td>
<td colsep></td>

<td>
<pre xxxsmall zoom>
<span xsmall TODO>Dev. Trouble-shoot</span>
<b>solc *bin output is empty, but there are no compilation warnings:</b>
PROBLEM:
    Next code compiles "OK" using
    SOLC INPUT               |  SOLC OUTPUT
    -------------------------|--------------------
    pragma solidity ^0.4.8;  |  A.bin  6060604...
    contract A {             |  B.bin  6060604...
      uint public a1;        |
    }                        |
                             |
    contract B <b>is A</b> { |
      uint8 public b1;       |
    }                        |

  <b red>Adding any constructor to the A contract, and keeping same B 
  generates erroneus empty B.bin</b>

SOLUTION:
   solc compiler consider the class abstract and does not generate any
   bin due to some of the following reasons:
    - B will need to provide parent A constructor with a parameter
      contract B is A {
        uint8 public b1;
      
        <b blue>constructor(address _a) A(_a) { // or A(0x00112...)
           ...
        }</b>
      }
   
    - B does NOT implementsall mehtods of declared interfaces or base clases


<b>Problem: Transaction with same hash already imported  error:</b>
<a href="https://ethereum.stackexchange.com/questions/9055/cant-broadcast-ethereum-transaction-whats-wrong-with-this-transaction">REF.1</a>, <a href="https://gitter.im/web3j/web3j?at=58d1e9ce5917e26076be161c">REF 2.web3j Gitter</a>
Solution: This means that the same transaction is sent twice with onley the nonce different.
 Probably it's a client error.
</pre>
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title>Plasma (Scalability framework)</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://plasma.io/">Plasma.io</a> 
Authors: Joseph Poon and Vitalik Buterin
- framework for incentivized and enforced execution of smart contracts which 
is scalable to a significant amount of state updates per second (potentially 
billions) enabling the blockchain to be able to represent a significant 
amount of decentralized financial applications worldwide. These smart 
contracts are incentivized to continue operation autonomously via network 
transaction fees, which is ultimately reliant upon the underlying blockchain 
(e.g. Ethereum) to enforce transactional state transitions.
_____________________________

https://plasma.io/plasma.pdf
The orchestrated transaction processing paradigm using the interplay between 
rootchains, plasma chains, and child chains through a combination of fraud-
proof mechanism designs and fidelity bond incentive structures help satisfy 
dynamics between the block-withholding and mass withdrawal surfaces. It also 
allows for further cryptoeconomic structures to be filled using mechanisms 
from systems like Casper or Truebit for mirroring concepts used in erasure 
coding in terms of the data availability problem that is prevalent in the 
space. For a multichain architecture, Ethereum would be able to combine the 
database coordination and throughput capabilities of a distributed database 
system with the public chain compatible capabilities of an actual blockchain.
_____________________________

https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
Through technical evaluations of tools like Plasma and formats of obtaining 
consensus in Casper, it is apparent that database management tools like 
MapReduce and Abstract Rewrite Systems will be implemented in Ethereum. In 
Plasma, MapReduce is an integral part of assembling the coordination of an 
account based system and a bitmap-UTXO commitment structure of a multichain 
setup.
  ...
Plasma shares quite a bit of influence from a heavily cryptoeconomic 
incentive structure focused platform called Truebit which was designed to 
increase the offchain computational capabilities of the Ethereum network. By 
architecting the Truebit system around a verification game in which Solvers 
of the overall consensus mechanism can be challenged by Verifiers which 
obtain a reward if they identify a nefarious counterparty, an internal 
cryptoeconomic ?checks and balances? of the system is created to incentive a 
dominant strategy of behaving fairly. As Plasma through the influence of 
TrueBit is focused on creating a multichain interoperability network, the 
internal enforcement of the system is paramount toward achieving information 
and consensus fidelity.

</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/cryptoeconomicslab/plasma-chamber">Plasma Chamber Framework:</a> 
- DApps dev framework that guarantees security, scalability, and usability
  utilizing Plasma technology. https://www.cryptoeconomicslab.com/
</pre>
</td>
<td>
<pre xxxsmall zoom>
 <a xsmall TODO href="https://leapdao.org/">Lead DAO</a> 
- More Viable Plasma design with smart contract like functionality.
</pre>
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title>Enterprise Integration</td>
<td>
<pre xxxsmall zoom bgorange>
  <span xsmall>Integration Layout</span>
REF: https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43
____________________________________________________________________________________________

<b>APPLICATIONS</b>

  DAPPS            +------------------+  +-----------------------------+
                   |   Applications   |  |  Explorers, Monitoring & BI |
                   +------------------+  +-----------------------------+

  INFRA CONTRACTS  +--------+  +----+*4 +----------+    +--------+  +------------+
  & STANDARS       |IDENTITY|  |RBAC|   |NETWORK   |    |TOKEN   |  |ETHEREUM    |
                   +--------+  +----+   |GOVERNANCE|    |STANDARS|  |NAME SERVICE|
                                        +----------+    +--------+  +------------+
____________________________________________________________________________________________

<b>TOOLING</b>

  Permisions &     +-------+2  +--------------+2     +---+3   +-----------------------------+3
  Credentials      |WALLETS|   |KEY MANAGEMENT|      |HSM|    |PERMISSIONING/AUTHENTICATION |
                   +-------+   +--------------+      +---+    +-----------------------------+

  INTEGRATION&     +-----------+2                    +--------------------------+3 +--------+3
  DEPLOYMENT       |INTEGRATION|                     |ENTERPRISE MANAGEMENT SYS.|  |ORACLES |
  TOOLS            |LIBRARIES  |                     +--------------------------+  +--------+
                   +-----------+                              

                   +--------+2   +-----------+2
  CLIENT           |JSON|RPC|    |INTER-CHAIN|
  INTERFACES       +--------+    +-----------+
____________________________________________________________________________________________

<b>PRIVACY</b>
                  +--------+2    +--------------------+3  +-------------------+3
                  |ON|CHAIN|     |PRIVATE|TRANSACTIONS|   |OFF+CHAIN          |
                  +--------+     +--------------------+   |(TRUSTED EXECUTION)|
                                                          +-------------------+   
____________________________________________________________________________________________

<b>SCALING</b>
                  +-----------------+2       +------------------+2
                  |ON+CHAIN(LAYER 2)|        |OFF+CHAIN(COMPUTE)|
                  +-----------------+        +------------------+

____________________________________________________________________________________________
<b>CORE BLOCKCHAIN</b>

  STORAGE/LEDGER  +------------+      +--------+      +---------+2       +-------------+3
                  |ON+CHAIN    |      |ON+CHAIN|      |OFF+CHAIN|        |ON+CHAIN     |
                  |PUBLIC STATE|      |STORAGE |      |STORAGE  |        |PRIVATE STATE|
                  +------------+      +--------+      +---------+        +-------------+

  EXECUTION       +---+         +-----+2     +-----------+2      +----------+3
                  |EVM|         |SYNC |      |PRECOMPILED|       |TRUSTED   |
                  +---+         +-----+      | CONTACTS  |       | EXECUTION|
                                             +-----------+       +----------+

  CONSENSUS       +---------+             +---------+3
                  |PUBLIC   |             |PRIVATE  |
                  |CONSENSUS|             |CONSENSUS|
                  +---------+             +---------+
____________________________________________________________________________________________
<b>NETWORK</b>

   NETWORK         +------+2         +---------------+3
   PROTOCOL        |DEVP2P|          |ENTERPRISE P2P |
                   +------+          +---------------+

1: Yellow Paper
2: Public     Ethereum
3: Enterprise Ethereum
4: Solidity libraries like Zeppelin allows for RBAC
   fine-grained access into the on-chain smart-contracts
   Standard RBAC in EEA/Quorum expected for mid/late 2019
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span TODO xsmall>Camel Connector</span>
@[https://github.com/bibryam/camel-web3j]
@[https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43]
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall TODO>EXTERNAL STORAGE (IPFS,...)</span>
TODO: Compare with alternative Storage "providers": IPFS , Maidsafe, Storj
- IPFS is just a protocol like http. It is unmotivated (don't have tokens).
- Eris is permissioned blockchain thing and use IPFS underneath.
- Storj, SAFE Network, Sia and Filecoin: motivated storage networks with 
  different underlying protocols and design decisions.
- Swarm is an organizational idea. A philosophical structure.
  ""serverless hosting incentivised peer-to-peer storage and content distribution""
  ""From the end user's perspective, Swarm is not that different from WWW,
    except that uploads are not to a specific server. The objective is to peer-to-peer
    storage and serving solution that is DDOS-resistant, zero-downtime, fault-tolerant
    and censorship-resistant as well as self-sustaining due to a built-in incentive
    system which uses peer to peer accounting and allows trading resources for payment.
    Swarm is designed to deeply integrate with the devp2p multiprotocol network layer
    of Ethereum as well as with the Ethereum blockchain for domain name resolution, 
    service payments and content availability insurance. """"""

""""""Two major features of swarm that sets it apart from other decentralised 
distributed storage solutions (bittorent, zeronet, IPFS) are 'upload and 
disappear' and the incentive system. The former refers to fact that Swarm 
does not only serve content, but it also provides a cloud storage service. 
Unlike related systems, you do not only publish the fact you host content, 
but there is a genuine sense in which you can just upload stuff to the swarm 
and potentially disappear (drop off as a node, disconnect or just operate 
without storage entirely) right away. Swarm aspires to be the generic storage 
and delivery service catering for all usecases ranging from serving low 
latency realtime interactive web applications as well as acting as guaranteed 
persistent storage for rarely used content. The incentive system makes sure 
that participating nodes following their rational self interest nontheless 
converge on an emergent swarm behaviour that is beneficial for the entire 
system as well as economically self-sustaining. In particular, it allows 
nodes in the network to pool their bandwidth and storage resources in the 
most efficient way to collectively provide services. """""""
here are two kinds of accounts in Ethereum which share the same address space
: External accounts that are controlled by public-private key pairs (i.e. 
humans) and contract accounts which are controlled by the code stored 
together with the account.
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="http://ethereumj.io/blog/2015/09/09/friendly-ether-bot/">External Inputs (Oracles)</a>
MS.Bletchley Cryplets: @[https://azure.microsoft.com/en-us/blog/cryptletsdd/]
*Example Oracle*
@Override
public void configure() throws Exception {
  from("web3j://http://127.0.0.1:7545?operation=ETH_LOG_OBSERVABLE&topics=" + topics)
    .to("log:com.ofbizian.CallbackGetBTCCap?level=INFO&showAll=true")

    .setHeader(OPERATION, constant(ETH_SEND_TRANSACTION))
    .setHeader(FROM_ADDRESS, constant("0xc8CDceCE5d006dAB638029EBCf6Dd666efF5A952"))
    .setHeader(TO_ADDRESS, constant("0x484982345fD584a0a16deC5F9ba330f6383af3d9"))
    .process(new Processor() {
      public void process(Exchange exchange) throws Exception {
        int random = rand.nextInt(50);
        Function function = new Function("setBTCCap", Arrays.<Type>asList(
          new Uint(BigInteger.valueOf(btcPrice))), Collections.<TypeReference<?>>emptyList());
        exchange.getIn().setHeader(DATA, FunctionEncoder.encode(function));
      }
    })
    .to("web3j://http://127.0.0.1:7545");
}
</pre>
</td>
<td>
<pre xxxsmall zoom>
 <a href="https://github.com/ethereum/wiki/wiki/Whisper">Whisper</a> <span xsmall>Dapp Protocol</span>
- communication protocol to communicate DApps with each other
  for off-chain Data.

*USE CASE:*
    DApps that need to publish small amounts of information to each other and 
have the publication last some substantial amount of time. For example, a 
currency exchange DApp may use it to record an offer to sell some currency at 
a particular rate on an exchange. In this case, it may last anything between 
tens of minutes and days. The offer wouldn't be binding, merely a hint to get 
a potential deal started.

    DApps that need to signal to each other in order to ultimately 
collaborate on a transaction. For example, a currency exchange DApp may use 
it to coordinate an offer prior to creating one (or two, depending on how the 
exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general 
communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network 
traffic analysis) comms to two correspondents that know nothing of each other 
but a hash. This could be a DApp for a whistleblower to communicate to a 
known journalist exchange some small amount of verifiable material and 
arrange between themselves for some other protocol (Swarm, perhaps) to handle 
the bulk transfer.

*geth experimental flags related to whisper:
  --shh                       Enable Whisper
  --shh.maxmessagesize value  Max message size accepted (default: 1048576)
  --shh.pow value             Minimum POW accepted (default: 0.2)
  

<span TODO>Whisper Alternative: "Message Contract" and "Telehash"</span>
</pre>
</td>
<td>
<pre xxxsmall zoom>
 <a xsmall TODO href="https://github.com/Arachnid/etherquery">EtherQuery (bc-BigQuery)</a>
Custom ethereum client that uploads blockchain data to BigQuery
</pre>
</td>
<td>
<pre bgorange xxxsmall zoom>
  <a xsmall TODO href="https://github.com/ConsenSys/ethql">GraphQL Interface</a>
Example GraphQL Queries 
@[https://github.com/ConsenSys/ethql/wiki/Example-Use-Cases]
  <b>Query a single block (5000000)</b>
<a TODO href="https://ethql-alpha.infura.io/graphql?query=%7B%0A%20%20block(number%3A%205000000)%20%7B%0A%20%20%20%20hash%0A%20%20%20%20transactions(filter%3A%20%7B%20withInput%3A%20true%20%7D)%20%7B%0A%20%20%20%20%20%20index%0A%20%20%20%20%20%20hash%0A%20%20%20%20%20%20from%20%7B%0A%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20to%20%7B%0A%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20decoded%20%7B%0A%20%20%20%20%20%20%20%20...%20on%20ERC20Transfer%20%7B%0A%20%20%20%20%20%20%20%20%20%20tokenContract%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20symbol%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20from%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20account%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%09address%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20tokenBalance%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20to%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20account%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20address%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20value%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">[fiddle]</a> 
{
  block(number: <b blue>5000000</b>) {                        ← Fetch all TXs from block <b blue>5000000</b>
    hash
    transactions(filter: <b orange>{ withInput: true }</b>) {   ← <b orange>that have input data</b>
      index
      hash
      from { address }
      to   { address }
      decoded {                                    
        ... on ERC20Transfer {                    ← for those that can be decoded as token transfers, return:
          tokenContract { symbol }                  ← token symbol
          from {                                    ← sending address
            account { address }                     
            tokenBalance                            ← sending address token balance
          }
          to {                                      ← receiving address
            account { address }
          }
          value                                     
        }
      }
    }
  }
}

<b>Information on specific blocks</b>
{
  blocks(numbers: [5942631, 5942640, 5927788]) {   ← blocks queried
    transactionsRoles(from:"0xF5b...") {           ← all TXs sent from adress 0xF5b...
      gasPrice                                     ← Return amount of gas expended in each TX 
    }
  }
}

<b>Information on a range of blocks</b>

 

{
  blocksRange(numberRange: [5400000, 5400005]) {  ← For all 6 blocks between 5400000 and 5400005
    transactions {                                  Return:
      hash
      value
      from {
        address
        balance                                     ←  balance of all addresses that sent a TXs.
      }
      to {
        address
      }
    }
  }
}
<b>Information on an account</b>
for account "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d". 

{
 account(address: "0x06012..."){ ← For account 0x6012... return:
   storage{
     value(at: 0)                   ← value stored at index 0 in (Solidity Contract) storage 
   }
 }
}

<b>Information on a TX</b>
{
  transaction(hash: "0x7cc...") {   ← For TX with hash 0x7cc... return:
    logs {                          ← fetch the log topics 
      topics
      decoded {                     ← and attempt to decode the TX to reveal
        event                         ← event
        entity                        ← entity
        standard                      ← Standard information
      }
    }
  }
}
</pre>
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title> EEA &amp; Quorum </td>
<td>
<pre xxxsmall zoom>
<span xsmall>Ext.Links</span>
Slack Chat               @[https://go-quorum.slack.com/]                             
WiKi                     @[https://github.com/jpmorganchase/quorum/wiki]             
Quorum Setup Summary     @[https://github.com/jpmorganchase/quorum/wiki/Getting-Set-Up] (WARN: use quorum-maker)
GitHub                   @[https://github.com/jpmorganchase/quorum/tree/master/docs] 
Official Docker Images   @[https://hub.docker.com/u/quorumengineering/]              
Quorum-Maker             @[https://github.com/synechron-finlabs/quorum-maker]
Whitepaper,design,..docs @[https://github.com/jpmorganchase/quorum/tree/master/docs]
Releases                 @[https://github.com/jpmorganchase/quorum/releases]
JPMorgan Quorum HomePage @[https://www.jpmorgan.com/country/ES/en/Quorum]
7 node example           @[https://github.com/jpmorganchase/quorum-examples/tree/master/examples/7nodes]
Quorum API               @[https://github.com/jpmorganchase/quorum/blob/master/docs/api.md]
Roadmap                  @[https://github.com/jpmorganchase/quorum/wiki/Product-Roadmap]
</pre>

<pre xxxsmall zoom>
  <span xsmall>EEA Summary</span>
[P]SMRT-030:Enterprise Ethereum clients MUST support 
   smart contracts of at least 24,576bytes in size
[P]SMRT-040:Enterprise Ethereum clients MUST read and enforce a size limit 
   for smartcontracts from the current network configuration (e.g. the genesis 
   block).
[P]SMRT-050: If no contract size limit is specified in a genesis block, 
   subsequent hard fork blockor network configuration, Enterprise Ethereum 
   clients MUST enforce a size limit on smartcontracts of 24,576 bytes.

- Permissioning is the property of a system that ensures operations are 
  executed by and accessible todesignated parties. For Enterprise Ethereum, 
  permissioning refers to:
  - the ability of a node to join an Enterprise Ethereum blockchain
  - the ability of individual accounts or nodes to perform 
    specific functions. 
  - Ex: an Enterprise Ethereum blockchain might only allow certain nodes
    to act as validators, and only certain accounts to instantiate smart
    contracts.Enterprise Ethereum provides a permissioned implementation 
    of Ethereum supporting peer nodeconnectivity permissioning, 
    account permissioning, and transaction type permission.

7.1.1 Nodes:
  [C] NODE-010:Enterprise Ethereum implementations MUST provide the ability
      to specify atstartup a list of static peer nodes to establish 
      peer-to-peer connections with.
  [C] NODE-020:Enterprise Ethereum clients MUST provide the ability to enable
      or disable peer-to-peer node discovery.
  [P] NODE-030:Enterprise Ethereum clients MUST provide the ability to specify
      a whitelist of thenodes permitted to connect to a node.
  [P] NODE-040:Enterprise Ethereum clients MAY provide the ability to specify
      a blacklist of thenodes not permitted to connect to a node.7.1 Permissions
      and Credentials Sublayer
  [P] NODE-050: It MUST be possible to specify the node whitelist required by 
      NODE-030 througha transaction into a smart contract.
  [P] NODE-060: It MUST be possible to specify the node blacklist allowed by 
      NODE-040 (ifimplemented) through a transaction into a smart contract.
  [P] NODE-080:Enterprise Ethereum clients MUST provide the ability to specify  
      node identities ina way aligned with the concept of groups.
  [P] NODE-090:Enterprise Ethereum clients MUST document which metadata parameters
      (if any)can affect transaction ordering, and what the effects are.
</pre>

<pre xxxsmall zoom>
<span xsmall>EEA Net Protocol Sublayer (enodes, ...)</span>
- Nodes MUST be identified and advertised using the 
  Ethereum <a href="https://github.com/ethereum/wiki/wiki/enode-url-format">enode URL format</a>
- Implementations SHOULD use the <a href="https://github.com/ethereum/wiki/wiki/%C3%90%CE%9EVp2p-Wire-Protocol">DEVp2p Wire Protocol</a>
  for messaging between nodes to establish and maintain a 
  communications channel for use by higher layer protocols.

- These higher layer protocols are known as capability protocols

- The <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol">Ethereum-Wire-Protocol</a> defines the capability 
  protocols for messaging between Ethereum client nodes to 
  exchange status, including block and TX info.

- messages are sent and received over an already 
  established DEVp2p connection between nodes. 

- Implementations SHOULD support, at a minimum, 
  Ethereum-Wire-Protocols eth/62 and eth/63

- Implementations MAY add new protocols or extend 
  existing Ethereum protocols

- To minimize the number of point -to-point connections 
  needed between private nodes , some private nodes 
  SHOULD be capable of relaying private TX data to
  multiple other private nodes.
</pre>
</td>

<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/jpmorganchase/quorum">Quorum Ethereum Extensions</a>
 - Transaction and contract privacy
 - Multiple voting-based consensus mechanisms
 - Network/Peer permissions management
 - Higher performance
</pre>

<pre xxxsmall zoom>
<a xsmall href="https://github.com/blk-io/quorum-examples">5nodesRTGS</a> example: 
  Starts up a set of 5 nodes that simulates a Real-time Gross
  Setlement environment with 3 banks, one regulator (typically
  a central bank) and an observer that cannot access the private data.
</pre>

<pre xxxsmall zoom>
  <span xsmall>Contract Design Considerations</span>
- Private contracts cannot update public contracts.
  (not all participants will be able to execute a private contract,
  and so if that contract can update a public contract, then each
  participant will end up with a different state for the public contract.
- Once a contract has been made public, it can't later be made private.
  You DO need to delete from the blockchain and create a new private contract
</pre>
</td>
<td>
<pre TODO xxxsmall zoom>
<span TODO xsmall>Supported Consensus</span>
- POA :
- RAFT:
- IBFT: (Istambul) Bizantine Fault Tolerant
</pre>
<pre xxxsmall zoom>
<span xsmall>IBFT: (Istambul) Bizantine Fault Tolerant</span> 
@[https://github.com/ethereum/EIPs/issues/650]
  - Target banks and fin.instutions, replacing PoW
    since validator scalability is not required.
  - Hash settlement finality and minimum latency.
  - Deeply inspired by Clique PoA @[https://github.com/ethereum/EIPs/issues/225]
  - also inspired by Hyperledger's SBFT, Tendermint, HydraChain, and NCCU BFT.
    ----------------------------------------------------------------------------------------
    Validator  : Block validation participant.                                                 |*VALIDATION ROUND LOOP*
    Proposer   : A block validation participant that is chosen                                 |[validators] → [validators]: enter validator.state "NEW ROUND"
                 to propose block in a consensus round.                                        |[validators] → [validators]: pick one (round-robin by default or sticky) as the proposer
    Round      : Consensus round. A round starts with the proposer creating                    |proposer → proposer : propose new block proposal 
                 a block proposal and ends with a block commitment or round change.            |proposer → network  : broadast block-proposal + PRE-PREPARE
    Proposal   : New block generation proposal which is undergoing consensus processing        |network  → [validators]: "forward" block-proposal + PRE-PREPARE
    Sequence   : Sequence number of a proposal. A sequence number should be greater than       |[validators] → [validators]: enter validator.state PRE-PREPARED 
                 all previous sequence numbers. Currently each proposed block height is its    |[validators] → network: broadcast PREPARE message
                 associated sequence number.                                                   |                        (make sure all validators are working on the
    Backlog    : The storage to keep future consensus messages due to the async nature of the  |                         same sequence and the same round)
                 network.                                                                      |network → [validators]: forward PREPARE
    Round state: Consensus messages of a specific sequence and round, including pre-prepare    |[validators] → [validators]: Wait until (2F + 1) PREPARE messages are received
                 message, prepare message, and commit message.                                 |                             then enter validator.state "PREPARED"
    Consensus                                                                                  |[validators] → network: broadcasts "COMMIT" message.
          proof: The commitment signatures of a block that can prove the block has gone        |                        (inform peers that validator accepts proposed block
                 through the consensus process.                                                |                        and is going to insert the block to the chain)
    Snapshot   : The validator voting state from last epoch                                    |[validators] → [validators]: wait for 2F + 1 of COMMIT messages 
                                                                                               |                             enter validator.state "COMMITTED" 
                                                                                               |                             insert the block to the chain
                                                                                               |                             enter validator.state "FINAL COMMITTED" 
                                                                                               |[validators] → [validators]: wait for 2F + 1 of "ROUND CHANGE" messages 

*RUNNING ISTANBUL BFT VALIDATORS&AMP;NODES:*
| $ geth  --datadir "/eth" init "/eth/genesis.json"                  // ← Initialize the data folder as (PRE-SETUP)
| $ geth --datadir "/eth" --mine --minerthreads 1 --syncmode "full"  // ← Start-up validators
| $ geth --datadir "/eth"                                            // ← Start-up regular nodes

*ISTANBUL OPTIONS:*                                                                           |*genesis.json*
| --istanbul.requesttimeout value  round in milliseconds (default: 10000)                     |- config field is required, and the pbft subfield must present. Ex:
| --istanbul.blockperiod    value  Default min.difference between two consecutive             |- See also genesis.json helper tools at:
|                                  block's timestamps in seconds (default: 1)                 |@[https://github.com/getamis/Istanbul-tools] 
                                                                                              |{
*NODEKEY AND VALIDATOR*                                                                       |  "config": {
|To be a validator, a node needs to meet the following conditions:                            |    "chainId": 2016,
|- Its account (nodekey-derived) address MUST be listed in extraData's validators section     |    "istanbul": { "epoch": 30000, "policy" 0 }
|- validator nodekey is used as priv.key to sign consensus messages                           |  },
                                                                                              |  "timestamp": "0x0",
*Encoding:*                                                                                   |  "parentHash": "0x000...000",
|Before encoding you need to define a toml file with vanity and validators fields             |  "extraData": "0x0000...000f89af85494475...aad0312b84100000...0c0",
|to define proposer vanity and validator set. Please refer to example.toml for                |  "gasLimit": "0x47e7c4",
|the example. The output would be a hex string which can be put into extraData                |  "mixhash": "0x6374...6e6365",
|field directly.  Command:                                                                    |  "coinbase": "0x333...33333",
|  $ istanbul encode --config ./config.toml                                                   |  "nonce": "0x0",
                                                                                              |  "difficulity": "0x0",
*Decoding:*                                                                                   |  "alloc": {}
|Use --extradata option to give the extraData hex string. The output would show               |}
|the following if presents: vanity, validator set, seal, and committed seal.      
|Command:                                                                         
|$ istanbul decode --extradata <EXTRA_DATA_HEX_STRING>                            
|to define proposer vanity and validator set. Please refer to example.toml for    
|the example. The output would be a hex string which can be put into extraData    
|field directly.  Command:                                                        
|  $ istanbul encode --config ./config.toml                                       
</pre>

<pre xxxsmall zoom>
<a xsmall href="https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md">Raft-based consensus</a>
$ geth --raft 
NON  BYZANTINE FAULT TOLERANCE with next advantages:
  - faster blocktimes (milliseconds vs seconds)
  - absence of forking
  - Compared with QuorumChain, does NOT "unnecessarily" create empty blocks

+-----------+----------------+-------------------------------------------------+
|Transport  | Ethereum p2p   |  Raft (over HTTP)                               |
|Layer      |                |                                                 |
+-----------+----------------+-------------------------------------------------+
|DATA TYPE  | communicate TXs|  communicate full blocks                        | 
+-----------+----------------+-------------------------------------------------+
|config     |                | Minting blocks frequency:  &lt;= 50ms ,         |
|params     |                |    (--raftblocktime (millisecs)                 |
|           |                | --raftport newTCPPort default to 50400 )        |
|           |                |                                                 |
|           |                |  static-nodes.json: required                    |
|           |                |  - initial list of nodes in the cluster         |
|           |                |  - order *MUST BE EQUALS ACROSS PEERS*          |
|           |                |                                                 |
|           |                | - ID URIs must include a raftport querystring   |
|           |                |   param specifying the raft port for each peer: |
|           |                |   e.g.                                          |
|           |                |    enode://abcd@127.0.0.1:30400?raftport=50400  |
+-----------+----------------+-------------------------------------------------+

removing a node from the cluster from the JS console:
# raft.removePeer(raftIdx)
                  ^
                  "1-indexed" index in the static peer list

Attaching a node to the cluster from the JS console:

# raft.addPeer("enode://abcd@127.0.0.1:30400?raftport=50400")
Then (outside the JS console) start the new geth node with the
flag --raftjoinexisting RAFTID in addition to --raft
</pre>

</td>
<td>
<pre xxxsmall zoom>
<span xsmall>TX Manager</span>
  - Quorum’s Transaction Manager is responsible for Transaction privacy. 
     It stores and allows access to encrypted transaction data, exchanges encrypted
     payloads with other participant's Transaction Managers but does not have 
     access to any sensitive private keys. It utilizes the Enclave for 
     cryptographic functionality (although the Enclave can optionally be 
     hosted by the Transaction Manager itself.)

  - """To send a private transaction, a PrivateTransactionManager must be 
     configured. This is the service which transfers private payloads to 
     their intended recipients, performing encryption and related operations 
     in the process."""
  - The Transaction Manager is restful/stateless and can be load balanced easily.

<a href='https://github.com/jpmorganchase/quorum/wiki/Transaction-Processing'>Transaction Processing</a>
  - 'Public Transactions' and 'Private Transactions' are a notional concept 
    only and Quorum does not introduce new Transaction Types, but rather, the 
    Ethereum Transaction Model has been extended to include an optional 
    '<b orange>privateFor</b>' parameter (the population of which results in a Transaction 
    being treated as private by Quorum) and the Transaction Type has a new 
    IsPrivate method to identify such Transactions.
  - <b orange>privateFor</b> can take multiple addresses in a comma separated list.
  - Private Transactions payload is only visible to the network
    participants specified in the <b orange>privateFor</b> parameter of the TX. 
  - Quorum Node sets the Transaction_Signature.V = 37 or 38 
    (as opposed to 27 or 28)

  - prior to propagate the TX to the rest of the network,
    mining/sender node replaces the original TX-Payload with
    a the hash of the encrypted Payload that received from the
    secure enclave implementation (Crux, Constellation,..).
    Participants involved in the <b orange>privateFor</b> TX
    will have the encrypted payload associated to the hash
    within their secure enclave.

  Example priv.TX A←→B:<span bgorange>
Party A and B belongs to TX AB, whilst C doesn't
Party A → A.Node: TX + payload 
                TX.<b orange>privateFor</b> [ pub.key A, pub.keyB]
A.Node → A TX Manager: Request to store TX payload
A_TX_Manager → Enclave: - Validate sender with A priv.key

Enclave → Enclave:  performs TX conversion (encrypt payload)
                    - generating [sym.key, random Nonce]
                    - encrypting TX.payload+Nonce with sym.key
                    - generate hash  SHA3-512 (encrypted payload)
                    - iterate through TX recipients [A, B] encrypting 
                      sym.key with recipient's pub.key (PGP encryption)
A_TX_Manager ← Enclave: encrypted payload, SHA3-512 hash, encrypted keys
A_TX_Manager → A_TX_Manager: store encrypted payload, encrypted sym.key
                             (using hash as index)
A_TX_Manager → B_TX_Manager: (via HTTPS) hash, encrypted (payload, sym.key) 
A_TX_Manager ← B_TX_Manager: Ack 
A.Node ←  A_TX_Manager: SHA3-512 (encrypted payload) 
A.Node →  A.Node: - Replace TX.payload with TX.sha3-512
                  - changes TX.V to 37 or 38 (indicates other nodes that 
                    hash represents priv.TX)
A_TX_Manager → Network:  (Ethereum P2P protocol) TX encrypted payload
Network → Network: +block containing TX AB
Network → Node N: block containing TX AB
Node N → Node N: Try validate TX in block
                 - Recognise TX.V is 37 or 38 
Node N → Node N TX_Manager: Do nodes holds private TX?
Node N ← Node N TX_Manager: YES  (continue validation) 
                         or "NotARecipient" (skip to next TX in block)
A,B Node → A,B enclave: TX payload
           A,B enclave: 1. validates signature
                        2. decrypts sym.key  private key that is held
                           in The Enclave, decrypts the Transaction Payload using
                           the now-revealed symmetric key and returns the decrypted
                           payload to the Transaction Manager.
A,B TX_Manager → A,B EVM: send decrypted payload 
A,B EVM → A,B EVM: contract code execution
                   Update Quorum Node's Private StateDB only. 
                   NOTE: code discarded once executed.
</pre>

<pre xxxsmall zoom>
<a TODO xsmall href="https://github.com/jpmorganchase/tessera">Tessera</a> <span xsmall>(EE TX Manager)</span>
- Enterprise Implementation of Quorum's transaction manager
- stateless Java system that is used to enable the encryption, 
  decryption, and distribution of private transactions for Quorum.

Each Tessera node:
  - Generates and maintains a number of private/public key pairs
  - Self manages and discovers all nodes in the network (i.e. their
    public keys) by connecting to as few as one other node
  - Provides Private and Public API interfaces for communication:
    Private API - This is used for communication with Quorum
    Public  API - This is used for communication between Tessera
                  peer nodes
  - Provides two way SSL using TLS certificates and various trust
    models like Trust On First Use (TOFU), whitelist, certificate 
    authority, etc.
  - Supports IP whitelist
  - Connects to any SQL DB which supports the JDBC client

<a TODO href="https://github.com/jpmorganchase/tessera/wiki/Interface-&-API">Tessera Wiki</a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Secure Enclave</span>
 - Distributed Ledger protocols typically leverage cryptographic techniques 
   for transaction authenticity, participant authentication, and historical 
   data preservation (i.e. through a chain of cryptographically hashed data
   .) In order to achieve a separation of concerns, as well as to provide 
   performance improvements through parallelization of certain crypto-
   operations, much of the cryptographic work including symmetric key 
   generation and data encryption/decryption is delegated to the Enclave.
 - The Enclave works hand in hand with the Transaction Manager to 
   strengthen privacy by managing the encryption/decryption in an isolated 
   way. It holds private keys and is essentially a “virtual HSM” isolated 
   from other components.
 - Different implementations of the enclave exists:
   - Constellation: Original, writen in Haskell
   - Crux         : Golang based, compatible with Constellation
</pre>
<pre xxxsmall zoom>
<a xsmall href='https://github.com/jpmorganchase/constellation'>Constellation secure enclave</a>,
  - <a href='https://github.com/jpmorganchase/quorum/blob/master/docs/privacy.md'>REF: Privacy.md, Quorum+Constellation</a>
  - self-managing, peer-to-peer network of "key server+PGP+MTAs" nodes
  - Constellation is not blockchain-specific, and potentially applicable
     in many other types of applications
  - Constellation's current primary application is to implement the 
    "privacy engine" for Quorum Private transactions (TX with a flag indicating 
    its pretended privacy and the addressable identifier )
  - Hosts a number of Private/Public key pair Curve25519 - NaCl-
  - Automatically discovers other nodes on the network after synchronizing 
    with as little as one other host.
  - Synchronizes a directory of public keys mapped to recipient hosts with 
    other nodes on the network.
  - Exposes public API allowing other nodes to send encrypted bytestrings to 
    your node, and to synchronize, retrieving information about the nodes 
    that your node knows about.
  - Exposes a private API which:
    - Allows you to send a bytestring to one or more public keys, returning 
      a content-addressable identifier. This bytestring is encrypted 
      transparently and efficiently (at symmetric encryption speeds) before 
      being transmitted over the wire to the correct recipient nodes (and only 
      those nodes.) The identifier is a hash digest of the encrypted payload 
      that every receipient node receives. Each recipient node also receives a 
      small blob encrypted for their public key which contains the Master Key 
      for the encrypted payload.
    - Allows you to receive a decrypted bytestring based on an identifier. 
      Payloads which your node has sent or received can be decrypted and retrieved 
      in this way.

    - Exposes methods for deletion, resynchronization, and other management functions.

  - Supports a number of storage backends including LevelDB, BerkeleyDB, SQLite,
    and Directory/Maildir-style file storage suitable for use with any FUSE 
    adapter, e.g. for AWS S3.

  - Uses mutually-authenticated TLS with modern settings and various trust 
    models including hybrid CA/tofu (default), tofu (think OpenSSH), and 
    whitelist (only some set of public keys can connect.)

  - Supports access controls like an IP whitelist.

<b>INSTALLATION</b>
Pre-Install supporting libraries:
  Ubuntu : $ apt-get install libdb-dev libleveldb-dev libsodium-dev zlib1g-dev libtinfo-dev
  Red Hat: $ dnf install libdb-devel leveldb-devel libsodium-devel zlib-devel ncurses-devel
  MacOS  : $ brew install berkeley-db leveldb libsodium

Install
  Alt 1: Precompiled binaries:
  <a href="https://github.com/jpmorganchase/constellation/releases">Release download</a>
  
  Alt 2: from source
    - First time only: Install Stack:
      Linux: $ curl -sSL https://get.haskellstack.org/ | sh
      MacOS: $ brew install Haskell-stack
    - First time only: run stack setup to install GHC, the Glasgow Haskell Compiler
    - Run stack install

Post-install: Generating key pair "node":
  $  constellation-node --generatekeys=node # generated keys can be locked with passwd

<b>RUNNING</b>
- can be run as stand-alone daemon via constellation-node, or 
  imported as a Haskell library, allowing to implement custom
  storage and encryption logic.

$ constellation-node "path_to_config_file" # or use ENV.VAR
# More info at <a href="https://github.com/jpmorganchase/quorum/blob/master/private/constellation/node.go">quorum/private/constellation/node.go</a>

<b>CONFIGURATION FILE FORMAT</b>
<a href="https://github.com/jpmorganchase/constellation/blob/master/sample.conf">REF</a>
url = "http://127.0.0.1:9001/"
port = 9001
workdir = "data"
socket = "constellation.ipc"
othernodes = ["http://127.0.0.1:9000/"]
publickeys = ["foo.pub"]
privatekeys = ["foo.key"]
alwayssendto = []
storage = "dir:storage"
verbosity = 1
tls = "strict"
tlsservercert = "tls-server-cert.pem"
tlsserverchain = []
tlsserverkey = "tls-server-key.pem"
tlsservertrust = "tofu"
tlsknownclients = "tls-known-clients"
tlsclientcert = "tls-client-cert.pem"
tlsclientchain = []
tlsclientkey = "tls-client-key.pem"
tlsclienttrust = "ca-or-tofu"
tlsknownservers = "tls-known-servers"
</pre>

<pre xxxsmall zoom>
<span xsmall>Crux (Constellation alternative)</span>
@[https://medium.com/web3labs/announcing-crux-a-secure-enclave-for-quorum-61afbfdb79e4]
- dropin Constellation replacement
- secure enclave  written in Golang (Constellation is written in Haskell)
- <a href="https://github.com/blk-io/quorum-examples">7 nodes example deployment with Crux</a>
- LevelDB used as storage (same as geth). 
  BerkeleyDB bindings available for compatibility with
  existing Constellation instance.

*BUILD*                                          *PRE-SETUP*
$ git clone https://github.com/blk-io/crux.git   generate new keys using:
$ cd crux                                        $ crux*--generate-keys* myKey
$ make setup && make
$ ./bin/crux

*USSAGE*
run it like: (almost identical to Constellation node):
$ crux --url=http://127.0.0.1:9001/ \          | crux --help reference:
       --port=9001 --workdir=crux \            |     crux.config              Optional config file
       --publickeys=tm.pub \                   |     --alwayssendto string    public key List  for nodes to send all transactions to
       --privatekeys=tm.key \                  |     --berkeleydb             switch to Berkeley DB for compatibility with Constellation data store [experimental]
       --othernodes=https://127.0.0.1:9001/    |     --generate-keys string   Generate a new keypair
                                               |     --othernodes string      "Boot nodes" used to discover the network
                                               |     --port int               The local port to listen on (default -1)
                                               |     --privatekeys string     Private keys hosted by this node
                                               |     --publickeys string      Public keys hosted by this node
                                               |     --socket string          IPC socket to create for access to the Private API (default "crux.ipc")
                                               |     --storage string         Database storage file name (default "crux.db")
                                               |     --url string             The URL to advertise to other nodes (reachable by them)
                                               |     --verbosity int          Verbosity level of logs (default 1)
                                               |     --workdir string         The folder to put stuff in (default: .) (default ".")
</pre>
</td>

</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Priv. TX Seq.</span>
─@[https://raw.githubusercontent.com/jpmorganchase/quorum─docs/master/images/QuorumTransactionProcessing.JPG]
                                             TxPayloadRequest
                                        ┌──────────────────────────────┐
  ┌─→                                   │                              │           3,10 En/De─cryption
  │                                     │         2 TXPayloadStore ┌─────────────┐             request ┌───────────┐
  │   ┌──────┐ 1 Private TX ┌───────────────────┐                  │             ├────────────────────→│           │
  │   │ Dapp │      AB      │                   ├─────────────────→┼ Transaction │                     │ Enclave A │
 P│   └────────────────────→┼   Quorum Node A   │                  │ Manager A   │                     │           │
 A│                         │                   │                  │             │←────────────────────┴───────────┘
 R│                         │  Public  Private  │←───────────────────────────────┘  4,11 Tx Response
 T│                         │  State    State   │ 6 TX Hash          │       ^
 Y│       8 Block w/Tx AB   │  ┌────┐   ┌────┐  │                    │       │
  │        ┌──────────────→ │  ├────┤   ├────┤  │                    │       │
 A│        │                │  └────┘   └────┘  │                    │       │
  │        │                │                   │                    │       │5
  │        │                └───────────────────┘                    │       │TXPayloadStore
  │        │                    ^     ^                              │       │
  │   ┌──────────┐      7 Ether │     │ 12 TxPayloadResp (TX Payload)│       │
  └─→ │Block 123 │           TX │     └──────────────────────────────┘       │
      ├───────── │     Standard │                                            │
      │TxAB      │     Protocol │            9.TxPayloadRequest              │
      └──────────┘              │          ┌──────────────────────────┐      │
   ┌─→ │   │                    v          │                          │      v      10 En/De─cryption
   │   │   │                ┌───────────────────┐                   ┌─v───────────┐           request  ┌───────────┐
   │   │   │                │                   │                   │             ├───────────────────→│           │
 P │   │   │                │   Quorum Node B   │                   │ Transaction │                    │ Enclave B │
 A │   │   │                │                   │                   │ Manager B   │←───────────────────┤           │
 R │   │   │                │  Public  Private  │                   │             │11.Tx Response      └───────────┘
 T │   │   │                │  State    State   │                   └─────────────┘
 Y │   │   │                │  ┌────┐   ┌────┐  │                     │
   │   │   └──────────────→ │  ├────┤   ├────┤  │                     │
 B │   │ 8 Block w/Tx AB    │  └────┘   └────┘  │                     │
   │   │                    │                   │                     │
   │   │                    └───────────────────┘                     │
   │   │                       ^       ^                              │
   │   │               7 Ether │       │ 12 TxPayloadResp (TX Payload)│
   │   │                    TX │       └──────────────────────────────┘
   └─→ │              Standard │
       │              Protocol │             9.TxPayloadRequest
   ┌─→ │                       │           ┌──────────────────────────┐
   │   │                       v           │                          │
   │   │                    ┌───────────────────┐                  ┌─────────────┐                    ┌───────────┐
 P │   │                    │                   │                  │             │                    │           │
 A │   │                    │   Quorum Node C   │                  │ Transaction │                    │ Enclave C │
 R │   │ 8 Block w/Tx AB    │                   │                  │ Manager C   │                    │           │
 T │   └──────────────────→ │  Public  Private  │                  │             │                    └───────────┘
 Y │                        │  State    State   │                  └─────────────┘
   │                        │  ┌────┐   ┌────┐  │
 C │                        │  ├────┤   ├────┤  │
   │                        │  └────┘   └────┘  │
   │                        │                   │
   │                        └───────────────────┘
   │                     ^                           ^        ^                          ^
   └─→                   │                           │        │                          │
                         └───────────────────────────┘        └──────────────────────────┘
                             Ethereum standard p2p                  CONSTELLATION
                                Network Protocol                       NETWORK

</pre>
<pre xxxsmall zoom>
<span xsmall>JS client privateFor ex.</span>
"privateFor": indicates the list of constellation (vs Ethereum) public keys
              of TX recipient. If not empty the TX will be private.
web3.eth.defaultAccount = eth.accounts[0];
var simpleSource = 'contract simplestorage { ... }'
var simpleCompiled = web3.eth.compile.solidity(simpleSource);
var simpleRoot = Object.keys(simpleCompiled)[0];
var simpleContract = web3.eth.contract(
    simpleCompiled[simpleRoot].info.abiDefinition);
var simple = simpleContract.new(42, 
    {from:web3.eth.accounts[0],
     data: simpleCompiled[simpleRoot].code,
     gas: 300000,
     privateFor: ["ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc="]
    }, function(e, contract) {
      if (e) { throw("err creating contract", e); }
      if (!contract.address) {
        console.log(contract.transactionHash + " mining...");
        return;
      }
      console.log("Contract Address: " + contract.address);
    });
</pre>
</td>
</tr>
</table>
<table>
<tr>
<td title>
  EEA Dev<br/>Ops
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>P2P Node Identity "enode"</span>
Extracted from <a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#network-formation">rlpx.md</a>
"""
 o*NODE Identity:*
   each node is expected to maintain a statico*secp256k1 private key* 
   which is saved and restored between sessions.                      
   It is recommended that the private key can only be reset manually, 
   for example, by deleting a file or database entry.                 
                                                                      
   There are two kinds of connections which can be established.       
   A node can connect to:                                             
     ─ a known peer which has previously been connected to            
       and from which a corresponding session token is available for  
       authenticating the requested connection                        
     ─ a new peer                                                     
"""                                                                   
- enode uri scheme is used by the*Node discovery protocol*
- enode uri scheme can be used in the bootnodes command line option                                                                      r*WARN:*
  of the client or as the argument to suggestPeer(nodeURL) function                                                                      r*DNS names are NOT allowed  * 
  in the JSRE.                                                                                                                           r*(Only IP addresses to avoid*
                                                                                                                                         r*DNS based attacks)         *
                                                                                                                                         └───────┬───────────────────┘
                                                                                                                                                 │
Extracted from: <a href="https://github.com/ethereum/wiki/wiki/enode-url-format">ethereum-wiki</a>                                 
                                               ┌────┴────────┐
enode://b*6f8a80d14311c39f35f516fa664deaaaa13e85b2f7493f37f6144d86991ec012937307647bd3b9a82abe2974e1407241d54947bbb39763a4cac9f77166ad92a0*@10.3.58.6:30303?discport=30301
        b*└─────────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────┘*                └─────┬──────┘ 
        b*                                                  │                     *                                                                              │       
        b*                                                  │                     *                                                                              │       
        b*                   64-bytes hexadecimal encoded node ID representing the*                                                                          UDP port used 
        b*                   secp256k1 public key                                 *                                                                          for discovery
        b*                   corresponding to node's private key                  *                                                                          (default to 
                                                                                                                                                           the TCP port)
*(DevOps) GENERATE PRIVATE KEY AND ENODE ID:*
(REF: https://kobl.one/blog/create-full-ethereum-keypair-and-address/)

*STEP 1: Generate private key*
$*openssl*ecparam -name secp256k1 -genkey -noout | tee >o*nodePrivateKey*
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIGLW3b7sUpzhb3I4/sLCbakIjfUz6KuBh3Xaox62beJ3oAcGBSuBBAAK
oUQDQgAEUarn9mq43dODnfxAVcSksAxHsTbrco9FnV0A7Mzqr6guzCQlCCmgXM7k
Kns43IkR1JfB8mwKkTfOPdykq9nGIg==
-----END EC PRIVATE KEY-----


*STEP 2: Show associated public-key in enode format (64 bytes hex-encoded)*
$ cato*nodePrivateKey* |*openssl*ec -noout -text                             | grep pub -A 5 | tail -n +2 | tr -d '\n[:space:]:' | sed 's/^04//'
                         ^^^^^^^^^^^^^^^^^^^^^^^^                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                       - Display info with public key                         - Convert public key to enode expected format (64bytes hex-encoded)
                       - Output will be similar to:                           - Output will be similar to:
                         Private-Key: (256 bit)                              b*067434d510e3e186a039583db727cd8d3daee9fc238a6d542eca03b0b7bc8528df9b4d878661f350c0ea3d5337a5831c94d84e22c5baffee7a55e9cb1f808e06*
                       o*priv:                                            *
                       o*    00:f4:16:f5:89:3d:60:86:8a:1d:77:4d:2f:74:3b:*
                       o*    29:53:5b:b9:cb:f9:50:0e:38:39:24:c5:7a:a9:1b:*
                       o*    b7:d2:b4                                     *
                       b*pub:                                             *
                       b*    04:06:74:34:d5:10:e3:e1:86:a0:39:58:3d:b7:27:*
                       b*    cd:8d:3d:ae:e9:fc:23:8a:6d:54:2e:ca:03:b0:b7:*
                       b*    bc:85:28:df:9b:4d:87:86:61:f3:50:c0:ea:3d:53:*
                       b*    37:a5:83:1c:94:d8:4e:22:c5:ba:ff:ee:7a:55:e9:*
                       b*    cb:1f:80:8e:06                               *
                         ASN1 OID: secp256k1
</pre>
</td>
<td>
<pre xxxsmall zoom>
  <span bgorange TODO xsmall>X509 Cert 2 Wallet</span>
@[https://cn.hyperledger.org/blog/2018/07/24/hyperledger-sawtooth-seth-and-truffle-101]
</pre>
</td>
<td colsep>Geth</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Setup Node</span>
<a href="https://github.com/ethereum/go-ethereum">REF</a>
STEP 1 :                              │STEP 2:             │STEP 3: (optional)
──────────────────────────────────────┼────────────────────┼──────────────────
 Create *genesis.json*                │Initialize node     │Setup bootstrap node
{                                     │(.../qdata/* files) │
  "config": {                         │$ geth o*init*\     │$ bootnode --genkey=boot.key
        "chainId": 0,                 │     *genesis.json* │$ bootnode --nodekey=boot.key
        "homesteadBlock": 0,          ├────────────────────┴────────────────────────────
        "eip155Block": 0,             │
        "eip158Block": 0              │
    },                                │
  "alloc"      : {                    │
  "0x00...01": {"balance": "111111"}, │
  "0x00...02": {"balance": "222222"}  │
  },                                  │
  "coinbase"   : "0x─20 bytes hex─",  │
  "difficulty" : "0x20000",           │
  "extraData"  : "",                  │
  "gasLimit"   : "0x2fefd8",          │
  "nonce"      : "0x0000000000000042",│
  "mixhash"    : "0x ─32bytes hex─",  │
  "parentHash" : "0x ─32bytes hex─",  │
  "timestamp"  : "0x00"               │
}                                     │
──────────────────────────────────────┴

Geth layout:
$DATADIR: (← defined by geth --datadir flag)
 ├─ .ethash/             ← ~1GB dataset used for PoW consensus
 ├─./genesis.json        ← geth init creates initial ddbb based on it   
 ├─./qdata/              ← Node Blockchain and state databases, keystore, process log,...
 ├─ ...                    
 ├─./qdata/geth/nodekey  ← generated automatically on first run or through 
 ├─ ...                    'bootnode -genkey .../nodekey' -writeaddress
 ├─./qdata/geth/chaindata/                                ^^^^^^^^^^^^^
 ├─ ...                                                   shows also pub.key   
 ├─./qdata/gethLogs/node1.log                             for enode url
 ├─ ...                                                    (optional)
 ├─./qdata/*keystore*/node1key 
 ├─./node1.conf
 ├─./keys/node1.key
 ├─./keys/node1a.pub
 ├─./keys/node1.pub
 └─./keys/node1a.key

*FUll CLI options*
@[https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options]
</pre>

</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Basic Admin</span>
<a href="https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts">Geth Account Mng</a>
  *(Geth) ACCOUNT "==" private key stored in file protected by password* stored under:
                       $DATADIR/keystore/UTC--'created_at_UTC_ISO8601'-'address hex'
  
  $*geth account*o*command* [options...] [arguments...]
                 o*^^^^^^^*
                 o*list   *  
                 o*new    *  
                 o*update *
                 o*import * ← import private key into new account 
                              Export key unencrypted*NOT*supported 
  
  Options:
  --datadir   Base directory for databases and keystore
  --keystore  (defaults to $DATADIR/keystore) Directory for the keystore (default = inside the datadir)

<a TODO href="https://github.com/ethereum/go-ethereum/wiki/Backup-&-restore">Backup/Restore</a> 

$ geth*upgradedb*        ← "Sometimes" the internal database formats need updating
$ geth*removedb*         ← cleanup: remove blockchain and state databases
                           (does not touch the keystore)
$ geth*export*'filename' 0 30000 ← Export blockchain in binary format
                         ^^^^^^^  
                         initial and
                         final block
                         
$ geth*import*'filename'         ← Import form binary file

*Geth extra CLIs*
@[https://github.com/ethereum/go-ethereum/tree/master/cmd]
 abigen      
*bootnode*   bootnode runs a bootstrap node for the Ethereum Discovery Protocol.
           @[https://godoc.org/github.com/ubiq/go-ubiq/cmd/bootnode]
 clef       *signs TXs and data*. Replacement for acct mgnt
 ethkey      simple tool for working with Ethereum keyfiles
 
 evm         evm executes EVM code snippets!!.
                - internal/compiler
                - compiler.go
                - disasm.go
                - main.go 
                - runner.go
                - staterunner.go
 faucet  
 geth    
 internal/browser    
 p2psim  
 puppeth  
 rlpdump     rlpdump is a pretty-printer for RLP data
 swarm       Command bzzhash computes a swarm tree hash.
 utils 
 wnode
</pre>
</td>

<td>
<pre xxxsmall zoom>
<span TODO xsmall>Geth Arch</span>
<a href="https://www.mycryptopedia.com/ethereum-geth-installing-and-running-a-node/">REF</a>
       ┌────────┐              ┌───────┐
       │JSON RPC│              │LevelDB│
       └────────┘              └───────┘
            ↑                      ↑
┌─────┐     │       ┌─────┐        │  ┌───────┐
│SWARM│     └──────→│ EVM ┼←───────┘  │Whisper│
└──┬──┘             └─────┘           └───┬───┘
   │                   ↓                  │
   │         ┌─────────────────────┐      │
   └────────→│     P2P/Gossip      │←─────┘
             └─────────┬───────────┘
                       ↓     
                  ···· ···   ···
                 ··   ·   ···  ··
                 ·   Network    ·
                 ······     ····
                       ·····


<a href="http://leveldb.org/">LevelDB</a> (key/value) storage backend.
  - entries stored lexicographically sorted by keys.
    (sorting comes-in very useful for querying)
  - Arbitrary byte arrays:
    keys and values are treated as simple arrays of bytes,
    so content can be anything from ASCII strings to binary blobs.
  - Compressed storage:
    Google’s Snappy compression library (optional) dependency,
    highly optimized for fast compression (vs high compress ratio)
  - Ex ussage:
    var level = require('level')
    var db = level('./db', { valueEncoding: 'json' })
    
    db.put('key', { example: true }, function (err) {
      if (err) throw err
    
      db.get('key', function (err, value) {
        if (err) throw err
        console.log(value)
      })
    })

<a TODO href="https://medium.com/coinmonks/data-structure-in-ethereum-episode-4-diving-by-examples-f6a4cbd8c329">Data structure in Ethereum</a>
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">Geth Console</a>
  $ geth*attach* o*--preload*"script1.js,..."                                http://123.123.123.123:8545
  $ geth*attach*                              b*--exec* " eth.blockNumber "
         ^^^^^^    ^^^^^^^^^                    ^^^^^^                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
     *Attach to*   (opt)preload                 batch                        local node if no specified
     *running  *   CSV script                    mode                           
      node         list                                            
┌────────────────────────────────────────┬───────────────────────────────────────────────────
│*Ex1: EXAMINE TX:*                      │*Ex2: CHECK ACCOUNT BALANCE/S*
│ $o*TX_ID*='0xaeb..b49'                 │ cat gethPreload.js ←  ˃ *loadScript*("gethPreload.js")
│ $ web3.eth.getTransaction(o*TX_ID*,    │                       ˃o*checkAllBalances()*;
│     function(e, r) {                   │ 
│        if (e) {                        │ function o*checkAllBalances()* {
│          console.log(e);               │   var totalBal = 0;
│          return;                       │   for (var acctNum in eth.accounts) {
│        }                               │     var acct = eth.accounts[acctNum];
│        console.log(JSON.stringify(r);  │     var acctBal = web3.fromWei(
│     } );                               │                     eth.getBalance(acct), "ether");
│                                        │     totalBal += parseFloat(acctBal);
│                                        │     console.log(
│                                        │        acct + " balance: " + acctBal + " ether");
│                                        │   }                                                 
│                                        │ };                                                  
└────────────────────────────────────────┴───────────────────────────────────────────────────
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Config Trouble-shoot</span>
<a href="https://web3js.readthedocs.io/en/1.0/index.html">Full 1.0 API</a>
console.dir(eth) does NOT work but all that needed is enter the object name in the prompt

> eth                                                                         > web3
→ {                                                                           → {
→   accounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],                 →   admin: {
→   blockNumber: 5,                                                           →     datadir: "/home/vagrant/singleNodeNetwork/qdata/dd1",<b>
→   coinbase: "0xed9d02e382b34818e88b88a309c7fe71e65f419d",                   →     nodeInfo: {
→   compile: {                                                                →       enode: "enode://ac6b1096....9373ef@[::]:21000?discport=0",
→     lll: function(),                                                        →       id: "ac6b1096ca56b9f6d00....373ef",
→     serpent: function(),                                                    →       ip: "::",
→     solidity: function()                                                    →       listenAddr: "[::]:21000",
→   },                                                                        →       name: "Geth/v1.7.2-stable-94e1e31e/linux-amd64/go1.9.5",
→   defaultAccount: undefined,                                                →       ports: { discovery: 0, listener: 21000 },
→   defaultBlock: "latest",                                                   →       protocols: { eth: {...} }
→   gasPrice: 0,                                                              →     },</b>
→   hashrate: 0,                                                              →     peers: [],
→   mining: false,                                                            →     ...
→   pendingTransactions: [],                                                  →   },
→   protocolVersion: "0x3e",                                                  →   ...
→   syncing: false,                                                           →   debug: { ...  },
→   call: function(),                                                         →   eth: {
→   contract: function(abi),                                                  →     accounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],
→   estimateGas: function(),                                                  →     blockNumber: 5,
→   filter: function(options, callback, filterCreationErrorCallback),         →     coinbase: "0xed9d02e382b34818e88b88a309c7fe71e65f419d",
→   getAccounts: function(callback),                                          →     ...
→   getBalance: function(),                                                   →     gasPrice: 0,
→   getBlock: function(),                                                     →     hashrate: 0,
→   getBlockNumber: function(callback),                                       →     pendingTransactions: [],
→   getBlockTransactionCount: function(),                                     →     syncing: false,
→   getBlockUncleCount: function(),                                           →     call: function(),
→   getCode: function(),                                                      →     getAccounts: function(callback),
→   getCoinbase: function(callback),                                          →     getBalance: function(),
→   getCompilers: function(),                                                 →     getBlock: function(),
→   getGasPrice: function(callback),                                          →     getBlockNumber: function(callback),
→   getHashrate: function(callback),                                          →     getBlockTransactionCount: function(),
→   getMining: function(callback),                                            →     ...
→   getPendingTransactions: function(callback),                               →     getStorageAt: function(),
→   getProtocolVersion: function(callback),                                   →     getTransaction: function(),
→   getRawTransaction: function(),                                            →     getTransactionCount: function(),
→   getRawTransactionFromBlock: function(),                                   →     getTransactionFromBlock: function(),
→   getStorageAt: function(),                                                 →     getTransactionReceipt: function(),
→   getSyncing: function(callback),                                           →     ...
→   getTransaction: function(),                                               →   },
→   getTransactionCount: function(),                                          →   isIBAN: undefined,
→   getTransactionFromBlock: function(),                                      →   miner: {  ...  },
→   getTransactionReceipt: function(),                                        →   net: { ...  },
→   getUncle: function(),                                                     →   personal: {
→   getWork: function(),                                                      →     listAccounts: ["0xed9d02e382b34818e88b88a309c7fe71e65f419d"],
→   iban: function(iban),                                                     →     listWallets: [{
→   icapNamereg: function(),                                                  →         accounts: [...],
→   isSyncing: function(callback),                                            →         status: "Unlocked",
→   namereg: function(),                                                      →         url: "keystore:///.../keystore/key1"
→   resend: function(),                                                       →     }],
→   sendIBANTransaction: function(),                                          →     ...
→   sendRawTransaction: function(),                                           →   },
→   sendTransaction: function(),                                              →   ..
→   sign: function(),                                                         →   shh: { ...  },
→   signTransaction: function(),                                              →   txpool: { ... },
→   submitTransaction: function(),                                            → }
→   submitWork: function()
→ }
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Disk Space</span><!-- disk_space_link  -->
<a href="https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs/826#826">REF</a>
Last Update: May 14th, 2018 / Block ~ 5_600_000
Geth (Go) 1.8.3 Ubuntu 16.4 LTS,  VPS + SSD | Parity (Rust)
--------------------------------------------+--------------------------------------------
Client / Mode    | Block Number |Disk Space | Client / Mode      |Block Number|Disk Space
=================|==============|========== | ===================|============|==========
geth light       | 5_600_000    |363M       | parity light       |5_600_000   | 89M
geth fast full   | 5_600_000    |142G       | parity warp fast   |5_600_000   | 82G
geth full full   | ?_???_??? [1]|239G + [1] | parity full fast   |5_600_000   | 78G
geth full archive| 4_980_000 [2]|671G       | parity full archive|5_600_000   |1.1T
                                            |                                      
[1] disk was full, I wasn't able to repeat  |
    this sync mode                          |
[2] I didn't manage to fully sync           |
    within 6 weeks, unfortunately.          |
--------------------------------------------+--------------------------------------------
</pre>
</td>
<td colsep> </td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/synechron-finlabs/quorum-maker">Quorum-Maker</a>
C&amp;P from https://github.com/synechron-finlabs/quorum-maker:
Synechron's Quorum Maker is a tool that allows users to create and manage Quorum network.
Manually editing configuration files and creating nodes is a slow and error-prone process.
Quorum Maker can create any number of nodes of various configurations dynamically with 
reduced user input. This provides a wizard-like interface with a series of questions to
guide the user when creating nodes. Quorum Maker can create nodes to:

  - run with docker-compose (Raft consensus/Quorum 2.2.0) for easy use in development environments; 
    or
  - nodes to be distributed on separate Linux boxes or cloud instances for a production environment 
    (Raft consensus/Quorum 2.2.0)

*INSTALL PRE-REQUISITES*
- install docker-CE ("Long Term Support") as explained in <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>

*INSTALL QUORUM-MAKER*
root@.../# git clone https://github.com/synechron-finlabs/quorum-maker

*QUORUM-MAKER USSAGE*
root@/.../quorum-maker# ./setup.sh *--help*
    ....
    Version 2.6.2 Built on Quorum 2.2.1
    Utility to setup Quorum Network
    
    join      Create a node and Join to existing Network
    attach    Attach to an existing Quorum Node. The node created hosts only Node Manager
    dev       Create a development/test network with multiple nodes
    
    Options:
    
    For create command:
      -n, --name              Name of the node to be created
      --ip                    IP address of this node (IP of the host machine)
      -r, --rpc               RPC port of this node
      -w, --whisper           Discovery port of this node
      -c, --constellation     Constellation port of this node
      --raft                  Raft port of this node
      --nm                    Node Manager port of this node
      --ws                    Web Socket port of this node
      -t, --tessera           Create node with Tessera Support (Optional)
    
    E.g.
    ./setup.sh create -n master --ip 10.0.2.15 -r 22000 -w 22001 -c 22002 --raft 22003 --nm 22004 --ws 22005
    
    For join command:
    
      -n, --name              Name of the node to be created
      --oip                   IP address of the other node (IP of the existing node)
      --onm                   Node Manager port of the other node
      --tip                   IP address of this node (IP of the host machine)
      -r, --rpc               RPC port of this node
      -w, --whisper           Discovery port of this node
      -c, --constellation     Constellation port of this node
      --raft                  Raft port of this node
      --nm                    Node Manager port of this node
      --ws                    Web Socket port of this node
      -t, --tessera           Create node with Tessera Support (Optional)
    
    E.g.
    ./setup.sh join -n slave1 --oip 10.0.2.15 --onm 22004 --tip 10.0.2.15 -r 23000 -w 23001 -c 23002 --raft 23003 --nm 23004 --ws 23005

For attach command:
  -n, --name              Name of the node to be created
  --ip                    IP address of existing Quorum
  --pk                    Public Key of existing Constellation
  -r, --rpc               RPC port of the existing Quorum
  -w, --whisper           Discovery port of this node
  -c, --constellation     Constellation port existing node
  --raft                  Raft port of existing node
  --nm                    Node Manager port of this node (New Node Manager will be created by this command)
  --active                Active attachment mode
  --passive               Passive attachment mode

E.g.
./setup.sh attach -n slave1 --ip 10.0.2.15 --pk BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo= -r 22000 --whisper 21000 --constellation 9001 --raft 50401 --nm 11004 --active

For dev command:
  -p, --project           Project Name
  -n, --nodecount         Number of nodes to be created
  -e, --expose            Expose docker container ports (Optional)
  -t, --tessera           Create node with Tessera Support (Optional)

E.g.
./setup.sh dev -p TestNetwork -n 3

-h, --help              Display this help and exit

</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://github.com/majd1239/Quarum-Maker-Kubernetes">Running on kubernetes</a> 
See also: https://github.com/synechron-finlabs/quorum-maker/issues/75
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a xsmall href="https://github.com/ethereum/go-ethereum/wiki/Metrics-and-Monitoring">Monitoring &amp; Metrics</a> 
˃*debug.metrics().p2p.InboundTraffic*        ˃*debug.metrics().chain.inserts*
{                                            {
  Avg01Min: '169.12K (2.82K/s)',               Avg01Min: '10 (0.17/s)',
  Avg05Min: '1.92M (6.42K/s)',                 Avg05Min: '61 (0.20/s)',
  Avg15Min: '3.57M (3.96K/s)',                 Avg15Min: '168 (0.19/s)',
  Total: '5.83M (2.97K/s)'                     Maximum: '2.157261657s',
}                                              Minimum: '2.271716ms',
                                               Percentiles: {
˃*debug.metrics(true).p2p.InboundTraffic*        20: '6.993756ms',
{                                                50: '12.342836ms',
  AvgRate01Min: 1599.6190029292586,              80: '21.765944ms',
  AvgRate05Min: 5367.754506658111,               95: '218.500479ms',
  AvgRate15Min: 3761.057607521597,               99: '376.015984ms'
  MeanRate: 2907.3919382272857,                },
  Total: 5901154                               Total: '432 (0.22/s)'
}                                           }



$*geth monitor*   ← periodically queries a node for 
                    metrics and plots them on the terminal 

$ geth monitor [--attach=api-url] metric1 metric2 ... metricN
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
             Ex metrics:
                   system/memory/allocs/AvgRate05Min        ← Full canonical metric
                   system/memory/allocs                     ← Group of metrics
                   system/memory                            ← Group of metrics
                   system/memory/allocs,frees/AvgRate01Min  ← Multiple branching metrics 
                   system/memory/*/AvgRate01Min             ← wildard pattern   (Not supported by planned) 
                   system/memory/allocs/!AvgRate01Min       ← Exclusion pattern (Not supported by planned) 

Available metrics (use geth monitor for full list)
    system/memory/
        allocs: number of memory allocations made
        frees: number of memory releases made
        inuse: memory currently being used
        pauses: time spent in the garbage collector
</pre>
</td>

</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title>Kaleido (SaaS Quorum)</td>
<td>
  <a xsmall TODO href="https://docs.kaleido.io/getting-started/about-kaleido/">Getting Started</a> 
</td>
<td>
<a xsmall TODO href="https://docs.kaleido.io/developer-materials/api-101/">Developer Material</a> 
</td>
<td>
<pre xxxsmall zoom>
<a xsmall TODO href="https://docs.kaleido.io/kaleido-services/">Services</a> 
Public Eth. Tether
Ether pool
Block Explorer
HD Wallet
IPFS
ID Registry
Eth-Connect
</pre>
</td>
<td>
  <a xsmall TODO href="https://docs.kaleido.io/aws-integrations/using-aws-integrations/">AWS Integration</a> 
</td>
<td>
  <a xsmall TODO href="https://docs.kaleido.io/support/troubleshooting/">Help And Support</a> 
</td>
</tr>
</table>
<hr xsmall />
<table>
<tr>
<td title>Pantheon</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>Pantheon Java Node</span>
@[https://docs.pantheon.pegasys.tech/en/stable/]
- Java based.
- Apache 2.0.
- Supports Proof of Work (Ethash)  and Proof of Authority (Clique)
- 
_________________________
Extracted from gitter channel: 2019-03-27
@[https://gitter.im/PegaSysEng/pantheon]

Adrian Sutton @ajsutton 2019-Mar 27 22:36
"""@earizon Pantheon is designed to work for both public and private networks.
It’s not explicitly designed to be Quorum compatible, though it can sync to a 
Clique or IBFT 1.0 Quorum network (but can NOT be a validator in an IBFT 1.0 
network). We do intend to support the Enterprise Ethereum Alliance spec which 
I believe Quorum is also targetting to boost interoperability.  We’re still 
fairly early in the benchmarking and performance improvement work for 
Pantheon so I can’t put exact numbers on things.
*Currently Pantheon tends to be slower than Geth for syncing*
(especially since our fast sync is still under development) but is easily fast
enough to keep up with all the public networks. 
Improving performance is a current focus... """
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Understanding codebase:</span>
@[https://www.youtube.com/watch?v=OJfib9kTK7U]
</pre>
</td>
<td title>Dev<br/>Ops</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Prerequisites</span>

<span xsmall>Disk/RAM</span>
                          DISK Space:  RAM:
test/private network      -200+MB      - 4+GB RAM
mainnet/public-test-net   -1.5+TB      - 8+GB RAM

<span xsmall>Disk/RAM</span>
</pre>
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>Minimum Private network</span>
@[https://docs.pantheon.pegasys.tech/en/stable/Getting-Started/Run-Docker-Image/]
@[https://docs.pantheon.pegasys.tech/en/stable/Tutorials/Create-Private-Network/]        (PoW)
@[https://docs.pantheon.pegasys.tech/en/stable/Tutorials/Create-Private-Clique-Network/] (PoA Clique)
@[https://docs.pantheon.pegasys.tech/en/stable/Tutorials/Create-IBFT-Network/]           (PoA IBFT)
$ git clone --branch 1.1.0 @[https://github.com/PegaSysEng/pantheon-quickstart.git]
$ cd pantheon-quickstart
$ ./run.sh               ← build docker images and run the containers
                           It also scales the regular node container to four containers 
                           to simulate a network with enough peers to synchronize.

   (ouput will be similar to)
   → List endpoints and services
   → ----------------------------------
   →         Name                       Command               State                              Ports                           
   → -----------------------------------------------------------------------------------------------------------------------------
   → quickstart_*bootnode*_1    /opt/pantheon/bootnode_sta ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_*explorer*_1    nginx -g daemon off;             Up      0.0.0.0:32770 →80/tcp                                      
   → quickstart_*minernode*_1   /opt/pantheon/node_start.s ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_node_1          /opt/pantheon/node_start.s ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_node_2          /opt/pantheon/node_start.s ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_node_3          /opt/pantheon/node_start.s ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_node_4          /opt/pantheon/node_start.s ...   Up      30303/tcp, 8545/tcp, 8546/tcp                              
   → quickstart_*rpcnode*_1     /opt/pantheon/node_start.s ...   Up      30303/tcp, 0.0.0.0:32769→8545/tcp, 0.0.0.0:32768→8546/tcp
   → ...
   → JSON-RPC HTTP service endpoint      :*http://localhost:32770/jsonrpc*
   → JSON-RPC WebSocket service endpoint :*ws://localhost:32770/jsonws   *
   → Web block explorer address          :*http://localhost:32770        *
   → 

$ ./list.sh  ← (re)display list of endpoints again

...
$ ./stop.sh  ← shut down private network without deleting the containers
               (./start.sh to restart)

$ ./remove.sh ← Shut downa and remove all data.

</pre>
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>set max Contract size</span>
- Done at the network (genesis.json) config level.
@[https://docs.pantheon.pegasys.tech/en/stable/Configuring-Pantheon/Config-Items/]
 Network             configuration items are specified in the genesis file.
 Item                Description
 Chain ID            Chain ID for the network
 Milestone blocks    Milestone blocks for the network
 ethash              Specifies network uses Ethash and contains fixeddifficulty
 clique              Specifies network uses Clique and contains Clique configuration items
 ibft2               Specifies network uses IBFT 2.0 and contains IBFT 2.0 configuration items
*contractSizeLimit*  ← free gas networks. Default is 24576 and the maximum size is 2147483647.
*evmStackSize     *  Maximum stack size. Specify to increase the maximum stack size in
                     private networks with very complex smart contracts. Default is 1024.
</pre>


</td>




</tr>
</table>

</body>
</html>
<!--
TODO_START:
_____________________________
Geth Key Handling:
<pre xxxsmall zoom>
- Keys are stored under <DATADIR>/keystore(backup regularly)
- keyfiles format(2017-05): UTC--<created_at UTC ISO8601>-<address hex>

geth account [arguments...]
geth account help <subcommand>
    subcommand:
    - new   : create new accounts. Will ask for password/passphrase and
              return its public address.
    - list  : list all existing accounts. 
              (Example Output)
              > Account #0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b}
              > Account #1: {c385233b188811c9f355d4caec14df86d6248235}
              > ...
    - import: import a private key into a new account
              $ geth --datadir /someOtherEthDataDir  account import ./key.prv
              > The new account will be encrypted with a passphrase.
              > Please enter a passphrase now.
              > Passphrase:
              > Repeat Passphrase:
              > Address: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}
              > export (unencrypted format >>NOT<< supported)
    - update: migrate to newest key format. account will be saved in newest version
              in encrypted format.  you are prompted for passphrase to unlock
              old-format account wallet and another to save updated file
              (can also be used to change file/wallet password)
              $ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b
              > Unlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b | Attempt 1/3
              > Passphrase:
              > 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b
              > Account 'a94f5374fce5edbc8e2a8697c15331677e6ebf0b' unlocked.
              > Please give a new password. Do not forget this password.
              > Passphrase:
              > Repeat Passphrase:
              > 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b

    - ??????: change password

using account NON-interactively (not connected to a geth node):

   Ex. unlock account wallet for one session: 
   $ geth --unlock <hex_formated_comma_separated_account_list> 
   Example:
   $ geth --unlock primary --rpccorsdomain localhost --verbosity 6 2>> geth.log 
   $ KEYLIST="0x407d73d8a49eeb85d32cf465507dd71d507100c1"
   $ KEYLIST="${KEYLIST},0,5"
   $ KEYLIST="${KEYLIST},e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32"
   $ geth --unlock "${KEYLIST}"
</pre>

_______________________________________________________

______________________________________________

{
"Alt 2: npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use
"
}


{ INSTALL SOLIDITY COMPILER (solc)    
Alt 1   "npm / Node.js
     $ npm install solc
 or  $ sudo npm install -g solc

This is probably the most portable and most convenient way to install Solidity locally. A platform-independent JavaScript library is provided by compiling the C++ source into JavaScript using Emscripten for browser-solidity and there is also an npm package available.To install it, simply use"   
Alt 2   "PPAs for Ubuntu. For the latest stable version.
Solidity Documentation, Release 0.4.8-develop
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc

If you want to use the cutting edge developer version:
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc"  
}
_____________________________________
LexiFi's Modeling Language for Finance

Screenshot

Developed by the company LexiFi, the Modeling Language for Finance (MLFi) is the first formal language that accurately describes the most sophisticated capital market, credit, and investment products. MLFi is implemented as an extension of OCaml.

MLFi users derive two important benefits from a functional programming approach. First, the declarative formalism of functional programming languages is well suited for specifying complex data structures and algorithms. Second, functional programming languages have strong list processing capabilities. Lists play a central role in finance where they are used extensively to define contract event and payment schedules.

In addition, MLFi provides crucial business integration capabilities inherited from OCaml and related tools and libraries. This enables users, for example, to interoperate with C and Java programs, manipulate XML schemas and documents, and interface with SQL databases.

Data models and object models aiming to encapsulate the definitions and behavior of financial instruments were developed by the banking industry over the past two decades, but face inherent limitations that OCaml helped overcome.

LexiFi's approach to modeling complex financial contracts received an academic award in 2000, and the MLFi implementation was elected “Software Product of the Year 2001” by the magazine Risk, the leading financial trading and risk management publication. MLFi-based solutions are gaining growing acceptance throughout Europe and are contributing to spread the use of OCaml in the financial services industry
___________________________
The ASTRÉE Static Analyzer

David Monniaux (CNRS), member of the ASTRÉE project, says: “ASTRÉE is a static analyzer based on abstract interpretation that aims at proving the absence of runtime errors in safety-critical software written in a subset of the C programming language.”

“Automatically analyzing programs for exactly checking properties such as the absence of runtime errors is impossible in general, for mathematical reasons. Static analysis by abstract interpretation works around this impossibility and proves program properties by over-approximating the possible behaviors of the program: it is possible to design pessimistic approximations that, in practice, allow proving the desired property on a wide range of software.”

“So far, ASTRÉE has proved the absence of runtime errors in the primary control software of the Airbus A340 family. This would be impossible by software testing, for testing only considers a limited subset of the test cases, while abstract interpretation considers a superset of all possible outcomes of the system.”

“ASTRÉE is written in OCaml and is about 44000 lines long (plus external libraries). We needed a language with good performance (speed and memory usage) on reasonable equipment, easy support for advanced data structures, and type and memory safety. OCaml also allows for modular, clear and compact source code and makes it easy to work with recursive structures such as syntax trees.”

____________________________________________
https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall
Difference between CALL, CALLCODE and DELEGATECALL
   
CALL and CALLCODE take the same number of operands (in the execution stack).
For the exception flag being pushed on top of the stack: 0 means exception, 1 means successful execution.
CALL is easy to understand, but I could not digest the subtle difference between CALL & CALLCODE. It is stated in the yellow paper that for

CALLCODE: This means that the recipient is in fact the same account as at present, simply that the code is overwritten.

What does it mean by the code is overwritten? Does that mean I can ask the contract to execute some external code? It would be helpful if anyone can provide me an example to differentiate between the two.

EDIT: DELEGATECALL was added in Homestead what is the difference?
Response:
DELEGATECALL basically says that I'm a contract and I'm allowing (delegating) you to do whatever you want to my storage. DELEGATECALL is a security risk for the sending contract which needs to trust that the receiving contract will treat the storage well.

DELEGATECALL was a new opcode that was a bug fix for CALLCODE which did not preserve msg.sender and msg.value. If Alice invokes Bob who does DELEGATECALL to Charlie, the msg.sender in the DELEGATECALL is Alice (whereas if CALLCODE was used the msg.sender would be Bob).
Details

When D does CALL on E, the code runs in the context of E: the storage of E is used.

When D does CALLCODE on E, the code runs in the context of D. So imagine that the code of E is in D. Whenever the code writes to storage, it writes to the storage of account D, instead of E.

contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3("setN(uint256)")), _n); // E's storage is set, D is not modified 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3("setN(uint256)")), _n); // D's storage is set, E is not modified 
  }
}

contract E {
  uint public n;
  address public sender;

  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    // msg.sender is D if invoked by D's callcodeSetN. None of E's storage is updated
    // msg.sender is C if invoked by C.foo(). None of E's storage is updated

    // the value of "this" is D, when invoked by either D's callcodeSetN or C.foo()
  }
}

contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}

When D does CALLCODE on E, msg.sender inside E is D as commented in the code above.

When an account C invokes D, and D does DELEGATECALL on E, msg.sender inside E is C. That is, E has the same msg.sender and msg.value as D.

____________________________________________

    <hr/>
    Libraries: similar to contracts, but their purpose is that
    they are deployed only once at a specific address and their code is reused
    using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. 
    In comparison to contracts:
    <ul>
      <li>No state variables</li>
      <li>Cannot inherit nor be inherited</li>
      <li>Cannot recieve Ether</li>
    </ul>
____________________________________________

'Ethereum client' refers to any node able to parse and verify the blockchain, its smart contracts ... .
 It also provides (JSON-RPC?) interfaces to create transactions and mining"
____________________________________________

Third party non-official clients:

parity (Rust client): https://github.com/ethcore/parity

ethereumj Java client: https://github.com/ethereum/ethereumj

ethereumjs-vm: https://github.com/ethereumjs/ethereumjs-vm

node-blockchain-server: https://github.com/ethereumjs/node-blockchain-server

____________________________________________
____________________________________________
http://martin.swende.se/blog/EVM-Assembly-trick.html#
"""I recently discovered a method to do generic proxying of Ethereum calls. Skip further down for nitty gritty details, I’ll start this off with some basics.
The problem

Sometimes, it’s convenient to build contract factories. For example, say you want to implement crowdsourcing, or auctions, or games, or DAOs. In those cases, instead of having one “Mother” auction which keeps track of active auctions (which, in turn keep track of bidders, offers and items), it makes sense to implement each auction/crowdfund/game/DAO as it’s own contract.

One problem is that these contracts are quite heavy; creating them may be very expensive and the creation of several may be limited by block gas limits. To counter this, the library-model can be used instead: """
____________________________

<a href='http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers'>Function modifiers</a>

_________________________
Security Considerations:
http://solidity.readthedocs.io/en/develop/security-considerations.html#security-considerations
________________________
The Ethereum Package Registry
   https://www.ethpm.com/
 A package index for Ethereum smart contract packages.

The Ethereum Package Registry is a package index for Ethereum smart contract packages. The registry is based on the ERC190 Smart Contract Packaging Specification.

"""Dear Ethereum,

We need to talk. You're not the easiest platform to work with. Don't get me wrong, you have some great qualities but it's time to grow up and start acting a bit more... mature

Since we care about you and really want you to succeed we made you something that should help. It's called a package index.

I know change can be a little scary but we're sure that once you try it you'll love it. Developers are going to like you more. Their bosses may even stop seeing you as the dangerous kid teaching their devs bad habits like copy/pasting code.

Please give it a try. We really do want the best for you.

Piper & Tim
"""
___________________
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids
List of Chain ID's:
CHAIN_ID    Chain(s)
1   Ethereum mainnet
2   Morden (disused), Expanse mainnet
3   Ropsten
4   Rinkeby
30  Rootstock mainnet
31  Rootstock testnet
42  Kovan
61  Ethereum Classic mainnet
62  Ethereum Classic testnet
1337    Geth private chains (default)
_____________________________
https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88
_____________________________
- create links to interesting sites:
http://www.digitalchamber.org/smart-contract-alliance.html 
http://ethereum.stackexchange.com/
https://www.google.es/?q=smart+contract+formal+verification
_____________________________
formal verification for Smart Contracts ( https://chriseth.github.io/notes/talks/formal_devcon2/#/ ,  http://www.cs.umd.edu/~aseem/solidetherplas.pdf , 
https://www.google.es/?q=smart+contract+formal+verification )

______________________
APP: Ethereum atomic Swaps
   https://github.com/AltCoinExchange/ethatomicswap
  created by https://www.altcoin.io, "A truly decentralized cryptocurrency exchange. Powered by Atomic Swaps."
______________________
1 Log per TX (NO compactado):
Cost  TX:    21000 gas/TX    * 1TX       = 21000
Coste evento:  375 gas/LOG   * 1LOG      =   375
Coste Topic:   375 gas/topic * 3topic    =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes =  1240
                                          ------
                                 TOTAL     23740 gas   = 23740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.228  Eu

5 Logs per TX (compactado):
Cost  TX:    21000 gas/TX    * 1TX        = 21000
Coste evento:  375 gas/LOG   * 1LOG       =   375
Coste Topic:   375 gas/topic * 3topic     =  1125
Coste byte/logs: 8 gas/byte  * 1500 bytes = 12400
                                           ------
                                  TOTAL     34900 gas  = 34900 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.33504 Eu (0.07 Eu 1Log)


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
                                               ------
                                      TOTAL    101000 gas  = 101000 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.9696 Eu


Internal Storage: (Balance in block-chain):
Cost  TX:      21000 gas/TX       * 1TX       = 21000
Cost storage:  20000 gas/32bytes  * 4*32 bytes= 80000
Coste evento:  375 gas/LOG   * 1LOG           =   375
Coste Topic:   375 gas/topic * 3topic         =  1125
Coste byte/logs: 8 gas/byte  * 150 bytes      =  1240
                                               ------
                                      TOTAL    103740 gas  = 103740 gas * 0.000000032 Eth/gas * 300 Euros/Eth = 0.995904 Eu
-------------------------------------------------
________________________________
https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#.gbg2nh4o5

Onward with Ethereum Smart Contract Security

If you’re new to Ethereum development, I recommend you read our Hitchhiker’s Guide to Smart Contracts in Ethereum before proceeding.

Learning Ethereum Smart Contract security is a very hard endeavor. There are few good guides and compilations, such as Consensys’ Smart Contracts 
Best Practices, or the Solidity Documentation Security Considerations. But the concepts are very hard to remember and internalize without writing your own code.

I’ll attempt a slightly different approach. I’ll explain some recommended strategies to improve smart contract security and show code examples where not
 following them results in problems. I’ll also show you code samples you can use to protect your smart contracts. Hopefully, this will help create a muscle
 memory of things to avoid, which will trigger mental warnings when writing actual code.

Without further ado, let’s dive into the best practices:
Fail as early and loudly as possible

A simple yet powerful programming good practice is to make your code fail as promptly as possible. And be loud about it. Let’s see an example of a function
 that behaves timidly:

// UNSAFE CODE, DO NOT USE!

contract BadFailEarly {
  uint constant DEFAULT_SALARY = 50000;
  mapping(string => uint) nameToSalary;

  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length != 0 && nameToSalary[name] != 0) {
      return nameToSalary[name];
    } else {
      return DEFAULT_SALARY;
    }
  }
}

We want to avoid a contract failing silently, or continuing execution in an unstable or inconsistent state. The function getSalary is checking for conditions 
before returning the stored salary, which is a good thing. The problem is, in case those conditions are not met, a default value is returned. This could hide 
an error from the caller. This is an extreme case, but this kind of programming is very common, and normally arises from fear of errors breaking our app.
Truth is, the sooner we fail, the easier it will be to find the problem. If we hide errors, they can propagate to other parts of the code and cause inconsistencies
 which are difficult to trace. A more correct approach would be:

contract GoodFailEarly {
  mapping(string => uint) nameToSalary;
  
  function getSalary(string name) constant returns (uint) {
    if (bytes(name).length == 0) throw;    
    if (nameToSalary[name] == 0) throw;
    
    return nameToSalary[name];
  }
}

This version also shows another desirable programming pattern which is separating preconditions and making each fail separately. Note that some of these
 checks (especially those depending on internal state) can be implemented via Function Modifiers.
Favor pull over push payments

Every Ether transfer implies potential code execution. The receiving address can implement a fallback function that can throw an error. Thus, we should never 
trust that a send call will execute without error. A solution: our contracts should favor pull over push for payments. Take a look at this innocent looking code for 
a bidding function:

// UNSAFE CODE, DO NOT USE!

contract BadPushPayments {
  address highestBidder;
  uint highestBid;
 
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0) {
      // return bid to previous winner
      if (!highestBidder.send(highestBid)) {
        throw;
      }
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
}

Note that the contract calls the send function and checks its return value, which seems reasonable. But it calls send in the middle of a function, which is unsafe. Why? Remember that, as stated above, send can trigger the execution of code in another contract.

Imagine someone bids from an address which simply throws an error every time someone sends money to it. What happens when someone else tries to outbid that? The send call will always fail, bubbling up and making bid throw an exception. A function call that ends in error leaves the state unchanged (any changes made are rolled back). That means nobody else can bid, and the contract is broken.

The easiest solution is to separate payments into a different function, and have users request (pull) funds independently of the rest of the contract logic:

contract GoodPullPayments {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  
  function bid() external {
    if (msg.value < highestBid) throw;
    
    if (highestBidder != 0) {
      refunds[highestBidder] += highestBid;
    }
    
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdrawBid() external {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund)) {
      refunds[msg.sender] = refund;
    }
  }
}

This time, we use a mapping to store refund values for each outbid bidder, and provide a function to withdraw their funds. In case of a problem in the send call, only that bidder is affected. This is a simple pattern that solves many other problems (such as reentrancy), so remember: when sending ether, favor pull over push payments.

I’ve implemented a contract you can inherit from to easily use this pattern. Here’s an example showing how to use it.
Order your function code: conditions, actions, interactions

As an extension of the fail-early principle, a good practice is to structure all your functions as follows: first, check all the pre-conditions; then, make changes to your contract’s state; and finally, interact with other contracts.

Conditions, actions, interactions. Sticking to this function structure will save you lots of problems. Let’s see an example of a function using this pattern:

function auctionEnd() {
  // 1. Conditions
  if (now <= auctionStart + biddingTime)
    throw; // auction did not yet end
  if (ended)
    throw; // this function has already been called

  // 2. Effects
  ended = true;
  AuctionEnded(highestBidder, highestBid);

  // 3. Interaction
  if (!beneficiary.send(highestBid))
    throw;
  }
}

This is in line with the fail fast principle, as conditions are checked in the beginning. It also leaves potentially dangerous interactions with other contracts to the very end.
Be aware of platform limits

The EVM has a lot of hard limits on what our contracts can do. These are platform-level security considerations, but may threaten your particular contract’s security if you don’t know about them. Let’s take a look at the following innocent-looking employee bonus management code:

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  
  function payBonus() {
    for (var i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = calculateBonus(employee);
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    // some expensive computation ...
  }
}

Read the code: it’s pretty straight-forward and seems correct. It hides 3 potential problems, though, based on platform limits.

The first problem is that the type of i will be uint8, because this is the smallest type that is required to hold the value 0. If the array has more than 255 elements, the loop will not terminate, resulting in gas depletion. Better use the explicit type uint for no surprises and higher limits. Avoid declaring variables using var if possible. Let’s fix that:

const Project = artifacts.require('./Project.sol')
const project = await Project.deployed()

const people = await project.getPeople([ 2, 5 ], { from: accounts[0] })

console.log('people =', people)
// this will print something like:
// people = [ ['0xdeadbeef', '0xabcdeff'], [123, 789] ]
//
// as you can see, we get back an array.  each element of this array
// represents a field in the struct type.  because we've returned
// many structs, each field has many values.  let's reassemble these
// into a more familiar (and more usable) format.

// we can figure out how many structs were returned by checking the
// length of any of the arrays that were returned.  they should all
// have the exact same length.
const numPeople = people[0].length

// for clarity's sake, let's define some constants so that we can see
// which field array we're accessing:
const FIELD_ADDR  = 0
const FIELD_FUNDS = 1

let peopleStructs = []
for (let i = 0; i < numPeople; i++) {
    const person = {
        addr:  people[FIELD_ADDR][i],
        funds: people[FIELD_FUNDS][i],
    }
    peopleStructs.push(person)
}

console.log('peopleStructs =', peopleStructs)
// this will print something like:
// peopleStructs = [
//     { addr: '0xdeadbeef', funds: 123 },
//     { addr: '0xabcdeff', funds: 789 }
// ]



The second thing you should consider is the gas limit. Gas is Ethereum’s mechanism to charge for network resources. Every function call that modifies state has a gas cost. Imagine calculateBonus calculates the bonus for each employee based on some complex computation like calculating the profit over many projects. This would spend a lot of gas, which could easily reach the transaction’s or block’s gas limit. If a transaction reaches the gas limit, all changes will be reverted but the fee is still paid. Be aware of variable gas costs when using loops. Let’s optimize the contract by separating the bonus calculation from the for loop. Please note that this still has the issue that as the employees array grows, the gas cost grows.

// UNSAFE CODE, DO NOT USE!

contract BadArrayUse {
  
  address[] employees;
  mapping(address => uint) bonuses;  
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      employee.send(bonus);
    }     
  }
  
  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation modifying the bonus...
    bonuses[employee] = bonus;
  }
}

Last, there is the call stack depth limit. The EVM’s call stack has a hard limit of 1024. That means that if the amount of nested calls reaches 1024, the contract will fail. An attacker can call a contract recursively 1023 times and then call our contract’s function, causing sends to silently fail because of this limit. PullPaymentCapable.sol was described above, and allows to easily implement pull payments. Inheriting from PullPaymentCapable and using asyncSend protects you from this.

Here’s a modified version of the code that fixes all these issues:

import './PullPaymentCapable.sol';

contract GoodArrayUse is PullPaymentCapable {
  address[] employees;
  mapping(address => uint) bonuses;
  
  function payBonus() {
    for (uint i = 0; i < employees.length; i++) {
      address employee = employees[i];
      uint bonus = bonuses[employee];
      asyncSend(employee, bonus);
    }
  }

  function calculateBonus(address employee) returns (uint) {
    uint bonus = 0;
    // some expensive computation...
    bonuses[employee] = bonus;
  }
}

To sum up, be sure to remember about (1) limits in the types you’re using, (2) limits in the gas costs of your contract, and (3) the call stack depth limit.
Write tests

Writing tests is a lot of work, but will save you from regression problems. A regression bug appears when a previously correct component gets broken based on a recent change.

I’ll be writing a more extensive guide on testing soon, but if you’re curious you can check Truffle’s testing guide.
Fault tolerance and Automatic bug bounties

Thanks to Peter Borah for inspiration on these two ideas. Code reviews and security audits are not enough to be safe. Our code needs to be ready for the worst. In case there is a vulnerability in our smart contract, there should be a way for it to safely recover. Not only that, but we should try to find those vulnerabilities as early as possible. That’s where automatic bug bounties built into our contract can help.

Let’s take a look at this simple implementation of an automatic bug bounty for a hypothetical Token contract:

import './PullPaymentCapable.sol';
import './Token.sol';

contract Bounty is PullPaymentCapable {
  bool public claimed;
  mapping(address => address) public researchers;
  
  function() {
    if (claimed) throw;
  }
  
  function createTarget() returns(Token) {
    Token target = new Token(0);
    researchers[target] = msg.sender;
    return target;
  }
  
  function claim(Token target) {
    address researcher = researchers[target];
    if (researcher == 0) throw;
    
    // check Token contract invariants
    if (target.totalSupply() == target.balance) {
      throw;
    }
    asyncSend(researcher, this.balance);
    claimed = true;
  }
}

As before, we’re using PullPaymentCapable to make our outgoing payments safe. This Bounty contract allows researchers to create copies of the Token contract we want audited. Anyone can contribute to the bug bounty by sending transactions to the Bounty contract’s address. If any researcher manages to corrupt his copy of the Token contract, making some invariant break (for example, in this case, making the total supply of tokens different from the Token’s balance), he’ll get the bounty reward. Once the bounty is claimed, the contract won’t accept any more funds (that nameless function is called the contract’s fallback function, and is executed every time the contract is sent money directly).

As you can see, this has the nice property that it is a separate contract and requires no modification of our original Token contract. Here’s a full implementation available on GitHub for anyone to use.

As for fault tolerance, we will need to modify our original contract to add extra safety mechanisms. A simple idea is to allow a contract’s curator to freeze the contract as an emergency mechanism. Let’s see a way to implement this behavior via inheritance:

contract Stoppable {
  address public curator;
  bool public stopped;

  modifier stopInEmergency { if (!stopped) _ }
  modifier onlyInEmergency { if (stopped) _ }
  
  function Stoppable(address _curator) {
    if (_curator == 0) throw;
    curator = _curator;
  }
  
  function emergencyStop() external {
    if (msg.sender != curator) throw;
    stopped = true;
  }
}

Stoppable allows one to specify a curator address that can stop the contract. What does “stopping the contract” mean? That’s to be defined by the child contract inheriting from Stoppable by using the function modifiers stopInEmergency and onlyInEmergency. Let’s see an example:

import './PullPaymentCapable.sol';
import './Stoppable.sol';

contract StoppableBid is Stoppable, PullPaymentCapable {
  address public highestBidder;
  uint public highestBid;
  
  function StoppableBid(address _curator)
    Stoppable(_curator)
    PullPaymentCapable() {}
  
  function bid() external stopInEmergency {
    if (msg.value <= highestBid) throw;
    
    if (highestBidder != 0) {
      asyncSend(highestBidder, highestBid);
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  
  function withdraw() onlyInEmergency {
    suicide(curator);
  }
}

In this toy example, the bid can now be stopped by a curator, defined when the contract is created. While the StoppableBid is in normal mode, only the bid function can be called. If something weird happens and the contract is in an inconsistent state, the curator can step in and activate the emergency state. This makes the bid function uncallable, and allows the function withdraw to work.

In this case, emergency mode would only allow the curator to destroy the contract and recover the funds, but in a real case, recovery logic could be more complex (for example returning funds to their owners). Here’s an implementation of Stoppable available on GitHub for anyone to use.
Limit the amount of funds deposited

Another way to protect our smart contracts from attacks is to limit their scope. Attackers will most probably target high-profile contracts managing millions of dollars. Not all smart contracts need to have such high stakes. Especially if we’re conducting experiments. In such cases, it might be useful to limit the amount of funds our contract accepts. This is as simple as a hard limit on the balance of the contract’s address.

Here’s a simplified example on how to do this:

contract LimitFunds {
  
  uint LIMIT = 5000;
  
  function() { throw; }
  
  function deposit() {
    if (this.balance > LIMIT) throw;
    ...
  }
}

The short fallback function will reject any direct payments to the contract. The deposit function will first check if the contract’s balance exceeds the desired limit, or throw an exception. More interesting things like dynamic or managed limits are easy to implement too.
Write simple and modular code

Security comes from a match between our intention and what our code actually allows to do. This is very hard to verify, especially if the code is huge and messy. That’s why it’s important to write simple and modular code.

This means, functions should be as short as possible, code dependencies should be reduced to the minimum, and files should be as small as possible, separating independent logic into modules, each with a single responsibility.

Naming is also one of the best ways to express our intention when coding. Think a lot about the names you chose, to make your code as clear as possible.

Let’s study an example of bad naming of Events. Look at this function from The DAO. I’m not going to copy the function code here because it’s very long.

The biggest problem is that it’s too long and complex. Try to keep your functions much shorter, say, up to 30 or 40 lines of code max. Ideally, you should be able to read functions and understand what they do in less than a minute. Another problem is the bad naming for the event Transfer in line 685. The name differs from a function called transfer by only 1 character! This is inviting confusion for everyone. In general, the recommended naming for events is that they should start with “Log”. In this case, a better name would be LogTransfer.

Remember, write your contracts as simple, modular, and well-named as possible. This will greatly facilitate others and yourself in auditing your code.
Don’t write all your code from scratch

Finally, as the old adage reads: “Don’t roll your own crypto”. I think it also applies to Smart Contract code. You’re dealing with money, your code and data is public, and you’re running in a new and experimental platform. The stakes are high and the chances to mess-up are everywhere.

These practices help secure our smart contracts. But ultimately, we should create better developer tools to build smart contracts. There are some interesting initiatives including better type systems, Serenity Abstractions, and the Rootstock platform.

There’s lots of good and secure code already written and frameworks are starting to appear. We’ve started to compile some of the best practices in this GitHub repo we called OpenZeppelin. Feel free to take a look and contribute with new code or security audits.
Wrapping up

To recap, the security patterns described in this article are:

    Fail as early and loudly as possible
    Favor pull over push payments
    Order your function code: conditions, actions, interactions
    Be aware of platform limits
    Write tests
    Fault tolerance and Automatic bug bounties
    Limit the amount of funds deposited
    Write simple and modular code
    Don’t write all your code from scratch

If you want to join the discussion about secure smart contract development patterns join us on slack. Let’s improve the smart contract development standards together!

To be up to date with our work in smart contract security, follow us on Medium and Twitter.
_______________________________________

See also: https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab#.xk3bv3cw8
_______________________________
<strong>Ethereum</strong><br>
Ethereum was able to successfully execute a hard fork called Byzantium. As part of this hard fork increased anonymity was provided through Zero-knowledge proofs, or zk-snark proofs. It also included more predictable gas charges which were becoming difficult to calculate with the increased number of ICOs. InfoQ previously covered this hard fork in the following <a href="https://www.infoq.com/news/2017/08/Ethereum-HardFork" target="_blank">article</a>.</p>
________________________
Ethereum ¿Opinion?: """
Bitcoin UTXO binary state (spent, unspent) gives no opportunity for multi-stage contracts or scripts
which keep any other interanl state beyond that. This makes it hard to make multi-stage options
contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary
for secure computational bounties). It also means that UTXO can only be used to build simple, one-off
contracts and not more complex "stateful" contracts such as decentralized organizations, and makes
meta-protocols difficult to implement. Binary state combined with value-blindness also mean that 
another important application, withdrawal limits, is impossible".
__________________________________
  <a href='https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/' TODO>How to build server less applications for Mist</a>
________________________
throw vs revert
_________________
https://github.com/ethereum/wiki/wiki/Whisper
In a nutshell whisper is a communication protocol for DApps to communicate with each other.
Use case

    DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.

    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.

    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.

    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.
_______________________________
https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c

_______________________________
_______________________________

____________________________

_______________________________
Solidity: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1
__________________
Solidity: https://coursetro.com/posts/code/102/Solidity-Mappings-&-Structs-Tutorial
_____________
__________________________________________
https://github.com/pirapira?utf8=%E2%9C%93&tab=repositories&q=&type=source&language=  
 ( Lot of interesting repos related to Ethereum)

_________________
selfdestruct(address recipient):
  destroy current contract
  send its funds to recipient 
________________________________

_____________________
https://entethalliance.org/enterprise-ethereum-alliance-advances-web-3-0-era-public-release-enterprise-ethereum-architecture-stack/
 The Enterprise Ethereum Alliance (EEA), with over 500 members, today unveiled the next phase of its Enterprise Ethereum specification strategy, with the public release of its Enterprise Ethereum Architecture Stack. This stack defines the building blocks needed to drive the Web 3.0 era of decentralized, connective intelligence ? the next generation of Enterprise Ethereum applications that, like the Internet, will work anywhere, and are capable of facilitating smart contracts without intermediaries. The stack, available as a free public document to download, incorporates components developed by the Ethereum Foundation.
_________________________
https://entethalliance.org/resources/
_________________________
Signing transactions Flow:
 - Identify the next available nonce for the sender account
 - Create the RawTransaction object
 - Encode the RawTransaction object using Recursive Length Prefix encoding
 - Sign the RawTransaction object
 - Send the RawTransaction object to a node for processing

The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.
_______________________
Tooling:
https://github.com/adridadou/eth-contract-api

 EthereumJ native API or how to call contracts easily and with type safety http://www.davidroon.com/ethcontractapi/
____________________________
ERC223: Safer ERC20 token standard:
https://github.com/ethereum/EIPs/issues/223
____________________________
https://github.com/paritytech/parity/issues/6342___________________________
____________________________
https://github.com/oraclize/ethereum-examples
http://www.oraclize.it/
_______________________________
Solidity Arrays vs Linked-lists:
https://ethereum.stackexchange.com/questions/51399/deleting-index-of-an-array-in-terms-of-optimization-for-looping
_______________________________
Consensys techs:
Balanc3             TravelBlocks                                 Linnia
Cellarius           Waterloo                                     Catalyst and Hub Account Manager
ConsenSys Academy   Panvala                                      Meridio
Plasma              Gitcoin                                      MetaMask
Gitcoin             Infura                                       N0d.capital
Token Foundry       Kaleido                                      Nethereum
Viant               Applied Researcher: Sharding                 Numia
uPort               Applied Researcher: Sidechains (PegaSys)     OpenLaw
Trustology          Quantitative/Qualitative Researcher          PegaSys
TruSet              Senior Design Researcher - Ujo Music















Ujo: Ethereum blockchain-based open music industry peer-to-peer platform built by ConsenSys.
Ujo aims to increase transparency and efficiency in the music industry through an automated,
decentralised rights management and payments system upon which any music service or
application can be built. Creators and rights holders register works and their stakes in those
works in smart contracts on the blockchain. Payments are delivered automatically and
instantly based on that information using the self-enforcing smart contract technology. Artists
may also publish policies for how their music may be used, facilitating an open marketplace in
which anybody can innovate a new business model, app or service as long as they meet the
terms of those policies.
__________________________________________
https://aleth.io:

https://media.consensys.net/alethio-lighting-up-the-blockchain-with-real-time-stats-a80bb30576db
Alethio’s analytics platform helps users visualize, interpret, and react to blockchain data in real time.


"""Though Ethereum has become a household name, what’s actually happening on the
 network remains a mystery for many. Current blockchain explorers provide little
 clarity into the evolving ecosystem. They are often geared towards developers
 and leave average users in the dark. At the same time, seasoned and committed 
users, from individuals to enterprises, still don’t have the resources they need
 to really make sense of the blockchain — whether that’s accessing real time 
block data, analyzing the application layer, detecting anomalies, or monitoring
 the statistical signals that translate to larger KPIs.

At Alethio, we take issue with this. For Ethereum to realize its true potential, users’ interactions with the blockchain should be fully transparent and understandable. As Ethereum grows in size and complexity, we believe the tools that inform user’s decisions, large or small, should evolve as well."""
_______________________
https://io.builders/blog/our-first-month-tools-languages-and-developments/
  Our first month: Tools, languages and developments
  Madrid, Spain
  Friday, June 1, 2018

  Time goes fast, and 5 weeks have passed since our 
  official Team start. We don't have everybody on board 
  but we have started with some developments. These are 
  the tools we are using:
  <ul>
  <li>Intellij IDEA and Atom as IDE</li>
  <li>Gitlab as CI. It allows us to create pipelines from 
  day one, natively integrated in our source code. With 
  its powerful docker based platform we are able to 
  compile, pass specific linters, test and audit the 
  security of our builds. 
  <a href="https://github.com/IoBuilders/solidity-test-and-security-pipeline/tree/master" target="_blank">Checkout out pipeline</a>.
  Our vision is to have full coverage and automatically 
  audited code, to be 100% sure that our smart contracts are safe from well known bugs and follow good practices.</li>
  <li>React Native for mobile development</li>
  <li>NodeJs, Java, Groovy and GO for backend development</li>
  <li><a href="https://www.jpmorgan.com/global/Quorum" target="_blank">Quorum</a> as the DLT</li>
  <li>Solidity 0.4.24</li>
  <li><a href="https://github.com/sc-forks/solidity-coverage" target="_blank">Solidity Coverage</a> as test coverage tool</li>
  <li><a href="http://truffleframework.com/" target="_blank">Truffle framework</a>: Lifecycle for solidity.</li>
  <li><a href="http://truffleframework.com/ganache/" target="_blank">Ganache</a>: Light node of Ethereum for testing purpose.</li>
  <li><a href="https://github.com/duaraghav8/Solium" target="_blank">Solium</a>: Linter &amp; security static analysis.</li>
  </ul>  
   
  Besides this, we have used <a href="https://www.gv.com/sprint/">Design Sprint</a> by Google Ventures,
  to discover and analize the customer journey, functional 
  approach of our first venture and develop/test it with 
  a prototype with real users. Hypothesis validation is on going!
  Thanks for Reading! Keep Posted!!!
  “With confidence, you have won before you have started.” —Marcus Garvey 
__________________________

_________________________
https://github.com/quantnetwork/eth-contract-metadata
_________________________
https://solidity.readthedocs.io/en/latest/050-breaking-changes.html
_________________________
https://yakindu.github.io/solidity-ide/
_________________________
Apache Camel + Ethereum JSON/RPC  protocol:
https://medium.com/@bibryam/enterprise-integration-for-ethereum-fa67a1577d43
________________________
https://openzeppelin.org/api/docs/ownership_rbac_RBAC.html
________________________
Timestamp in Ethereum:
https://ethereum.stackexchange.com/questions/7853/is-the-block-timestamp-value-in-solidity-seconds-or-milliseconds
https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp
________________________
https://ethereum.stackexchange.com/questions/18461/how-can-dapps-work-on-smartphones

Status is a good start to develop a Ethereum mobile dapp.

    Status is an open source messaging platform and mobile browser to interact with decentralized applications that run on the Ethereum Network.

    Decentralized Apps at your fingertips: With Status your mobile device becomes a light client node on the Ethereum Network, enabling you to access Ethereum’s entire ecosystem from anywhere.

    Smarter private messaging: Status is more than a messenger. Send payments and smart contracts to friends from within chats, and enjoy encrypted messaging by default, using a peer-to-peer protocol that doesn’t rely on centralized servers.

Status app (Ethereum Mobile gateway) is currently in alpha and can be tested on Android and iPhone.

Please find below a quick tutorial how to deploy a dapp on Status.Let's imagine you have a dapp (ReactNative, Ionic, ...) running on {DAPP_URL}

    Download Status on your phone and configure an account

    Install status-dev-cli npm i -g status-dev-cli

    In status console, enter /debug. That will give you your device IP address {DEVICE_IP}

    From your machine, make sure you can see you device and status: status-dev-cli scan (status must be running)

    Last step, consist in registering the dapp in status: status-dev-cli add "{\"whisper-identity\": \"my-dapp\", \"dapp-url\": \"{DAPP_URL}\", \"name\": \"MyDAPP\"}" --ip {DEVICE_IP}

You can now refresh you status app and you will see appear MyDapp in the list. The browser will launch you dapp and it can interact (web3) with the Ethereum blockchain and smart contracts.

By default, status run on the testnet network. You can switch to another node (private, testrpc or mainnet) with the following command status-dev-cli switch-node {NODE_URL} --ip {DEVICE_IP}

Documentation: Here

Some examples: Me and other devs have recently attended to the Status hackaton. This blog post (Winners Announcement) will illustrate some of the projects developed in a one-week period.
___________________________
Pantheon: Ethereum Java Client for the "Enterprise" with private TXs
https://pegasys.tech/enterprise/
_________________________
https://www.augur.net/
_________________________
https://ethereum.stackexchange.com/questions/267/why-dont-ethereum-addresses-have-checksums
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
  ICAP: Inter Exchange Client Address Protocol (ICAP) compatible 
        with IBAN account formatting.
        https://github.com/ethereum/wiki/wiki/Inter-exchange-Client-Address-Protocol-(ICAP)
_____________________
https://github.com/machinomy/contracts/blob/master/contracts/Unidirectional.sol

Machinomy simple Channels on Ethereum contract
_____________________
https://www.codementor.io/sambhav2612/setting-up-a-dao-contract-for-meetup-groups-k6jvjpvnr
_____________________
https://github.com/status-im/geth_exporter
geth metrics exporter for Prometheus
______________________________
https://legalconsortium.org/apply/
______________________________
https://solidity.readthedocs.io/en/v0.5.0/style-guide.html
______________________________
- Who-is-Who:
  https://github.com/juanfranblanco?tab=following

Quorum TODO_Start: {{{
_____________________________________________________
<p>See the <a href="https://github.com/jpmorganchase/quorum/blob/master/docs/api.md#privacy-apis">Quorum API</a> page for details on the <code>sendTransaction</code> call, which includes some modifications to the standard Ethereum call.</p>
    <li>
      <p>Developing Smart Contracts with Solidity</p>
      <p>Smart Contracts can be public or private to one or more network participants.  
      <p>Public  Transactions/Smart Contracts: Send an Ethereum Transaction to the network (TX.to         = "empty" creates a Contract)</p>
      <p>Private Transactions/Smart Contracts: Send an Ethereum Transaction to the network setting TX.privateFor = participant(s) public_key_list</p>
      <p>Example JSON message:
       <pre>
{ 
  "jsonrpc":"2.0",
  "method":"eth_sendTransaction",
  "params":[
    {
     "from": $FROM_AC,
     "to": $TO_AC, 
     "data": $CODEHASH,
     "privateFor": ["$PUBKEY1,PUBKEY2"]
    }
  ],
  "id":$ID
} 
       </pre>
      </p>
_________________________________
Youtube Video: Raspeberry Pi java sending telemetry data to quorum.
https://www.youtube.com/watch?v=64kMWxTaXw8
___________________________________________________


## Permissioned Network
Node Permissioning is a feature that controls which nodes can connect to a given node and also to which nodes this node can dial out to. Currently, it is managed at individual node level by the command line flag `--permissioned` while starting the node.

If the `--permissioned` node is present, the node looks for a file named `<data-dir>/permissioned-nodes.json`. This file contains the list of enodes that this node can connect to and also accepts connections only from those nodes. In other words, if permissioning is enabled, only the nodes that are listed in this file become part of the network. It is an error to enable `--permissioned` but not have the `permissioned-nodes.json` file. If the flag is given, but no nodes are present in this file, then this node can neither connect to any node or accept any incoming connections.

The `permissioned-nodes.json` follows following pattern (similar to `static-nodes.json`):

```json
[
  "enode://enodehash1@ip1:port1",
  "enode://enodehash2@ip2:port2",
  "enode://enodehash3@ip3:port3",
]
```

Sample file:

```json
[
  "enode://6598638ac5b15ee386210156a43f565fa8c48592489d3e66ac774eac759db9eb52866898cf0c5e597a1595d9e60e1a19c84f77df489324e2f3a967207c047470@127.0.0.1:30300",
]
```

In the current release, every node has its own copy of `permissioned-nodes.json`. In a future release, the permissioned nodes list will be moved to a smart contract, thereby keeping the list on chain and one global list of nodes that connect to the network.
___________________
Quorum Enterprise Toolkit:
Quorum Core +
  - remporting DB & adapters
  - Entitlements Framework
  - Certificate Authority
  - SAML/OAuth Integration
  - Data Archival/Pruning
  - Quorum API (RESTful)
  - Blockchain Explorer
  - Node Manager
  - Monitoring Capabilities
____________________________________
<td>
  Layers of Privacy 
<pre xxxsmall zoom>
<a href="https://media.consensys.net/busting-the-myth-of-private-blockchains-9ae0ed058b0d">[REF@media.consensys.net]</a>
- In reality, privacy is not a property of any blockchain. 
  Rather, there are layers of privacy that can be applied to any blockchain, 
  even public chains, allowing for private or “shielded” transactions on a 
  public blockchain. This allows companies to benefit from the decentralized 
  security of a public blockchain while concealing private information.

- Layers of Privacy with Enterprise Blockchains
  Privacy and confidentiality are essential for enterprise solutions. 
  Enterprises have a number of concerns when considering blockchain 
  implementations:

  - Access: who has permissions to read and/or write?
  - Visibility: to whom are transactions broadcasted?
  - Storage: how is data stored?
  - Execution: who has the right to start, stop, or restart a process?

- A private blockchain is only as secure as the permissioning and 
  security controls around the network. As these “private” networks gain more 
  participants, enforcing controls around access and visibility becomes more 
  difficult. For example, the way that Fabric ensures transaction privacy 
  between different parties within a consortium is through the concept of 
  channels. A channels is essentially a single protected route between two 
  parties. This means you need a channel for each party pair and must maintain 
  all of this infrastructure as the system evolves, making it more complicated 
  to manage.

- Layered Privacy:
  -  Permissioning 
     layer  : permissioning or credentials layer of tooling which 
              involves who has access to information and how that is
              controlled and authenticated.
  -  Privacy
       layer: maintaining the confidentiality of the participants,
              data, and terms.
              Even within a single layer, there’s multiple sublayers
              where privacy can be kept on-chain, off-chain, and through
              private transactions. 
              - Privacy of  
                participants: ensure participants remain anonymous to one
                              another as well as to those outside of the
                              network with on-chain cryptographic mechanisms 
                              like ring signatures, stealth addresses, mixing,
                              or storage of private data off-chain.
              - Privacy of 
                        data: keep transactions, balances, smart contracts,
                              and other data encrypted on or off chain, with
                              cryptographic tools like zero-knowledge proofs
                              and zk-SNARKS, Pedersen commitments, or off-chain
                              privacy layers like TEEs.
              - Privacy of
                       terms: keep terms of contracts between two parties private 
                                    with range proofs or Pedersen commitments.

- <b>Private blockchains do not give you privacy by default</b>. There is a distinction
  between permissioned networks and private transaction managers. Really, the only
  privacy that private blockchains do provide by default are that the 
  participants and contracts cannot be viewed by non-participants. Rather, 
  privacy layers must be built on any blockchain and can be built into both 
  public and private chains, or, with a combination of the two (such as 
  Ethereum and Quorum).

- <b>Layer 2 of the EEA client specification V2</b>
- many options for Private Transactions available providing various layers of privacy.
  - Pantheon: the protocol by  PegaSys, the engineering team at ConsenSys.
    Enterprise Ethereum client in Java.
  - Privacy layers for public/permissioned networks in progress:
    - zk-SNARKS and zero-knowledge proofs: hide transaction attributes like balances.
    - ring signatures and hashes: provide layers of privacy for
                      participants, data, and/or terms.
    - off-chain solutions: store private data and perform high-throughput transactions.

  - Project Ubin:
    - Shielded public transactions that are validated by the whole
      network but whose amount (and/or asset type,...) are shielded.
    - collaborative Ethereum project between ConsenSys and the 
      Monetary Authority of Singapore to create an interbank payment network.
    - In Project Ubin, a consortium of financial institutions used 
      zero-knowledge proofs to enable the transfer of digital assets on a
      distributed ledger without revealing information about the balances
      or transaction amounts.

  - Project Khokha (South African Reserve Bank "PoC"): Pedersen Commitments
    - Pedersen commitments are also additively homomorphic, which means that
      for a balance update, network participants can validate that the correct
      update has happened without knowing the opening balance, the closing balance,
      or the transfer amount.
    - Pedersen commitments and Folklore range proofs to process the typical
      daily volume of payments for the SARB with full confidentiality and 
      finality in less than two hours. These commitment schemes proved to be
      much quicker to validate than the zero-knowledge proofs.
    - Adhara has been exploring substituting range proofs with bullet proofs,
      which are much smaller and quicker to validate. Very simply, instead
      of writing the balances and the transaction amounts in the clear as in
      a normal ERC20 contract, nodes write a proof or a Pedersen commitment
      of the balance.
  - Public-First + Privacy Layers = Future-Proof
    - Business networks need resilience, interoperability, permissioning,
      and privacy to succeed.

   These requirements, however, are out of scope for proprietary distributed ledgers, let alone traditional database technologies. The Ethereum blockchain’s granular privacy layers and public-first approach make it a powerful enterprise solution for organizations that need the flexibility of an in-house platform and that want the global reach to participate in economies of scale.

Visit our Enterprise Ethereum homepage to connect with ConsenSys Solutions and learn more about how Ethereum can future-proof your organization. Stay tuned for Part 5 of this series, “The Enterprise Ethereum Infrastructure, Tool, and Application Stack.”

Disclaimer: The views expressed by the authors and contributors above do not necessarily represent the views of Consensys AG. ConsenSys is a decentralized community with ConsenSys Media being a platform for members to freely express their diverse ideas and perspectives. To learn more about ConsenSys and Ethereum, please visit our website.
Thanks to John Wolpert.

    BlockchainEthereumEnterprise TechnologyTechnologyBusiness

Go to the profile of ConsenSys
ConsenSys

A blockchain venture production studio building decentralized applications on Ethereum. Go to www.consensys.net and subscribe to our newsletter.
ConsenSys Media
ConsenSys Media

News, insights, and education on all things decentralization from leaders in the blockchain industry
</pre>
</td>
_________________
https://media.consensys.net/j-p-morgan-is-using-ethereum-to-launch-a-digital-u-s-dollar-heres-what-it-means-for-blockchain-64f0fe3e55bc?_hsenc=p2ANqtz-_G8oE25VrDDhDoGzsYJvAyJIsx8tTX8dRxqT6JFbZyn0ymF1UEmtrKqtZCCB0S24Aih9M6WMSTP3881SUa2PapCU2JD65yE0UEw1ya-ep6KMccBqs&_hsmi=69989245
______________
https://twitter.com/goquorum
https://github.com/jpmorganchase/
Quorum Slack:
<a href="https://clh7rniov2.execute-api.us-east-1.amazonaws.com/Express/">Quoram Slack</a>

______________________
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
____________________
<td>
<a xsmall TODO href="https://solidity.readthedocs.io/en/latest/types.html?highlight=push">Callbacks</a>
pragma solidity >=0.4.22 <0.6.0;

contract Oracle {
  struct Request {
    bytes data;
    function(uint) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes memory data, <b orange>function(uint) external callback</b>) public {
    requests.push(Request(data, callback));
    emit NewRequest(requests.length - 1);
  }
  function reply(uint requestID, uint response) public {
    // Here goes the check that the reply comes from a trusted source
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); // known contract
  uint exchangeRate;
  function buySomething() public {
    oracle.query("USD", this.oracleResponse);
  }
  function oracleResponse(uint response) public {
    require(
        msg.sender == address(oracle),
        "Only oracle can call this."
    );
    exchangeRate = response;
  }
} 
</td>
_______________________________
<td>
<a xsmall TODO href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3-Secret-Storage-Definition</a>
</td>
_________________________
https://info.binance.com/en/research/marketresearch/img/BinanceResearch-JPMCoin.pdf
_____________________________________
http://blog.notdot.net/2012/08/Damn-Cool-Algorithms-Homomorphic-Hashing
___________________________
https://github.com/trufflesuite/ganache-cli/issues/154
Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:

[] "anything"
[A] "A in first position (and anything after)"
[null, B] "anything in first position AND B in second position (and anything after)"
[A, B] "A in first position AND B in second position (and anything after)"
[[A, B], [A, B]] "(A OR B) in first position AND (A OR B) in second position (and anything after)"
}}}
_________________________________
https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4
Migrating your Truffle project to Web3 v1.0 (2019-07-13)
_________________
 
  <span xsmall>TXs in Solidity:</span>
<pre xxxsmall zoom>
addressInstance.balance (uint256): balance in Wei
addressInstance.transfer(uint256 amount): 
    msg.sender →(amount in wei) → addressInstance
    throws on failure 

addressInstance.send(uint256 amount): returns (bool):
    msg.sender ->(amount in wei) ->addressInstance
    returns true/false, does NOT throw an exception

- In addressInstance.transfer (or send), if addressInstance
  is a contract address, its code (more specifically: its fallback function, if present) 
  will be executed together with the transfer call. This is a limitation of the EVM and
  cannot be prevented. <br/>
  If that execution runs out of gas or fails in any way, the Ether transfer will be
  reverted and the current contract will stop with an exception.
</pre>
_____________________
raw-calls do NOT rethrow exceptions:
https://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests
______________________________________
https://blog.coinfabrik.com/using-the-cardcontact-smartcard-usb-hsm-in-an-ethereum-poa-chain/
Using the CardContact SmartCard USB HSM in an Ethereum PoA Chain
__________________________
https://ethereum.stackexchange.com/questions/25484/could-address-reuse-leak-your-mnemonic-seed/25705#25705
______________________________
Upgrade driven development on Ethereum with ZeppelinOS - Live Coding Workshop in New York City
https://www.reddit.com/r/ethdev/comments/b6z152/upgrade_driven_development_on_ethereum_with/?utm_medium=android_app&utm_source=share
_________________________________
https://medium.com/@squeezer/weve-launched-our-squeezer-2-way-payment-dapp-818ae6ae57e6
_________________________________
TODO:(1) {{{ 
______________________
Ethereum 2019 Grants:
- https://thematter.io/
  Productionising ‘Plasma Ignis’ code, a SNARK-driven “roll up” that can support up to 500 transactions per second.

- https://github.com/libp2p/py-libp2p
   Python implementation of libp2p which will be used in Eth2.0 research, 
   as well as in many other projects by UPenn seniors completing their capstone
   project (Zixuan Zhang, Robert Zajac, Alexander Haynes, and Aspyn Palatnick).

- https://www.reddit.com/r/ethereum/comments/alnmxn/ethereum_on_arm_geth_and_parity_clients_update/
  Ethereum on ARM - Supporting the decentralisation of Ethereum by providing Ethereum client images on resource constrained devices, including an initial investigation into using ARM nodes for Eth2.0 staking.

- https://github.com/goerli
  Cross-client testnet spearheaded by Chainsafe and widely supported by the Ethereum community. Launched at GörliCon at the end of January.

- https://github.com/kayagoban/shadowlands
  Python based, TextUI rapid prototyping platform for Eth apps which breaks the paradigm that everything must be a web app.
  
- https://certik.org/deepsea_blockchain.html
  Research at Yale and Columbia to further their work on DeepSEA, a formally verified language that compiles to the EVM.


_______________________
https://eoschain.co/ ERC20 based chain for IoT (fast micropayments?)
______________________________________
http://cryptomining-blog.com/tag/intel-opencl-mining/
_________________________________
...
https://media.consensys.net/blockchain-vs-distributed-ledger-technologies-1e0289a87b16
Ethereum Casper Proof of Stake

An example of cryptoeconomic incentive layers can also be seen in Ethereum?s transition to a proof of stake consensus mechanism via implementations of Casper. While proof of work has its own internalized game theoretical incentive structure to dissuade participants from commandeering the network, the transition to proof of stake has even further internal structures for disincentivizing participants from equivocating or trying to create alternative instances of the blockchain when encountering forks. The staking protocol creates a Byzantine Fault Tolerant environment where Ether would be bonded into the consensus mechanism. What this means is that individuals would be bound by a fidelity bond to behave honorably within the system.
....
Cosmos and Tendermint

Cosmos is also building an ecosystem that relies on the Tendermint consensus mechanism that relies heavily upon Byzantine Fault Tolerance algorithms. The platform depends on validators that have similar roles as miners in the bitcoin network. The validators have staking tokens called Atoms which are used to secure the network via a proof of stake mechanism that relies upon the trust generated by the bonded validators. The interplay between the players in the ecosystem is also indicative of a game theoretical structure where validators can lose their tokens or the tokens delegated to them if discovered to be violating the protocol. Due to this bonded deposit design of stakeholders within this system, the consensus mechanism allows for an incentivization mechanism that secures the network. This security design allows for the proper functioning of the Application Blockchain Interface (ABCI), the Inter-Blockchain Communication protocol (IBC) as well as the varying interactions between the Cosmos hub and zones.
....
____________________________________
https://github.com/nucypher/nucypher
________________________
truffle migrations explained (Linking libraries, ...):
https://www.youtube.com/watch?v=8i03-M_4aT0&feature=youtu.be
________________________
https://solidity.readthedocs.io/en/develop/contracts.html#libraries
________________________
https://github.com/ethereum/solidity/issues/3985
__________________________
https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2
_________________
https://elementsproject.org/                      ← !!!
""""
  Built upon and extending Bitcoin\u2019s codebase, it lets developers familiar 
  with the bitcoind API to quickly and cost-effectively create working 
  blockchains and test proof-of-concept projects. Being built on the Bitcoin 
  codebase also allows Elements to function as a testbed for changes 
  to the Bitcoin protocol itself.
""""
https://github.com/ElementsProject/secp256k1-zkp  ← !!!
https://everis.passle.net/post/102fjgv/blockchain-momentum-makes-it-into-tier-1-bank-financial-results-announcement
_____________________
https://github.com/ethereum/EIPs/issues/648
_____________________
https://ewasm.readthedocs.io/en/mkdocs/
____________________
Ethereum WebAssembly is a proposed redesign of the Ethereum smart contract execution layer using a deterministic subset of WebAssembly.
The use of WebAssembly as a format for smart contracts gains a variety of benefits, a few of which are listed below:
- Near-native execution speed for smart contracts
- The possibility to develop smart contracts in many traditional programming languages, such as C, C++, and Rust
- Access to a vast developer community and the toolchain surrounding WebAssembly 
____________________
https://software.intel.com/en-us/blogs/2019/02/22/can-a-blockchain-controlled-robot-change-the-future
_________________________
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1538.md
- This standard provides a contract architecture that makes upgradeable contracts flexible, unlimited in size, and transparent.
- A transparent contract publicly documents the full history of all changes made to it.
- All changes to a transparent contract are reported in a standard format.
}}}
____________________________
Override max contract size limit:
https://ethereum-magicians.org/t/removing-or-increasing-the-contract-size-limit/3045

Note: Pantheon (maybe others) allows to tune max.contract size.
__________________________
<td> 
<pre xxxsmall zoom>
<span xsmall>Non Classified</span>
  <a TODO href='https://github.com/ethpm/ethpm-js'>https://github.com/ethpm/ethpm-js</a>
      Javascript library for publishing and consuming Ethereum packages,
      provides utilities for publishing and consuming Ethereum packages based
      on the Ethereum Package Manager specification. It is meant to be integrated
      directly into development tools to support their use of the Ethereum Package
      Management ecosystem.

  <a TODO href='https://yakindu.github.io/solidity-ide/'>Yakindu Solidity IDE (Eclipse based)</a>

  
  <a href="https://etherscan.io/pushTx">https://etherscan.io/pushTx</a>
      Send raw-transactions
  <a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">tmux:</a> General (BSD/Linux/UNIX) tool for multiplexing terminals and create long-running
      sessions that persists ssh disconnections.
      - It allows for example to have an terminal with vim editing solidity files,
        another one editing JS files, another one with the truffle debugger,  
        the geth console, ...
      - Sessions will persists until the PC/server is restarted. We can disconnect
        and reconnect to the same session repeatedly. The terminal layout will be
        saved. 
      - It also allow different users to share the session and terminals and is
        very efficient in terms of bandwidth (when compared to VNC or RDesktop),
        since there are not graphics involved.
</pre>
</td>
<td colsep></td>



-->
