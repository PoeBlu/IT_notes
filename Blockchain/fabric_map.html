<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Hyperledger Fabric Map<!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>

<a href="https://hyperledger-fabric.readthedocs.io/">Docs</a>/
<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/command_ref.html">cli</a>/
<a href="https://github.com/hyperledger/fabric/">GitHub</a>/
<a href="https://github.com/hyperledger/fabric/tree/release-1.2/protos">Protos</a>
<br/>
<h1 sylte="color:red;">WARN: DO NOT USE FABRIC AT ALL</h1>
<table>
<tr>
<td>

  <hr xxxsmall />
<a href="https://github.com/hyperledger/fabric/tree/master/devenv">Vagrant Dev.Env</a>
  <hr xxxsmall />
  External Links:
  <ul xxsmall zoom>
  <li><a href='https://github.com/hyperledger/fabric'>GitHub</a></li>
  <li><a href='https://godoc.org/github.com/hyperledger/fabric'>GoLang API DOC</a></li>
  <li><a href='https://stackoverflow.com/questions/tagged/hyperledger-fabric'>Stack OverFlow</a></li>
  <li><code>git clone <a href='https://github.com/hyperledger/fabric-samples.git'>Fabric Samples@Github</a></code><br/>
      (<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/'>First-network</a>) </li>
  <li><a href='https://hyperledger-fabric.readthedocs.io/en/latest/'>Fabric Doc Home</a>                      </li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html">Glossary</a>                </li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/releases.html">Release Notes</a>           </li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/questions.html">Still Have Questions?</a>  </li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/status.html">Status</a>                    </li>
  </ul>

  Bibliography
  <ul xxxsmall zoom>
  <li> <a href="https://www.safaribooksonline.com/library/view/hands-on-blockchain-with/9781788994521/">Hands-On Blockchain with Hyperledger</a>
  </li>
  </ul>

  <a href='https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html'>Prerequisites:</a>
  <ul xxxsmall zoom>
  <li><a href='https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites'>Docker CE for Centos</a></li>
  <li>Dependencies: cURL, git,<br/>
         docker 17.06.02-ce+ (2017-09-05)(docker engine 1.13.x NOT supported),
         <a href='https://go-repo.io/'>adding docker-ce repo to yum</a>
         <br/>
         docker-compose 1.14.0+ See <a href='https://docs.docker.com/compose/install/#install-compose'>here</a> to install latest version
  </li>
  <li>Go programming language 1.9.x <br/>
    Check $GOPATH="working directory" (example $HOME/go)
    <a href='https://go-repo.io/'>Install custom golang repo</a>
  </li>
  <li>Node.js 6.9.x Runtime (7.x not yet supported) and NPM (npm install npm@3.10.10 -g)</li>
  <li>Python 2.7 (sudo apt-get install python)</li>
  <li>Python 2.7 (sudo apt-get install python)</li>
  </ul>
  Development and contributing:
  <ul xxxsmall>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/CONTRIBUTING.html">Contributions Welcome!</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/MAINTAINERS.html">Maintainers</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/jira_navigation.html">Using Jira to understand current work items</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">Setting up the development environment</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html">Building Hyperledger Fabric</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#building-outside-of-vagrant">Building outside of Vagrant</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#configuration">Configuration</a></li>
  <li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#logging">Logging</a></li>
  <li><a href="Gerrit/lf-account.html">Requesting a Linux Foundation Account</a></li>
  <li><a href="Gerrit/gerrit.html">Working with Gerrit</a></li>
  <li><a href="Gerrit/changes.html">Submitting a Change to Gerrit</a></li>
  <li><a href="Gerrit/reviewing.html">Reviewing a Change</a></li>
  <li><a href="Gerrit/best-practices.html">Gerrit Recommended Practices</a></li>
  <li><a href="testing.html">Testing</a></li>
  <li><a href="Style-guides/go-style.html">Coding guidelines</a></li>
  <li><a href="Style-guides/go-style.html#generating-grpc-code">Generating gRPC code</a></li>
  <li><a href="Style-guides/go-style.html#adding-or-updating-go-packages">Adding or updating Go packages</a></li>
  </ul>

  Prebuilt docker images:
<pre xxxsmall zoom>
Base:                          TCP
                               PORTS
  hyperledger/fabric-peer      7050(orderer) ← (linux ps) $ <a href="https://github.com/hyperledger/fabric/blob/release-1.1/core/peer/peer.go">peer node start</a>
  hyperledger/fabric-orderer   7051(peer)    ← (linux ps) $ <a href="https://github.com/hyperledger/fabric/blob/release-1.1/...">orderer</a>
                               7053(peer_event)
                               6060(???)
  hyperledger/fabric-ccenv           Fabric chaincode container/environment
  hyperledger/fabric-ca        7054(ca) Default Fabric CA (linux ps) $ fabric-ca-server start --ca.certfile /etc/... --ca.keyfile /etc/... -b admin:adminpw -d
  hyperledger/fabric-javaenv         Fabric Java chaincode environment
  hyperledger/fabric-tools           "command line shell"
                                     It must mount volumes in a way similar to:
                                     /var/run/          :/host/var/run/
                                     ./../chaincode/    :/opt/gopath/src/github.com/chaincode
    X.509 generated by 'cryptogen' → ./crypto-config    :/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
                                     ./scripts          :/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
   Orderer genesis.block (config), → ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
        channel tx, anchorPeer txs
        generated by 'configtxgen'

Extra:
  hyperledger/fabric-membersrvc ???? Fabric Member Service docker image
  hyperledger/fabric-couchdb    5984(couchdb) Fabric Couchdb docker image
  hyperledger/fabric-kafka           Fabric Kafka docker image 
  hyperledger/fabric-zookeeper       Fabric Zookeeper docker image

Dev:
  hyperledger/fabric-baseimage       base image for https://gerrit.hyperledger.or…
  hyperledger/fabric-baseos          Fabric base OS
</pre>

ENV.VARS:
<pre xxxsmall zoom>
CORE_PEER_GOSSIP_USELEADERELECTION=true
CORE_PEER_GOSSIP_ORGLEADER=false
CORE_PEER_PROFILE_ENABLED=true
CORE_PEER_ID=peer0.exporterorg.trade.com
CORE_PEER_ADDRESS=peer0.exporterorg.trade.com:7051
CORE_PEER_GOSSIP_BOOTSTRAP=peer0.exporterorg.trade.com:7051
CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.exporterorg.trade.com:7051
CORE_PEER_LOCALMSPID=ExporterOrgMSP


ORDERER_GENERAL_LOGLEVEL=INFO
ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
ORDERER_GENERAL_GENESISMETHOD=file
ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
ORDERER_GENERAL_LOCALMSPID=TradeOrdererMSP
ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp

FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
FABRIC_CA_SERVER_CA_NAME=ca-exporterorg


# TLS RELATED
       CORE_PEER_TLS_ENABLED=true
 ORDERER_GENERAL_TLS_ENABLED=true
FABRIC_CA_SERVER_TLS_ENABLED=true

        CORE_PEER_TLS_KEY_FILE=/etc/.../server.key
  FABRIC_CA_SERVER_TLS_KEYFILE=/etc/.../355f8e6...cb_sk
ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key

CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt
ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]

  FABRIC_CA_SERVER_TLS_CERTFILE=/etc/...
ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
        CORE_PEER_TLS_CERT_FILE=/etc/.../server.crt
</pre>

MINIMUM DEPLOYMENT (DEV.MODE, Extracted from <a href="https://github.com/hyperledger/fabric-samples/tree/release-1.1/chaincode-docker-devmode">chaincode-docker-devmode/docker-compose-simple.yaml</a>)
<pre xxxsmall>
 +-------------------------------------------------+
 |ORDERER: PORTS: 7050:7050                        |
 +-------------------------------------------------+-------------------------------------------------+
 |image: hyperledger/fabric-orderer                |PEER: PORTS: 7051 7053 6060                      |
 |ORDERER_GENERAL_LOGLEVEL=debug                   |-------------------------------------------------+-------------------------------------------------+
 |ORDERER_GENERAL_LISTENADDRESS=orderer            |image: hyperledger/fabric-peer                   |CHAINCODE:                                       |
 |ORDERER_GENERAL_GENESISMETHOD=file               |CORE_PEER_ID=peer                                |-------------------------------------------------+
 |ORDERER_GENERAL_GENESISFILE=orderer.block        |CORE_PEER_ADDRESS=peer:7051                      |image: hyperledger/fabric-ccenv                  |
 |ORDERER_GENERAL_LOCALMSPID=DEFAULT               |CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer:7051      |GOPATH=/opt/gopath                               |
 |ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp |CORE_PEER_LOCALMSPID=DEFAULT                     |CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock|
 |command: orderer                                 |CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock|CORE_LOGGING_LEVEL=DEBUG                         |
 |                                                 |CORE_LOGGING_LEVEL=DEBUG                         |CORE_PEER_ID=example02                           |
 |                                                 |CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp     |CORE_PEER_ADDRESS=peer:7051                      |
 |                                                 |command: peer node start \                       |CORE_PEER_LOCALMSPID=DEFAULT                     |
 +-------------------------------------------------+    --peer-chaincodedev=true -o orderer:7050     |CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp     |
                                                   |depends-on: orderer                              |command: /bin/bash -c 'sleep 6000000'            |
                                                   +-------------------------------------------------+                                                 |
                                                                                                     |depends-on: orderer, peer                        |
                                                                                                     +-------------------------------------------------+

                                                   +-------------------------------------------------+
                                                   |CLI:                                             |
                                                   +-------------------------------------------------+
                                                   |image: hyperledger/fabric-tools                  |
                                                   |GOPATH=/opt/gopath                               |
                                                   |CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock|
                                                   |CORE_LOGGING_LEVEL=DEBUG                         |
                                                   |CORE_PEER_ID=cli                                 |
                                                   |CORE_PEER_ADDRESS=peer:7051                      |
                                                   |CORE_PEER_LOCALMSPID=DEFAULT                     |
                                                   |CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp     |
                                                   |command: /bin/bash -c './script.sh'              |
                                                   |depends-on: orderer, peer                        |
                                                   +-------------------------------------------------+
</pre>
</td>
<td>
  Consortium Network Schema:
<pre bgorange xxxsmall>
CONSORTIUM NETWORK IS DEFINED THROUGH CHANNELs:  Network 1 ←────→ (1...n) MSP

    Peer N ←────→ M  Channel    1 ←────→ 1 Ledger       1 ←────→ 1 blockchain      
    ──────           ─────────             ──────                   ──────────     
    Roll *1          Ledger                Immutable blockchain     genesis block*4
    ledger copy*2    Members(Orgs)         current DDDBB state *3                  
                     members                                                       
                        .anchor_peers                                              
                     chaincode apps   1 ←────→ N  Chaincode *6                     
                     Ordering Nodes               ─────────
                     MSP (ACLs) *5                - asset definitions
                     Block policies               - code ("enforcing rules")
                                                    to modify asset
                                                  - id := peer - name - version 
                                                    (Ex: 'peer0.org.example.com-fabcar-1.0')
 
*1 Roll: Commiter(Proposer) or Endorser (signer)
*2 The peer keeps a ledger copy for each channel it belongs to.

*3 - Current DDBB state is sometimes referred to as World State
   - Current DDBB state can be implemented by:  
     - LevelDB: default key/value state database embedded in the peer process
     - CouchDB: optional alternative JSON document store external state database
                with enriched query capability 
   - The key/value represent the Assets
     <a class="reference external" href="https://github.com/hyperledger/composer">Hyperledger Composer</a> can easily define assets</li>

*4 Genesis block defines policies, ACLs, initial members and anchor peers

*5 Membership service Providers (MSP):
   - Authenticate each peer to other channel's nodes
   - crypto-materials can be derived from different CAs

*6 Chaincode is installed only on peers that need read/write access to the assets
   Chaincode is invoqued by endorsers and executed in isolated Docker container

NODES ("logical" communication entities)

 Physical 1 ←────→ N  Node 
 Server              ────
                      - type: Client *1, Commiter Peer *2, Endorser Peer *3,  Ordering Service *4

*1 Client: "FrontEnd" NodeJS, Java,... triggering new TX proposal in the Commiter peer
*2 Commiter Peer: commits TXs proposals and maintains a copy of the ledger
*3 Endorser Peer: (or endorser vs a particular chaincode). Signs TXs
*4 Orderer  runs the communication service that implements an atomic or total order broadcast
</pre>

  <b>APPLICATION DEVELOPMENT &AMP; TRANSACTION PIPELINE</b>
<pre bgorange xxxsmall zoom>
PRE-SETUP:
     ┎─                                  ┒
     ┃0. Create cryptographic matherial  ┃
     ┖  with cryptogen+crypto-config.yml ┚
_______________________________________________________________________________

 ┎─                ┒        ┎                 ┒        ┎                         ┒
 ┃1. Instantiate   ┃─────→  ┃2. Join peers to ┃ ─────→ ┃3. Install smart contract┃
 ┖  the blockchain ┚        ┖  the blockchain ┚        ┖   on the peers          ┚
        ↑                    ↑                           │ 
        ┆                    ┆                           │
        ┆                    ↓                           │
        ┆                 ╭──────╮                       │
        └╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌→│LEDGER│                       │
                          │ DDBB │←╌╌╌╌╌╌╌╌╌╌┐           │
    ┌─────┐       ┌╌╌╌╌╌╌→└──────┘           ┆           │
    │     ↓       ┆                          ┆           │
    │    ┎        ┆                 ┒      ┎             ↓              ┒
    └─── ┃5. Write to, or read from,┃ ←──  ┃4. Initialize smart contract┃
         ┖   the smart contract     ┚      ┖   Ledger state             ┚
                  │
                  ↓
            Communitcate result to
            (ser/application

1. Instantiation in Fabric means the creation of a channel and bootstrapping of the ordering service
   In Fabric we use the configtxgen+config.yml (or config.json) to describe the (channel) network.
   (genesis.block and orderer+members config.tx)config.tx)

2. Joining the blockchain (channel in Fabric) allows each peer to maintain a copy of the ledger
   initialized to a blank key-value store. 
   Every peer that's joined to the channel will possess ledger commitment privileges and may
   participate in a gossip protocol in order to sync ledger state with each other.
   Endorsement policies are defined here indicating the list of principals and stating the 
   policy attributes

3. A subset of the peers joined to the channel will be selected to run the smart contract;
   , that is, such peers will possess endorsement privileges. The contract code will
   be deployed to these peers and built for subsequent operation. 

4. Once step 4 finish the application is "up and running".
</pre>

  "Standard" three-layer architecture
<pre xxxsmall zoom>
                      ╭─────────╮ 
1.APPLICATION         │User     │ 
                      │Interface│
                      ╰─────────╯
                          ┃
                          ┃ Middleware API
2.MIDDLEWARE              ┃
╭───────────────────────────────────────────────────────────────────────────────────────╮ 
│Channel       Registration&amp;   Chaincode    Transaction    Chaincode    Event       │
│Operations    enrollement         Setup        Submission     Queries      Subscription│
╰───────────────────────────────────────────────────────────────────────────────────────╯
                     ┃               ↑
     Chain invocation┃               ┃ Transaction
     and Queries     ┃               ┃ Result Events
                     ↓               ┃
                   ╭─────────────────────╮
3.SMART-CONTRACT   │LEDGER     CHAINCODE │
                   ╰─────────────────────╯

Fabric provides a (Node.js and Java) SDK for the Middleware operations as well ase the "peer" CLI,
generated upon building ($ make peer) the Fabric source code.
</pre>

  Example integration
<pre xxxsmall zoom>
channel.sendTransactionProposal();   protocol-specific transaction
          ┊                                    ┊
╭────╮←────────── ╭───────╮ ←───────────────────────────────╭────────────────╮
│Peer│←────────── │Adaptor│                                 │Entrepise system│
╰────╯    ┊       ╰───────╯ ─────┐business            ┌────→│/Integration bus│
  │ eventHub.registerTXEvent();  │event               │     ╰────────────────╯
  │                               │     ╭─────────╮   │
  ├─ Ledger                       └───→ │Messaging│───┘
  │                                     │System   │
  └─ World state                        ╰─────────╯
</pre>

  <a  href='https://hyperledger-fabric.readthedocs.io/en/latest/msp.html'>Membership Service Providers (MSP)</a>
<pre xxxsmall zoom>
- Membership Service Provider (MSP) aims to offer an abstraction of a membership operation architecture
- In particular, MSP abstracts away all cryptographic mechanisms and protocols behind issuing and
  validating certificates, and user authentication. An MSP may define their own notion of identity.

- network can be governed by one or more MSPs. 

MSP INSTANCE CONFIGURATION:

- configuration needs to be specified locally at each peer and orderer and channel
  to enable identity and signature verification of [peers, orderers, clients] 
  amongst each other.
- for each MSP instance a MSP ID ("name") needs to be specified in order to reference that MSP instance
  in the network (e.g. msp1, org2, and org3.divA).
  This is the name under which membership rules of an MSP representing a consortium, org, ...
  is to be referenced in a channel.
  MSP IDs are required to be unique per MSP instance.  For example, shall two MSP instances
  with the same identifier be detected at the system channel genesis, orderer setup will fail.

- In the case of default implementation of MSP, a set of parameters need to be specified to
  allow for identity (certificate) validation and signature verification  (deduced by RFC5280):
   - list of self-signed (X.509) certificates to constitute the root of trust
   - (optional) list of X.509 certificates to represent intermediate CAs this provider considers for certificate validation;
   - list of MSP administrators (X.509) certificates
     owners of these certificates are authorized to request changes to this MSP configuration (e.g. root CAs, intermediate CAs)
   - (optional) list of Organizational Units that valid members of this MSP should include in their X.509 certificate; 
     used when, e.g., multiple organizations leverage the same root of trust, and intermediate CAs, 
     and have reserved an OU field for their members
   - (optional) list of certificate revocation lists (CRLs) each corresponding to exactly one of the liste
     (intermediate or root) MSP Certificate Authorities;

In addition to verification related parameters, for the MSP to enable the node on which it is instantiated
to sign or authenticate, one needs to specify:
  - The signing key used for signing by the node (currently only ECDSA keys are supported)
  - The node's X.509 certificate, that is a valid identity under the verification parameters of this MSP.

WARN: MSP identities never expire; they can only be revoked by adding them to the appropriate CRLs.
      Additionally, there is currently no support for enforcing revocation of TLS certificates.

WARN: there is NO support for certificates including RSA keys.

MSP setup on the peer&amp;orderer side:

STEP 01: node administrator should create a folder "$MY_PATH/mspconfig" with next layout (peers and orderers):

  mspconfig
    admincerts/           #            PEM files for administrator certificate
    cacerts/              #            PEM files for root CA's certificate
    intermediatecerts/    # (optional) PEM files for intermediate CA's certificate
    crls/                 # (optional) CRLs
    keystore/             #            PEM file with the node's signing key; (RSA keys are not supported)
    signcerts/            #            PEM file with the node's X.509 certificate
    tlscacerts/           # (optional) PEM files for TLS root CA's certificate
    tlsintermediatecerts/ # (optional) PEM files for intermediate TLS CA's certificate
    config.yaml           # (optional) file to config. supported "Organizational Units"&amp;"identity classifications"
                          # Example:
                          # (An MSP identity will be valid if it carries at least one of these organizational unit identifiers)
                          # |OrganizationalUnitIdentifiers:
                          # |  - Certificate: "cacerts/cacert1.pem"             # path relative to MSP root folder
                          # |    OrganizationalUnitIdentifier: "commercial"
                          # |  - Certificate: "cacerts/cacert2.pem"
                          # |    OrganizationalUnitIdentifier: "administrators"
                          # | NodeOUs:
                          # |   Enable: true   #  enables the identify classification in default MSP implementation *1
                          # |   ClientOUIdentifier:
                          # |     Certificate: "cacerts/cacert.pem"
                          # |     OrganizationalUnitIdentifier: "clientOU" # ← must match the OU of client x509 cert
                          # |   PeerOUIdentifier:
                          # |     Certificate: "cacerts/cacert.pem"
                          # |     OrganizationalUnitIdentifier: "peerOU"   # ← must match the OU of peer   x509 cert
                          # 
                          # *1 - clients: submits transactions, queries peers, etc.
                          #    - peers  : endorses or commits transactions. 
                          #    client and peer is mutually exclusive
                          # 
                          #    - When classification is enabled, administrators (admincerts/*PEM)
                          #      need to be clients of that MSP, (their x509 certificates need
                          #      to carry the OU that identifies the clients)

STEP 02: Specify the mspconfig path relative to FABRIC_CFG_PATH and the MSP ID of the node's MSP as follow:
                         peer                       orderer
                         ------------------------------------
file to edit             core.yaml                  orderer.yaml
parameter for path       mspConfigPath              LocalMSPDir 
parameter for MSP-ID     localMspId                 LocalMSPID 
ENV.VARS(override def)   CORE_*                     ORDERER_*

STEP 03: (Orderer only)
Generate and provide to the orderer the genesis block of the system channel.

  - verification parameters of all the MSPs that appear in the network need
    to be specified, and included in the system channel's genesis block.
    (MSP ID, certs, admin certs,...)
  - genesis block allows orderers to authenticate channel creation requests.
  
  - For application channels, the verification components of only the MSPs that 
    govern a channel need to reside in the channel's genesis block.
  
  WARN: it is the responsibility of the application to ensure that correct MSP 
        configuration information is included in the genesis blocks (or the most 
        recent configuration block) of a channel prior to instructing one or more of 
        their peers to join the channel.
  WARN: When bootstrapping a channel with the help of the configtxgen tool, one can 
        configure the channel MSPs by including the verification parameters of MSP in 
        the mspconfig folder, and setting that path in the relevant section in 
        configtx.yaml.

WARN: Reconfiguration of a "local" MSP is only possible manually, and requires that 
      the peer or orderer process is restarted.
      (online/dynamic reconfiguration planed for future releases)

  See also: <a href="https://hyperledger-fabric.readthedocs.io/en/latest/msp.html#best-practices">BEST-PRACTICES</a>
</pre>
  <hr/>
  <a TODO href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/">Fabric CA</a>
  <span xsmall>(alternative to Openssl/cryptogen/... to generate MSP crypto material)
<!--
  <a TODO href="https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html">ca cli</a>
-->
  </spam>
  <hr/>
</td>
<td colsep></td>
<td>
  <hr xxxsmall />
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/configtx.html">Channel Configuration TX ("configtx")</a><br/>
<pre xxxsmall zoom>
- Per-channel Shared configuration is the result of configuration transactions
  (alias <b>"configtx"</b>, with configtx.type =  HeaderType_CONFIG || HeaderType_CONFIG_UPDATE) 
- A "configuration block" contains a single configtx
- <b>"Genesis Block" : alias for first "configuration block"</b>
- configtx is:
  - versioned
  - permissioned: 
    each config. has associated policy (→ configtx signatures must match)
  - hierarchical (tree of configuration groups)

<a href="https://github.com/hyperledger/fabric/blob/master/protos/common/configtx.proto">configtx.proto@GitHub</a>

Ex: given the configuration:
  Channel: (version 0)          
    Orderer (version 0)       
    Application (version 3) 
       <b orange>Org1</b> (version 2)     

  configuration update modifying <b orange>Org1</b>
| read_set                  write_set  
| Channel: (version 0)         | Channel: (version 0)
|     Application: (version 3) |     Application: (version 3)
|                              |         <b orange>Org1</b> (version 3)
|                              |



- When the orderer receives a CONFIG_UPDATE for a channel which does not exist,
    the orderer assumes that this must be a channel creation request and performs the following

??? → orderer: CONFIG_UPDATE request  (if channel doesn't exists "update" → "create")
orderer → orderer: extract Consortium value from top level group.
orderer → orderer: Verify:
                   - organizations in /Application is subset of Consortium orgs.
                   - ApplicationGroup.version == 1
                   - if (consortium has members) 
                       verify new channel also has application members 
orderer → orderer: create template-config as:
                   Orderer group =  Orderer group from ordering system channel
                   Application group =  newly specified members
                   Application group.mod_policy = ChannelCreationPolicy specified in consortium config
orderer → orderer: new CONFIG TX = apply CONFIG_UPDATE as update new template-config
                   CONFIG_UPDATE applies modifications to the Application group (v.1) 
                   validating updates against the ChannelCreationPolicy. 
                   mod policy for any other modifications (org's anchor peers,...) 
                   will be invoked.
orderer → ordering: new CONFIG TX
          system
          channel

Note: policy is evaluated in the context of the new configuration, so
   a policy requiring ALL members, would require signatures from all
   the new channel members, not all the members of the consortium.
</pre>

  Channel Creation Flow
<pre xxxsmall zoom>
[STEP 0: Channel Creation]
client SDK → config_system_chaincode: anchor peers, members(orgs)
config_system_chaincode → + genesis_block
...
[STEP 1: Adding New Member]
??? → new_member: share genesis_block or if applicable, a more recent reconfiguration block
</pre>
  <hr />
  <a TODO xsmall href="https://hyperledger-fabric.readthedocs.io/en/latest/channel_update_tutorial.html">
    Adding an Org to a Channel</a>
</td>
<td colsep></td>
<td>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">Ledger Features</a>
  <ul xxxsmall zoom> 
  <li>Query and update ledger using key-based lookups, range queries, and composite key queries</li>
  <li>Read-only queries using a rich query language (if using CouchDB as state database)</li>
  <li>Read-only history queries - Query ledger history for a key, enabling data provenance scenarios</li>
  <li>TRANSACTIONS CONSIST OF THE VERSIONS OF KEYS/VALUES THAT WERE READ IN CHAINCODE 
      (READ SET) AND KEYS/VALUES THAT WERE WRITTEN IN CHAINCODE (WRITE SET).<br/>
      Note: Golang chaincode use next functions for read-sets and and write-sets:
<pre xxxsmall>
+-------------------------------------+---------------------------------------------------------------
|GetState(key string) ([]byte, error) | Returns the value of the `key` from the Worldstate. 
|                                     | If the key does not exist in the Worldstate the function 
|                                     | returns (nil, nil). 
|                                     | The function does not read data from the WriteSet and
|                                     | hence uncommitted values modified by PutState are not returned. 
+-------------------------------------+---------------------------------------------------------------
|PutState(key string, value []byte)   | Records the specified `key` and `value` into the WriteSet. 
|                                     | The function does not affect the ledger until the transaction 
|                                     | is committed into the ledger. 
+-------------------------------------+---------------------------------------------------------------
|DelState(key string) error           | Marks the the specified `key` as deleted in the WriteSet. 
|                                     | The key will be marked as deleted and removed from Worldstate  
|                                     | once the transaction is committed into the ledger. 
+-------------------------------------+---------------------------------------------------------------
</pre>
  </li>
  <li>Transactions contain signatures of every endorsing peer and are submitted to ordering service</li>
  </ul>
  Deploy vs Invoke TX
  <ul xxxsmall zoom>
  <li>Deploy transactions create new chaincode and take a program as parameter.
      When a deploy transaction executes successfully, the chaincode has been 
      installed 'on' the blockchain. Deployment specifies the endorsement policy
      for the chaincode.</li>
  <li>Invoke transactions perform an operation in the context of previously
      deployed chaincode. An invoke transaction refers to a chaincode and to
      one of its provided functions. When successful, the chaincode executes
      the specified function - which may involve modifying the corresponding
      state, and returning an output.</li>
  </ul>
  <hr />
  <a href='https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html'>TX FLOW (Consensus)</a>
<pre bgorange xxxsmall zoom >
Participant (peer) A : Buyes radishes
Participant (peer) B : Sells radishes
[configuration setup]
Admin → +Channel: set up and run
Admin →  Channel: register and endorse A,B with CA
                   (A and B must endorse any TX)

Admin → +Chaincode : - Initial key/value State 
                      - Logic for TX

Admin → A, B : Install chaincode

[STEP 1 Prepare TX proposal]
client   → client    : ┌─────────────────────┐
                       │new TX-proposal      │
                       ├─────────────────────┤
                       │TX.chaincode.function│
                       │TX.funct_input       │
                       └─────────────────────┘

[STEP 2 Prepare TX proposal]
client    → client    : Package TX-proposal         
client    → client    : Sign(Packaged-TX-proposal, user's credentials)
client    → Channel   : Signed-packaged-TX-proposal ("purchase" request)
Channel   → endorser  :  Signed-packaged-TX-proposal
            (^endorser list actually)
endorser  → endorser  :  Verify:
                      - TX proposal is well formed
                      - it has not been submitted already
                        in the past (replay-attack protection)
                      - signature is valid (using MSP)
                      - submitter is properly authorized 
                        (ensures that submitter satisfies the 
                         channel's Writers policy)
endorser  →  Chaincode: TX.chaincode.funct(TX.input)
Chaincode →  Chaincode: execute funct against current database-state  
Chaincode →  endorser : TX.result = [ response value, read set, write set ]

[STEP 3 Wait for endorsement]
client    →  client   : - wait until "enough" messages and signatures on 
                          (TRANSACTION-ENDORSED, tid, *, *) statements to
                          conclude that the TX proposal is endorsed. (may 
                          involve one+ round-trips with endorsers).
                        - If the submitting client does not manage to 
                          collect an endorsement for a transaction  
                          proposal, it abandons this transaction with an
                          option to retry later.
                        - For transaction with a valid endorsement, we 
                          now start using the ordering service.

[STEP 4 Send endorsed TX to Orderer for inclusion in Blockchain]
App →Channel→ orderer :(Just for write 2 ledger)
                       TX.proposal + TX.result + endorsing sign.
orderer   →   orderer : Order chronologically
                   create blocks of TX
                   Serializability is a default isolation guarantee

orderer   →   peers   : TX block
peers     →   peers   : validate block
peers     →   peers   : Update ledger
peers     →   Client  : event "TX appended to chain"
</pre >
  <br/>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html">Read-Write set semantics</a>
<pre bgorange xxxsmall zoom { >
TX simulation:  read set + write set are prepared
read  set [("key", "value in" , "version"   )] → TX → [("key", "value out", "version++" )] 
 * "value out" or isDelete=true

Example:
consider a set of five ordered transactions 
   (T1 → T2 → T3 → T4 → T5)
simulated on the same snapshot of the world state:
    
Initial state: 
   [/* key value  version */
     ( k1 ,  1  ,   v1   ),
     ( k2 ,  2  ,   v2   ),
     ( k3 ,  3  ,   v3   ),
     ( k4 ,  4  ,   v4   ),
     ( k5 ,  5  ,   v5   )]
_________________________________________
T1 → Write k1 → (k1,2,v1')
     Write k2 → (k2,2,v2')
   Result:
     validation OK (no reads)
_________________________________________
T2 → Read(k1,1,v1)
      Write k3 → (k3,3,v3')
   Result:
     validation ERROR  (reads k1 v1 &lt; current version v1')
_________________________________________
T3 → Write  k2 → (k2, v2'')
   Result:
     validation OK (no reads)
     k2 updated to (k2,3,v2'')
_________________________________________
T4 → Write(k2, v2'''), read(k2)
   Result:
     validation ERROR  (reads k2 v1 &lt; current v2'')
_________________________________________
T5 → Write k6 → (k6, v6')
      read(k5)
   Result:
     validation OK (k5,v1 still in version v1 )
_________________________________________

Note: Transactions with multiple read-write sets are not yet supported.
</pre } >
</td>
<td colsep></td>
<td>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">Endorsement policies</a>
  <ul xxxsmall zoom>
  <li>used to instruct a peer on how to decide whether a TX is properly endorsed.</li>
  <li>
<pre>
participant "Validation System Chaincode" as VSCC
note: TX: transaction with one or more endorsement 
          from as many endorsing peers. 
client → peer: TX with endorsing signatures
[TX validation flow start]
peer   → peer.VSCC: determine validity of TX by:
                    1) TX.endorsements signatures are valid
                    <b>2)</b> number of endorsements is appropiate
                    <b>3)</b> endorsements come from the expected source(s)
                    2) and 3) are specified by <b>endorsement policies</b>
</pre>
  </li>
  <li>Endorsement policy syntax in the CLI
<pre>

<b>principal</b>: MSP_ID.ROLE                                      | Endorsement Policy syntax:
           MSP_ID indicates the MSP validating:             |     EXPR(E[, E...])
             - the identity of the signer                   |     EXPR := 'AND' | 'OR'
             - the role that the signer has within that MSP |     E : =  <b>principal</b> |  or EXPR
           ROL is one of member | admin | client | peer

Examples:
  ┌───────────────────────────────────────────────────────┬─────────────────────────────────────────┐
  │            EXPRESION                                  │ ENDORSEMENT POLICY REQUEST FOR TXs      │
  ├───────────────────────────────────────────────────────┼─────────────────────────────────────────┤
  │ AND('Org1.member', 'Org2.member', 'Org3.member'     ) │ 1 sig. from all principals              │
  ├───────────────────────────────────────────────────────┼─────────────────────────────────────────┤
  │ OR ('Org1.member', 'Org2.member'                    ) │ 1 sig. from either of the principals    │
  ├───────────────────────────────────────────────────────┼─────────────────────────────────────────┤
  │ OR ('Org1.member', AND('Org2.member', 'Org3.member')) │    1 sig. from a Org1.member            │
  │                                                       │ or 1 sig. from Org2.member + Org3.member│
  └───────────────────────────────────────────────────────┴─────────────────────────────────────────┘

</pre>
  </li>
  <li>Validation policy for chaincode TX endorsements can be specified at chaincode deployment
    time (<code>peer chaincode instantiate</code>) using the -P switch.<br/>
     If not specified, the default policy is "any member of any organization in the channel". Ex:
<pre>
($ docker exec -it cli bash)
$ peer chaincode instantiate -C <channelid> -n mycc <b>-P "AND('Org1.member', 'Org2.member')"</b>
</pre>

Note
A new organization added to the channel after instantiation can query a chaincode (provided the
query has appropriate authorization as defined by channel policies and any application level 
checks enforced by the chaincode) but will not be able to commit a transaction endorsed by it.

 The endorsement policy needs to be modified to allow transactions to be committed with
endorsements from the new organization (see Upgrade and Invoke Chaincode).
  </li>
  </ul>
 
<pre xxxsmall zoom>
  <a href="https://github.com/hyperledger/fabric/blob/master/protos/common/policies.proto">policies.proto@GitHub</a>
─────────────────────────────────────────────────────────────────────────────────────────────────────
message Policy {                               │ message SignaturePolicyEnvelope {
    // policy to be evaluated by orderer       │     int32 version = 1; // protect SigPol. 
    enum PolicyType {                          │                        // from changes
        UNKNOWN = 0; // *1                     │     SignaturePolicy rule = 2;
        SIGNATURE = 1;                         │      repeated MSPPrincipal identities = 3;
        MSP = 2;                               │ }
        IMPLICIT_META = 3;                     │
    }                                          │
    int32 type = 1; // ← 1-1000 reserved       │
    bytes value = 2;     or PolicyType         │
}                                              │
───────────────────────────────────────────────┼──────────────────────────────────────────────────────
message SignaturePolicy {                      │ message ImplicitMetaPolicy {
    message NOutOf {                           │     enum Rule {
        int32 n = 1;                           │         ANY = 0;      // true if no-subpolicies or any is true
        // Note recursion (tree like)!         │         ALL = 1;      // true if all sub-policies true
        repeated SignaturePolicy rules = 2;    │         MAJORITY = 2; // true if strict majority of sub-policies true
    }                                          │     }
    oneof Type {                               │     string sub_policy = 1;
        int32 signed_by = 1; // signature from │     Rule rule = 2;
        NOutOf n_out_of = 2;    (self or CA)   │ }
    }                                          │ // depends on the hierarchical nature (immediate childs) of configuration
}                                              │ // eval.algo: SELECT policy FROM "immediate-child-groups"
                                               │ //                WHERE immediate-child-group.policy_name=sub_policy
</pre>
  </ul>
  <a href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>Example endorsement policies</a>
  <ul xxxsmall zoom>
  <li>
    The predicate may contain logical expressions and evaluates to TRUE or FALSE.
    Typically the condition will use digital signatures on the transaction invocation issued by endorsing peers for the chaincode.</li>
  <li>Suppose the chaincode specifies the endorser set 
<pre>
E = {Alice,Bob,
     Charlie,Dave,
     Eve,Frank,George}
</pre>.
     Some example policies:</p>
    <ul>
    <li>A valid signature from on the same tran-proposal from all members of E.</li>
    <li>A valid signature from any single member of E.</li>
    <li>Valid signatures on the same tran-proposal from endorsing peers according to the condition:
<pre>
(Alice OR Bob) AND 
(any two of:
   Charlie, Dave,
   Eve, Frank, George)
</pre>
    </li>
    <li>Valid signatures on the same tran-proposal by any 5 out of the 7
        endorsers. (More generally, for chaincode with n &gt; 3f endorsers,
        valid signatures by any 2f+1 out of the n endorsers, or by
        any group of more than (n+f)/2 endorsers</li>
    <li>Suppose there is an assignment of “stake” or “weights” to the endorsers, like
        {Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}
        where the total stake is 100: The policy requires valid signatures
        from a set that has a majority of the stake (i.e., a group with
        combined stake strictly more than 50), such as {Alice, X} with
        any X different from George, or {everyone together except Alice}, and so on.</li>
    <li>The assignment of stake in the previous example condition could be
        static (fixed in the metadata of the chaincode) or dynamic (e.g.,
        dependent on the state of the chaincode and be modified during the
        execution).</li>
    <li>Valid signatures from (Alice OR Bob) on tran-proposal1 and valid
        signatures from (any two of: Charlie, Dave, Eve, Frank, George) on
        tran-proposal2, where tran-proposal1 and tran-proposal2 differ only
        in their endorsing peers and state updates.</li>
    </ul>
  </li>
  </ul>

  <hr/>

  <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-overview.html">SERVICE DISCOVERY</a>
<pre xxxsmall zoom>
- Service discovery runs on peers. External apps will choose a well-known group of trusted peers 
  (probably a peer owned by the organization).

 - Provides (dynamically changing) information to (external) application:
   - CAs
   - orderers and peers TLS certs on the channel
   - IP addresses and port numbers
   - relevant endorsement policies 
   - which peers have the chaincode installed (so the application knows which peers to send chaincode proposals to)
   - which peers are already synchronized (their ledgers upated) avoiding submiting to "delayed" peers
     (tx will be invalidated upon commit wasting resources)
   - which peers are needed for endorsement given a channel and a chaincode ID:
     - Discovery service will compute a descriptor comprised of two objects:

                   | DESCRIPTION                              | EXAMPLE
      -------------+------------------------------------------+------------------------------------
       Layout      | peer group list                          | Layouts : [                       ←"endorsement policy requires 
                   | and corresponding amount                 |   QuantitiesByGroup:                a signature from one peer 
                   | of peers from each group                 |    { "Org1": 1, "Org2": 1, }        in Org1 <b>AND</b> one peer in Org2"
                   | which should be selected                 | ]                                   (list instead of map for <b>OR</b>?)
      -------------+------------------------------------------+------------------------------------
       Group2peer  | map group in the layout                  | EndorsersByGroups : {              ←names of available peers in
                   | to the peers of the channel              |   “Org1”: [peer0.org1, peer1.org1], those orgs who can endorse 
                   | In practice, each group would            |   “Org2”: [peer0.org2, peer1.org2]
                   | most likely be peers that represent      | }                                   
                   | individual organizations, but because    |                                     
                   | the service API is generic and ignorant  |
                   | of organizations this is just a "group". |
      -------------+------------------------------------------+------------------------------------
      
       - Fabric SDK will selects a random (for "OR") layout from the list
       - then a set of peers based on the criteria specified on the client side 
         (prefer peers with higher ledger heights, exclude offline peers, ...), or
         a random peer if there is no "favourite".


DISCOVERY SERVICE CAN PROVIDE ANSWER FOR:
  - CONFIGURATION QUERY: Returns the MSPConfig of all organizations in the channel
      along with the orderer endpoints of the channel.
  - PEER MEMBERSHIP QUERY: Returns the peers that have joined the channel.
  - ENDORSEMENT QUERY: Returns an endorsement descriptor for given chaincode(s) in a channel.
  - LOCAL PEER MEMBERSHIP QUERY: Returns the local membership information of the peer
    that responds to the query. By default the client needs to be an administrator for the 
    peer to respond to this query.
</pre>
<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-cli.html">discovery cli</a>
<pre xxxsmall zoom>
PRE-SETUP: persist TLS/Key/Cert/MSP config:

$ discover --configFile <b blue>conf.yaml</b> \
    --peerTLSCA tls/ca.crt \
    --userKey msp/keystore/ea4f6a38ac7057b6fa9502c2f5f39f182e320f71f667749100fe7dd94c23ce43_sk \
    --userCert msp/signcerts/User1\@org1.example.com-cert.pem \
    --MSP Org1MSP saveConfig

<b blue>conf.yaml</b> will be created for reuse in next commands:

$ cat <b blue>conf.yaml</b>
version: 0
tlsconfig:
  certpath: ""
  keypath: ""
  peercacertpath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/User1@org1.example.com/tls/ca.crt
  timeout: 0s
signerconfig:
  mspid: Org1MSP
  identitypath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem
  keypath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/ea4f6a38ac7057b6fa9502c2f5f39f182e320f71f667749100fe7dd94c23ce43_sk

_______________________________________________________________________________
$ discover --configFile <b blue>conf.yaml</b> <b>peers</b> --channel mychannel  --server peer0.org1.example.com:7051
[
 { "MSPID": "Org2MSP", "LedgerHeight": 5, "Endpoint": "peer0.org2.com:7051", "Identity": "-----BEGIN CERT...", "Chaincodes": [ "mycc" ] },
 { "MSPID": "Org2MSP", "LedgerHeight": 5, "Endpoint": "peer1.org2.com:7051", "Identity": "-----BEGIN CERT...", "Chaincodes": [ "mycc" ] },
 { "MSPID": "Org1MSP", "LedgerHeight": 5, "Endpoint": "peer0.org1.com:7051", "Identity": "-----BEGIN CERT...", "Chaincodes": [ "mycc" ] },
 { "MSPID": "Org1MSP", "LedgerHeight": 5, "Endpoint": "peer1.org1.com:7051", "Identity": "-----BEGIN CERT...", "Chaincodes":    null }
                                                                                          ^enrollment certificate of peer
                                                                                           Use "$ openssl x509 -text -noout" to print 
]

mapping from MSP IDs to orderer endpoints, as well as the FabricMSPConfig which can be used to verify all peer and orderer nodes by the SDK:

$ discover --configFile <b blue>conf.yaml</b> <b>config</b> --channel mychannel --server peer0.org1.example.com:7051
{
  "msps": {
    "OrdererOrg": {"name": "OrdererMSP", "root_certs": [Base64], "admins": [Base64], "crypto_config": { "signature_hash_family": "SHA2", "identity_identifier_hash_function": "SHA256" }, "tls_root_certs": [Base64] },
    "Org1MSP":    {"name": "Org1MSP",    "root_certs": [Base64], "admins": [Base64], "crypto_config": { "signature_hash_family": "SHA2", "identity_identifier_hash_function": "SHA256" }, "tls_root_certs": [Base64],
                   "fabric_node_ous": { "enable": true,
                     "client_ou_identifier": { "certificate": Base64, "organizational_unit_identifier": "client" },
                     "peer_ou_identifier"  : { "certificate": Base64, "organizational_unit_identifier": "peer" }
                   }
    },
    "Org2MSP": {...},
    ...
  },
  "orderers": { "OrdererOrg": { "endpoint": [ { "host": "orderer.example.com", "port": 7050 } ] } }
}

$ discover --configFile <b blue>conf.yaml</b> <b>endorsers</b> --channel mychannel  --server peer0.org1.example.com:7051 --chaincode mycc
[
    {
        "Chaincode": "mycc",
        "EndorsersByGroups": {
            "G0": [ { "MSPID": "Org1MSP", "LedgerHeight": 5, "Endpoint": "peer0.org1.example.com:7051", "Identity": "-----BEGIN CERT..." } ],
            "G1": [ { "MSPID": "Org2MSP", "LedgerHeight": 5, "Endpoint": "peer1.org2.example.com:7051", "Identity": "-----BEGIN CERT..." }, 
                    { "MSPID": "Org2MSP", "LedgerHeight": 5, "Endpoint": "peer0.org2.example.com:7051", "Identity": "-----BEGIN CERT..." } ]
        },
        "Layouts": [ { "quantities_by_group": { "G0": 1, "G1": 1 } } ]
    }
]
</pre>




</td>
</tr>
</table>

<table>
<tr>
<td>
  <a href='http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html'>Chaincode 4 devs</a>
  <ul xxxsmall zoom>
  <li>GoLang/NodeJS/Java(planned) program implementing a mandatory interface  <code>"Chaincode"</code>:
    (<a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#Chaincode">Go</a>,
     <a href="https://fabric-shim.github.io/ChaincodeInterface.html">Node.js</a>) and business logic agreed by members<br/>
    In particular:
<pre>
  Init  : triggered by incomming "instantiate"/"upgrade" TX proposals
          Chaincode will perform state initialization or upgrade/migration to new version

 Invoke : triggered by incomming "invoke" TX proposals
          Used to access ("get") and modify ("set") the ledger, and to make
          invocations between chaincodes
</pre>
  </li>
  <li>The other shim standard interface is <code>"ChaincodeStubInterface"</code>, used to access and modify
    the ledger.
   (<a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#ChaincodeStubInterface">Go</a>,
    <a href="https://fabric-shim.github.io/ChaincodeStub.html">Node.js</a>)
  </li>
  <li>Runs in a secured Docker container isolated from endorsing peer process</li>
  <li>Restricted to permissions, a chaincode may invoke another chaincode in the
      same channel (read/write) or different channels (read only)</li>

  Simple Asset Chaincode ("sacc")
<pre xxxsmall>
$ sudo yum install libtool-ltdl-devel # or similar in Ubuntu/... + 
$ mkdir -p $GOPATH/src/sacc &amp;&amp; cd $GOPATH/src/sacc + 
$ edit ($GOPATH/src/sacc)"sacc.go"
package main

import (
    "fmt"
    "github.com/hyperledger/fabric/core/chaincode/shim" // Mandatory Interface
    "github.com/hyperledger/fabric/protos/peer"
)

// Model structs
type SimpleAsset struct {
}

// --------------------------------------------------
// Mandatory Interface implementation (Init,  Invoke)
// --------------------------------------------------
   
    func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
      args := stub.GetStringArgs() // STEP 1: Get args from TX proposal

      if len(args) != 2 { // Preconditions
        return shim.Error("Incorrect arguments. Expecting a key and a value")
      }

      err := stub.PutState(args[0], []byte(args[1])) // store key and value on ledger
      if err != nil {
        return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
      }
      return shim.Success(nil)

    }

    // method may create a new asset by specifying a new key-value pair.
    func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
        // Extract the function and args from the transaction proposal
        fn, args := stub.GetFunctionAndParameters()

        var result string
        var err error
        if fn == "set" { result, err = set(stub, args)
        } else         { result, err = get(stub, args) }
        if err != nil  { return shim.Error(err.Error()) }

        return shim.Success([]byte(result)) // Return the result as success payload
    }

// --------------------------------------------------
// Business logic
// --------------------------------------------------
    func set(stub shim.ChaincodeStubInterface, args []string) (string, error) {
        if len(args) != 2 { return "", fmt.Errorf("Incorrect arguments. Expecting a key and a value") }
    
        err := stub.PutState(args[0], []byte(args[1]))
        if err != nil { return "", fmt.Errorf("Failed to set asset: %s", args[0]) }
        return args[1], nil
    }
    
    // Get returns the value of the specified asset key
    func get(stub shim.ChaincodeStubInterface, args []string) (string, error) {
        if len(args) != 1 { return "", fmt.Errorf("Incorrect arguments. Expecting a key") }
    
        value, err := stub.GetState(args[0])
        if err != nil { return "", fmt.Errorf("Failed to get asset: %s with error: %s", args[0], err) }
        if value == nil { return "", fmt.Errorf("Asset not found: %s", args[0]) }
        return string(value), nil

// --------------------------------
// Standar go-lang main entry point
// --------------------------------
func main() {
    if err := shim.Start(new(SimpleAsset)); err != nil {
            fmt.Printf("Error starting SimpleAsset chaincode: %s", err)
    }
}
</pre>
  </ul>
  Building Chaincode
<pre xxxsmall zoom>
$ cd ...
$ go get -u github.com/hyperledger/fabric/core/chaincode/shim
$ go build
</pre>

  Testing (dev mode)
<pre bgorange xxxsmall zoom>
In "prod mode" chaincode is run on the peer.
In "dev mode", chaincode is built and started by the user.

Create an "end-to-end" test: install chaincode on peer →, instantiate it , invoke method → querying status:
STEP 1: Start "dev mode" with pre-built orderer/channel artifacts in examples/chaincode-docker-devmode
$ cd chaincode-docker-devmode

┌───────────────────────────────┬─────────────────────────────────────────┬────────────────────────────────────┐
│STEP 1.1: Terminal 1           │ STEP 1.2: Terminal 2                    │ STEP 1.3: Terminal 3               │
│                               │ Put chain code in listen mode           │ Install on peer, invoke, query     │
├───────────────────────────────┼─────────────────────────────────────────┼────────────────────────────────────┤
│Start the network:             │ Build and start the chaincode           │ Use the chaincode                  │
│- SingleSampleMSPSolo orderer  │ $ docker exec -it chaincode bash        │ - install the chaincode            │
│- peer in "dev mode"           │ root@/.../chaincode # \                 │                                    │
│- chaincode env. container     │   cd sacc &amp;&amp; go build                   │ $ docker exec -it cli bash         │
│- CLI container ("shell")      │                                         │                                    │
│                               │ # Run the chaincode:                    │ root@/... # \                      │
│$ docker-compose -f \          │ root@/.../chaincode # \                 │   peer chaincode install \         │
│  docker-compose-simple.yaml up│     CORE_PEER_ADDRESS=peer:7052 \       │   -p chaincodedev/chaincode/sacc \ │
│                               │     CORE_CHAINCODE_ID_NAME=<b>mycc</b>:0 \     │   -n <b>mycc</b> -v 0                     │
│                               │     ./sacc                              │ root@/... # \                      │
│                               │ (check logs for successful registration)│   peer chaincode instantiate \     │
│                               │                                         │   -n <b>mycc</b> -v 0 \                   │
│                               │ # Note: chaincode is NOT yet associated │   -c '{"Args":["a","10"]}' \       │
│                               │ # with any channel                      │   -C <b green>myChannel</b>                     │
│                               │                                         │ # Now invoke to change "a" → "20"  │
│                               │                                         │ root@/... # \                      │
│                               │                                         │   peer chaincode invoke \          │
│                               │                                         │   -n <b>mycc</b> \                        │
│                               │                                         │   -c '{"Args":["set", "a", "20"]}' │
│                               │                                         │   -C <b green>myChannel</b>                     │
│                               │                                         │                                    │
│                               │                                         │ # Query to check final value       │
│                               │                                         │ root@/... # \                      │
│                               │                                         │   peer chaincode query \           │
│                               │                                         │   -n <b>mycc</b>                          │
│                               │                                         │   -c '{"Args":["query","a"]}'      │
│                               │                                         │   -C <b green>myChannel</b>                     │
└───────────────────────────────┴─────────────────────────────────────────┴────────────────────────────────────┘

NOTES: 
you can easily test different chaincodes by adding them to the chaincode subdirectory and relaunching your network.
At this point they will be accessible in your chaincode container.
</pre>
  (Optional) Chaincode value encryption
  <ul xxxsmall zoom>
  <li>Encryption is achieved by leveraging the 
    <a href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/shim/ext/entities">entities extension</a>
   which is a <a href="https://godoc.org/github.com/hyperledger/fabric/bccsp">BCCSP</a> wrapper with commodity 
   factories and functions to perform cryptographic operations such as encryption and elliptic curve digital signatures. <br/>
    For example, to encrypt, the invoker of a chaincode passes in a cryptographic
    key via the transient field. The same key may then be used for subsequent 
    query operations, allowing for proper decryption of the encrypted state values.
    See <a href="https://github.com/hyperledger/fabric/tree/master/examples/chaincode/go/enccc_example">Examples</a>
    with specific attention to the utils.go helper program.
  </li>
  </ul>
  Managing external dependencies (non Go standard library)
<pre xxxsmall zoom>
$ govendor init
$ govendor add +external               // Add all external package, or
$ govendor add github.com/external/pkg // Add specific external package
</pre>
</td>
<td>
   SHIM API
<pre xxxsmall zoom bgorange>
+-------------------------------------+---------------------------------------------------------------
|GetState(key string) ([]byte, error) | Returns the value of the `key` from the Worldstate. 
|                                     | If the key does not exist in the Worldstate the function 
|                                     | returns (nil, nil). 
|                                     | The function does not read data from the WriteSet and
|                                     | hence uncommitted values modified by PutState are not returned. 
+-------------------------------------+---------------------------------------------------------------
|PutState(key string, value []byte)   | Records the specified `key` and `value` into the WriteSet. 
|                                     | The function does not affect the ledger until the transaction 
|                                     | is committed into the ledger. 
+-------------------------------------+---------------------------------------------------------------
|DelState(key string) error           | Marks the the specified `key` as deleted in the WriteSet. 
|                                     | The key will be marked as deleted and removed from Worldstate  
|                                     | once the transaction is committed into the ledger. 
+-------------------------------------+---------------------------------------------------------------
|GetTxID() string                     | Returns an unique Id of the transaction proposal. 
+-------------------------------------+---------------------------------------------------------------
|GetChannelID() string                | Returns an Id of the channel the transaction proposal was sent to. 
+-------------------------------------+---------------------------------------------------------------
|InvokeChaincode(                     | Calls an Invoke function on a specified chaincode, in the context 
| chaincodeName string, args [][]byte,| of the current transaction. 
| channel string) pb.Response         | - If the invoked chaincode is on the same channel, the ReadSet and
|                                     |   WriteSet will be added into the same transaction. 
|                                     | - If the invoked chaincode is on a different channel, 
|                                     |   the invocation can be used only as a query. 
+-------------------------------------+---------------------------------------------------------------
|func GetHistoryForKey(key string)    | Returns a list of historical states, timestamps and transactions ids. 
|  (HistoryQueryIteratorInterface, error) 
+-------------------------------------+---------------------------------------------------------------
|func GetCreator() ([]byte, error)    | Returns the identity of the user submitting the transaction proposal. 
+-------------------------------------+---------------------------------------------------------------
|GetTransient()                       | Returns a map of fields containing cryptographic material which
|   (map[string][]byte, error)        | may be used to implement custom privacy layer in the chaincode. 
+-------------------------------------+---------------------------------------------------------------
|GetBinding() ([]byte, error)         | Returns data which can be used to enforce a link between
|                                     | application data and the transaction proposal. 
+-------------------------------------+---------------------------------------------------------------
|GetDecorations() map[string][]byte   | Returns data produced by peer decorators which modified the chaincode input. 
+-------------------------------------+---------------------------------------------------------------
|GetSignedProposal()                  | Returns data elements of a transaction proposal. 
|    (*pb.SignedProposal, error)      |
+-------------------------------------+---------------------------------------------------------------
|GetTxTimestamp()                     | Returns a timestamp of the transaction creation 
|    (*timestamp.Timestamp, error)    | by the client. The timestamp is consistent across all endorsers. 
+-------------------------------------+---------------------------------------------------------------
|SetEvent(name string, payload []byte)| Sets an event attached to the transaction proposal response. 
|    error                            | This event will be be included in the block and ledger. 
+-------------------------------------+---------------------------------------------------------------
</pre>
</td>
<td>
<a href='http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html'>Build Your First Network</a>,
<pre xxxsmall zoom>
Building Your First Network (fabric-samples/first-network, byfn.sh)

1 "solo" ordering service:
two Orgs x 2 peers(nodes)

$ cd ...fabric-samples/first-network

cli: used to join peers to channel
     deploy and instantiate chaincode
     drive execution of transactions against deployed chaincode

-------------------------------------------------------------------------------------------------------------------------------------
$  byfn.sh generate  # generate certificates, genesis  block, channel(+anchored peers)
           ^^^^^^^^
-------------------------------|-------------------------------------------|-------------------------------------------
GENERATE NETWORK ARTIFACTS     | INPUT net.topology(Orgs, components)      | GENERATED OUTPUT (.../crypto-config)
cryptogen generate \           | crypto-config.yaml                        | x509 keys/certificates:
 --config=./crypto-config.yaml | --------------------------------------    | Org1/2 root ca-certs
                               | OrdererOrgs:                              | /crypto-config
                               | - Name: <b orange>Orderer</b>                           |   /<b orange>ordererOrganizations</b>
                               |   Domain: <b orange>example.com</b>                     |     /<b blue>example.com</b>
                               |   CA:                                     |      /msp
                               |       Country: US                         |       /(tlscacerts|admincerts|cacerts)/
                               |       Province: California                |      /users/(Admin|user1|...)@"example.com"
                               |       Locality: San Francisco             |       /msp/...
                               |   Specs:                                  |      /orderers/orderer."dom"/
                               |     - Hostname: <b orange>orderer</b>                   |       (/msp/...,/tls/...)
                               | - Name: Org1                              |      /tlsca/...
                               |   Domain: org1.example.com                |      /ca/...
                               |   EnableNodeOUs: true                     |   /<b orange>peerOrganizations</b>
                               |   ...                                     |     /<b blue>org1.com</b>
                               | <b orange>orderer.example.com</b> will                  |      /msp/...
                               | be tied to MSP ID of <b orange>Orderer</b>              |      /peers/(peer0|peer1|Admin|User1!...)@.<b blue>org1.com</b>
                               |                                           |        (/msp/...,/tls/...)
                               |                                           |      /tlsca/...
                               |                                           |      /ca/...
                               |                                           |     /<b blue>org2.com</b>
-------------------------------|-------------------------------------------|-------------------------------------------
configtxgen :                  | configtx.yaml contains definitions for:   |  Generates Orderer and Channel <b green>Artifacts</b>
                               |   - Orderer Org (OrdererOrg)              |  - Orderer <b orange>Configuration</b> <b green>./channel-artifacts/genesis.block</b>
 # FABRIC_CFG_PATH tells       |   - Member Org1 + MSP directory location  |  - channel <b orange>Configuration</b> <b green>./channel-artifacts/channel.tx</b>
 # configtxgen location of     |   - Member Org2 + MSP directory location  |   - anchor peers transactions          <b green>./channel-artifacts/Org1MSPanchors.tx</b>
 # configtx.yaml               |   - SampleConsortium (Org1 + Org2)        |                                        <b green>./channel-artifacts/Org2MSPanchors.tx</b>
 export FABRIC_CFG_PATH=$PWD   |     Note: Consortia exist within the network scope 
                               |       (SampleConsortium defined    in *system-level  profile*)
# 1. ORDER GENESIS BLOCK       |       Channels  exist within the consortium scope             
 ../bin/configtxgen \          |       (SampleConsortium referenced by *channel-level profile*)
   -profile TwoOrgsOrdererGenesis  - anchor peer0.org1.example.com         |
   -outputBlock \              |   - anchor peer0.org2.example.com         |
   ./channel-artifacts/genesis.block                                       |
                               |  ---------------------                    |
# 2. CHANNEL TX                |                                           |
 ../bin/configtxgen            |  - "Profiles"                             |
   -profile TwoOrgsChannel     |  
   -outputCreateChannelTx      |  
   ./channel-artifacts/channel.tx ---------------------                    |
   -channelID $CHANNEL_NAME    |  (anchor peers for each Peer Org)         |
                               |
# 3. PEER TX UPDATE            |
../bin/configtxgen             |
  -profile TwoOrgsChannel      |
  -outputAnchorPeersUpdate     |
   ./channel-artifacts/Org1MSPanchors.tx
  -channelID $CHANNEL_NAME     |
  -asOrg Org1MSP               |
-----------------------------------------------------------
</pre>
Starting the network:
<pre xxxsmall zoom>
(Orderer and peers will stand by waiting for client requests)
The genesis.block must be present indicating the initial configuration
(consensus, block-size, ...) used by the blockchain network
CHANNEL_NAME=$CHANNEL_NAME \
TIMEOUT=<pick_a_value> \
docker-compose -f docker-compose-cli.yaml up -d
</pre>

Create Channel:
<pre xxxsmall zoom>
# enter CLI container (cli defined in docker-compose-cli.yaml)
# CRYPTO_DIR="/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/"
# ORDERER_HOST="orderer.example.com:7050"
$ docker exec -it cli bash  \
-e CHANNEL_NAME=mychannel \
-e ORDERER_ROOT_CERT="${CRYPTO_DIR}/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"

root@0d...:../peer# <b orange>peer channel create</b> \
    -o $ORDERER_HOST \
    -c $CHANNEL_NAME 
    -f <b green>./channel-artifacts/channel.tx</b> \
    --tls $CORE_PEER_TLS_ENABLED 
    --cafile ${ORDERER_ROOT_CERT} # Used for TLS handshake
(returns genesis block - <channel-ID.block> - which we will use to join the channel).
It contains the configuration information specified in channel.tx.
</pre>

Join peer to the channel.
<pre xxxsmall zoom >
root@0d.../peer# <b orange>peer channel join</b> -b &lt;channel-ID.block&gt;
(join other peers join by making appropriate changes in ENVVARS)
</pre>

  Install and Instantiate Chaincode<br/>
  <ol xxxsmall zoom >
  <li>We need to install the chaincode on every peer that will 
    execute and endorse our transactions, and then instantiate
    the chaincode on the channel.</li>
  <li>install (sample Go code) onto one of the four peer nodes.<br/>
        Next command places the <e>source code</e> onto our peer's filesystem:
<pre { >
.../peer# GIT_REPO="github.com/hyperledger/fabric"
.../peer# GIT_REPO="${GIT_REPO}/examples/chaincode"
.../peer# GIT_REPO="${GIT_REPO}/go/chaincode_example02"
.../peer# peer chaincode install \
                 -n mycc -v 1.0 -p ${GIT_REPO}
</pre } >
  </li>
  <li>Instantiate chaincode on the channel,
    set endorsement policy for the chaincode,
    and launch a chaincode container for the targeted peer.
<pre { >
root@0d.../peer# peer chaincode \
    instantiate \
    -o orderer.example.com:7050 \
    --tls $CORE_PEER_TLS_ENABLED \ 
    --cafile ${CA_F} \
    -C $CHANNEL_NAME \
    -n mycc -v 1.0 \
    -c '{"Args":["init","a", "100", "b","200"]}' \
    -P "OR ('Org1MSP.member','Org2MSP.member')" 

# Note: -(P)olicy: <a href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">required endorsement level</a>
#                 for TX against this chaincode 

</pre } >
  </ol>

  Query and invoque<br/>
  <ol xxxsmall zoom >
  <li>Query for the value of a to make sure the chaincode was properly instantiated and the state DB was populated.
<pre>
root@0d.../peer# peer chaincode query \
          -C $CHANNEL_NAME -n mycc \
          -c '{"Args":["query","a"]}'
</pre>
  </li>
  <li>
Let’s move 10 from a to b:
<pre>
root@0d.../peer# peer chaincode invoke \
    -o orderer.example.com:7050  \
    --tls $CORE_PEER_TLS_ENABLED \
    --cafile ${CA_F} \
    -C $CHANNEL_NAME -n mycc \
    -c '{"Args":["invoke","a","b","10"]}'
</pre>
  </li>
  </ol>
</td>
<td>
<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-cli.yaml'>docker-compose-cli.yaml</a>
<pre xxxsmall zoom { >
...
services:
  orderer.${DOMAIN}:
    container_name: orderer.${DOMAIN}
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.${DOMAIN}
...
  peer0.${ORG1}.${DOMAIN}:
  (same for  peer1.${ORG1}.${DOMAIN})
  (same for  peer0.${ORG2}.${DOMAIN})
    container_name: peer0.${ORG1}.${DOMAIN}
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.${ORG1}.${DOMAIN}

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    ...
    volumes:
        ...
        - ./crypto-config     :.../peer/crypto/
        - ./channel-artifacts :.../channel-artifacts
    depends_on:
      - orderer.${DOMAIN}
      - peer0.${ORG1}.${DOMAIN}
      - ...
</pre }>

  <a href='https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go'>fabric-samples fabcar.go</a>
<pre xxxsmall zoom { >
 (Summary Error checks removed)
// structures
type Car struct {                   type SmartContract struct { }
    Make   string `json:"make"`
    Model  string `json:"model"`
    Colour string `json:"colour"`
    Owner  string `json:"owner"`
}

func (s *SmartContract) initLedger(
       APIstub shim.ChaincodeStubInterface) sc.Response {
    cars := []Car{ // ledger initialization outside Init
        Car{ Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
        Car{Make: "Ford", Model: "Mustang", Colour: "red", Owner: "Brad"},
        ...  }

    i := 0 ; for i &lt; len(cars) {
        carAsBytes, _ := json.Marshal(cars[i])
        APIstub.PutState("CAR"+strconv.Itoa(i), carAsBytes)
        fmt.Println("Added", cars[i])
        i = i + 1
    }
    return shim.Success(nil)
}

// called when instantiated by the blockchain network
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
    return shim.Success(nil)
}

/* called as a result of application request to
   run the Smart Contract "fabcar" */
func (s *SmartContract) Invoke( APIstub shim.ChaincodeStubInterface) sc.Response {
    // Retrieve the requested Smart Contract func.+args.
    function, args := APIstub.GetFunctionAndParameters()
    if function == "queryCar" {
        return s.queryCar(APIstub, args)
    } else if function == "initLedger" {
        return s.initLedger(APIstub)
    } else if function == "createCar" {
        return s.createCar(APIstub, args)
    } else if function == "queryAllCars" {
        return s.queryAllCars(APIstub)
    } else if function == "changeCarOwner" {
        return s.changeCarOwner(APIstub, args)
    }
}

func (s *SmartContract) queryCar( APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    return shim.Success(carAsBytes)
}

func (s *SmartContract) createCar( APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
    var car = Car{Make: args[1], Model: args[2],
                  Colour: args[3], Owner: args[4]}
    carAsBytes, _ := json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}

func (s *SmartContract) queryAllCars( APIstub shim.ChaincodeStubInterface) sc.Response {
    startKey := "CAR0"
    endKey := "CAR999"
    resultsIterator, err := 
       APIstub.GetStateByRange(startKey, endKey)
    defer resultsIterator.Close()
    
    var buffer /* JSON array */ bytes.Buffer
    buffer.WriteString("[")
    for resultsIterator.HasNext() {
        queryResponse, err := resultsIterator.Next()
        ...
        buffer.WriteString("{\"Key\":")
        buffer.WriteString("\"")
        ...
    }
    ...
    return shim.Success(buffer.Bytes())
}

func (s *SmartContract) changeCarOwner( APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
    carAsBytes, _ := APIstub.GetState(args[0])
    car := Car{}
    json.Unmarshal(carAsBytes, &amp;car)
    car.Owner = args[1]
    carAsBytes, _ = json.Marshal(car)
    APIstub.PutState(args[0], carAsBytes)
    return shim.Success(nil)
}

func main /* testing purposes*/() {
    // Create new Contract
    err := shim.Start(new(SmartContract))
}
</pre } >
  <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/query.js'>fabcar query.js</a>
<pre xxxsmall zoom { >
(errors and async code removed)
var hfc = require('fabric-client');
var path = require('path');
var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    network_url: 'grpc://localhost:7051',
};

var client = new hfc(); // create client
wallet = hfc.newDefaultKeyValueStore(
    { path: options.wallet_path });
client.setStateStore(wallet); // Set wallet path
// associate user to app
user = client.getUserContext(options.user_id, true);
var channel = client.newChannel(options.channel_id);
channel.addPeer(client.newPeer(options.network_url));
// make query
var transaction_id = client.newTransactionID();
const request = {
  chaincodeId: options.chaincode_id,
  txId: transaction_id,
  fcn: 'queryAllCars', args: [''] };
query_responses = channel.queryByChaincode(request);
// console.log("count = ", query_responses.length)
if (query_responses[0] instanceof Error) {
  console.error("error from query = ", query_responses[0]);
}
console.log("Response: ", query_responses[0].toString());
</pre } >
  <a href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/invoke.js'>fabcar invoke.js</a>
<pre xxxsmall zoom { >
(errors removed)
var hfc = require('fabric-client');
var path = require('path');
var util = require('util');

var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'PeerAdmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    peer_url: 'grpc://localhost:7051',
    event_url: 'grpc://localhost:7053',
    orderer_url: 'grpc://localhost:7050'
};

var client = null;
var targets = [];
console.log("Create a client and set the wallet location");
client = new hfc();
var wallet = hfc.newDefaultKeyValueStore({ path: options.wallet_path });
console.log("Set wallet path, and associate user ", 
          options.user_id, " with application");
client.setStateStore(wallet);
var user = client.getUserContext(options.user_id, true);
console.log("Check user is enrolled, and set a query URL 
         in the network");
var channel = client.newChannel(options.channel_id);
var peerObj = client.newPeer(options.peer_url);
channel.addPeer(peerObj);
channel.addOrderer(client.newOrderer(options.orderer_url));
targets.push(peerObj);
var tx_id = client.newTransactionID();
console.log("Assigning transaction_id: ", tx_id._transaction_id);
// createCar - requires 5 args, ex: args:
// ['CAR11', 'Honda', 'Accord', 'Black', 'Tom'],
// changeCarOwner - requires 2 args , ex: args: ['CAR10', 'Barry'],
// send proposal to endorser
var request = {
    targets: targets,
    chaincodeId: options.chaincode_id,
    fcn: 'createCar',
    args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
    chainId: options.channel_id,
    txId: tx_id
};
var results = channel.sendTransactionProposal(request);
var proposalResponses = results[0];
var proposal = results[1];
var header = results[2];
let isProposalGood = false;
console.log(util.format(
    'Successfully sent Proposal and received'
  + ' ProposalResponse: Status - %s, message - "%s",'
  + ' metadata - "%s",' 
  + ' endorsement signature: %s',
    proposalResponses[0].response.status,
    proposalResponses[0].response.message,
    proposalResponses[0].response.payload,
    proposalResponses[0].endorsement.signature));
var request = {
    proposalResponses: proposalResponses,
    proposal: proposal,
    header: header
};
// set the transaction listener and 30sec timeout 
// if the TX did not get committed within timeout
// fail the test
var transactionID = tx_id.getTransactionID();
var eventPromises = [];
let eh = client.newEventHub();
eh.setPeerAddr(options.event_url);
eh.connect();

let txPromise = new Promise((resolve, reject) => 
{
  let handle = setTimeout(() => {
    eh.disconnect(); reject(); }, 30000);
  eh.registerTxEvent(transactionID, (tx, code) => {
    clearTimeout(handle);
    eh.unregisterTxEvent(transactionID);
    eh.disconnect();
    if (code === 'VALID') {
        console.log(
            'TX has been committed on peer ' +
            eh._ep._endpoint.addr);
        resolve();
    }
  });
});
eventPromises.push(txPromise);
var sendPromise = channel.sendTransaction(request);
var results = sendPromise.concat(eventPromises)) 
    console.log('event promise all '
    + ' complete and testing complete');
var response = results[0]; // 1st returned value is from
                   // 'sendPromise' which is from
                   // 'sendTransaction()' call
if (response.status === 'SUCCESS') {
    console.log('Successfully sent TX to orderer.');
    return tx_id.getTransactionID();
}
</pre } >
</td>
</tr>
</table>
<hr/>


<table>
<tr>
<td>
  <a href='https://fabric-sdk-node.github.io/'>Client NodeJS SDK</a> available to:
  <ul xxxsmall>
  <li>create <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">channels</a></li>
  <li>ask <a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#peer">peer nodes</a> to join the channel</li>
  <li>install <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode">chaincodes</a> in peers using the consensus process (can be preinstalled in setup scripts)</li>
  <li>instantiate chaincodes in a channel</li>
  <li>invoke transactions by calling the chaincode</li>
  <li>
      Query the <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#ledger-features">ledger</a> for transactions or blocks<br/>
  </li>
  <li TODO >receive ledger updates</li>
  </ul>
  APIs are split between two npm modules:
  <ul xxxsmall>
  <li>COMPOSER-CLIENT:<br/>
      - submits TXs to a network, CRUD opts on assets and participants<br/>
      - installed as local dependency for app.<br/>
      - When in production this is only module that needs to be added
        as a direct dependency of the application.</li>
  <li>COMPOSER-ADMIN:<br/>
      - manages business networks (creation/deploy, undeploy)<br/>
      - installed as a local dependency of admin. apps</li>
  </ul>
</td>
<td>
  <a href="https://github.com/hyperledger/fabric-sdk-java">Client Java SDK</a>
  <ul xxxsmall zoom>
  <li>manage the lifecycle of Hyperledger channels and user chaincode</li>
  <li>execute user chaincode, query channel blocks and TXs</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-java/blob/master/src/test/java/org/hyperledger/fabric/sdkintegration/End2endIT.java">End2endIT</a> provide a "full-journey" example installing, instantiating, invoking and querying a chaincode.</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-java/blob/master/src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java">End2endAndBackAgainIT.java</a> shows recreating the channel objects created in End2endIT.java and upgrading chaincode and invoking the up graded chaincode</li>
  <li>Monitor events on the channel</li>
  <li>Channels may be serialized via Java serialization in the context of a client</li>
  <li>Channels deserialized are not in an initialized state. Applications need to handle migration of serialized files between versions</li>
  <li>Hyperledger's certificate authority client</li>
  <li>
<pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt;
    &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>
  </li>
  <li> Chaincode endorsement policies
    <ul xxxsmall>
    <li>Policies are described in the <a href="https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob;f=docs/endorsement-policies.md;h=1eecf359c12c3f7c1ddc63759a0b5f3141b07f13;hb=HEAD">Fabric Endorsement Policies</a> document.</li>
    <li>You create a policy using a Fabric tool ( an example is shown in 
<a href="https://jira.hyperledger.org/browse/FAB-2376?focusedCommentId=21121&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-21121">JIRA issue FAB-2378</a>)
  and give it to the SDK either as a file or a byte array. The SDK, in turn, will use the policy when it creates chaincode instantiation requests.</li>
    <li>To input a policy to the SDK, use the ChaincodeEndorsementPolicy class.</li>
    <li>For testing purposes, there are 2 policy files in the src/test/resources directory
<pre>
    policyBitsAdmin ( which has policy AND(DEFAULT.admin) meaning 1 signature from the DEFAULT MSP admin' is required )
    policyBitsMember ( which has policy AND(DEFAULT.member) meaning 1 signature from a member of the DEFAULT MSP is required )
</pre>
    </li>
    and one file in the src/test/fixture/sdkintegration/e2e-2Orgs/channel directory specifically for use in the end to end test scenario
    <li>
    members_from_org1_or_2.policy ( which has policy OR(peerOrg1.member, peerOrg2.member) meaning 1 signature from a member of either organizations peerOrg1, PeerOrg2 is required)
    </li>
    <li>Alternatively, you can also use ChaincodeEndorsementPolicy class by giving it a YAML file 
      that has the policy defined in it. See examples of this in the End2endIT testcases that use 
      src/test/fixture/sdkintegration/chaincodeendorsementpolicy.yaml The file chaincodeendorsementpolicy.yaml
      has comments that help understand how to create these policies. The first section lists all the signature
      identities you can use in the policy. Currently, only ROLE types are supported. The policy section
      is comprised of n-of and signed-by elements. Then n-of (1-of 2-of) require that many (n) in that section
      to be true. The signed-by references an identity in the identities section.
    </li>
    </ul>
  </li>
  <li>Channel creation artifacts
    <ul>
    <li>Channel configuration files and orderer bootstrap files ( see directory 
      src/test/fixture/sdkintegration/e2e-2Orgs ) are needed when creating a new channel. 
      This is created with the Hyperledger Fabric configtxgen tool. This must be run after
      cryptogen and the directory you're running in must have a generated crypto-config  
      directory.<br/>
      (If build/bin/configtxgen tool is not present run make configtxgen)
    </li>
    <li>For v1.0 integration test the commands are:
<pre>
$ build/bin/configtxgen -outputCreateChannelTx foo.tx -profile TwoOrgsChannel -channelID foo
$ build/bin/configtxgen -outputCreateChannelTx bar.tx -profile TwoOrgsChannel -channelID bar
</pre>
    For v1.1 integration the commands use the v11 profiles in configtx.yaml. You need to for now copy
    the configtx.yaml in e2e-20orgs to the v1.1 directory and run from there:
<pre>
$ configtxgen -outputBlock orderer.block -profile TwoOrgsOrdererGenesis_v11
$ configtxgen -outputCreateChannelTx bar.tx -profile TwoOrgsChannel_v11 -channelID bar
$ configtxgen -outputCreateChannelTx foo.tx -profile TwoOrgsChannel_v11 -channelID foo
(This should produce in the v1.1 directory: bar.tx,foo.tx, orderer.block)
</pre>
     Note: The above describes how this was done. If you redo this there are private key files which
     are produced with unique names which won't match what's expected in the integration tests. 
     One examle of this is the docker-compose.yaml (search for _sk)
    </li>
    </ul>
  </li>
  <li>GO Lang chaincode dependencies must be contained in vendor folder.</li>
  <li>(See also  Basic Troubleshooting section)</li>
  </ul>
  
</td>
</tr>
</table>
<br/>
<table>
<tr>
  <th colspan=10>
    <a href="https://hyperledger.github.io/composer/latest/introduction/introduction">COMPOSER</a>
    (Incubation, <a href='https://www.hyperledger.org/projects/composer'>project page</a>),
    (<a href="https://github.com/jt-nti/composer-devenv">Vagrant VirtBox Provisioning</a>)
  </th>
</tr>
<tr>
<td>
  Composer enables to quickly create business logic running on the blockchain + REST APIs
  <ul xxxsmall zoom>
  <li>Development toolset and framework to develop blockchain apps (model, gui, roles, ...).</li>
  <li><a href='https://composer-playground.mybluemix.net/'>On-oline playground</a></li>
  <li><a href='https://hyperledger.github.io/composer/installing/development-tools.html'>Installing</a></li>
  <li><a href='https://hyperledger.github.io/composer/tutorials/tutorials.html'>
        Playgorund, Developer, Queries Tutorials, deploying to a single/multiple org. in Fabric</a></li>
  </ul>
  Businness Networks <a href="https://hyperledger.github.io/composer/latest/introduction/key-concepts">core concepts</a>
<pre xxxsmall zoom { >
 INPUT             OUTPUT
┌──────────────┐   ┌───────────────────────┐
│* .cto        │   │Business Network       │
│- Assets      │   │Archive *.bna          │
│- Participants│   │(Package-up input ready│
│- Transactions│   │ to deploy "somewhere")│
├──────────────┤   └───────────────────────┘
│*.js          │
│- Transaction │  - Identities&amp;ID cards can be associated with
│  Functions   │    Participants
├──────────────┤  - ID cards are a combination of identity, 
│*.acl         │    connection profile and metadata
│- Access      │
│  Control     │  - Transaction processor functions can emit Events
├──────────────┤    to notify external systems about "anything"
│*.qry         │
│- Query defini│
│  rules       │
└──────────────┘
</pre } >

  <code>models/sample.cto</code>
  Defines participants, assets, txs, events
<pre xxxsmall zoom { >
namespace org.acme.sample

participant SampleParticipant identified by participantId
{
  o String participantId
  o String firstName
  o String lastName
}

asset SampleAsset identified by assetId {
  o String assetId
  --> SampleParticipant owner
  o String value
}

transaction SampleTransaction {
   --> SampleAsset asset
   o String newValue
}

event SampleEvent {
  --> SampleAsset asset
  o String oldValue
  o String newValue
}
</pre } >
  <code>lib/sample.js</code>
<pre xxxsmall zoom { >
function sampleTransaction(tx) {
  var oldValue = tx.asset.value;

  tx.asset.value = tx.newValue;

  return getAsetRegistry('org.acme.sample.SampleAsset')
    .then(function (assetRegsitry) {
           return assetRegistry.update(tx.asset);
     })
    .then(function () {
       var event = getFactory().newEvent('org.acme.sample',
          'SampleEvent');
       event.asset = tx.asset;
       event.oldValue = oldValue;
       event.newValue = tx.newValue;
       emit(event);
    });
}
</pre } >
  <code>permissions.acl</code>
<pre xxxsmall zoom { >
rule EverybodyCanReadEverything {
  description: "Allow all participants read access to all resources"
  participant: "org.acme.sample.SampleParticipant"
  opeartion: READ
  resource: "org.acme.sample.*"
  action: ALLOW
}

rule EverybodyCanSubmitTransactions {
  description: "Allow all participants to submit TXs"
  participant: "org.acme.sample.SampleParticipant"
  operation: CREATE
  resource: "org.acme.sample.SampleTransaction"
  action: ALLOW
}

rule OwnerhasFullAccessToTherAssets {
  description: "full access to participants assets"
  participant: "org.acme.sample.SampleParticipant"
  operation: ALL
  resource(r): "org.acme.sample.SampleTransaction"
  condition: (r.owner.getIdentifier() === p.getIdentifier())
  action: ALLOW
}

rule SystemACL {
  description: "System ACL to permit all access"
  participant: "org.hyperledger.composer.system.Participant"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}

rule NetworkAdminSsytem {
  description: "full access for network admins. to sys.res."
  participant: "org.hyperledger.composer.system.NetworkAdmin"
  operation: ALL
  resource: "org.hyperledger.composer.system.**"
  action: ALLOW
}
</pre } >

  <a href="https://github.com/hyperledger/composer-tools">Composer Tools@GitHub</a>
</td>
<td>
  CONNECTION PROFILES
  <ul xxxsmall zoom>
  <li>Used across Hyperledger Composer to specify how to connect to an execution runtime.</li>
  <li> json document in user's home diretory containing info such as IP addresses&amp;ports of
     fabric-peers, cryptographic certs,...</li>
  </ul>
</td>
<td>
  Rest Server:
  <ul xxxsmall zoom>
  <li>automatically generates a Open API (Swagger) REST API 
    At runtime implements CRUD support for assets/participants 
    and allows TXs to be submitted for processing or retrieved</li>
  <li>LOOPBACK CONNECTOR
    <ul>
    <li>Used by the Composer REST Server</li>
    <li>It may also be used standalone by integration tools that support LoopBack natively.</li>
    <li>Can also be used with the LoopBack tools to create more sophisticated customizations of the REST APIs.</li>
    </ul>
  </li>
</td>
<td>
  <li><a href="https://hyperledger.github.io/composer/latest/tutorials/playground-tutorial.html">PLAYGROUND WEB "IDE"</a>
    <ul xxsmall >
    <li>GUI to define and test business networks.</li>
    <li><a href="https://composer-playground.mybluemix.net/">public-online</a> or <a href="https://hub.docker.com/r/hyperledger/composer-playground/">docker-local-online</a></li>

    <li>Allows business analyst to quickly import samples and prototype business logic that executes on the Web or Hyperledger Fabric runtime.</li>
    </ul>
  </li>
</td>
<td>
  YEOMAN CODE GENERATORS 
  <ul xxxsmall zoom>
  <li>Used to create skeleton projects</li>
  <li> Angular web application  </li>
  <li> Node.js application      </li>
  <li> Skeleton business network</li>
  </ul>
</td>
</tr>
</table>

<!--
<table>
<tr>

<td>
  <ul xxxsmall zoom >
  <li>BLOCKCHAIN STATE STORAGE:<br/>
    Blockchain ledger:  stores all TXs submitted through a business network<br/>
    Blockchain state database: current state of assets and participants <br/>
  </li>
  <li>CONNECTION PROFILES:
<pre>
- Used to connect to a runtime.
- JSON document @ user's home directory (or ENV.VAR)  and referenced
  by name when using the Composer APIs or the Command Line tools.
- C.P. ensures that code and scripts are easily portable from one 
  runtime instance to another. 
  </li>
  <li>ASSETS:
- Anything that can be owned by someone.
- Assets MUST HAVE a unique identifier.
- Assets may be related to other assets or participants.
  </li>
  <li>PARTICIPANTS:<br/>
- members of a business network.<br/>
- They may own assets and submit transactions.<br/>
- Participant MUST HAVE an identifier.<br/>
  </li>
  <li>IDENTITIES AND ID CARDS:<br/>
- Participants can be associated with an identity.<br/>
- ID cards are a combination of : <br/>
  - identity<br/>
  - connection profile<br/>
  - metadata.<br/>
- ID cards simplify the process of connecting to business network
  and extend the concept of an identity outside the B.N. to a<br/>
  'wallet' of identities, each associated with a specific business
  network and connection profile.<br/>
  </li>
  <li>TRANSACTIONS<br/>
- mechanism by which participants interact with assets.<br/>
  </li>
  <li>QUERIES<br/>
- used to return data about the blockchain world-state.<br/>
- Queries are defined within a business network, and can include
  variable parameters for simple customization. By using queries,
  data can be easily extracted from your blockchain network.<br/>
- Queries are sent by using the Hyperledger Composer API.
  </li>
  <li>EVENTS:<br/>
- Defined in the business network definition in the same way as assets or participants.<br/>
- Once events have been defined, they can be emitted by transaction processor functions
  to indicate to external systems that something of importance has happened to the ledger.<br/>
- Applications can subscribe to emitted events through the composer-client API.
  </li>
  <li>ACCESS CONTROL RULES<br/>
- fine-grained control over what participants have access to what assets
  in the business network and under what conditions.<br/>
- Access control language is rich enough to capture sophisticated conditions
  declaratively, such as "only the owner of a vehicle can transfer
  ownership of the vehicle".<br/>
- Externalizing ACR from TX processor logic makes it easier to inspect,
  debug, develop and maintain.<br/>
  </li>
  <li>HISTORIAN REGISTRY<br/>
- Specialised registry which records successful transactions,
  including the participants and identities that submitted them.<br/>
- TXs are stored as HistorianRecord assets, are defined in the
  Hyperledger Composer system namespace.<br/>
  </li>
  </ul>
</td>  
</tr>
</table>

</body>
<!--
TODO_start:
support for cross-chaincode transactions (post-v1 feature)
_________________________________
<a href='https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html'>2.1.1. PROPOSE message format</a>

<p>The format of a PROPOSE message is &lt;PROPOSE,tx,[anchor]&gt; , where
tx is a mandatory and anchor optional argument explained in the following.</p>

tx=&lt;clientID,chaincodeID,txPayload,timestamp,clientSig&gt;, where
<ul>
  <li>clientID is an ID of the submitting client,</li>
  <li>chaincodeID refers to the chaincode to which the transaction pertains,</li>
  <li>txPayload is the payload containing the submitted transaction itself,</li>
  <li>timestamp is a monotonically increasing (for every new transaction) 
      integer maintained by the client,</li>
  <li>clientSig is signature of a client on other fields of tx</li>
</ul>

<p>The details of txPayload will differ between invoke transactions
and deploy transactions (i.e., invoke transactions referring to a
deploy-specific system chaincode). For an invoke-transaction,
txPayload would consist of two fields</p>

<ul>
   <li>txPayload=&lt;operation,metadata&gt;, where<ul>
   <li>operation denotes the chaincode operation (function) and arguments,</li>
   <li>metadata denotes attributes related to the invocation.</li>
</ul>

<p>For a <strong>deploy transaction</strong>, txPayload would consist of three fields</p>
<ul>
  <li>txPayload = &lt;source, metadata, policies&gt; where<ul>
  <li>source denotes the source code of the chaincode,</li>
  <li>metadata denotes attributes related to the chaincode and
  application,</li>
  <li>policies contains policies related to the chaincode that
      are accessible to all peers, such as the endorsement policy.
      Note that endorsement policies are not supplied with
      deploy transaction, but
      deploy contains endorsement policy ID and
      its parameters (see Section 3).</li>
</ul>

<ul>
<li>anchor contains read-version-dependencies, or more
   specifically, key-version pairs (i.e., anchor is a subset of
   PROPOSE request to specified versions of keys in a KVS (see Section 1.2.). 
   If the client specifies the anchor argument, an endorser endorses a transaction
   only upon <em>read</em> version numbers of corresponding keys in its local
   KVS match anchor (see Section 2.2. for more details).
</li>
</ul>
<p>Cryptographic hash of tx is used by all nodes as a unique
transaction identifier tid=HASH(tx)). The client
stores tid in memory and waits for responses from endorsing peers.</p>
________________________________
Video Tutorial: https://www.youtube.com/watch?v=fdFUsrsv5iw 
________________________________________

_______________________________________
    It is a good practice to model chaincode asset data as JSON, so that you have 
   the option to perform complex rich queries if needed in the future.</li>
____________________________________
 Certificates and other cryptography artifacts
____________________________
Fabric endorsement-policies:
https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob;f=docs/endorsement-policies.md;h=1eecf359c12c3f7c1ddc63759a0b5f3141b07f13;hb=HEAD

 Organization  1 ←────→ 1  MSP
 ────────────              ────
                           MSPID
                           priv.keys
                           certificates

   Fabric requires that each organization has private keys and certificates for use in signing and verifying messages going to and from clients, peers and orderers. Each organization groups these artifacts in an MSP (Membership Service Provider) with a corresponding unique MSPID .

Furthermore, each organization is assumed to generate these artifacts independently. The fabric-ca project is an example of such a certificate generation service. Fabric also provides the cryptogen tool to automatically generate all cryptographic artifacts needed for the end to end test. In the directory src/test/fixture/sdkintegration/e2e-2Orgs/channel

The command used to generate end2end crypto-config artifacts:

v1.0 build/bin/cryptogen generate --config crypto-config.yaml --output=crypto-config

v1.1 cryptogen generate --config crypto-config.yaml --output=v1.1/crypto-config

___________________________________
 <td>
  <a TODO href='https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html'>CouchDB configuration</a><br/>
  <a TODO href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html">Gossip data dissemination protocol</a></span><br/>
  <a TODO href="https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html">Bringing up a Kafka-based Ordering Service</a></span>:identify steps needed to have a set of Fabric ordering service nodes (OSNs) use Kafka cluster providing an ordering service to the blockchain network</a>
</td>   
___________________________________
During ChainCode instantiation (<code>$ peer chaincode instantiate ...</code>) if the identity classification is enabled
(see Membership Service Providers (MSP)), one can use the PEER role to restrict endorsement to only peers.
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/pluggable_endorsement_and_validation.html
___________________________
https://hyperledger-fabric.readthedocs.io/en/latest/error-handling.html
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/logging-control.html

____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/enable_tls.html

_______________________________
https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html

____________________________________
https://hyperledger-fabric.readthedocs.io/en/latest/idemixgen.html
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/architecture.html
_______________________________
https://hyperledger-fabric.readthedocs.io/en/latest/Fabric-FAQ.html
______________________________
https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html
_____________________________________
https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html
_____________________________________
<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.1/architecture.html">ARCHITECTURE</a>
_____________________________________
TODO:(0) <a href="http://hyperledger-fabric.readthedocs.io/en/latest/commands/configtxgen.html">configtxgen</a>
_____________________________________
Capabilities (v1.1+, defined in config.tx) define features which must be
present in a fabric binary for that binary to safely participate in the
fabric network. (TODO: Added to X.509 certs?).
Capabilities apply to both orderers and peers and must be supported by both.
_____________________________________
You will have to install the Composer playground in addition then the Composer rest server during the lab.
_____________________________________
In an ideal trade scenario, only the process of preparing and shipping the goods would take time. Recently, the adoption of SWIFT messaging over manual communication has made the document application and collection processes more efficient, but it has not fundamentally changed the game. A blockchain, on the other hand, with its (almost) instantaneous transaction commitments and assurance guarantees, opens possibilities that did not previously exist.

As an example, the one variation we introduced in our use case was payment by installments, which cannot be implemented in the legacy framework because there is no guaranteed way of knowing and sharing information about a shipment's progress. Such a variation would be deemed too risky in this case, which is why payments are linked purely to documentary evidence. By getting all participants in a trade agreement on a single blockchain implementing a common smart contract, we can provide a single shared source of truth that will minimize risk and simultaneously increase accountability

The criterion for the approval of a transaction (or invocation) is an endorsement policy (which we will revisit later in this chapter). It is framed in terms of the organizations that are participating in the application network, and not the peers themselves
_________________________________
https://github.com/HyperledgerHandsOn/
_________________________________
Every chaincode must implement the Chaincode interface, whose methods are called in response to the received transaction proposals. The Chaincode interface defined in the SHIM package is shown in the following listing:
type Chaincode interface {
     Init(stub ChaincodeStubInterface) pb.Response
     Invoke(stub ChaincodeStubInterface) pb.Response 
}

 As you can see, the Chaincode type defines two functions: Init and Invoke.Both functions have a single argument, stub, of the type ChaincodeStubInterface.The stub
 argument is the main object that we will use when implementing the chaincode functionality, as it provides functions for accessing and modifying the ledger, obtaining invocation arguments, and so on.Additionally, the SHIM package provides other types and functions in order to build chaincodes; you can inspect the whole package at: https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim.
_________________________

Fabric CA issues Enrollment Certificates (ecerts) for network users. 
  The ecert represents the identity of the user and is used as a signed 
transaction when a user submits to Fabric. Prior to invoking a transaction, 
the user must therefore first register and obtain an ecert from the Fabric CA.
_________________________
Attribute-based Access Control (ABAC):
can be used by the chaincode to control access to its functions and data. The 
ABAC allows the chaincode to make access control decisions based on 
attributes associated with user identity. Users with an ecert can also access 
a series of additional attributes (that is, name/value pairs).

In the following steps, we will show you how to register a user and create an 
ecert with attributes. We will then retrieve the user identity and the 
attributes in the chaincode to validate access control. We will then 
integrate this functionality into our tutorial chaincode.First, we must 
register a new user with the Fabric CA. As part of the registration process, 
we have to define the attributes that will be used once the ecert is generated
. A user is registered by running the command, fabric-ca-client register. The 
access control attributes are added by using the suffix :ecert.
_________________________
Plugable consensus include:
PBFT, No-Op, SIEVE, ... more
_________________________
Who is Who: https://www.hyperledger.org/about/leadership
_________________________
KAFKA in Fabric:
- The abc of kafka on Fabric: https://codeburst.io/the-abcs-of-kafka-in-hyperledger-fabric-81e6dc18da56
- https://github.com/hyperledger/fabric/blob/master/docs/source/kafka.rst
- https://cdn-images-1.medium.com/max/1600/1*LG29hSWrrAuVBa8NojeAtA.png
_________________________
What's new 1.2:
https://hyperledger-fabric.readthedocs.io/en/release-1.2/whatsnew.html

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data/private-data.html">Private Data Collections</a>
A way to keep certain data/transactions confidential among a subset of channel
members. We also have an architecture document on this topic which can be found
<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data-arch.html">here</a>.</li>

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-overview.html">Service Discovery</a>
Discover network services dynamically, including orderers, peers, chaincode, and endorsement policies, to simplify client applications.


<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/access_control.html">Access control</a>
How to configure which client identities can interact with peer functions on a per channel basis.

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/pluggable_endorsement_and_validation.html">Pluggable endorsement and validation</a>:
Utilize pluggable endorsement and validation logic per chaincode.


NEW-TUTORIALS
<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/upgrade_to_newest_version.html">Upgrade to version v1.2</a>
Leverages the BYFN network to show how an upgrade flow should work. Includes both a script (which can serve as a template for upgrades), as well as the individual commands

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/couchdb_tutorial.html">CouchDB</a>
How to set up a CouchDB data store (which allows for rich queries).

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private_data_tutorial.html">Private data</a>: Shows how to set up a collection using BYFN.
<a  href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#manage-certificates">Query certificates based on various filter criteria (Fabric CA)</a>
Describes how to use fabric-ca-client to manage certificates.


<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/network/network.html">Fabric network as a concept</a>:
A look at the structure of the various pieces of a Fabric network and how they interact.
______________________
FROM: https://hyperledger-fabric.readthedocs.io/en/latest/pluggable_endorsement_and_validation.html
core.yaml(@"peers") can declare also a mapping between the endorsement/validation logic name and the implementation to be run
</html>
