<html>
<head>
   <meta charset="UTF-8">
   <title>XXXX Map</title>
<style>
*[important]    { font-weight: bold; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv *[xxxsmall]{ font-size:1rem; }
#zoomDiv *[ xxsmall]{ font-size:1rem; }
#zoomDiv *[  xsmall]{ font-size:1rem; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[topic] {background-color:#FFFFFF; min-width:5%; max-width:10%; font-size: 1rem;}
td[summa] {background-color:#FAFAFA; min-width:30%; max-width:30%; }
td[col1]   {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; }
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
   /* Notes:
    * The name (and number) of columns 'topic', 'summa', 'col1', 'col2' is arbitrary.
    * Change at will. For example for development projects there could be a column for each 
    * software life-cycle similar to:  
    * topic -> summary -> documentation -> development -> testing/CI -> deployment -> QA
    * WARN: Don't forget to change the css too.
   */

  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td topic >topic</td> 
  <td summa >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>

  </td>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2  >
  Ex.1:
     <pre xxsmall>
     ...
     </pre>
  </td>
  <td >
     <table subtable1>
     <tr subtable1>
       <td subtable1></td>
       <td subtable1></td>
       <td subtable1></td>
     </tr>
     </table>
  </td>

</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>
<tr header_delimit {>
  <td topic >topic</td>
  <td summa >summa</td>
  <td col1  ></td>
  <td col2  ></td>
</tr>
<tr {>
  <td topic ><a href='https://www.tensorflow.org/'>Tensor Flow</a></td>

  <td summa >
    <ul>
      <li>
You might think of TensorFlow Core programs as consisting of two discrete sections:<br/>
    - Building the computational graph<br/>
    - Running the computational graph
      </li>
      <li>TensorBoard: display pictures of the Computational graph </li>
    </ul>
  </td>
  <td col1  >
    <pre>
import tensorflow as tf
    </pre>
  </td>
  <td col2  ></td>
</tr }>
<tr header_delimit {>
  <td colspan=4 >Building blocks</td>
</tr>

<tr {>
  <td topic >tensor</td>
  <td summa >
    <ul>
      <li>
    A tensor consists of a set of primitive values shaped into an array of any number of dimensions. <br/>
      </li>
      <li>tensor rank = number of dimensions</li>
      <li></li>
    </ul>
  </td>
  <td col1  ></td>
  <td col2  ></td>
</tr }>


<tr {>
  <td topic >Session</td>
  <td summa >
    <ul>
      <li></li>
    </ul>
  </td>
  <td col1  >
    <ul>
      <li>
        <pre { >
sess = tf.Session()
# init is a handle to TF sub-graph initializing
# all the global variables
init = tf.global_variables_initializer()
sess.run(init)
        </pre }>
      </li>

  </td>
  <td col2  ></td>
</tr }>

<tr {>
  <td topic >(Graph Tensor) Node</td>
  <td summa >
    <ul>
      <li>Each node takes zero or more tensors as inputs and produces a tensor as an output.</li>
      <li>constant node: takes no inputs, outputs a value it stores internally. </li>
      <li>Operations are also nodes</li>
    </ul>
  </td>
  <td col1  >
    <ul>
      <li>create two floating point constants node1 and node2:
        <pre { >
node1 = tf.constant(3.0, dtype=tf.float32)
node2 = tf.constant(4.0) # tf.float32 implicit
sess.run([node1, node2])
> [3.0, 4.0]
node3 = tf.add(node1, node2)
sess.run(node3)
> [4.0]
        </pre }>
      </li>
      <li>Variables (trainable model)
        <pre { >
W = tf.Variable([ .3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)
#                ^initial value 
x = tf.placeholder(tf.float32)
linear_model = W * x + b
session.run(linear_model, {x:[1,2,3,4])
> [0. 0.30000001 0.60000002 0.90000004]
# y: input data
y = tf.placeholder(tf.float32)
<p important>
# A loss function measures how far apart 
# the current model is from provided data (y)
squared_deltas = tf.square(linear_model - y)
loss = tf.reduce_sum(squared_deltas)
sess.run(loss, {
  y: [0, -1, -2, -3],
  x: [1, 2, 3, 4]
})
> 23.66
</p>

        </pre }>
      </li>
   </ul>

  </td>
  <td col2  >
   <ul>
      <li>Manual fix loss function
        <pre { >
fixW = tf.assign(W, [-1.])
fixb = tf.assign(b, [1.])
sess.run([fixW, fixb])
sess.run(loss, {x: [1, 2, 3, 4], y: [0, -1, -2, -3]})
> 0.0
        </pre }>
      </li>
   </ul>
  </td>
</tr }>

<tr {>
  <td topic >Computational Graph (CG)</td>
  <td summa >
    <ul>
      <li> A CG is a series of TensorFlow operations arranged into a graph of nodes.
      </li>
      <li>placeholders: used to parameterize external inputs (promise of value provided later)
        <pre {>
a = tf.placeholder(tf.float32)
b = tf.placeholder(tf.float32)
adder_node = a + b  # + provides a shortcut for tf.add(a, b)
input={a: 3, b: 4}
sess.run(adder_node, feed_dict=input)
> 7
input={a: [1, 3], b: [2, 4]}
sess.run(adder_node, feed_dict=input)
[3., 7.]

        </pre }>
 
</li>
      <li>
        To make the model trainable, we need to be able to
        modify the graph to get new outputs with the same input.
        Variables allow us to add trainable parameters to a
        graph. They are constructed with a type and initial value:
      </li>
      <li></li>
      <li></li>
    </ul>
  </td>
  <td col1  >
graph=[node1, node2]
sess.run(graph)
  </td>
  <td col2  ></td>
</tr }>

<tr {>
  <td topic >Training (tf.train)</td>

  <td summa >
    <ul>
      <li>
      </li>
    </ul>
  </td>
  <td col1  >
    <pre>
    </pre>
  </td>
  <td col2  ></td>
</tr }>

</table>
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 


-->
<!--
ma: https://www.tensorflow.org/get_started/get_started
-->

<!--
keras.io:
high-level neural networks API, written in Python and capable of running on top of TensorFlow, CNTK, or Theano. 
It was developed with a focus on enabling fast experimentation. Being able to go from idea to result with the least possible delay is key to doing good research.

__________________
aidu, the Chinese Internet giant, has released ApolloScape, a massive dataset for autonomous vehicle simulation and machine learning.

ApolloScape is an order of magnitude bigger and more complex than existing similar datasets such as Kitti and CityScapes. ApolloScape offers 10 times more high-resolution images with pixel-by-pixel annotations, and includes 26 different recognizable objects such as cars, bicycles, pedestrians and buildings. The dataset offers several levels of scene complexity with increasing number of pedestrians and vehicles, up to 100 vehicles in a given scene, as well as a wider set of challenging environments such as heavy weather or extreme lighting conditions. The ApolloScape dataset is a work in progress, and this release corresponds to the first subset, which contains 144k image frames.

The ApolloScape dataset is part of version 2 of Apollo, Baidu's open autonomous driving platform. The Apollo source code, open sourced under an Apache-2.0 license, includes a 2D/3D simulation driving vehicle environment as well as hardware instructions to set up a vehicle for further data collection. Clear instructions can be found in the Apollo GitHub project to help install the simulation environment within a Docker environment.

This dataset will be used to boost research on automated-learning tasks such as finding the roads (Drivable Area Segmentation), detecting the objects (Road Object Detection), allowing model generalization for different locations or weather conditions (Domain Adaptation of Semantic Segmentation) and tracking moving objects (Instance-level Video Movable Object Segmentation).

These research tasks make up the Workshop on Autonomous Driving (WAD) Challenge sponsored by Baidu and taking place next June during CVPR 2018, the IEEE International Conference on Computer Vision and Pattern Recognition. The WAD challenge regroups researchers and engineers across academia and industries to discuss computer vision applications in autonomous driving.

According to ArsTechnica, Waymo, the self-driving unit of Google parent company Alphabet, is currently leading the global innovation in autonomous vehicles along with GM, while Baidu is for the time being viewed more as a contender in the automated driving sector. Opening up the ApolloScape dataset could be interpreted as a move by Baidu to weaken Google's data advantage and increase its own relative position in the industry.

To that effect, Baidu further announced it has joined the Berkeley DeepDrive (BDD) Industry Consortium, a top-tier research alliance which includes Ford, NVIDIA, Qualcomm, and General Motors. BDD focuses on innovations in deep reinforcement learning, cross-modal transfer learning applied to autonomous driving.

Baidu has also partnered with Udacity, an online data-science education website, to launch on online course titled Intro to Apollo which is part of Udacity’s nano degree on self-driving cars. The course start date has not yet been set.

KPMG’s 2018 Index on Autonomous Vehicles Readiness ranks China at number 16 in terms of the 20 countries preparedness for an autonomous vehicle future. Baidu is one of three major Chinese autonomous driving companies along with JingChi.ai and Pony.ai.
-->
</html>
 







