<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Interledger Map(v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->

<table style='width:100%'>
<tbody>
<tr>
  <th colspan=3 header_delimit>Interledger</th>
  <td colsep></td>
  <th colspan=3 header_delimit>building blocks</th>
</tr>
<tr>
<td>
  <a href="https://interledger.org/">interledger.org</a>:<br/>
  <ul xxxsmall zoom >
  <li> open protocol suite for sending distributed payments across different ledgers, not tied to any one company, blockchain, or currency</li>
  <li>
<pre xxxsmall zoom>
        INTERLEDGER       INTERNET 
          (ILP)             (IP)
        ARCHITECTURE "vs" ARCHITECTURE
┌───────────┬────────────────┬─────────────┐
│Application│SPSP  HTTP-ILP  │HTTP SMTP .. │
├───────────┼────────────────┼─────────────┤
│Transport  │  IPR    PSK    │ TCP   UDP   │
├───────────┼────────────────┼─────────────┤
│Interledger│      ILP       │          IP │
├───────────┼────────────────┼─────────────┤
│Plugin     │BLP             │   Ethernet  │
│           │ILP-over-HTTP   │   WiFi      │
├───────────┼────────────────┼─────────────┤
│Harware    │ledger/connector│host/router  │
└───────────┴────────────────┴─────────────┘
</pre>
  </li>
  </ul>

  <span>ILP Timeline Evolution:</span
  <a href="https://github.com/interledger/rfcs/pull/266">REF:</a><br/>
  <ol xxxsmall zoom >
    <li>Interledger as a SETTLEMENT System (ORIGINAL VIEW) <br/>
      <ul>
        <li>ILP cryptography support on settlement ledgers.</li>
        <li>Ledgers will have support for conditional transfers and are fast enough.</li>
        <li>Trust-lines are an unusual type of ledger.</li>
      </ul>
    </li>
    <li>Interledger as a CLEARING System (CURRENT VIEW September 2017+)<br/>
      <ul>
        <li>connectors as central actors acting as "clearing houses"</li>
        <li>NORMAL CASE: connectors have some credit/trustlines relationship with each other. ILP payments go through them</li>
        <li>UNUSUAL CASE:  You send every transfer through some ledger</li>
        <li>ILP: try to standardize the clearing protocol<br/>
           entitities needed by connectors to clear payments: [transfers, fulfillments, rejections, quotes, route broadcasts]<br/>
           <b>"""settle is completely divorced from clearing payments""".</b>
        </li>
      </ul>
    </li>
    <li>The Internet *WITH* VALUE (FUTURISTIC VIEW) <br/> 
      <ul>
        <li>LAYER 0: ability to send paid paquests(requests), and conditionally paid paquets(requests)</li>
        <li>LAYER 1: ILP Address namespace to route packets</li>
        <li>LAYER 2: Data on top of ILP. Ability to send/receive paid data by just connecting to the ILP network.
            (Stream services, PaaS, ....)</li>
        <li><span cite> (Evan Schwartz)"""...An argument here is that the reason IPv6 didn't really take off
         was because it offered relatively minor improvements over IPv4. In contrast, ILP introduces the ability
         to send value as well as information and the ILP Addresses are much more flexible even than IPv6 addresses."""</span>
        </li>
      </ul>
    </li>
  </ol>
</td>
<td>
<span>Links of Interest</span>
<ul xxxsmall zoom >
<li><a href="https://github.com/interledger/rfcs">RFCs</a>,
    <a href="https://github.com/interledger/rfcs/issues">RFCs issues</a> and
    <a href="https://github.com/interledger/rfcs/pulls">RFCs Pull Requests</a>
</li>
</ul>
<span>Tutorials and guides:</span>
<ul xxxsmall zoom >
  <li><a href="https://github.com/interledger/rfcs/blob/master/0020-explain-like-im-five/0020-explain-like-im-five.md">Explain like I'm five</a></li>
  <li><a href="https://interledger.org/tutorials/">https://interledger.org/tutorials/</a></li>
  <li><a href="https://github.com/interledger/rfcs/blob/master/0019-glossary/0019-glossary.md">Glossary</a></li>
  <li><a href="https://github.com/interledger/interledger/wiki">Interledger Wiki</a></li>
  <li>(Partially outdated)<a href="https://www.slideshare.net/Interledger/interledger-workshop-berlin-1-june-2017/120">Interledger Presentation @ Workshop Berlin</a></li>
  <li><a href="https://www.crypto101.io/">https://www.crypto101.io/</a> free introductory course on cryptography for programmers of all ages</li>
  <li><a href="https://interledger.org/interledger.pdf">Original white paper</a> ("Outdated", -many, many changes from the original vision-)</li>
</ul>

<span>Community channels:</span>
<ul xxxsmall zoom >
<li>Chat: <a href="https://gitter.im/interledger/">https://gitter.im/interledger/</a>(talk here to Interledger developers and protocol architecs)</li>
<li><a href="https://lists.w3.org/Archives/Public/public-interledger/">public-interledger@W3C mailing list</a>(low activity)</li>
<li><a href="https://lists.hyperledger.org/pipermail/hyperledger-quilt/">Hyperledger Quilt@Linux Foundation</a>(Talk here to Java Quilt developers) </li>
<li><a href="https://interledger.org/community.html">More info</a></li>
</ul>
<span>Community meetings</span>:
<ul xxxsmall zoom >
<li><a href="https://bluejeans.com/795795755">General ILP Protocol Biweekly community meetings -bluejeans-</a> (Windows/Android/iPhone)</li>
<li><a href="https://zoom.us/j/976595524">Java "Quilt" Developpers meeting @zoom.us</a></li>
</ul>
</td>
<td>
<span>Development Links</span>
<ul xxxsmall zoom >
  <li><a href='https://github.com/interledger/rfcs/tree/master/asn1'>Binary ASN1 Definition of ILP packets</a></li>
  <li><a href="https://github.com/interledgerjs">GitHub repositories for (reference Implementation) NodeJS code</a></li>
  <li><a href="https://github.com/hyperledger/quilt/">GitHub repositories for Java implementation ("Hyperledger Quilt")</a></li>
  <li><a href="https://w3c.github.io/webpayments/proposals/interledger-payment-method.html">Interledger Payment method for W3C browser Payment API</a></li>
  <li>NodeJS Tooling:
    <ul>
      <li><a href='https://code.visualstudio.com/'>Visual Code Studio</a> is the recomended IDE for NodeJS development</li>
      <li><a href='https://github.com/earizon/utility_shell_scripts/blob/master/node_wrapper.sh'>node_wrapper.sh</a> allows to easely run NodeJS in a dockerized enviroment (and change the default node version used if needed)</li>
    </ul>
  </li>
  <li>Java Tooling:
    <ul>
      <li>IntelliJ, Eclipse or Netbeans have been used with no major problems.<br/>
          IntelliJ is recomended when using Kotlin</li>
    </ul>
  </li>
  </li>
</ul>

<span>Testing</span>
<ul xxxsmall zoom >
 <li><span>who is in TestNet</span> 
     <a href='http://connector.land/?test=yourdomain.com#/ledgers'>http://connector.land/?test=yourdomain.com#/ledgers</a>
  (your node will appear if you add it through the '?test=')<br/>
  <br/>
  - Michael test ledgers: 'gar.michielbdejong.com.' AND 'zup.michielbdejong.com.'
 </li>
 <li><a href='https://github.com/interledger/interledger/wiki/The-Interledger-Testnet-of-Testnets-(IToT)'>Testnet-of-Testnets WiKi</a></li>
 <li><a href="https://github.com/interledger/interledger/wiki/Testnet-of-Testnets-design">Testnet desing</a></li>
 <li><a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jul/0024.html'>e-mail Michiel de Jong</a>
    """As discussed ..., we started building a testnet. You
      can now choose your node's home ledger to be part of live network (prefix `g.`) or
      testnet (prefix `test.`). We ask everybody who runs a connector to situate their 
      connector firmly on one side of that divide, so either you connect only between `g.` ledgers, or
      you connect only between `test.` ledgers. """
 </li>
 <li>
   <a href='https://gist.github.com/michielbdejong/0cec98ab8f1798cd26198f98cca50958'>michielbdejong@testnet-of-testnets.md</a>
   list different testing faucets for 
   <a href="https://testnet.manu.backend.hamburg/faucet">BTC</a>,
   <a href="https://ripple.com/build/ripple-test-net/">XRP</a>,
   <a href="https://www.rinkeby.io/">ETH</a>,
   <a href="http://ltc.makejar.com/">LTC</a>,
   <a href="https://faucet.testnet.z.cash/">ZCASH</a>
   and test-case scenarios from simplest to the more complex ones:
   <ol xxxsmall zoom >
    <li>baseline: pay to any testnet</li>
    <li>step 1: baseline connector</li>
    <li>step 2: multi-hop</li>
    <li>step 3: end-to-end</li>
    <li>step 4: routing</li>
    <li>step 5: sender-paychan</li>
    <li>step 6: receiver-paychan</li>
    <li>step 7: bidirectional-paychan</li>
   </ol>
 </li>
 <li>"Ping" people at <a href='https://gitter.im/interledger/Lobby'>Gitter Lobby</a> to set up peering!</li>
</ul>
</td>
<td colsep> </td>
<td>
  <span><a href='https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md'>RFC-0015 ILP Address</a></span>
  <ul xxxsmall zoom >
    <li>Every ledger or blockchain account is asigned a "mostly unique"<code>ILP Address</code>.<br/>
        Since there is no central authority goberning ILP address asignation collision between ILP addresses is
        possible but that collision will be detected soon since payments are also protected by sha256 hashes.
        (An ILP payment arriving to wrong recipients will not match the pre-acorded sha256 hash)
    </li>
    <li>ILP addresses provide a mechanism to route payments to their intended destination through a 
        recursive series of ILP network nodes</li>
    <li><code>Destination Addresses</code> are complete addresses that can receive payments, always mapping to
        one account in a ledger</li>
    <li><code>Addresses Prefixes</code> are INcomplete addresses representing a group of destination addresses,
        or a connector node</li> 
    <li>See <a href='https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md'>
        for more info about different type of addresses, allocation schemes, requirements and REGEX</li>
  </ul>
  <span>External Links</span>
  <ul xxxsmall zoom >
    <li><a href='https://github.com/interledger/rfcs/blob/master/asn1/InterledgerTypes.asn'>ASN1 Type def</a></li>
    <li><a href="https://github.com/interledger/rfcs/issues/31">Proposal: ILP Address Mapping</a></li>
    <li><a href="https://github.com/interledger/rfcs/issues/77">Proposal: Connector forwarding/delivery distinction</a></li>
    <li><a href="https://github.com/fluid-money/ilp-connector-java/wiki/A-Survey-of-Interledger-Account-Identifiers">ILP Account ID Format Survey</a>(explains the different <br>representations for unique AccountID)</li>
    <li>Mailing Threads <a href="https://lists.w3.org/Archives/Public/public-interledger/2016Dec/0001.html">1</a></li>
    <li><a href="https://github.com/interledger/rfcs/issues/132">Addressing small ledgers/currencies</a></li>
    <li><a href="https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/InterledgerAddress.java">InterledgerAddress.java</a></li>
  </ul>
  <span>Trust-lines / Payment Channels</span>
  <ul xxxsmall zoom >
    <li>Trust-line: Virtual ledger established amongst peers that keeps a
      temporal balance that periodically gets sincronised with the (real)
      settlement ledger<br/>
      Trus-lines can be divided into:
      <ul>
        <li>asymmetrical trustline: ledger with two account holders,
          and one of them is also the ledger administrator.</li>
        <li> symmetrical trustline: ledger with two account holders,
          who collaborate on an equal basis to administer the 
          ledger between them.</li>
      </ul>
    </li>
    <li>Payment-channel: A trust-line with the support of 
      a blockchain or cryptographic system to secure/enhance
      payments.<br/>
      Lightning and <a href="https://ripple.com/build/payment-channels-tutorial/">
      Ripple XPR Channels</a> are two well known examples.<br/>
      More info and theory about them can also be found in the
      <a href="https://en.bitcoin.it/wiki/Payment_channels">Bitcoin wiki</a>
    </li>
  </ul>
  <span><a href="https://github.com/interledger/rfcs/blob/e949d28c19936e379e8fb5e6579b070ac66c018a/0000-payment-pointers/0000-payment-pointers.md">RFC-PR: Payment pointers</a></span> (and <a href="blob/e949d28c19936e379e8fb5e6579b070ac66c018a/0000-payment-pointers//0000-payment-pointers.md">P.R.</a>)

  <ul xxxsmall zoom >
    <li>standardized identifier for accounts that can <b>RECEIVE</b> payments.<br/>
    <li>A payment pointer can be resolved to an "https" URL that provides
       the location of a payment setup service endpoint
       (previous step to payment)</li>
    <li>(design goal): It's used for (pre)payment setup protocols BUT 
        it should be possible for any new payment setup protocol to "reuse"
        payment pointers.</li>
    <li>
      <p>The syntax of a payment pointer is (ABNF):
<pre>
  "$" host path-abempty
</pre>
      The corresponding URL will be
<pre>
  "$" host path-abempty 
</pre>
(empty path-abempty is replaced by <a href="https://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml">/well-known</a>/pay)

      Examples:
<pre>
$myWebShop.com/invoice/123
  -> https://myWebShop.com/invoice/123
$myWebShop.com 
  -> https://myWebShop.com/.well-known/pay
</pre>
      </p>
    </li>
  </ul>
</td>
<td>
  <span><a href='https://github.com/interledger/rfcs/blob/master/0003-interledger-protocol/0003-interledger-protocol.md'>RFC-0003 ILP Protocol</a></span>
<pre xxxsmall zoom>
Sender        Connector 1     Connector 2      Receiver
      STEP 1: Payment SETUP
├ ←── sender and receiver agree on payment ───→ ┤
│     amount, destination address and           │
│     condition (=sha256 of fulfillment)        │
...                                            ... 
      STEP 2: START ILP Payment
├── sendData──→ │               │               │
│               ├── sendData──→ │               │
│               │               ├── sendData──→ │
│               │               │←─ fulfillment─┤
│               │←─ fulfillment─┼─ sendMoney──→ │
│←─ fulfillment─┼─ sendMoney──→ │               │
├─ sendMoney──→ │               │               │
</pre>
  <span>Code references</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledgerjs/five-bells-condition/blob/master/src/lib/condition.js'>five-bells-condition/src/lib/condition.js</a></li>
  <li><a href='https://github.com/interledgerjs/five-bells-condition/blob/master/src/lib/fulfillment.js'>five-bells-condition/src/lib/fulfillment.js</a></li>
  <hr/>
  <li><a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/Condition.java'>Condition.java</a></li>
  <li><a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/Fulfillment.java'>fulfillment.java</a></li>
  </ul>

  <span>Quoting (protocol)</span>
  <ul xxxsmall zoom > 
  <li> 
  Allow senders to determine exchange rate between
  their assets (for example USD) and the receiver's 
  assets (for example EUR) before making a payment
  </li> 
  </ul> 

  <span>digits/precision/scale</span>
  <ul xxxsmall zoom >
  <li>decimal_digits: a hint for GUIs, the conventionally displayed number of decimal places for a given asset.</li>
  <li>Precision: number of digits in a number.</li>
  <li>Scale: number of digits to the right of the decimal point in a number.</li>
  <li>Examples:<br/>
     - 123.45 has a precision of 5 and a scale of 2<br/>
     - a USD ledger might use a precision of 15 and a scale of 6 and 2 decimal_digits
  </li>
  </ul>
</td>
<td>
  <span><a href='https://github.com/interledger/rfcs/blob/master/0003-interledger-protocol/0003-interledger-protocol.md#interledger-protocol-ilp'>Interledger Payment</a></span>
  <ul xxxsmall zoom >
    <li>An payment consists of an ordered (in time) list of local transfers between connectors.</li>
    <li>The execution of each local transfer is coordinated by the ILP protocol</li>
    <li>REMOTE TRANSFERS + SETTLEMENT diagram using escrow + cryptoconditions
<pre>
┌───┬────────────────────────────────┬───┬───────────────────────────────────┐
│   │ LOCAL TRANSFERS @ LEDGER1      │ C │ LOCAL TRANFERFS @ LEDGER 2        │
├───┼────────────────────────────────┤ O ├───────────────────────────────────┤
│   │                                │ N │                                   │
│↓  │                                │ N │                                   │
│T 1│ sender → (amount1) → hold      │ E │                                   │
│I 2│                                │ C │ connector → (amount2) → hold      │
│M 3│                                │ T │ hold      → (amount2) → recipient │
│E 4│ hold   → (amount1) → connector │ O │                                   │
│↓  │                                │ R │                                   │
└───┴────────────────────────────────┴───┴───────────────────────────────────┘
↑                ↑                                      ↑
│                └── amount1 (inbound ammount) must ────┘
│                be greater than amount2 (outbound ammount)
│                  for the connector to have any profit 
│
└ local transfers 1, 2: PREPARE   PHASE 
local transfers 3, 4: EXECUTION PHASE 
</pre>
    </li>
    <li>In the PREPARE PHASE the crypto-condition is "linked" to the payment
  and execution is conditioned to receiving the fulfillment 
  (fulfillment == "cryptographic receipt") before a timeout
    </li>
    <li>In the universal (non-atomic) mode it's possible for a timeout
       in ledger1 in step 4 after step 3 is executed properly in ledger 2.
       In that case ledger 2 looses money.
    </li>
    <li>An external "clock" (notary, orderer, oracle in blockchain nomenclature or transaction manager -DDBB nomenclature-) is needed for full atomic-mode</li>
  </ul>
  <span>MULTIHOP CASE</span>
  <ul xxxsmall zoom>
  <li>
<pre>
boxes represent local ledger TXs or trust-line rebalance
amt1 = ammount1, amt2 = ammount2, amt3 = ammount3

    LEDGER1       CON1         CON2      LEDGER2   LISTENING
     |           |←TrustLine→|           |        APP for dst
┌──────────────┐ |           |           |         account
│send→amt1→hold│ |           |           |            |
└──────────────┘ |           |           |            |
     +-sendData-→|           |           |            |
     |           |-sendData-→|           |            |
     |       ┌─────────┐ ┌─────────┐     |            |
     |       │IOY-=amt2│ │IOY+=amt2│     |            |
     |       └─────────┘ └─────────┘     |            |
     |           |           |-sendData-→|            |
     |           |           |    ┌──────────────┐    |
     |           |           |    │con2→amt3→hold│    |
     |           |           |    └──────────────┘    |
     |           |           |           |-condition-→|
     |           |           |           |←fulfillm---|
     |           |           |    ┌──────────────┐
     |           |           |    │hold→amt3→dst │
     |           |           |    └──────────────┘
     |           |           |           |
     |           |           |←fulfillm--|
     |           |←fulfillm--|           |
     |       ┌─────────┐ ┌─────────┐     |
     |       │IOY+=amt2│ │IOY-=amt2│     |
     |       └─────────┘ └─────────┘     |
     |←fulfillm--|           |           |
┌──────────────┐ |           |           |
│hold→amt1→con1│ |           |           |
└──────────────┘ |           |           |
</pre>
  </li>
  <li>inbound amount decreases from hop to hop. If it get lower than destination amount in the ILP header payment will be rejected.</li>
  <li>For connector 1/2 to have profit (and mitigate risk if payment is not atomic):
        <code>ammount1 greater than ammount2 greater than ammount3</code>
  </li>
  </ul>
  
  </td>
</tr>
</table>
<table>
<tr>
<td>
<span>Trust relationships in Universal (non-atomic) Mode</span>
<ul xxxsmall zoom >
  <li>
-extracted from Michiel de Jong's comment on Gitter (Nov 02 19:46)-<
<pre xxxsmall zoom>
INTERLEDGER ROLES := 
  SENDER, LEDGER, CONNECTOR, RECEIVER
Trust relationships:
sender    trusts ledger    with its balance
receiver  trusts ledger    with the payment amount
receiver  trusts connector with the opportunity cost
                           of trying a payment
                           that may fail *1
connector trusts ledgers   with its balances
connector trusts [sender, receiver, connectors] 
                           with the opportunity cost 
                           of trying a payment.
</pre>
  </li>
  <li>'TRUSTLESS CONNECTORS' refers to the fact that senders and receivers
   don't trust connectors with any actual value (except opportunity cost in case the connector fails)
  </li>
</ul>
</td>
<td>
<span><a href='https://github.com/interledger/rfcs/blob/master/0022-hashed-timelock-agreements/0022-hashed-timelock-agreements.md'>0022-Hashed Timelock Agreements</a></span>
(HTLC), which is the Bitcoin/Lightning Network term for conditional
transfers where the conditions and timeouts are enforced by the ledger.<br/>
<ul xxxsmall zoom >
<li>Hashed Timelock Agreements is a generalization of the idea of a Hashed Timelock Contract</li>
<li>Hashlocks and timeouts can be enforced by ledgers or they can be upheld by senders
    and recipients themselves. (In ILPv4+ a ledger is considered just another connector)</li>
</ul>

    Technology vs Complexity vs Risk 
<pre  xxxsmall zoom>
                        Conditional        Ledger Escrow      Simple Payment    Trustlines
                        Payment Channels  (using HTLCs)           Channels
                          (with  HTLCs)
--------------------------------------------------------------------------------------
Ledger Support Required   High             High                   Medium          Low 
Implementation Complexity High             Medium                 Low             Low
Bilateral Risk            Low              Low                    Medium          High

</pre>
 <span>documentation links</span>
 <ul xxxsmall zoom >
   <li><a href='https://github.com/interledger/rfcs/blob/9a4ffd6ff0f47dd3a9655332f2221f6240c21e3b/0000-hashed-timelock-agreements.md'>RFC-PR</a></li>
   <li><a href='https://www.youtube.com/watch?v=8zVzw912wPo&t=951s'>[Video] Lightning & Payment Channels Explained</a></li>
   <li><a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0009.html'>1</a></li>
   <li><a href='https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-1464710791/'>
       UNDERSTANDING THE LIGHTNING NETWORK, PART 1: BUILDING A BIDIRECTIONAL BITCOIN PAYMENT CHANNEL</a>
   </li>
   <li><a href='https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-creating-the-network-1465326903/'>
       UNDERSTANDING THE LIGHTNING NETWORK, PART 2, CREATING THE NETWORK</a>
   </li>
   <li><a href='https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-completing-the-puzzle-and-closing-the-channel-1466178980/'>
       UNDERSTANDING THE LIGHTNING NETWORK, PART 3: COMPLETING THE PUZZLE AND CLOSING THE CHANNEL</a>
   </li>
   <li>
       <a href="http://dev.lightning.community/overview/">Lightning Overview</a>
   </li>
 </ul>
</td>
<td>
<span>Error Handling</span>
<ul xxxsmall zoom >
  <li>Errors may be generated at any point as an Interledger payment is being prepared or by the receiver.</li>
  <li>Connectors that are notified of an outgoing transfer being rejected MUST reject the corresponding
      incoming transfer with the same error</li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/0003-interledger-protocol/0003-interledger-protocol.md'>ILP Protocol(Errors Section)</a></li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/0003-interledger-protocol/0003-interledger-protocol.md#ilp-error-format'>ilp-error-format</a></li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/0003-interledger-protocol/0003-interledger-protocol.md#ilp-error-codes'>ilp-error-codes</a></li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/asn1/InterledgerProtocol.asn'>Error ASN.1 bin.format</a></li>
  <li>Non expected errors like "division-by-zero", "null-pointers", "asserts to false", ... will be returned as internal errors (if triggered by
      the connector) or application errors (if triggered by external applications handling connectors incomming payments) </li>
</ul>
<span>Java development Links</span>
<ul xxxsmall zoom >
  <li>
    <a href='https://github.com/hyperledger/quilt/blob/refactor/ilpv4/ilp-core/src/main/java/org/interledger/core/InterledgerErrorCode.java'>InterledgerErrorCode.java</a>,
    <a href='https://github.com/hyperledger/quilt/blob/refactor/ilpv4/ilp-core/src/main/java/org/interledger/core/InterledgerProtocolException.java'>InterledgerProtocolException.java</a> and 
    <a href='https://github.com/hyperledger/quilt/blob/refactor/ilpv4/ilp-core/src/main/java/org/interledger/core/InterledgerRejectPacket.java'>InterledgerRejectPacket.java</a>
    @ quilt/ilp-core
  </li>
  <li>Example error processing:
<pre>
new InterledgerProtocolException(
    InterledgerRejectPacket.builder()
    .code(InterledgerErrorCode.T00_INTERNAL_ERROR)
    .triggeredBy(parentConnector.config.ilpAddress)
    .data(e.getCause()!=null?e.getCause().
    toString().getBytes():e.toString().getBytes())
    .build());
</pre>
  </li>
</ul>
<span>JavaScript development Links</span>
<ul xxxsmall zoom >
  <li><a href='https://github.com/interledgerjs/ilp-packet/blob/master/index.ts'>ILPError@ilp-packet/index.js</a></li>
</ul>
</td>
<td>
  <span>Tunning TIMEOUTS in UNIVERSAL (non-atomic) mode</span>
  <ul xxxsmall zoom >
  <li>Timeout scenario:
<pre>
      sender -> connector1 -> connector2 -> receiver
              |           |            |  <-fulfill- |
+10 msecs     |           | <-fulfill- |             |
+ 3  secs  timeout     timeout         |             |
</pre>
      If the fulfillment arrives to connector2 it will execute pending on-hold money from connector1, but since the fulfillment arrives late to connector1, both sender and connector1 (that were waiting for up to a timeout for the fulfillment response) will rollback. Sender gets its money back but connector1, that was already paid to connector2, is not rewarded and looses money.
  </li>
  <li><a href="https://lists.w3.org/Archives/Public/public-interledger/2017Jul/0027.html">Mail thread</a></li>
  <li>Avoiding timeouts warrants atomicity for the distributed transaction. Nothingless, the default mode of operation just warrants that
          "most" of the times the transaction will be atomic except for a few scenarios where race-condition can arise.<br/>
         Extracted from <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0055.html'>Alternative Algorithm for Timeouts</a>
         """It's possible that at some point there is an overload in the destination ledger. At this point the average time to process
            the incomming transfer, executing and returning the fulfillment will increase approaching the initial timeout.
            The closer it is to the timeout the more probable for race condition during the "travel back"."""<br/>
         Different solutions exists for safe (timeout-free) solutions, like using an external clock acting as "notary" or "judge"
         deciding deterministically when a payment timed-out or not. Also "very big" timeouts will suffice.
  </li>
  </li>
  <li>
     Setting correct timeouts in essential for proper network performance.<br/>
     Using "big timeouts" will be safer but will block money in the escrow and decrease the liquidity<br/>
     We also want to minimize the risk or race-condition when payment is fulfilled in the receiving ledger
     but rejected on the sending ledger due to a timeout in the window-time when the fulfillment is
     returning back to the originating (sending) ledger.
  </li>
  <li>
     <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Aug/0027.html'>ref</a>
     """... the ILP packet already has an expiry.
     It's implemented in the PSK details so the receiver knows whether the
     packet it issued is still valid. But that's an application layer concern,
     because it's only the receiver who looks at the ILP packet's expiry. The
     connectors only need to know the expiries of the local transfers..."
  </li>
  <li>
     <ul>
     <li>See retry policy in <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/executeSourceTransfer.js'>executeSourceTransfer.js</a></li>
     </ul>
  </li>
  </ul>
</td>
<td>
  <span>Atomic mode (AM)</span>
  <ul xxxsmall zoom >
    <li>Standard Universal Mode introduces risks to connectors due to race-conditions (See topic "Tunning TIMEOUTS").</li>
    <li>Atomic mode warrants ACID transfers through all the ledgers BUT is not 
        yet part of the standard ILP RFCs.</li>
    <li>Extracted from <a href="https://github.com/interledger/rfcs/blob/master/0007-atomic-transport-protocol/0007-atomic-transport-protocol.md">
     <span cite>"""The Atomic mode outlined in the Interledger whitepaper may be
      used within segments of an Interledger payment path amongst groups of connectors
      and ledgers that support the required functionality. In an open system of 
      interconnected ledgers, it seems unlikely that all parties in a payment path
      would have commonly trusted entities between them that could serve as notaries.
      The protocols used within specific groups need not be standardized because the
      failure to select commonly trusted notaries would prevent interoperability anyway"""</span>
    </li>
  </ul>
  Different approached exist:
  <ul xxxsmall zoom >
  <li><a href='https://en.wikipedia.org/wiki/Two-phase_commit_protocol'>Two-phase commit protocol</a></li>
  <li>Threshold conditions (extension of multisignature conditions). 
    <p cite>
        from <a href='https://github.com/hyperledger/quilt/issues/101'>Issue #101</a>:
        """(David Fuelling) In atomic-mode, the local-ledger transfers use threshold conditions (among other things) to wrap Preimage conditions used in the ILP packet."""
    </p>
    <p cite>From <a href='https://tools.ietf.org/html/draft-thomas-crypto-conditions-03'>Crypo-condtions draft</a>
        """Crypto-conditions elegantly support weighted multi-signatures and
         multi-level signatures.  A threshold condition has a number of
         subconditions, and a target threshold.  Each subcondition can be a
         signature or another threshold condition.  This provides flexibility
         in forming complex conditions."""
    </p>
  </li>
  <li>
    See (Re:) Atomic Payments thread in w3c list started by Ryan Fugger
    <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/thread.html'>June</a>,
    <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Aug/thread.html'>August</a>
    Extracted from Stefan Thomas <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0040.html'>reply</a>:
    <p cite>....we haven't abandoned the ideal insofar ...
       we still want any many payments as possible to be atomic ...
       we cannot assume that atomic mode will always be available.<br/>
       ... all participants along the payment chain have to have full
       unconditional trust in the notary ... in order to be able to use
       atomic mode all of the time, there must be at least one notary that 
       is trusted by all people in the world. Otherwise, we may
       run into situations where a liquidity path is available, but no valid
       notary can be selected.<br/>
       
       It is possible to use multiple notaries in a payment, but that actually
       doesn't make the trust problem easier and arguably makes it harder... 
       then we now need all participants to trust notaries such that none 
       of the notaries they trust would ever collude with any other notary they trust.
       <br/>
       ...
       <b>It is possible to use atomic mode in the context of a universal mode
       payment. Any number of participants can decide to make the transfer between
       them subsidiary to some notary. If all the participants do that,
       congratulations, the payment is fully atomic.<br/>
       
       SO THE IDEA IS TO DEFAULT TO UNIVERSAL MODE AND USE ATOMIC WHERE POSSIBLE
       </b>
       
       Ripple is currently building a proprietary network for banks that uses
       atomic mode internally and universal mode externally.<br/>
       
       ...XRP Atomic Mode Autodetection (XAMA). The idea is to allow participants in 
       a payment to detect that XRP is used as one of the hops and then defer to
       the outcome of the XRP transaction instead of using their own timeouts, 
       effectively making the XRP Ledger a de-facto notary.
        This can be generalized as a defer-right and defer-left behavior.
        Any neighboring pair of participants (:= sender|receiver|connector) can
       - by mutual agreement - decide to defer the outcome of their
       transfer to whatever the outcome on the ledger right of them or the ledger
       left of them.<br/>
  </li>
  <li>and from Adrian-Hope <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0059.html'>reply</a>:<br/>
  <span cite>
In my experience to date, it's most often people familiar with existing
payment systems that want atomic mode. I think that in time <b>we'll find that
complete end to end atomicity comes at a cost that is not justified for a
lot of payments.</b><br/>

<b>... There are operational costs that must be covered but ... the cost to 
move the bytes from A to B to make a payment is certainly nowhere
near the 1% and up that most payments cost to send.</b><br/>

<b>In a world where ILP is a foundational layer ...  it's still possible
 for someone to send a payment at almost zero cost if they accept the 
 associated risks.</b>
</span>
  </li>
  <li>
About New ILP architecture <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Aug/0018.html'>From Adrian Hope</a>
<div xxsmall>
<p> Ledger layer components don't have to understand ILP unless they choose to
re-use the condition for their own local transfer. Ledgers themselves
*never* have to understand ILP.</p>

<p>Remember a ledger layer protocol could use a completely different
conditional payments scheme, like atomic mode ILP, where it takes the
end-to-end condition and creates a new compound condition that depends on
the fulfillment and some notary signature.</p>
  </li>
  </ul>
</td>
</tr>
<!-- } BUILDING BLOCKS END -->
</table>

<table>
<!-- CONNECTOR PROTOCOLS START { -->
<tr>
  <th header_delimit colspan=3>CONNECTOR PROTOCOLS</th>
  <td colsep></td>
  <th header_delimit colspan=3>TRANSPORT PROTOCOLS</th>
  <td colsep></td>
  <th header_delimit colspan=3>APPLICATION PROTOCOLS</th>
</tr>
<tr>
<td>
  <span><a href="https://github.com/interledger/rfcs/pull/349">ILP-over-HTTP</a></span>
  <ul xxxsmall zoom >
  <li>
<pre xxxsmall zoom>
REQUEST:
&gt; POST / HTTP/1.1
&gt; ILP-Destination: g.crypto.bitcoin.....
&gt; ILP-Condition: x73kz0AGyqYqhw/c5LqMhSgpcOLF3rBS8GdR52hLpB8=
&gt; ILP-Expiry: 2017-12-07T18:47:59.015Z
&gt; ILP-Amount: 1000
&gt;
(end-to-end binary data body 32767 Bytes max)
    
NOTE: ILP-Expiry and ILP-Amount change at each "hop"

RESPONSE:
PAYMENT "OK"             | PAYMENT ERROR
-------------------------+-----------------------------------
&gt; HTTP/1.1 200 OK        | &gt; HTTP/1.1 400 Bad Request
&gt; ILP-Fulfillment: ...   | &gt; ILP-Error-Code: F02
&gt; Content-Length: 0      | &gt; ILP-Error-Name: no route found
&gt;                        | &gt; ILP-Error-Triggered-By: g.xrp...
                         | &gt; ILP-Error-Message:
                         | &gt; Content-Length: 0
                         | &gt; 
</pre>
  </li>
  </ul>

  <span>Development Links</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/michielbdejong/ilp-plugin-http/blob/master/index.js'>NodeJS implementation</a></li>
  <li><a href='https://github.com/everis-innolab/ilp-everconnector/blob/master/src/main/java/org/everis/interledger/plugins/ILPOverHTTPPlugin.java'>Everconnector Plugin</a></li>
  </ul>
</td>
<td> 
  <span><a href='https://github.com/interledger/rfcs/blob/master/0023-bilateral-transfer-protocol/0023-bilateral-transfer-protocol.md'>RFC23 Bilateral Transfer Protocol BTP</a> </span>
  <ul xxxsmall zoom >
  <li>previously Common Ledger Protocol CLP</li>
  <li>@michielbdejong 
    <span cite>"""BTP is just a wrapper around ILP packets that makes it 
    easier to send them over WebSockets...<br/>
    ... I guess the advantage of HTTP is that it's easier (to implement).
    The Advantage of WebSockets is that it allows a client (so a computer 
    that's not publicly addressable, e.g. a laptop or phone) to be a receiver,
    and that some JavaScript-based connectors may only support WebSockets 
    (but if a JavaScript-based connector wants to peer with a Java-based one,
     it would be easy to add ilp-plugin-http)"""
    </span></li>
  <li>Generic BTP plugin base class for ILP: 
    <a href="https://github.com/interledgerjs/ilp-plugin-btp/issues/2">ilp-plugin-btp issue:</a>
    (only prepare / fulfill / reject needed must be implemented in ILPv4)<br/>
    <span cite>
      <p>In the readme, we should explain that this plugin implements "BTP/2.0"
        (if that's what we want to call it), and is 
      <a href="https://github.com/interledgerjs/ilp-plugin-btp/blob/master/index.js#L343">incompatible</a> with BTP/1.0.
      </p>
      <p>
      Also, we need to explicitly document (since it's so confusing) that the new 
      Transfer/Response/Error sequence <strong>decreases</strong> (settles) the 
      sender's <code>unsecuredAmount</code>.
       This is the opposite of how in BTP/1.0 the Prepare/Fulfill/Reject sequence
      used to <strong>increase</strong> (cause) the sender's <code>unsecuredAmount</code>,<br>
      see <a href="https://github.com/interledger/rfcs/pull/360#issuecomment-355737129">interledger/rfcs#360 (comment)</a>.<br/>
       It would be easy to oversee this difference, and think that Transfer/Response/Error is just the unconditional version 
      of Prepare/Fulfill/Reject. Or maybe we should just say "forget everything you think you know about BTP". :)   
      </p>
    </span>
  </li>
  <li>Can be used in place of ILP-over-HTTP</li>
  <li>"""In lots of scenarios, we don't have an underlying ledger that's fast enough to do every ILP payment on-ledger.
       If two parties want to transact, they can send transfers directly to one another with BTP. BTP requires that
       the two parties trust one another (up to a limit) for funds that have not yet been settled on the underlying ledger.
       If their trust limit is high enough, the two parties can transact without settling on an underlying ledger at all."""<br/>
      (from Quilt chat: """BTP is just a wrapper around ILP packets that makes it easier to send them over WebSockets.
       So our first choice is, do we want Quilt to use WebSockets or HTTP for its API? I would vote for HTTP. """</li>
  <li>C&P from Adrian Hopes comment:<br/>
        <span cite>The single-JS-stack/plug-in architecture is limiting in that it is difficult to re-use
            these ledger integrations in other stacks.  <br/>
            Fortunately we recently we came to consensus on a common wire protocol to use between nodes
            called the Bilateral Transfer Protocol (BTP)."""</li>
  <li>ILP does not depends on BTP</li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/asn1/BilateralTransferProtocol.asn'>ASN.1 def</a></li>
  <li>glossary:
    <ul>
      <li>**BTP Connection**: websocket connection over which BTP packets are
        sent. Websockets (as opposed to raw TLS sockets) are used because they provide
        message framing and can be used from the browser.
      </li>
      <li>**BTP Packets**: protocol data units formally defined in ASN.1</li>
      <li>**Peers** are the parties on a BTP connection. Your peer is the party on the
          other side of the BTP connection.</li>
      <li>**Bilateral Ledger**: (not to be confused with the **Underlying (settlement) Ledger**)
          ledger which the peers on a BTP connection are keeping track of.
          When a peer keeping Authoritative State receives a BTP
          packet, they process it and adjust their copy of the bilateral ledger.
      </li>
      <li>**Authoritative State**: authoritative view of the Bilateral Ledger's
      state, maintained by one (one peer must the other ) or both of the peers
      (they can get into dispute due to timeouts+race-conditions)</li>
      <li>**request is In-Flight**: if the request has been sent out, but no response has been sent yet</li>
      <li>**transfer is In-Flight**: if it has been prepared but not yet fulfilled nor rejected</li>
      <li>**Underlying Ledger**: moves value between the two peers when they settle their balance</li>
    </ul>
  </li>
  <li>BTP Sub-protocols include optional functionality like ledger
      metadata, balance, automated settlement, and dispute resolution.<br/>
  </li>
  </ul>

  <span>Doc.Links</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledger/rfcs/blob/726705c99d0324d352ab698eb618ae28d369eef1/00XX-bilateral-transfer-protocol/00XX-bilateral-transfer-protocol.md'>GitHub PR</a></li>
  <li><a href='https://github.com/interledger/rfcs/blob/master/0023-bilateral-transfer-protocol/0023-bilateral-transfer-protocol.md'>PR291 for RFC</a></li>
  </ul>

  <span>Dev.Links</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledgerjs/btp-toolbox/branches'>BTP-toolbox</a> for building and debugging with the BTP</li>
  <li>I'm using the tf-connector repo to set it up. What do we need to do to connect ?
    Michiel de Jong @michielbdejong Jan 29 21:42 @rhuairahrighairidh cool! i think you
    could configure an ilp-plugin-btp instance with { server: 'btp+wss://:<token>@amundsen.ilpdemo.org:1801' }
    and relationship 'parent'. i haven't tried tf-connector myself yet, though,
    so let us know if you run into any trouble configuring that!
  </li>
  </ul>
</td>
<td>
  <span><a href='https://github.com/interledger/rfcs/blob/master/0010-connector-to-connector-protocol/0010-connector-to-connector-protocol.md'>RFC-0010 Connector to Connector protocol CCP</a></span>
  <ul xxxsmall zoom >
  <li>Protocol for updating conectors routes (vs. handling "money" transfer)</li>
  <li>Connectors discover their peers through out-of-band communication 
      (configuration files at start-up), or by looking at 
      <code>https://connector.land</code> and contacting the administrator of 
      another connector.</li>
  <li>Once peered, two connectors have a bilateral (vs settlement) ledger between them;
      this is often a ledger with just two accounts  often administered collaboratively 
      by the two connectors.</li>
  <li>
      <p>
        Extracted from Gitter chat:<br/>
        """Q: Regarding the CCP protocol, it's ussing json in the RFC as well as in the ilp-connector implementation.<br/>
        On the Amundsen connector I see a reference to a binary CcpPacket that doesn't look to be yet used.<br/>
        Is there any plan to change to Binary, stay with JSON or something else? """
        """A: @michielbdejong Nov 09 16:33<br/>
        despite the name 'packet', the routebroadcast-over-BTP proposal (which hasn't really been used yet in practice),
        is also JSON: https://github.com/interledgerjs/amundsen/blob/master/src/protocols.js#L59<br/>
        however, the updated proposal is this:
        <a href='https://github.com/interledger/interledger/wiki/Interledger-over-BTP#changes-to-ccp-sub-protocol'>
        https://github.com/interledger/interledger/wiki/Interledger-over-BTP#changes-to-ccp-sub-protocol
        </a> (basically, define the 'custom' protocol, which adds a level of nesting)
      </p>
      <p>Extracted from the wiki:
        <h2>Changes to <code>ccp</code> sub-protocol</h2>
        <p>To be decided, but probably the <code>ccp</code> sub-protocol will be deprecated
           in favor of the new <code>custom</code> sub-protocol, to be used with contentType 
           MIME_APPLICATION_JSON, and exactly like currently implemented in 
           <a href="https://github.com/interledgerjs/ilp-connector">https://github.com/interledgerjs/ilp-connector</a>
           version 21.1.10. See an example of the <code>custom</code> field in 
           <a href="https://github.com/interledger/rfcs/blob/master/0021-plugin-rpc-api/0021-plugin-rpc-api.md#send-request-routing">
             https://github.com/interledger/rfcs/blob/master/0021-plugin-rpc-api/0021-plugin-rpc-api.md#send-request-routing</a>.
           This is for the 'routes' packet, but the 'request full table' packet gets deprecated, as it will now 
           piggy-back on route broadcasts, like implemented in
           <a href="https://github.com/interledgerjs/ilp-connector/commit/7e4189de27640e02de336331ff6c4f6a617a6fed">
           https://github.com/interledgerjs/ilp-connector/commit/7e4189de27640e02de336331ff6c4f6a617a6fed</a>
      </p>
  </li>
  </ul>
</td>
<td colsep></td>
<td>
   Basic of ILP Transport Protocols
   <ul xxxsmall zoom>
   <li>A critical function of Interledger Transport Protocols is to determine 
     the path exchange rate and handle any changes in the rate.</li>
   <li>Senders SHOULD judge amounts and prices only in their own units
     using the calculated path exchange rate, because destination units can
     be manipulated by the receiver (by using a connector with an exchange
     rate they control).</li>
   <li>Implementations SHOULD use the ratio of the amount that arrived at the 
     remote endpoint and the amount sent to determine the path exchange rate. 
     They MAY send an unfulfillable test packet when the connection is 
     initiated to estimate the path exchange rate.</li>
   </ul>
</td>
<td>
  <span>Interledger Payment Request (IPR)</span>
  <ul xxxsmall zoom >
    <li>End-to-end transport protocol in which the receiver of an Interledger payment first 
    communicates a request for payment to the sender. A method is proposed for receivers 
    to generate payment requests such that they can verify incoming payments without storing
    all outstanding requests.</li>
    <li>This protocol is binding (non-repudiable). See PSK for an alternative non-binding(repudiable) protocol.<br/>
    </li>
  </ul>

  <span>Document. Links</span>
  <ul xxxsmall zoom >
    <li><a href='https://github.com/interledger/rfcs/blob/master/0011-interledger-payment-request/0011-interledger-payment-request.md'>RFC</a></li>
    <li><a href='https://github.com/interledger/rfcs/blob/master/asn1/InterledgerProtocol.asn'>Payment ASN.1 bin.format</a></li>
  </ul>

  <span>Development Links</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledgerjs/ilp'>ILP Client</a>includes an IPR client
      <a href='https://github.com/interledgerjs/ilp/blob/master/src/lib/ipr.js'>@src/lib/ipr.js</a></li>
  </ul>
</td>
<td>
  <span><a href="https://github.com/interledger/rfcs/blob/master/0025-pre-shared-key-2/0025-pre-shared-key-2.md">RFC 0025 Pre-Shared Key(PSK)v2</a></span>(replaces RFC 0016 PSK)
<pre  xxxsmall zoom>
Pre-Shared Key Transport Protocol (PSKv2)
--- setup --
note: server is probably an SPSP right now "pointed" by a payment pointer
client ←→ server : setup encrypted (HTTPS) channel
client ←→ server : exchange PSK version, 32-byte random shared secret *1, receiver ILP address
note: *1: See also <a href="https://github.com/interledger/rfcs/blob/master/0016-pre-shared-key/0016-pre-shared-key.md##appendix-a-recommended-algorithm-for-generating-shared-secrets">Appendix: Recommended algorithm fro generating sahred secrets</a>

ENCRYPTION: AES-256-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a>
</pre>
  <ul xxxsmall zoom >
  <li>The full PSK_data is encoded into byte-streams to form the data portion of the 
     <a href='https://github.com/interledger/rfcs/blob/master/asn1/InterledgerProtocol.asn'>ILP Payment Packet</a>
  </li>
  <li><span TODO>Update v2 changes over PSK v1</span><br/>
    <a href='https://gist.github.com/emschwartz/235ac5bdfcd0a6b07315a248c0cd84ee'>Motivation for changing PSK2 Draft 1</a><br/>

    <span cite>Draft 1 of PSK2 attempts to support both streaming and chunked payments.
      However, it includes some features that are only useful for chunked payments and
      does not include some others that would be needed for a proper chunked 
      payments implementation.<br/>
      Based on a conversation with @sharafian (summarized <a href="https://gist.github.com/emschwartz/235ac5bdfcd0a6b07315a248c0cd84ee">here</a>),
      this proposes narrowing the scope of PSK2 while making it easier
      to build use cases like streaming and chunked payments on top.
    </span><br/>
    <a href="https://github.com/interledger/rfcs/pull/384">PSK v2 PR: Remove chunked payments from PSKv2</a><br/>
    <p>When streaming payments, it makes more sense to have
    a completely stateless receiver that has a single callback to handle all incoming chunks,
    and applications will want more direct control over how they determine whether to
    accept or reject individual packets. Also, we wanted to
    <a href="https://github.com/interledgerjs/ilp-protocol-psk2/issues/5">support application data</a> 
    but PSKv2 did not go all the way to implementing segmentation and reassembly like TCP.
    (<a href="https://github.com/sentientwaffle" class="user-mention">@sentientwaffle</a> 
    also asked the first time he read the spec why we didn't separate the chunked 
    payments part from the rest of PSKv2)
    </p>
    <p>This change simplifies the protocol and includes only the features necessary for:</p>
    <ol>
      <li>Generating the conditions and fulfillments from a shared secret</li>
      <li>Encrypting and authenticating request and response data</li>
      <li>Providing the sender a way to indicate to the receiver the minimum
          amount they should get to accept a given packet.</li>
    </ol>
    This is implemented in
       <a href="https://github.com/interledgerjs/ilp-protocol-psk2/pull/19">interledgerjs/ilp-protocol-psk2#19</a>
  </li>
  </ul>

  <span>Documentation Links</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledger/rfcs/blob/master/0016-pre-shared-key/0016-pre-shared-key.md'>RFC</a></li>
  <li><a href='https://github.com/interledger/rfcs/issues/197'>Issue 197 Should public headers be removed from PSK?</a></li>
  </ul>

  <span>Development Links</span>
  <ul xxxsmall zoom >
  <li>The<a href='https://github.com/interledger/rfcs/blob/master/0016-pre-shared-key/0016-pre-shared-key.md'>RFC</a> contains pseudo-code for both the sender and receiver of the payment</li>
  <li><a href='https://github.com/interledgerjs/ilp/blob/master/src/lib/psk.js'>ilp/src/lib/psk.js</a></li>
  <li> <a href='https://github.com/interledgerjs/ilp'>ILP Client</a>includes an PSK client</li>
  <hr/>
  <li><a href='https://github.com/hyperledger/quilt/tree/development/src/main/java/org/interledger/psk'>org.interledger.psk@java-ilp-core</a><br/>
        <a href='https://github.com/interledger/java-ilp-core/pull/54'>This PR 54</a> refactors PSK builders/interfaces to follow same patterns, decouples encrypt/decrypt from encoding/decoding, ...
  </li>
  <li><a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/psk/PskContext.java'>PskContext.java</a><br/> contains the context for Sender, Receiver. Notice the SenderPskContext can genrate the fulfillment (and so it can NOT probed that he didn't create it).
  </li>
  <li> <a href='https://github.com/hyperledger/quilt/tree/development/src/test/java/org/interledger/psk'>Java Tests</a></li>
  </ul>
</td>
<td colsep></td>
<td colspan=2>
  <span><a href='https://github.com/interledger/rfcs/blob/master/0009-simple-payment-setup-protocol/0009-simple-payment-setup-protocol.md'>SPSP</a></span><br/>
  <ul xxxsmall zoom >
  <li>Before starting an ILP payment senders ("wallets") needs to know the destination ILP address and
     the amount. SPSP is one high-level protocol used for that purpose.</li>
  <li><a href="https://github.com/interledgerjs/ilp/blob/master/test/spsp.test.js">SPSP tests@interledgerjs/ilp</a>></li>
  <li>Simple Payment Setup Protocol to create "input" condition to initiate an ILP payment.</li>
  <li>The flow of payment can be similar to:
<pre>
client → webshop: browse catalog and click on pay
webshop → client: SPSP payment pointer
client ←→ payment pointer: Agree payment-data:
            [ILP destination address , amount]
-- ILP Payment --
client → local connector: sendData(payment-data)
...
client ← local connector: fulfillment (payment receipt) OR ILP error
</pre>
  </li>
  <li>SPSP may be used by end-user applications, such as a digital wallet with a user interface 
      for the sender to initiate payments.</li>
  <li>SPSP is NOT enforced and other protocols and/or procedures can be used</li>
  </li>
  <li>Any SPSP receiver will run an SPSP server and expose an HTTPS endpoint called the SPSP payment pointer.</li>
  <li>SPSP uses the Pre-Shared Key v2(PSK2) transport protocol for condition generation and data encoding</li>
  <li>SPSP ussually is "good enough" because the payment sender can present the
    fulfillment to connectors to probe that the payment was recieved by the recipient even 
    if it wasn't ... but he will not win much with that. He will just loose his money  
    The receiver can not probe the opposite but he just received money for free.<br/>
    <br/>
    IPR is just needed in some "corner" scenarios when the receiver could be fined 
    because un-intentionally he received the money and he was obligated
    to declare the error to some authority. 
    IPR is "slightly" safer, 100% non-repudiable, but takes more message rounds 
    between sender and receiver and so it less suitable for small payments. 
  </li>
  <li>custom mime-type: "application/spsp+json"</li>
  </ul>

  <span>Docu.Links</span>
  <ul xxxsmall zoom >
  <li>
    <a href='https://github.com/interledger/rfcs/issues/220'>Open issue: spsp: emphasize need to use a different shared_secret each time</a>
    """ <code>shared_secret</code> needs to be different each time someone queries the public spsp endpoint. 
        ... avoid broken implementations ... if someone else gets to see the same shared_secret as you,
        then it's no longer secret."""
  </li>
  <li><a href='https://github.com/interledger/rfcs/issues/152'>Closed issue: How SPSP should look like?</a>(How to split methods?, How invoices work?, Can we query with URL instead of a webfinger acct?, Should SPSP use SSP or IPR?,...)</li> 
  <li><a href='https://github.com/interledger/rfcs/blob/master/asn1/InterledgerPaymentRequest.asn'>ASN.1 bin.def.</a></li>
  </ul>

  Development links
  <ul xxxsmall zoom >
  <li><a href='https://github.com/sharafian?utf8=%E2%9C%93&tab=repositories&q=ilp-spsp&type=&language='>(sharafian@Ripple) SPSP JS implementation</a> using PSK2.<br/>
      Note: (WIP)  <a href='https://github.com/interledgerjs/ilp-protocol-psk2'>PSK2 JS implementation</a>
  </li>
  <li>(Follows the (maybe outdated) SPSP+PSK v1? links)
    <ul>
    <li><a href="https://github.com/jgallare/java-spsp-client-spring">Juan Carlos Gallardo Initial Java+Sprint SPSP Client@Github</a></li>
    <li>Evan Schwartz <a href='https://github.com/emschwartz/cicada'>Cicada</a> "Minimal" ILP/SPSP server for receiving payments</li>
    <li><a href='https://github.com/interledgerjs/ilp'>ILP Client</a>includes an SPSP client 
        <a href='https://github.com/interledgerjs/ilp/blob/master/src/lib/spsp.js'>@ilp/src/lib/spsp.js</a>
    </li>
    <li><a href='#java-spsp-client'>java-spsp-client</a></li>
    </ul>
  </li>
  </ul>

  TESTING:
  <ul xxxsmall zoom>
  <li> Launch SPSP service</span><br/>
<a href="https://github.com/interledger/tutorials/blob/53b6930b158d5921add604346cc319d97dc1bf02/payment-pointer/index.md">Payment-pointer tutorial</a>
<pre>
1 Create your payment pointer:
$ npm install -g <b>ilp-spsp-server</b>
$ DEBUG=* ilp-spsp-server \
  - -subdomain michielbdejong

2 Pay yourself
$ npm install -g ilp-spsp
$ DEBUG=* ilp-spsp send - \
  -receiver '$michielbdejong.localtunnel.me' \
  - -amount 100

Expect:
You should see something like:
 paying 100 to "$michielbdejong.localtunnel.me"...
 sent!
</pre>
  </li>
  <li><a href="https://github.com/emschwartz/ilp-butterfly">ILP-Butterfly Minimal browser ILP/SPSP client</a></span></li>
  <li><a href="https://github.com/emschwartz/ilp-butterfly">ILP-Butterfly Minimal browser ILP/SPSP client</a>
  Fully client-side app for sending Interledger payments from the browser.<br/>
    It uses the <a href="https://github.com/interledgerjs/ilp">ILP Client</a> and the
  <a href="https://github.com/interledgerjs/ilp-plugin-payment-channel-framework">ILP Plugin RPC</a>
  to send Interledger payments from the browser. <br/>
  </li>
<!--
    <ol>
      <li TODO>Update to use isolated (non ilp-kit) service</li>
      <li>Clone git
<pre small>
$ git clone https://github.com/interledgerjs/ilp-kit
</pre>
      </li>
      <li>Lunch docker instance with an script similar to: cat launch_ilp_kit_docker.sh 
<pre small>
#!/bin/sh
PWD=`pwd`
VOLUME="-v ${PWD}:/usr/src/app" 
CONTAINER_NAME="ilp-kit-everis"
OPTS=""
OPTS="$OPTS -ti"
OPTS="$OPTS -p 3100:3100 $OPTS -p 3010:3010 "
# OPTS="$OPTS -p 9229:9229 "
# OPTS="$OPTS -p 9222:9222 "
OPTS="$OPTS -p 8080:8080 "
OPTS="$OPTS $VOLUME "
IMAGE="interledgerjs/ilp-kit:latest"
sudo docker run $OPTS ${IMAGE} bash
</pre>
      </li>
      <li>Init Postgresql database with:
<pre small>
cat setupPostgresql.sh 
#!/bin/sh

sed -i "s/md5$/trust/" /etc/postgresql/9.4/main/pg_hba.conf 
/etc/init.d/postgresql start
sleep 2

SQL_FILE="/tmp/init_database.sql"
cat <<EOF >$SQL_FILE
CREATE USER ilpkit WITH PASSWORD 'ilpkit';
CREATE DATABASE ilpkit;
GRANT ALL PRIVILEGES ON DATABASE ilpkit TO ilpkit;
GRANT ALL PRIVILEGES ON DATABASE ilpkit TO postgres;
EOF

psql -U postgres -h 127.0.0.1 -f $SQL_FILE
</pre>
      </li>
      <li>Launch API like:
<pre small>
cat launch_api.sh 
#!/bin/sh

export DEBUG=true
export NODE_PATH=./api 
export NODE_ENV=production 
node debug bin/api.js
</pre>
      </li>
    </ol>
-->
  </li>
  </ul>
</td>
<td>
  <span>Fragment/Stream payments</span>
  <ul xxxsmall zoom >
  <li><a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0022.html'>1</a></li>
  <li>Testing: <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jul/0009.html'>Setting up a testnet</a></li>
  </ul>

  <hr/>

  <span><a href="https://github.com/interledger/rfcs/pull/309">RFC PR ILQPv2</span>
  <ul xxxsmall zoom >
  <li><a href='https://github.com/interledger/rfcs/pull/309'>PR #309: Replace ILQP with End-to-End Quoting</a></li>
  <li>primarily designed for individual payments (vs streams payments)</li>
  <li>It allows a sender to determine the exchange rate between their ledger and the receiver's ledger "on demand" (just before starting the payment).</li>
  <li><a href='https://github.com/interledger/rfcs/pull/309'>PR #309: Replace ILQP with End-to-End Quoting</a></li>
  <li>end-to-end protocol implemented by Interledger senders and receivers (not connectors, in contrast to ILQPv1)</li>
  <li>ILQPv2 assumes all connector exchange rates are linear and that there are no fixed fees (no Liquidity Curves)</li>
  <li>Senders may use a dedicated quoting module or ILQPv2 may be included in a Transport Layer protocol</li>
  <li>
<pre>
sender -> receiver: specially crafted 
                    test payment
receiver -> sender: reject + specific 
                    error message
</pre>
  </li>
  <li>connectors MUST ignore the amount in the ILP Packet, and neither attempt to deliver the exact amount in the packet or reject payments where the transfer amount is lower than the amount in the packet and MUST relay error messages back to the sender.
  </li>
  <li>Model of Operation:
  <ul>
  <li>Fixed Source Amount ("if I send this much, how much will the receiver get?"):
<pre>
sender → sender:+ILP "crafted" packet:
                   {dst address,
                    amount=0,
                    condition="crafted",
                    data=u"ILQP/2.0\n...."}
sender → connector:+TX:
                   {amount=fixed_by_src,
                    ILP crafted packet}
connector → receiver: ILP packet
receiver → connector: reject 
                     + amount received 
                     + TX expiresAt
connector → sender: reject 
                     + amount received 
                     + TX expiresAt
sender → sender: Inspect error.ammount
sender → sender: +ILP packet with
                  estimated fixed_src_amount
</pre>
Note: connectors recognizing the specially crafted condition MAY "forward" the payment without actually reserving funds, since they know the payment will not be executed.
  </li>
  <li>Fixed Destination Amount:<br/>
    (Same as fixed source amount but initial TX amount is set to arbitrary probe value.  </li>
  </ul>
  </li>
  </ul>
</td>
<td>
  <a href="https://github.com/interledger/rfcs/blob/master/0028-web-monetization/0028-web-monetization.md">Web Monetization browser API</a>
  <ul xxxsmall zoom> 
  <li>ILP micropayments to monetize a site. </li>
  <li>Is Not a W3C Web Payments API</li>
  <li>Web Monetization makes use of Payment Pointers in order to associate a 
   site with an ILP destination, and SPSP in order to set up ILP payments.</li>
  <li>
<pre>
Flow
browser → web: visit page
browser ← web: html + JS
browser → JS:  run
JS      → JS: check window.monetize is defined
JS      → monetize: Promise = monetize({ receiver /*payment pointer*/ })
monetize→ UI: ask user to pay
monetize← UI: "OK"
monetize→ ??: initiate ILP payment
---
If confirmation of receipt is required,
the backend which provides the SPSP server can be queried.
</pre>
  </li>
  </ul>
</td>
</tr>
</table>

<table>
<tr>
  <th colspan=5 header_delimit>ILP code stack</th>
</tr>
<tr>
  <td>
  <b>JS and NodeJS</b>
  <span><a href="https://github.com/interledgerjs/ilp-plugin-payment-channel-framework">ilp-plugin-payment-channel-framework</a></span>

  <ul xxxsmall zoom >
  <li>Framework for creating payment-channel based ILP ledger plugins, 
  including a framework for attaching on-ledger settlement mechanisms.</li>
  <li>"""Any ledger protocol author can definitely fork BTP, or 
       design something completely different from scratch.<br/>
       However, as we've found writing ledger plugins, it's much easier to
       use something like the payment channel framework than implement everything
       yourself. That framework will be changed to use the BTP as the base protocol
       and allow individual plugins to add custom messages (in the same way you can
       add custom RPC methods now) and custom data to existing messages (in the same
       way you can add custom arguments to existing RPC calls now). The benefit of
       allowing for multiple plugin types is that we don't have to standardize this
       layer. But as we've seen from experience it's way easier to implement plugins
       if you can reuse something like that framework that does 80% of the work for
       you (and avoids common gotchas)"""
  </li>
  <li>From <a href='https://github.com/interledger/rfcs/pull/263'>RFC PR263</a></li>
  <li><a href='https://github.com/interledgerjs/ilp-plugin-payment-channel-framework'>GitHub</a></li>
  <li></li>
  <li></li>
  </ul>
  <a href="https://github.com/interledger/interledger/wiki/Architecture">REF: ILP Architecture</a>
  <ul xxxsmall zoom >
  <li>Early on in the project the goal was to define a standard interface for "ledgers" which would abstract away the functions of a particular ledger and expose the functions required of a sender, receiver or connector. Given that the technology of choice for the majority of contributors at the time was Javascript, this was done in Javascript and described in <a href="https://interledger.org/rfcs/0004-ledger-plugin-interface/" rel="nofollow">IL-RFC 4 the Javascript Ledger Plugin Interface</a></li>
  <li>
    Subsequently a number of Javascript plugins have been developed that expose this interface including:</p>
    <ul>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-bells">ilp-plugin-bells</a> for the reference Five Bells Ledger (pre-ILPv4)</li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-btp">Plain account (BTP; no settlement)</a></li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-mini-accounts">Plain asymmetric server (BTP; no settlement)</a></li>
    <li>(See Ripple in Blockchains section for more info about Ripple Network XRP support)t)</li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-ethereum">ilp-plugin-ethereum</a> for Ethereum<br/>
       I'll work on https://github.com/sharafian/ilp-plugin-ethereum-asym-server this week.
       Can you try using https://github.com/sharafian/ilp-plugin-ethereum-asym-client ?<br/>
       Michiel de Jong @michielbdejong Feb 26 14:43 I think I'll try to use Machinomy on Rinkeby
       instead of Ropsten, see machinomy/machinomy#160 Amundsen now runs 
       https://github.com/michielbdejong/ilp-plugin-ethereum-asym-server on port 1813,
       see https://github.com/interledger/interledger/wiki/amundsen#18q1 - I'll write a
       client-side LPIv2 plugin for it and try out if it works! :)
       ...<br/>
       <a href="https://github.com/machinomy/machinomy-contracts/blob/master/contracts/Unidirectional.sol">Unidirectional.sol</a> ethereum contract for payment channels<br/>
      Michiel de Jong @michielbdejong Mar 01 11:25<br/>
      @ukstv I'm a bit stuck on sharafian/ilp-plugin-ethereum-asym-client#1 - we want to create the payment
      channel while explicitly setting the user's address and the peer address,
      see <a href="https://github.com/michielbdejong/ilp-plugin-ethereum-asym-client/blob/master/index.js#L53-L56">L53-56</a>,
      any idea how we can do that?<br/>
      Sergey Ukustov @ukstv Mar 01 11:57 @michielbdejong There is one, commented on the issue.  
    </li>
    <li><a href="https://github.com/emschwartz/ilp-plugin-ethereum-paychan">Ethereum Payment Channels</a></li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-bitcoin-paychan">ilp-plugin-bitcoin-paychan</a> for Bitcoin using payment channels</li>

    <li><a href="https://github.com/interledgerjs/ilp-plugin-virtual">ilp-plugin-virtual</a> for establishing a "Virtual" ledger between two nodes</li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-chain">ilp-plugin-chain</a> for Chain</li><br>
        <a href="https://github.com/interledgerjs/ilp-plugin-lightning">ilp-plugin-lightning</a> for Bitcoin/Litecoin lightning networks<br/>
        <a href="https://github.com/interledgerjs/ilp-lightning-demo">ILP-LIGHTNING demo</a><br/>
    </li>
    <li><a href="https://github.com/interledgerjs/ilp-plugin-stripe">ilp-plugin-stripe</a>
        Receive money in your <a href="https://stripe.com/be">Stripe</a> sandbox account, using Amundsen, Interfaucet<br/>
        Michiel de Jong @michielbdejong Jan 31 14:56 <br/>
        You can now receive money in your Stripe sandbox account, using Amundsen, Interfaucet and https://github.com/interledgerjs/ilp-plugin-stripe. <br/>
        I'll temporarily put lnd on port 1801, as we wait for more ports to be opened.
        Then, I'll put 18Q1 interface for none/stripe/flutterwave on 1810, xrp on 1811, lnd on 1812, eth on 1813.
        I'll keep Amundsen ports 1820-1829 reserved for 18Q2, etcetera.<br/>
        Adrian Hope-Bailie @adrianhopebailie 11:39<br/>
        @michielbdejong is this documented somewhere?<br/>
        Michiel de Jong @michielbdejong 13:03
        @adrianhopebailie not yet! created this: 
        https://github.com/interledger/interledger/wiki/amundsen
        -the-Interledger-testnet-bootstrap-server
    </li>
    <li><code>BTP "TO" FROG "TO" Existing ledgers</code>
      FROG wraps an existing connector plugin (for example five-bells-plugin) into a BTP connection.

      New implementations are encouraged to natively support BTP and can run alongside a ledger adaptor 
      such as Frog in the BTP Toolbox which can load ledger plugins as required and wrap
      these in a BTP interface.
    </li>
    </ul>
  </li>
  </ul>
  <a href='https://github.com/interledgerjs/ilp-connector-shard'>Connector Shard</a>
  <ul xxxsmall zoom >
  <li>
    "As pioneered by @justmoon in the ilp-connector-shard,
     this implementation assumes that each account will be managed
     by a single process. This allows the balance to be cached and
     updated in memory and enables using fast, single-process databases
     such as LevelDB or RocksDB."
     simple, good performance, easy to set up, easy to extend/reimplement,
     robust against DoS attacks, scales to many users,
     Composable (could be run with/without UI, static routes, etc,..)
  </li>
  </ul>
<td colsep></td>
<td>
  <b>JAVA</b>
  <span><a href="https://github.com/hyperledger/quilt/">HYPERLEDGER QUILT</a></span><br/>
  <div floatl >
  <ul xxxsmall zoom >
    <li>Interfaces and specs (common structs to all <br>implementations) for different ILP compliant systems</li>
    <li><a href='https://github.com/hyperledger/quilt/tree/master/crypto-conditions'>crypto-conditions</a>(only preimage (fulfillment) to sha256 (condition) is used for ILPv4 but many others exists for future or non-standard implementations -multisignature, ... - </li>
    <li><a href='https://github.com/hyperledger/quilt/tree/master/ilp-core'>ilp-core</a> Main ILP classes ilike
      <a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/InterledgerAddress.java'>ILP Address</a>,
      <a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/InterledgerException.java'>ILP Exceptions</a>,
      <a href='https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/InterledgerPacket.java'>ILP Packet</a>,
      SPSP, PSK, ILQP, ...
    </li>
  </ul>
  Documentation links:
  <ul xxxsmall zoom >
  <li><a href="https://gitter.im/interledger/java">Gitter</a></li>
  <li><a href='https://github.com/hyperledger/quilt/blob/master/architecture.md'>Architecture & Roadmap notes</a></li>
  </ul>
  <span><a href="https://github.com/everis-innolab/ilp-everconnector">ilp-EverConnector</a></span>
  <ul xxxsmall zoom >
  <li>Java Connector using CompletableFutures and VertX framework to provide "NodeJS-like" async behaviour.</li>
  </ul>
  
  <span>Configuration:</span>
  <ul xxxsmall zoom >
  <li>All config. is done through standard java properties files.</li>
  <li>At startup the config files are parsed and converted to inmutable (read only) config. objects</li>

  <li><a href="https://en.wikipedia.org/wiki/Fail-fast">fail-fast</a> <a href="https://github.com/everis-innolab/ilp-everconnector/tree/master/src/main/java/org/everis/interledger/config">configuration</a>: At startup all the configuration is "OK" or server rejects to start.</li>
  </li>
  <li>A running connector uses configuration for the connector itself and for each plugin attached to the running instance. Example:<br/>
        <a href="https://github.com/everis-innolab/ilp-everconnector/tree/master/config/dev_network/two_connectors">Example config/dev_network/two_connectors (connector1 -> connector2 -> Amundsen)</a></li>
  </ul>
  </div>
  <div floatl>
  <span>Data flow Sequence diagram:</span><br/>
  <img src="everconnector_data_flow.png" xxxsmall zoom />
<!-- everconnector_data_flow.pu
@startuml
participant "external\nclient"     as cl
participant "Vertx\n(HTTP)\nRequest\nThread" as el
participant "plugin\nin"  as p1
participant core       as co
participant forwarder  as fo
participant "local\nhandler"  as re
participant "worker\nthread\npool" as tp 
participant "plugin\nout"  as p2
participant "external\nconnector"     as co2
note over el,p1: Supposing plugin uses HTTP+Vertx

note over p1,p2:start-up 
co -> tp+: instantiate\n workers\n threadpool
co -> p1+: instantiate\n plugin\nfrom config
co -> p2+: instantiate\n plugin\nfrom config
co -> fo : instantiate\n routing\ntables
p1 -> el+: instantiate
p2 -> el+: instantiate
note over p1,p2:...wait for external data
cl -> el: payment\ndata
el -> p1: payment\ndata
p1 -> p1: initial checks
p1 -> tp: get thread from pool\n(normal scenario, data must be\n and p1 wait on pooled thread)
tp -> p1: thread1
p1 -> co: data
alt
else  destination is local
co -> re: data
re -> co: fulfillment
else  non local, forward
co -> fo: data
fo -> fo: find\nbest route
fo -> fo: match\nroute plugin
fo -> p2: data
p2 -> co2: data
co2 -> p2: fulfillment
p2 -> co: fulfillment
end
co -> p1: fulfillment
p1 -> el: fulfillment
el -> cl: fulfillment
@enduml
-->
  </div>
</td }>
<td colsep></td>
<td>
  <b>BLOCKCHAIN PLUGINs IMPL.</b><br/>
  <div floatl>
  <span><a href='https://github.com/interledger/interledger/wiki/Interledger-over-XRP'>ILP over XRP</a>(Ripple "XRP" Network) 

  <a href='../Blockchain/ripple_network_map.html'>Ripple Map</a><br/>
  JS Devel. Links
  <ul xxxsmall zoom>
  <li>ilp-plugin-xrp-asym-client</li> 
  <li><a href="https://github.com/ripple/ilp-plugin-xrp-paychan">ilp-plugin-xrp-paychan</a> for XRP using Payment Channels
      (See also: <a href"https://ripple.com/build/payment-channels-tutorial/">Ripple Payment-channels tutorial</a> using JSON-RPC API) 
  </li>
  <li>XRP Asymmetric <a href="https://github.com/interledgerjs/ilp-plugin-xrp-asym-server">Server</a>/<a href="https://github.com/interledgerjs/ilp-plugin-xrp-asym-client">Client</a></li>
  <li><a href="https://github.com/ripple/ilp-plugin-xrp-escrow">ilp-plugin-xrp-escrow</a> for XRP using XRP Escrow</li>
  </ul>

  Java Devel. Links
  <ul xxxsmall zoom >
  <li><a href="https://github.com/sublimator?utf8=%E2%9C%93&tab=repositories&q=&type=source&language=">Nicholas Dudfield(Sublimator)repos</a> including
    Java Ripple client</li>
  <li>Initial Java Support for XPR Blockchain: <a href="https://github.com/ripple/ripple-lib-java">github.com/ripple/ripple-lib-java</a> XRP client </li>
  </ul>
  </div>

  <div floatl>
  <span><a href='https://github.com/interledger/interledger/wiki/Interledger-over-ETH'>ILP over Ethereum</a></span>
  <ul xxxsmall zoom >
  <li><a href="https://github.com/sharafian/ilp-plugin-ethereum">Sharafian Ethereum</a> JS connector Plugin</li>
  </ul>
  </div>

  <div floatl>
  <span>BTC/LTC/ZCASH</span>
  <ul xxxsmall zoom >
  <li><a href="https://github.com/interledgerjs/ilp-plugin-bitcoin-paychan">Bitcoin/LiteCoin/Zcash</a> JS connector plugin</li>
  </ul>
  </div>
  </td>
</tr>
</tbody>
</table>

<table>
<th colspan=12 header_delimit>Unordered</th>
<tr>
<td>
  <a href="https://github.com/interledger/rfcs/tree/master/0018-connector-risk-mitigations">Connector Risk Mitigation: </a>
  <ul xxxsmall zoom>
  <li><span cite>When you set up an IToT node, it doesn't matter which ledger you connect
   to first. Just like it doesn't matter whether you connect to the internet
   via WiFi or Ethernet or 3G. The easiest way to set up an IToT node, so far,
   is using a NodeJS script running on your laptop, in combination with an XRP
   testnet account. First, we need an Interledger payment script. Interledger
   payments are quite simple in fact, you just need to send the generate a random
   string called the fulfillment, and then send the SHA256 hash of that fulfillment
   along with your ledger-specific transfer. If you pay to yourself then you can
   easily reply to the incoming payment from the same script, using the fulfillment
   of the SHA256 condition. ...</span><br/>
  <span cite>Evan Schwartz @ Gitter: """Connectors have a risk that their peers will not 
   settle with them for the full value of payments they've sent through. The 
   mitigations for that are to limit your exposure to whatever level you're 
   comfortable with. If your settlement mechanism is free, like payment channel
   updates, you could keep the amount you need to trust your peers for very 
   low."""</span></li>
  <li>(Extracted from RFC0029-STREAMs) To avoid storing a 32 byte secret for each connection, a server
   MAY deterministically generate the shared secret for each connection from a single server secret
   and a nonce appended to the ILP Address given to a particular client, for example by using an HMAC.
  </li>

</td>  
<td>
  <a href="https://interledger.org/tutorials/streaming-payments/">Streaming Tutorial</a><br/>
  <ul xxxsmall zoom>
  <li>
    <span cite>Just use an increasing paymentId++ (And do NOT disconnect in the outgoing_fulfill handler)<br/>
    Mid-request payments:<br/>
    - To increase speed http response with a 402 status is dropped in the shop 
    server (avoid client's disconnection), return 200 status, flush the headers,
    and stall the delivery of the body. The body will consist of the letters the
    client buys, and will keep streaming them indefinitely, until the client 
    interrupts the connection , or the server process is terminated:
    </span>
<pre>
res.writeHead(200, {
  'Pay': [
       1,
       plugin.getAccount() + '.' + user,
       base64(secret) ].join(' ')
})
// Flush the headers in a first TCP packet:
res.socket.write(res._header)
res._headerSent = true

In the client:
- res.body.pipe(process.stdout)
</pre>
  </li>
  </ul>
</td>  
<td>
  <a href="https://interledger.org/tutorials/hosted-ledgers/">ILP hosted payments</a><br/> how to use a hosted ledger to speed things up
  <ul xxxsmall zoom>
  <li>
<pre>
  __ Initial setup __
  shop devel -> shop:
     Add a ledger to the shop app.
     (private ledger / "trust-line")
  client     -> shop: open account 
  __ (stream) payment __
  client     -> shop: pay letters
    to client's account at shop.ledger
   (much faster than XRP)
</pre> 
The shop's ledger will expose version 1.0 of the Bilateral Transfer Protocol (BTP),
     optimization of the Ledger Plugin Interface (LPI), transported over a WebSocket.
     These BTP packets are similar to the objects passed to plugin.sendTransfer 
     or plugin.fulfillCondition, although they are a bit more concise, and before they
     go onto the WebSocket, they are serialized into OER buffers.
  </li>
  </ul>
</td>  
<td>
  <a href="https://github.com/interledgerjs/tf-connector/">Terraform Connector@github</a>

  <ul xxxsmall zoom >
  <li>"""instructions to run an Interledger connector. As the community creates
    more ways to deploy the connector, they'll be added to this repository.  
    These instructions are intended for people who want to take part in the 
    early Interledger network as connectors. You'll have to find other members 
    of the community to peer with, and will have to maintain your connector in 
    order to stay on the network.<br/>
    These instructions will not be perfect, so don't hesitate to ask for help in
    our Gitter. If you find any mistakes, please submit a PR to this repo to help 
    future readers."""</li>
  <li><a href="https://github.com/interledgerjs/tf-connector/#tier-1-with-xrp-and-aws">Tier 1 with XRP and AWS</a>
  <li><a href="https://github.com/interledgerjs/tf-connector/#set-up-your-domain">Set up your domain</a></li>
  <li><a href="https://github.com/interledgerjs/tf-connector/#acting-as-a-server">Acting as a server</a></li>
  <li><a href="https://github.com/interledgerjs/tf-connector/#adding-another-peer">Adding another peer</a></li>
  <li><a href="https://github.com/interledgerjs/tf-connector/#upgrading-to-ssl">Upgrading to SSL</a></li>
  </ul>
  <ul xxxsmall zoom >
  <li><a href="https://github.com/interledgerjs/tf-connector/#tier-2-with-xrp-and-aws">Tier 2 with XRP and AWS</a></li>
  <li><a href="https://github.com/interledgerjs/tf-connector/#access-your-connector">Access your Connector</a>
  </ul>
</td>  
<td>
  <a href="https://github.com/sharafian/moneyd">"Home router" for ILP payments</a>
<pre>
npm install -g moneyd
</pre>
</td>  
<td>
    Anonymous payments:
<pre xxxsmall zoom >
Adrian Hope-Bailie on Gitter:
"""A node that wants to allow anonymous senders to send
payments through it can simply require them to prefund
the payments. An implementation of this is available
using XRP Payment Channels"""
</pre>
   Chunked payments: 
<pre xxxsmall zoom >
    Evan Schwartz @ Gitter: """Chunked payments are not atomic so it is 
theoretically possible that a payment could complete 80% and then you'd need 
to get the receiver to send the money back. However, I think that case might be
more analogous to having all the internet cables between here and Japan cut 
suddenly. It's theoretically possible, and it would definitely impact our 
experience of communicating, but in practice it's not something we worry about 
on a day to day basis. If a payment completes only 80% and there's absolutely 
no liquidity to finish it, there's a decent chance that we have bigger problems
to worry about."""
</pre>
</td>  
<td>
   <b>roadmap</b>
<pre xxxsmall zoom >
Evan Schwartz @emschwartz Feb 28 16:09 @nathanawmk it's coming together 
<a href="https://github.com/interledger/interledger/issues/">here</a> 
(see the issues titled "Phase X")<br/>
Nathan Aw @nathanawmk Feb 28 16:15 @emschwartz Thanks!! 
I saw Phase 0, Phase 1, Phase 2, Phase 3. I guess we are looking at Phase 0 now?
And we are looking April as the roll out date? Is this something that I can share?
Because I am trying to get more folks interested and aware of interledger in 
this part of the world -- Singapore and Hong Kong specifically.
</pre>
</td>
<td>
  <span><a href="">W3C Web Payments &amp; Interledger</a></span><br/>
  <ul xxxsmall zoom>
  <li>
    <span cite>(Adrian Hope Bailie to <public-pyaments-wg@w3.org>, <public-interledger@w3.org>)<br/>
    Hi all, I have just pushed an updated Interledger Payment Method spec to WG repo.<br/>
  
    I have also added an explainer which you can see on the GitHub repo:
    <a href="https://github.com/w3c/webpayments/tree/gh-pages/proposals/interledger">
        https://github.com/w3c/webpayments/tree/gh-pages/proposals/interledger</a><br/>
    <br/>
    The spec is here:
     <a href="https://w3c.github.io/webpayments/proposals/interledger/">
         https://w3c.github.io/webpayments/proposals/interledger/</a><br/>
    Welcome any feedback!<br/> <br/>
    Given that Chrome have now publicly announced their intent to ship Payment 
    Handler we (the Interledger community) are looking for any Payment Handler
    implementers interested in adding support for Interledger."""</li>
    </span>
  </li>
  </ul>
</td>

</tr>
</table>

</body>
<!--

_________________________
<span xbig TODO><a href="https://github.com/interledger/rfcs/pull/347">Ledger Plugin Interface v2</span>
    <ul>
      <li>Ephemeral Transfers</li>
    </ul>
_____________________________________________

_________________
Payment Sockets Proposals (2018-02-22):
"""Here are the slides I presented on the call today about Payment Sockets:
    <a href="https://www.slideshare.net/Interledger/payment-sockets-interledger-community-group-presentation">https://www.slideshare.net/Interledger/payment-sockets-interledger-community-group-presentation</a> 
     You can find the original proposal and discussion of this protocol <a href="https://github.com/interledger/rfcs/issues/388">here</a>&nbsp;and the (work in progress) implementation <a href="https://github.com/emschwartz/ilp-protocol-paystream">here</a>. Comments and ideas are welcome!
     PS I'm interested to hear what people think about whether PSK2 and payment sockets should be combined to be PSK3 or whether they should remain separate. You can find discussion about that question <a href="https://github.com/interledger/rfcs/issues/388#issuecomment-367429050" >here</a>
____________________
ILPv4 "Enlightment"

----------- 2017-09-06 -----------
Dennis Appelt: Command line tools for SPSP and ILP.
   SPSP quote request can be piped
   Commented to add support for CLP

Per Lind: IOTA ..

BATCHs/Vauchs? Protocol (over CLP?): 
  It's described in https://github.com/interledger/interledger/wiki/Interledger-over-CLP
----------- 2017-10-04 -----------
- connectors forwading do not look at the money
- connectors delivering look at the ILP amount to ensure money is the
  "expected" => Proposal: Let receiver choose what to do with the packet
    => eliminates the distinction in the connector between "forward" and
       "delivery"
 
Evan cited some short of connector delivery vs forward related setting flag: ?is local?
 
Evan also cited a prototype to get fast and dirty with ILP (not public yet):
----------  2017-10-18 -----------
{
 The Bill and Melinda Gates Foundation just announced a major project 
they have launched which implements Interledger at its core.

There are a lot of details on the http://mojaloop.io website but I
thought it would be a good idea to give anyone in the community 
that is interested in the project, a deeper dive on this week's call.

I just blogged about it here: 
https://adrian.hopebailie.com/a-standard-for-mobile-money-interop-5e8ab75a4ad8 (including a special thanks to all of you for contributing to this community over the lat 2 years)

The code is already available on GitHub here: https://github.com/LevelOneProject/leveloneproject

Bill Gates Fundation:   Financial Services for the poor
   Kenya   : "¿empeza?" 45% of market -> network
   Tanzania: 4 o 5 mobile money providers
   Peru    : 40+   mobile money providers
   ^^^^^^ ILP to connect them all ^^^^
}

Douglas Jackson:
DFPs:?
DFSs:?

Roger Bass: ?

Scheme Layer: Rules?

Scheme operator: Central Bank (Governement) or Consortion
                  "Central Switch"


Scheme rules:
    - Central Clearing Ledger
    - National Settlement system
    - Reserves accounts used for settlement
      fraud and checks services by each participant
      central directory : look up "phone number"


------------- 2017-12-13 -------------------
{
Ledger Plugin Interface v2
https://github.com/interledger/rfcs/pull/347

ILP over HTTP
https://github.com/interledger/rfcs/pull/349

PSK v2
https://github.com/interledger/rfcs/pull/351

ILP-Kit v4
https://github.com/interledgerjs/ilp-kit
}
__________________
________________
_________________
https://github.com/sharafian/ilp-spsp-server
_________________
_________________
dora-gt Is there any material to refer about amount control, like... 
- if I want to send $10 by XRP, how to control destination amount?
- if I want the receiver to receive just $10. How to make it accurate in the higher layer without using ILQP.

Evan Schwartz @emschwartz Feb 04 19:22 @dora-gt great question. 
That type of functionality is now in the transport layer, rather than the Interledger layer:
- If you want to specify a minimum that the receiver should accept for a certain packet, 
  that can be included in the ILP Prepare data as is done in PSK2
  (https://github.com/interledger/rfcs/pull/384/files#diff-d46f90d06e8466d8aba6f793b0f26a25R167 )
- If you want to determine the path exchange rate you can send an unfulfillable test payment and 
   ask the receiver how much arrived, also done in PSK2 
  (https://github.com/interledger/rfcs/pull/384/files#diff-d46f90d06e8466d8aba6f793b0f26a25R203 ).

- The two major changes with ILPv4:
  - some of the fields moved from  Ledger Layer's transfer object UP to the ILP packet (Interledger layer)

  - some of the functionality that was in the Interledger layer was moved into the transport layer.

  We realized that you could get the same benefits from ILQP and having the fixed destination amount
  in the ILP packet without needing all of the connectors and the core of the network
  to have special functionality for that

The changes I do think affect functionality when seen from the outside, are: 

Payment Changes for ILPv4:
 +-------------------------+--------------+---------------------+
 |Dropped                  | Replaced by  | Advantage           |
 +-------------------------+--------------+---------------------+
 |fixed-destination-amount | best-effort  | no more need for    |
 |                         |              | price-based routing |
 +-------------------------+--------------+---------------------+
 | multi-dollar            | sub-dollar   | no more need for    |
 |                         |              | on-ledger escrow    |
 +-------------------------+--------------+---------------------+

______________________________
Q: Hi interledger community,

I have followed development of interledger from the inception, but i have struggled to understand all possible applications it can be used for.

I read blog post about HTTP-ILP: Paid API Calls with Interledger and I understood how beneficial this could and offer some advantages for the API project im working on.

In brief we are building merchant to wallet API. It enables mobile wallet providers to implement shopping features into their wallets
from pool of merchants, through an API we are providing.

My question is, How big of a job this is to implement with existing software and is there any example APIs that have implemented
paid API calls in production?

A: Hi @Hiirihii, welcome to the Interledger chat! For larger payments you probably want to look at the Simple Payment Setup Protocol (SPSP) https://medium.com/interledger-blog/spsp-simple-payment-setup-protocol-2028292e6925 and https://github.com/sharafian/ilp-spsp-invoice-server rather than HTTP-ILP
Sorry @nathanawmk, this isn't the place for questions about ripplenet. You can find more information about it at https://ripple.com/solutions/process-payments/ or use the contact form there to get in touch with folks that can answer questions about it
_________________
Ben Sharafian @sharafian mar. 19 23:00
https://medium.com/interledger-blog we have a new interledger blog; I've posted a couple of articles here to help people get set up with Moneyd on the testnet and SPSP
_____________________
Ruaridh
@rhuairahrighairidh
mar. 24 03:30

I'm trying to understand how the plugins handle payment channels. Wondering if this is this correct:

    plugin.connect() creates a channel via on chain transaction (if it doesn't exist already)
    plugin.sendMoney() creates and sends a paychan claim via BTP
    plugin.handleMoney() recieves paychan claims via BTP and checks they are valid
    plugin.disconnect() closes out the channel by submitting, on chain, the last stored claim

Also, do the plugins monitor their blockchain for fraudulent paychan claim submissions or is that left out for now?
Michiel de Jong
@michielbdejong
mar. 24 07:31
that looks correct! what do you mean with fraudulent submissions? the receiver only has to check that the sender's claim is valid, and submit it, right?
________________

"""Basically moneyd is an ILP connector that is pre-configured to automatically peer with any publicly reachable ILP connector. You can run a connector manually, but it's a lot more involved. It requires maintenance and configuration to keep it up to date and manage your peering relationships with other major connectors. If you want to deploy a publicly accessible connector you can follow the instructions here: https://github.com/interledgerjs/tf-connector , but you might find it tricky unless you're familiar with the stack.

If you want to run a local setup of Interledger, you can use moneyd local (https://github.com/interledgerjs/moneyd-xrp#local-test-network). That would work similarly to the configuration you proposed, in which the connector has no external connections. You can use this mode to pay between programs connected to your local moneyd instance.

If you want to run a connector that connects through XRP on the test network, you can use moneyd on the testnet (https://github.com/interledgerjs/moneyd-xrp#test-network) which will automatically manage payment channels over XRP. We're also working on Ethereum and Lightning support, although they're not in the moneyd package yet.

What do you want to do on Interledger? I can tell you which setup would make the most sense
"""
_______________________
ILP-Stream will "overseed" PSKv2
  https://github.com/interledgerjs/ilp-protocol-stream
_______________________
ILPv4:
https://github.com/interledger/rfcs/blob/mj-whitepaper-ilpv4/whitepaper/interledger.pdf
__________________________
Prefer "Loopback" (just a few lines of code) over PSK (still evolving) for transport protocol.
__________________________

_______________
Payment Pointer or SPSP Endpoint
__________________
<td>
  <a href="https://github.com/interledger/rfcs/blob/master/0029-stream/0029-stream.md">RFC-29 STREAM(Transport Pro.)</a><br/>
successor to PSK2
  <ul xxxsmall zoom>
  <li>Application Layer protocols, such as the Simple Payment Setup Protocol (SPSP)
 can use STREAM to send money and data between endpoints.</li>
  <li>Multiplexed Bi-directional Money and Data Transport for ILP for reliably
    sending multiple "logical streams" of money and data between two parties
    over ILP</li>
  <li>Designed for applications involving streaming payments or data,
    as well as those requiring sending larger discrete payments and messages</li>
  <li>A virtual connection is established between a "client" and a "server" and
    can be used to send authenticated ILP packets between them</li>
  <li>Provides connection-level flow (congestion) control, adjusting the rate
     at which money and data are sent</li>
  <li>ILP packet data Authentication and encryption</li>
  <li>Generating and fulfilling ILP packet conditions</li>
  <li>Connection migration</li>
  <li>Like PSK2, STREAM uses a shared secret to authenticate and
   encrypt multiple packets, as well as to generate the conditions and fulfillments.<br/>
    In addition, STREAM enables sending money and data in both directions between
   the two endpoints and automatically determines how much money and data can be
   sent in each ILP packet. STREAM borrows heavily from QUIC's packet format, 
   stream multiplexing, and approach to flow control.
  </li>
  <li>
<pre>DEFINITIONS 
Client    - endpoint initiating STREAM connection
Server    - endpoint accepting incoming STREAM connections
Endpoint  - client or server end of a connection, which can be the
            sender or receiver of money and/or data
            - Endpoints.ConnectionMaxStreamId indicates max. number of
              of concurrently active incoming streams supported. Must
              be indicated to the peer endpoint. Implementations SHOULD
              use a default max stream ID of 20, which allows each endpoint
              to open up to 10 concurrent streams.
            - Endpoint.StreamMaxMoney: advertises max. amount of money it's 
              willing to receive,
            - Endpoint.StreamMaxData: Advertises maximum number of bytes each 
              stream can receive.
            - Endpoints.ConnectionMaxData advertises the total number of bytes it's 
              willing to receive on a given connection summing up all streams.


Connection- The session established between two endpoints that
            uses a single shared secret and multiplexes multiple 
            streams of money and/or data
Sender    - endpoint that sends a particular ILP Prepare packet.
            Because STREAM connections are bi-directional, either
            endpoint can be the sender of a given packet
Receiver  - The endpoint that receives a particular ILP Prepare
            packet and responds with either an ILP Fulfill or
            Reject packet. Because STREAM connections are bi-directional,
            either endpoint can be the receiver of a given packet
Stream    - A logical, bi-directional channel of ordered bytes and
            money within a STREAM connection
            Streams are given numerical IDs. Client-initiated streams
            are given odd numbers starting with 1 and server-initiated
            streams are given even numbers starting with 2.


Shared Secret - A cryptographically-secure random seed that is shared
            between the two endpoints comprising a connection and is 
            used to derive keys for encrypting packets and generating 
            conditions and fulfillments
STREAM packet - A payload sent as the data portion of an ILP packet that
            can be parsed by a STREAM endpoint
</pre>
  </li>
  <li>
  </li>
  <li></li>
  <li></li>
  <li></li>
  <li></li>
  </ul>

5.1.1. Encryption Envelope

Field      Type         Description
Random IV  12-Byte UInt Nonce used as input to the AES-GCM algorithm.
                        Also ensures conditions are random.
                        Endpoints MUST NOT encrypt two packets with
                        the same nonce
Authentication Tag  16-Byte UInt    Authentication tag produced by AES-GCM encryption that ensures data integrity
Ciphertext  0-32739 Bytes   Encrypted data (see below for contents)

Note that the Ciphertext is NOT length-prefixed. The length can be inferred from the ILP packet because the whole data field is encoded with a length prefix. (This is done so that the entire data field is indistinguishable from random bytes.)
5.1.2. Encryption Pseudocode

The encryption key used for every packet sent for a given connection is the HMAC-SHA256 digest of the shared secret and the string "ilp_stream_encryption", encoded as UTF-8 or ASCII (the byte representation is the same with both encodings).

var iv = random_bytes(12);
var encryption_key = hmac_sha256(shared_secret, "ilp_stream_encryption");
var { ciphertext, auth_tag } = aes_256_gcm(encryption_key, iv, data);

5.1.3. Maximum Number of Packets Per Connection

Implementations MUST close the connection once either endpoint has sent 2^31 packets. According to NIST, it is unsafe to use AES-GCM for more than 2^32 packets using the same encryption key. (STREAM uses the limit of 2^31 because both endpoints encrypt packets with the same key.)
5.2. STREAM Packet

See the ASN.1 definition for the formal packet specification.
Field   Type    Description
Version     UInt8   1 for this version
ILP Packet Type     UInt8   ILPv4 packet type this STREAM packet MUST be sent in (12 for Prepare, 13 for Fulfill, and 14 for Reject). Endpoints MUST discard STREAM packets that comes in on the wrong ILP Packet Type. (This is done to prevent malicious intermediaries from swapping the data fields from different valid ILP packets.)
Sequence    VarUInt     Identifier for an ILP request / response. Clients and Servers track their own outgoing packet sequence numbers and increment the Sequence for each ILP Prepare they send. The Receiver MUST respond with a STREAM packet that includes the same Sequence as the Sender's Prepare packet. A sender MUST discard a STREAM packet in which the Sequence does not match the STREAM packet sent with their ILP Prepare.
Prepare Amount  VarUInt     If the STREAM packet is sent on an ILP Prepare, this represents the minimum the receiver should accept. If the packet is sent on an ILP Fulfill or Reject, this represents the amount that the receiver got in the Prepare.
Frames  SEQUENCE OF Frame   An array of Frames, which are specified below.
Junk Data   N/A     Extra bytes that MUST be ignored. Implementations MAY append zero-bytes to pad packets to a specific size. Future versions of STREAM may specify additional fields that come after the Frames (zero-bytes MUST be used for padding to avoid confusion with future protocol versions).
5.3. Frames

See the ASN.1 definition for the formal specification of the frame encoding and each frame type.

Each frame is encoded with its 1-byte type and length prefix. Implementations MUST ignore frames with unknown types. Future versions of STREAM may add new frame types.
Field   Type    Description
Type    UInt8   Identifier for the frame type (see below)
Data    Variable-Length Octet String    Frame contents

The frame types are as follows and each is described in greater detail below:
Type ID     Frame
0x01    Connection Close
0x02    Connection New Address
0x03    Connection Max Data
0x04    Connection Data Blocked
0x05    Connection Max Stream ID
0x06    Connection Stream ID Blocked
0x10    Stream Close
0x11    Stream Money
0x12    Stream Money Max
0x13    Stream Money Blocked
0x14    Stream Data
0x15    Stream Data Max
0x16    Stream Data Blocked
5.3.1. ConnectionClose Frame
Field   Type    Description
Error Code  UInt8   Machine-readable Error Code indicating why the connection was closed.
Error Message   Utf8String  Human-readable string intended to give more information helpful for debugging purposes.

If implementations allow half-open connections, an endpoint MAY continue sending packets after receiving a ConnectionClose frame. Otherwise, the endpoint MUST close the connection immediately.
5.3.2. ConnectionNewAddress Frame
Field   Type    Description
Source Address  ILP Address     New ILP address of the endpoint that sent the frame.
5.3.3. ConnectionMaxData Frame
Field   Type    Description
Max Offset  VarUInt     The total number of bytes the endpoint is willing to receive on this connection.

Endpoints MUST NOT exceed the total number of bytes the other endpoint is willing to accept.
5.3.4. ConnectionDataBlocked Frame
Field   Type    Description
Max Offset  VarUInt     The total number of bytes the endpoint wants to send.
5.3.5. ConnectionMaxStreamId Frame
Field   Type    Description
Max Stream ID   VarUInt     The maximum stream ID the endpoint is willing to accept.
5.3.6. ConnectionStreamIdBlocked Frame
Field   Type    Description
Max Stream ID   VarUInt     The maximum stream ID the endpoint wishes to open.
5.3.7. StreamClose Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Error Code  UInt8   Machine-readable Error Code indicating why the stream was closed.
Error Message   Utf8String  Human-readable string intended to give more information helpful for debugging purposes.

If implementations allow half-open streams, an endpoint MAY continue sending money or data for this stream after receiving a StreamClose frame. Otherwise, the endpoint MUST close the stream immediately.
5.3.8. StreamMoney Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Shares  VarUInt     Proportion of the ILP Prepare amount destined for the stream specified.

The amount of money that should go to each stream is calculated by dividing the number of shares for the given stream by the total number of shares in all of the StreamMoney frames in the packet.

For example, if an ILP Prepare packet has an amount of 100 and three StreamMoney frames with 5, 15, and 30 shares for streams 2, 4, and 6, respectively, that would indicate that stream 2 should get 10 units, stream 4 gets 30 units, and stream 6 gets 60 units.

If the Prepare amount is not divisible by the total number of shares, implementations SHOULD round the stream amounts down. The remainder SHOULD be allocated to the lowest-numbered open stream that has not reached its maximum receive amount.
5.3.9. StreamMaxMoney Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Receive Max     VarUInt     Total amount, denominated in the units of the endpoint sending this frame, that the endpoint is willing to receive on this stream.
Total Received  VarUInt     Total amount, denominated in the units of the endpoint sending this frame, that the endpoint has received thus far.

The amounts in this frame are denominated in the units of the endpoint sending the frame, so the other endpoint must use their calculated exchange rate to determine how much more they can send for this stream.
5.3.10. StreamMoneyBlocked Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Send Max    VarUInt     Total amount, denominated in the units of the endpoint sending this frame, that the endpoint wants to send.
Total Sent  VarUInt     Total amount, denominated in the units of the endpoint sending this frame, that the endpoint has sent already.
5.3.11. StreamData Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Offset  VarUInt     Position of this data in the byte stream.
Data    VarOctetString  Application data.

Packets may be received out of order so the Offset is used to indicate the correct position of the byte segment in the overall stream. The first StreamData frame sent for a given stream MUST start with an Offset of zero.
5.3.12. StreamMaxData Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Max Offset  VarUInt     The total number of bytes the endpoint is willing to receive on this stream.
5.3.13. StreamDataBlocked Frame
Field   Type    Description
Stream ID   VarUInt     Identifier of the stream this frame refers to.
Max Offset  VarUInt     The total number of bytes the endpoint wants to send on this stream.
5.4. Error Codes

Error codes are sent in StreamClose and ConnectionClose frames to indicate what caused the stream or connection to be closed.
Error Code  Name    Description
0x01    NoError     Indicates the stream or connection closed normally.
0x02    InternalError   The endpoint encountered an unexpected error.
0x03    EndpointBusy    The endpoint is temporarily overloaded and unable to process the packet.
0x04    FlowControlError    The other endpoint exceeded the flow control limits advertised.
0x05    StreamIdError   The other endpoint opened more streams than allowed.
0x06    StreamStateError    The other endpoint sent frames for a stream that is already closed.
0x07    FrameFormatError    The other endpoint sent a frame with invalid syntax.
0x08    ProtocolViolation   The other endpoint sent invalid data or otherwise violated the protocol.
0x09    ApplicationError    The application using STREAM closed the stream or connection with an error.
6. Condition and Fulfillment Generation

There are two methods the sender can use to generate the condition, depending on whether they want the payment to be fulfillable or not.
6.1. Unfulfillable Condition

If the sender does not want the receiver to be able to fulfill the payment (as for an informational quote), they can generate an unfulfillable random condition.

var condition = random_bytes(32);

6.2. Fulfillable Condition

If the sender does want the receiver to be able to fulfill the condition, the condition MUST be generated in the following manner.

The shared_secret is the cryptographic seed exchanged during Setup. The string "ilp_stream_fulfillment" is encoded as UTF-8 or ASCII (the byte representation is the same with both encodings). The data is the encrypted STREAM packet.

var hmac_key = hmac_sha256(shared_secret, "ilp_stream_fulfillment");
var fulfillment = hmac_sha256(hmac_key, data);
var condition = sha256(fulfillment);

6.3. Fulfillment Generation

The following pseudocode details how the receiver regenerates the fulfillment from the data.

The shared_secret is the cryptographic seed exchanged during Setup. The string "ilp_stream_fulfillment" is encoded as UTF-8 or ASCII (the byte representation is the same with both encodings). The data is the encrypted STREAM packet.

var hmac_key = hmac_sha256(shared_secret, "ilp_stream_fulfillment");
var fulfillment = hmac_sha256(hmac_key, data);

Appendix A: Similarities and Differences with QUIC

Unlike QUIC, STREAM:

    Has only one packet header instead of QUIC's short and long headers.
    Uses the shared secret to identify the Connection rather than having a separate Connection ID.
    Does not include a cryptographic handshake, because STREAM assumes a symmetric secret is communicated out of band.
    Does not support unidirectional frames. The QUIC community had significant debate over whether to include unidirectional streams, bidirectional streams, or both. They settled on both primarily to support the HTTP request/response pattern as well as HTTP/2 Server Push. Unidirectional streams were left out of STREAM because they add complexity and are a premature optimization for this protocol now.
    Does not have ACK frames, because ILP Prepare packets must be acknowledged with either a Fulfill or Reject packet. If the response includes an (authenticated) STREAM packet, the sender can treat that as an acknowledgement of the control and data frames from the Prepare packet they sent.
    Does not have Ping, Path Challenge, or Path Challenge Response frames, because a STREAM packet with no frames can be used instead. As long as the Client and Server increment the packet sequence for each packet they send, a valid Fulfill or Reject packet from the Receiver that includes the correct sequence in the encrypted data serves as the path challenge and response.
</td>
____________________________
Adrian Hope @ interledger/Lobby chat:
If anyone is interested in contributing to this work and helping to make it easy for others to provide alternative implementations we have some spec debt which we need to repay and these would be great first issues to tackle.
https://github.com/interledger/rfcs/issues?q=is%3Aissue+is%3Aopen+label%3A%22spec+debt%22
The ILDCP, PING and routing protocols are all implemented in https://github.com/interledgerjs/ilp-connector but not yet documented as RFCs
____________________________
Dora-gt @ interledger/Lobby:
JFYI, I just found there was an agreement called ?TBT?.
If ILP is defined on ISO, that might be great to be spread over the world.
TBT = Agreement on Technical Barriers to Trade
____________________________
Web-Payments + ILP:
https://medium.com/interledger-blog/web-payments-with-interledger-using-moneyd-gui-3c471525b60a
____________________________
N3TC4T Jul 13 12:31
new BTP server , that's was pretty easy to run , just needed some trick and thanks @sharafian for his help
btp.xrp.markets
____________________________
[DevOps] Terraform confif for deploying a tier-2 ilp-connector
https://github.com/interledgerjs/tf-connector

N3TC4T @N3TC4T Jul 17 00:19 Here is an Tire 1 docker example https://github.com/xrp-community/tf-connector-docker

_________________________________
Kincaid O'Neil @kincaidoneil Jul 18 20:13
Are multi plugins assumed to have infinite liquidity? e.g., should they throw an error in sendData if the server does not have enough money to cover the PREPARE? Or is that something implemented at the connector level?
Ben Sharafian @sharafian Jul 18 20:20
multi plugins do all their balance internally so from the connector's perspective they have infinite balance
_________________________________
Jul 18 20:54 For multi plugins (take eth over machinomy for example), the ILP address is no longer of the form g.ilp.eth.<eth_address> but rather g.ilp.eth.<token> which is a hashed value that cannot be used to reconstruct the eth_address. What is the reason for this?
Ben Sharafian @sharafian Jul 18 21:03 The ethereum address is just a settlement detail, but doesn't say anything about the actual network topology. You could have multiple peering relationships using the same ethereum account but with different Interledger addresses, or you could theoretically have a link that you settle with multiple different addresses. Interledger is a network that exists on top of settlement infrastructure so we don't try to make any 1:1 mapping from the settlement network to the interledger network
_________________________________
[DevOps] https://medium.com/interledger-blog/running-your-own-ilp-connector-c296a6dcf39a
_________________________________
[DevOps] Reverend Ripple @Reverend_Ripple_twitter Jul 23 22:55
I've been battling issues with our new firewall appliances the last couple days and havent had a chance to get back to the I'll connector ... Will try to get back at it tonight, so I'll be looking for a peer list too!
Adrian Hope-Bailie @adrianhopebailie Jul 23 23:10 @Reverend_Ripple_twitter cool, when you're ready you need to:
    Decide if you'll run the BTP server or client (client is easier because you won't need to open any new incoming ports)
    Give me your Ripple address
    If you're gonna run a server then also give me the BTP server URL of the XRP paychan plugin you configured
Best if you share these all via a direct message :smile:
_________________________________
    <a href='https://github.com/rfcs/crypto-conditions/tree/master/test-vectors/valid'>Test vectors</a> contains a set of fulfillment and conditions that any compliant implementation must pass.
Only preimage (https://github.com/rfcs/crypto-conditions/blob/master/test-vectors/valid/0005_test-basic-preimage.json= ) is used right now

-->

</html>
