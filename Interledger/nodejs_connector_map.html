<html>
<head>
   <meta charset="UTF-8">
   <title>NodeJS ILP-Connector map</title>
<style>
pre { background-color:#FFFFFA; outline:1px dotted grey; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
body      { font-family:sans-serif; padding: 0; margin: 0; }
#zoomDiv *[xxxsmall]{ font-size:1rem; }
#zoomDiv *[xxsmall] { font-size:1rem; }
#zoomDiv *[xsmall]  { font-size:1rem; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}
a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[col1]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col2]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
td[col3]  {background-color:#FFFFFF; min-width:30%; max-width:30%; }
tr[header_delimit] > *{background-color:#AAAAAA; color:#FFFFFF; font-size:2em; ; text-align: center;}
</style>

<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
function onTDDoubleClick()      { zoomDivDOM.innerHTML = "('Esc' to close)<br/>" + this.innerHTML; }

function onPageLoaded() {
   /* Notes:
    * The name (and number) of columns 'topic', 'summa', 'col1', 'col2' is arbitrary.
    * Change at will. For example for development projects there could be a column for each 
    * software life-cycle similar to:  
    * topic -> summary -> documentation -> development -> testing/CI -> deployment -> QA
    * WARN: Don't forget to change the css too.
   */

  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
}
</script>
</head>
<!--
ROW TEMPLATE:
<tr {>
  <td col1 >
     <pre>
     </pre>
  </td>  
  <td col2  >
     <pre>
     </pre>
  </td>
  <td col3 >
     <pre>
     </pre>
  </td>
</tr }>
-->
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>
<br/> <br/> <br/> <br/>
<table>

<tr header_delimit } {>
  <td colspan=3 ><a href='https://github.com/interledgerjs/ilp-connector/tree/master/src/lib'>lib</a></td>

</tr>
<tr {>
  <td col1 >
    <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/ledgers.js'>src/lib/ledgers.js</a><br/>
     <pre>
const PLUGIN_EVENTS = [
  'incoming_transfer', 'incoming_prepare', 
  'outgoing_fulfill' , 'outgoing_cancel'  , 'outgoing_reject'
]

class /*export*/ Ledgers extends EventEmitter
    // properties
    this.pluginList
    this.plugins // { prefix ⇒ LedgerPlugin }
    this.tables = routingTables
    this._config
    this._pairs // TradingPairs
    this._ledgers = new Map() // { prefix }
    this.requestHandler = co.wrap(this._requestHandler.bind(this))
    this._relayEvents = {}
    // methods--------------
    connect (options) // For each plugin in pluginList connect
    add (ledgerPrefix, creds, tradesTo, tradesFrom)
    getPlugin (ledgerPrefix) 
    getPlugins () { return this.pluginList }
    remove (ledgerPrefix)
    * _requestHandler (requestMessage)
    registerInternalRequestHandler (requestHandler)
    registerExternalRequestHandler (requestHandler) 
    addPlugin (prefix, plugin) 
    removePlugin (prefix) 

     </pre>
  </td>  
  <td col2  >
    <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/trading-pairs.js'>src/lib/trading-pairs.js</a><br/>
     <pre>
class /*export*/ TradingPairs
  this._sources // 
      {  from1 /*USD@red.ilpdemo*/ :
            Set(
               to1_1 /*EUR@blue.ilpdemo.*/ ,
               to1_2 /*XRP@example.virtual. ...,) ,
         from2 :
            Set(
               to2_1 /*EUR@blue.ilpdemo.*/ ,
               to2_2 /*XRP@example.virtual. ...,) ,
      }
  this._pairsCache //
  // ----------------
  addPairs (pair_list /* pair =[from,to]*/)
  add (from, to)
  removeAll (id) /* remove any matching from/to */
  empty()
  toArray ()
     </pre>
  </td>
  <td col3 >
    <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/executeSourceTransfer.js'>src/lib/executeSourceTransfer.js</a><br/>
Add (exec)fulfillment to src_transfer and submit to src_ledger<br/>
(ERRORS, RETRIES AND TIMEOUTS LOGIC REMOVED)
     <pre>
function * /*exported*/ executeSourceTransfer (
     destinationTransfer, fulfillment, ledgers, backend, config) {
  const noteToSelf = destinationTransfer.noteToSelf || {}
  const sourceTransferLedger = noteToSelf.source_transfer_ledger
  const sourceTransferID = noteToSelf.source_transfer_id
  const sourceTransferAmount = noteToSelf.source_transfer_amount

  const plugin = ledgers.getPlugin(sourceTransferLedger)

  const fulfillPromise = function (retry, number) {
    return Promise.resolve(
      plugin.fulfillCondition(sourceTransferID, fulfillment))
      .then(function () {
        backend.submitPayment({
          source_ledger: sourceTransferLedger,
          source_amount: sourceTransferAmount,
          destination_ledger: destinationTransfer.ledger,
          destination_amount: destinationTransfer.amount
        })
      })
   }
}
     </pre>
  </td>
</tr }>

<tr {>
  <td col1 >
     <p>
       <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/message-router.js'>src/lib/message-router.js</a>
     </p>
     <p>See Related RFC:
       <a href='https://github.com/interledger/rfcs/blob/master/0010-connector-to-connector-protocol/0010-connector-to-connector-protocol.md'>
       0010-connector-to-connector-protocol.md</a>
     </p>
     (ERRORS, ASYNC CODE REMOVED, USING "PSEUDO-CODE")
     <pre {>
class /*export*/ MessageRouter (opts) {
  this.config 
  this.ledgers 
  this.routingTables 
  this.routeBroadcaster
  this.routeBuilder 
  this.ledgers.registerInternalRequestHandler(this.handleRequest.bind(this))
  --------------------------------------------------------------------------
  // PROCESS INCOMING MESSAGE. (EITHER ILQP or NEW_ROUTES).
  // REPLY MESSAGE TO SENDER IF APPLICABLE
  function handleRequest (request /*req. Message*/)

  function _handleRequestByPacket (packet, sender) =
    switch (TYPE_ILQP = packet[0]) {
      LIQUIDITY_REQUEST:
          routeBuilder.quoteLiquidity(packetData)
      BY_SOURCE_REQUEST:
          routeBuilder.quoteBySource(packetData)
      BY_DESTINATION_REQUEST:
          routeBuilder.quoteByDestination(packetData)
    }

  // UPDATE LOCAL ROUTING TABLE WITH ROUTES IN PAYLOAD
  function receiveRoutes (payload /* new routes */, sender)
}
     </pre }>
  </td>  
  <td col2  >
     <pre>
     </pre>
  </td>
  <td col3 >
     <pre>
     </pre>
  </td>
</tr }>


<tr header_delimit {>
  <td colspan=3 >src/lib/config.js</td>
</tr>
<tr {>
  <td col1 >
ledgers this connector has accounts on used to auto-generate pairs.
     <pre>
export LEDGERS={ // us
   "http://usd-ledger.example": {
     "currency": "USD",
     "plugin": 'ilp-plugin-example',
     "options": {
       // plugin options ...
     }
   },
   "http://eur-ledger.example/some/path": {
     "currency": "EUR",
     "plugin": 'ilp-plugin-example',
     "options": {
       // plugin options ...
     }
   }
}
     </pre>
  </td>  
  <td col2  >
     <pre>
export ROUTES=[
    {
     "targetPrefix": "", // match any route
     "connectorLedger": "ilpdemo.red."
     "connectorAccount": "ilpdemo.red.connie"
    },
    {
      "targetPrefix": "usd.",
      "connectorLedger": "example.other."
      "connectorAccount": "example.other.connector"
     }]

export PAIRS=[
    ["USD@http://usd-ledger.example","EUR@http://eur-ledger.example"],
    ...
]
PEERS=peer1,peer2,peer3

ROUTE_BROADCAST_ENABLED # defaults to true

# For a 'core' node in an open network, set both to true.
# For a 'periphery' node in an open network,
#  set only the first one to true.
# For a node in a network where price competition between
# routes is not needed, set both to false.
BROADCAST_CURVES # defaults to true
STORE_CURVES # defaults to true

ROUTE_BROADCAST_INTERVAL # def. 30 * 1000 // milliseconds
ROUTE_CLEANUP_INTERVAL   # def. 1000 // milliseconds
ROUTE_EXPIRY             # def. 45 * 1000 // milliseconds
QUOTE_EXPIRY             # def. 45 * 1000 // milliseconds

AUTOLOAD_PEERS # defaults to false

# secret is used to generate destination transfer IDs
# that cannot be guessed and squatted on by others
export SECRET=<base64 32bytes string>
export UNWISE_USE_SAME_TRANSFER_ID=false


     </pre>
  </td>
  <td col3 >
     <pre {>

export DEBUG_REPLY_NOTIFICATIONS=true

const envPrefix = 'CONNECTOR'

export BACKEND='fixerio'
export MIN_MESSAGE_WINDOW=10 # in secs, defaults to 1
export MAX_HOLD_TIME=10 # in secs, defaults to 10
export DB_URI
export FX_SPREAD # defaults to 0.002 (0.2%)
export SLIPPAGE # defaults to 0.001 // 0.1%


# BACKEND_URI must be defined for backends that connect to an external
# component to retrieve the rate or amounts (it is therefore required
# when using the ilp-quote backend)
export BACKEND_URI=....

     </pre }>
  </td>
</tr }>

<tr header_delimit } {>
  <td colspan=3 >models</td>
</tr>
<tr {>
  <td col1 >
     src/models/pairs.js
     <pre>
function /*exported*/ getPairs (config, tradingPairsService) {
  const tradingPairs = tradingPairsService.toArray()
  return tradingPairs.map((pair) => {
    const currencies = pair.map(function (currencyLedgerString) {
      return currencyLedgerString.split('@')
    })
    return {
      source_asset: currencies[0][0],
      source_ledger: currencies[0][1],
      destination_asset: currencies[1][0],
      destination_ledger: currencies[1][1]
    }
  })
}
     </pre>
  </td>  
  <td col2  >
     src/models/payments.js
     <pre>
function * validateExpiry (sourceTransfer, destinationTransfer, config) 
           ^used by updateIncomingTransfer
module.exports = {
  function * updateIncomingTransfer (
             sourceTransfer,
             ledgers,
             config,
             routeBuilder)
  function * processExecutionFulfillment (
             transfer,
             fulfillment,
             ledgers,
             backend,
             config)
  function * rejectIncomingTransfer (
             sourceTransfer,
             _rejectionMessage,
             ledgers)
  function * rejectSourceTransfer (
             destinationTransfer,
             rejectionMessage,
             ledgers)
}
     </pre>
  </td>
  <td col3 >
     src/models/subscriptions.js
     <pre>
module.exports = {
  function * subscribePairs (ledgers, config, routeBuilder, backend) {
    ledgers.on('incoming_prepare' , (plugin, transfer) => ...)
    ledgers.on('incoming_transfer', (plugin, transfer) => ...)
    ledgers.on('outgoing_cancel'  , (plugin, transfer, rejectionMessage) => ...)
    ledgers.on('outgoing_reject'  , (plugin, transfer, rejectionMessage) => ...)
    ledgers.on('outgoing_fulfill' , (plugin, transfer, fulfillment) => ...)
  }
}
     </pre>
  </td>
</tr }>

<tr header_delimit } {>
  <td colspan=3 ><a href='https://github.com/interledger/rfcs/tree/master/0004-ledger-plugin-interface'>Plugin Interface</a></td>
<tr {>
  <td col1 >
     NodeJS Plugin Interface. See <a href='https://github.com/interledgerjs?utf8=%E2%9C%93&q=-plugin-&type=&language='>list of existing plugins</a>
     <pre>
class FiveBellsLedger extends EventEmitter2
  constructor (options) 

  async connect (options) 

  disconnect ()

  isConnected () 

  getInfo () 

  getAccount () 

  async getBalance ()

  registerRequestHandler (requestHandler) 

  deregisterRequestHandler () 

  sendRequest (message) 

  async sendTransfer (_transfer) 

  async fulfillCondition (transferId, fulfillment)

  getFulfillment (transferId) 

  rejectIncomingTransfer (transferId, rejectionMessage) 
     </pre>
  </td>  
  <td col2  >
     <pre>
     </pre>
  </td>
  <td col3 >
     <pre>
     </pre>
  </td>
</tr }>
</tr>


<tr header_delimit } >
<tr {>
  <td col1       >
    Liquidity Curves
    <ul>
      <li>
     C&P From ASN.1 comment. L.C.  describe the relationship between input and output amount
     for a given path between a pair of ledgers.<br/>
     The curve is expressed as a series of points given as coordinates 
     of the form <inputAmount, outputAmount>. If a sender sends 'inputAmount'
     units to the connector, the recipient will receive 'outputAmount'.<br/>
     It may represent the liquidity through a single connector, 
     or multiple liquidity curves can be combined into one to represent 
     the liquidity through a given path of connectors.<br/>
     Points are ordered by inputAmount. The inputAmount is strictly increasing
     from point to point. The outputAmount is monotonically increasing, 
     meaning each successively point must have an equal or greater outputAmount.<br/>
     The first point represents the minimum amount that can be transacted, while
     the final point represents the maximum amount that can be transacted.<br/>
     If a query does not match a point exactly, implementations MUST use linear
     interpolation. When querying by outputAmount, if multiple points match
     exactly, the lowest inputAmount of any of these points MUST be returned.
     <pre>
  O a │
  U m │             P3   Curve=[P1,P2,P3] = 
  T o │    P2 p p p            [(x1,y1),(x2,y2),(x3,y3)]
  p u │   p                        x3 gt x2 gt x1 AND 
  u n │  p                         y3 gt y2 gt y1
  t t │ p                p: Interpolated
      │P1 
      └───────────────
         INput amount
      </li>
      <li>
        Connectors use liquidity curves locally, derived from exchange rate
        from fixer.io + spread, <span TODO>using the maximum point as the difference between the
        current balance and the minimum balance on the ledger</span>
      </li>
      <li>Liquidity curves can be combined and then re-simplified to specified number of points</li>
      <li>Quotes are answered using curves from routing table if present, remote quote otherwise</li>
     </pre>
  </td>
  <td col2 >
    <ul>
    <li> <a href="https://github.com/interledger/rfcs/blob/master/asn1/InterledgerTypes.asn">ASN.1 bin.def.</a></li>
    </ul>
  </td>
  <td col3   >
    <ul>
        <li> <a href="https://github.com/interledgerjs/ilp-routing/blob/master/src/lib/liquidity-curve.js">JS LiquidityCurve class @ ilp-routing/src/lib/liquidity-curve.js</a>
<pre>

class LiquidityCurve
  this.data /* array 16 * N ("buffer") */
  this.points /* array (x,y) */// strictly increasing
  ----------------------
  amountAt (xVal) 
  amountReverse (yVal)

  simplify (maxPoints) 
  combine (curve) 
  join (curve)

  shiftX (_dx)
  shiftY (_dy)

  toBuffer () = this.data

</pre>
        </li>
        <li> <a href="https://github.com/interledgerjs/ilp-routing/blob/master/test/liquidity-curve.test.js">JS liquitidy-curver.tests.js @ ilp-routing</a></li>
        <hr/>
        <li> <a href="https://github.com/interledger/java-ilp-core/pull/68">PR 68. feat>java-ilp-core: support liquidity quotes</a></li>
        <li> <a href="https://github.com/interledger/java-ilp-core/issues/70">java-ilp-core Issue: Use Java Money ExchangeRate instead of LiquidityCurve</a></li>
        </ul>
  </td>
</tr }>
<tr name="ilp-routing" {>
  <td col1 >
     <a href='https://github.com/interledgerjs/ilp-routing/'>Routing</a><br/>
     Connectors maintain a routing table of ILP addresses. Routing is a recursive lookup 
     through the routing tables of any number of connectors. When a connector receives a query,
     it finds the longest prefix match for the queried address. Then, it follows one of the
     following cases:
     <ul>
     <li>Routing decisions are made by each connector, not source-routed</li>
     <li>Assumptions:
        <ul>
          <li>Which route to take should depend on the price and payment size</li>
          <li>Timeouts are roughly the same</li>
          <li>Throughput is not taken into account - a link is either up or down</li>
          <li>Exchange rates don’t change all the time (which would produce a lot of routing updates)</li>
        </ul>
     </li>
     <li>Issues:
        <ul>
          <li>Not yet taking into account reliability (difficult to tell who’s at fault)</li>
          <li>Peers can attract all traffic from directly adjacent connectors by broadcasting lower hop numbers</li>
          <li>Not yet doing route filtering</li>
          <li>Not taking into account total amount of liquidity for a path -- (open question whether that an issue to worry about or just payment size)</li>
        </ul>
     </li>

     <li>If the matching address is marked for local delivery, the connector prepares a transfer
       to that address in one of the ledgers connected to it.
     The connector maps the ILP address to an account within the ledger. (This is the base case.)
     </li>
     <li>
     If the matching address is marked as forwarded delivery, it has the address of another 
     connector associated with it in the routing table. The connector makes a routing lookup on 
     the connector associated with the address. (This is the recursive case.)
     </li>
     <li>From <a href='https://lists.w3.org/Archives/Public/public-interledger/2017Jun/0058.html'>Mailing List</a>:
       Connectors can keep track of all of the payments they are a part of and
       their positions in different currencies. The reference implementation has a
       way to configure it to do this
     </li>
     <li>Example simple routing table (defined in env. variable):
       <pre {>
export ROUTES=[
    {
     "targetPrefix": "", // match any route
     "connectorLedger": "ilpdemo.red."
     "connectorAccount": "ilpdemo.red.connie"
    },
    {
      "targetPrefix": "usd.", // match dolars
      "connectorLedger": "example.other."
      "connectorAccount": "example.other.connector"
     }
]
       </pre }>
     </li>
     </ul>
  </td>
  <td col2 >
     <ul>
     <li>
        CCP broadcasted Routes <a href='https://github.com/interledgerjs/five-bells-shared/blob/v22.0.1/schemas/Routes.json'>five-bells-shared/schemas/Routes.json</a>
        <pre xsmall {>
Route Schema:
* "source_ledger": {"$ref": "IlpAddress.json"},
* "destination_ledger": {"$ref": "IlpAddress.json"},
* "min_message_window": {
    "type": "number",
    "minimum": 0,
    "description": "secs min.diff btw src and dst TX'expiries"
  },
* "source_account": {
    "$ref": "IlpAddress.json",
    "description": "the connector's account on source_ledger"
  },
  "destination_account": {
    "$ref": "IlpAddress.json",
    "description": "(only used for local routes)"
  },
  "destination_precision": {
    "type": "number",
    "description": "precision of dst ledger"
  },
  "destination_scale": {
    "type": "number",
    "description": "scale of dst ledger"
  },
* "points": {
    "$ref": "LiquidityCurve.json",
    "description": "point list describing exchange rate"
  }
        </pre }>
     </li>
     <li>Summary of CCP <a href='https://github.com/interledgerjs/ilp-connector/blob/v17.0.2/schemas/RoutingUpdate.json'>ilp-connector/schemas/RoutingUpdate.json schema</a>

        <pre xsmall {>
{
  "title": "RoutingUpdate",
  "description": "A routing update object",
  "type": "object",
  "properties": {
  * "hold_down_time": {
      "description": "mSec. conn. claims routes to be fresh",
      "type": "integer",
      "minimum": 1
    },
  * "unreachable_through_me": {
      "description": "ledger list now unreachable",
      "type": "array",
      "minItems": 0,
      "items": {
        "$ref": "IlpAddress.json"
      }
    },
  * "new_routes": {
      "description": "Route list added since last update",
      "$ref": "Routes.json"
    }
  }
}
        </pre }>
     </li>
     <li>Route broadcasts contain ILP prefixes, liquidity curves (optional), and <span TODO>number of hops (to avoid routing blackholes)</span></li>
     <li><a href='https://docs.google.com/document/d/1ifGKVnWcg3MIEbGou4mgZMVKo3ldeFB1WAKvdsQPios/edit'>Initial Doc</a> from the ILP Routing Working Group explaining the current status, current issues, open questions, possible scenarios (connecting crypto-currencies, friend-to-friend network, payments for retails goods, micropayments, ...) </li>
     <li><a href='https://github.com/interledger/rfcs/blob/master/0010-connector-to-connector-protocol/0010-connector-to-connector-protocol.md'>RFC-0010 Connector to Connector protocol</a> describes de protocol to interchange data between connectors (See topic for more info)</li>
     <li>
        <a href='https://gist.github.com/justmoon/a59fd43958ce421c8b4a88d5143c718b#route-broadcast-example'>(Stefan Thomas gist) Route Broadcast Example</a>
        A connector wants to tell a peer about a new route.
        <pre xsmall {>
{
  "ledger":"peer.sZapq.usd.",
  "from": "peer.sZapq.usd.bVHMFFYfda...",
  "to": "peer.sZapq.usd.hMhQUg-lLvVg...",
  "data": [{
    "type": "https://interledger.org/rel/ccp/update",
    "new_routes": [{
      "source_ledger": "peer.sZapq.usd.",
      "destination_ledger": "us.usd.ilptestblah.",
      "points": [
        [ 0, 0 ],
        [ 100000000, 99799999.99 ]
      ],
      "min_message_window": 1,
      "source_account": "peer.sZapq.usd.bVHMF..."
    }],
    "withdrawn_routes": [
      "old.destination."
    ]
  }]
}
        </pre }>
     </li>
     </ul>
  </td>
  <td col3   >
     <ul>
     <li><a href='https://github.com/interledgerjs/ilp-routing/blob/master/src/lib/route.js'>class Route @ ilp-routing/src/lib/route.js</a> 
         <pre {>
class Route:
  this.curve LiquidityCurve

  // through which incoming route enters this con.
  this.sourceLedger  (required)
  // to which this connector should forward payments
  this.nextLedger
  // last ledger on this route (def. to nextLedger)
  this.destinationLedger

  // if targetPrefix specified, dstns matching it
  // will follow this route rather than dstns
  // matching 'destinationLedger'
  // See interledgerjs/ilp-routing/issues/49
  this.targetPrefix 
  this.minMessageWindow
  this.expiresAt
  this.additionalInfo
  this.isLocal
  this.sourceAccount
  this.destinationAccount

  this.addedDuringEpoch
  this.paths // array of path arrays
----  METHODS ------------
  amountAt (x)
  amountReverse (y)
  getPoints ()

  // for path:
  //   localLedger -> trustLine -> dstnLedger 
  //   =>  this.paths === [ [] ], path_length 2
  // for path:
  //  localLedger->trustLine->anotherTL->dstnLedger 
  // has this.paths === [ ['anotherTrustLine'] ] and 
  //     path length 3
  maxPathLength () 

  combine (alternateRoute)
  join (tailRoute, expiryDuration, addedDuringEpoch)

  shiftX (dx)
  shiftY (dy)
  simplify (maxPoints)

  isExpired ()
  bumpExpiration (holdDown /*mSecs*/)
  toJSON () 
         </pre }>
         and
         <a href='https://github.com/interledgerjs/ilp-routing/blob/master/test/route.test.js'>related tests</a>
     </li>
     <li>
       <a href='https://github.com/interledgerjs/ilp-routing/blob/master/src/lib/routing-table.js'>ilp-routing src/lib/routing-table.js</a>
        <pre xsmall { >
class RoutingTable 
  this.destinations = PrefixMap
          &lt;destination, /routes*/Map &lt;hop, route>>()
  -----------------------------
  addRoute    (destination, nextHop, route)
  removeRoute (destination, nextHop)

  // destinationAddress = ['g','us','bank1',...]
  // Compute shortest prefix that uniquely matches  
  // the target or destinationAddress if no matches
  getAppliesToPrefix (routePrefix, destinationAddress)
     return {IlpAddress} 

  findBestHopForSourceAmount 
      (destination, sourceAmount) 

  findBestHopForDestinationAmount 
      (destination, destinationAmount)
        </pre } >
        and
        <a href='https://github.com/interledgerjs/ilp-routing/blob/master/test/routing-table.test.js'>related tests</a>
     </li>
     <li><a href='https://github.com/interledgerjs/ilp-routing/blob/master/src/lib/routing-tables.js'>ilp-routing src/lib/routing-tables.js</a> (not to be confused with similar filename <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/routing-tables.js'>ilp-connector src/lib/routing-tables.js</a>)
         <pre {>
// A next hop of PAIR distinguishes a local pair A→B
//  from a complex route that just happens to be local,
// i.e. when A→C & C→B are local pairs.
const PAIR = 'PAIR'

class RoutingTables :
  this.currentEpoch 
  this.expiryDuration /*millisecs*/
  this.sources // PrefixMap{srcLedger: RoutingTable}
  this.localAccounts Map {"ledger": accountURI }
  this.addLocalRoutes(localRoutes)
  --- methods --------
  incrementEpoch ()

  // Each local route should include the optional
  // `destinationAccount` parameter.
  addLocalRoutes (_localRoutes)

  removeLedger (ledger)

  // Given a `route` B→C, create a route A→C for
  // each source ledger A with a local route to B.
  addRoute (_route, noExpire)

  _addRouteFromSource (tableFromA, ledgerA,
                       routeFromBToC, noExpire) 

  _removeRoute (ledgerB, ledgerC, connectorFromBToC)

  removeExpiredRoutes ()

  bumpConnector (connectorAccount, holdDownTime) 

  invalidateConnector (connectorAccount)

  invalidateConnectorsRoutesTo (connectorAccount, ledger)

  eachSource (fn)

  // function(routeFromAToB, ledgerA, ledgerB, nextHop)
  eachRoute (fn)

  toJSON ( /*int*/ maxPoints) Routes

  getLocalPairRoute (sourceLedger, nextLedger)

  findBestHopForSourceAmount 
      (sourceAddress, finalAddress, sourceAmount)

  findBestHopForDestinationAmount 
      (sourceAddress, finalAddress, finalAmount)
         </pre }>
         and
         <a href='https://github.com/interledgerjs/ilp-routing/blob/master/test/routing-tables.test.js'>related tests</a>
     </li>
     <li><a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/route-broadcaster.js'>route-broadcaster.js @ ilp-connector</a> and
         <a href='https://github.com/interledgerjs/ilp-connector/blob/master/test/routeBroadcasterSpec.js'>tests</a>
     </li>
     <li><a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/route-builder.js'>route-builder.js</a></li>
     <li><a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/routing-tables.js'>routing-tables.js</a> and
         <a href='https://github.com/interledgerjs/ilp-connector/blob/master/test/routingTablesSpec.js'>tests</a>
     </li>
     <li><a href='https://github.com/interledgerjs/ilp-routing'>library to calculate routes and r.tables</a></li>
     <hr/>
     </ul>
  </td>

</tr }>

  <td colspan=3 >Routing</td>
</tr>
<tr {>
  <td col1 >
    C&amp;P from <a href='https://github.com/interledgerjs/ilp-connector/blob/master/src/lib/routing-tables.js'>routing-tables.js</a>
    <p>
    When routing payments across multiple ledgers, each hop will round the amounts
    according to the precision of the ledger. These rounding errors can accumulate
    to the point where a connector later in a path may receive an amount that is
    less than the rate they are willing to accept.
    </p>
    <p>
    Connectors broadcast slightly pessimistic rate curves in order to compensate for
    rounding errors across multi-hop routes. They shift the curve by the maximum
    amount that could be lost due to rounding errors, so that even if the incoming
    amount is rounded down by that amount the resulting value will still match the
    connector's minimum rate.
    </p>
    <p>
    Connectors use unshifted rate curves locally to determine whether an incoming
    payment request matches their minimum rate. When applying this rate, they round
    in their favor to ensure that they never accept a payment that is lower than their rate.
    </p>
    <p>
    This class maintains two sets of routing.RoutingTables: the "local" tables are
    the optimistic ones and the "public" tables are the pessimistic ones.
    </p>
    <p>
    The "local" tables consist of the raw local routes, joined to adjacent connector's
    (public, shifted) routes. They are used for findBestHopFor*, the results of which
    must be rounded in the connector's own favor to ensure that they don't lose money.
    </p>
    <p>
    The "public" tables consist of the local shifted routes, joined to the remote
    (shifted) routes. Before joining, the local routes are shifted right by
    1/10^destination_ledger_scale to account for rounding errors. Their curves are
    broadcast to adjacent connectors.
    </p>
    <p>
    <pre>
    Summary:
    
    | Method                      | Shifted? |
    |-----------------------------|----------|
    | Broadcasted routes          | yes      |
    | Quote-by-liquidity          | yes      |
    | Quote-by-source-Amount      | no       |
    | Quote-by-destination-amount | yes      |
    | Payment                     | no       |
    </pre>
    </p>
  </td>  
  <td col2  >
  </td>
  <td col3 >
  </td>
</tr }>

</table>
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 
-->

<!--
TODO: 
connector-protocol.md
    this.routingTables.bumpConnector(sender, holdDownTime)

createApp @ src/app.js:
A connector app is composed of:
   1 config object
   1 RoutingTables (backend, expireDuration, fxSpread, slippage)
   1 Ledgers 
   1 Quoter(config.quoteExpiry)
   1 Backend (config.backend)
   1 RouteBuilder(
        config.expiry.minMessageWindow,
        config.expiry.maxHoldTime,
        config.slippage,
        config.secret )
   1 RouteBroadcaster(
      routingTables,
      backend,
      ledgers,
      config.broadcastCurves,
      config.peers,
      config.*)
   1 MessageRouter
  }

Extracted from:
https://github.com/interledgerjs/ilp-routing/blob/master/src/lib/route.js
Example:
this = { sourceLedger: S1, nextLedger: N1, destinationLedger:  J, paths: [ [P1.1,  P1.2 ]                                         ]  }
tail = { sourceLedger: J , nextLedger: N2, destinationLedger: D2, paths: [ [Q1.1, Q1.2]               , [Q2.1, Q2.2]              ]  }
join = { sourceLedger: S1, nextLedger: N1, destinationLedger: D2, paths: [ [P1.1 P1.2 J N2 Q1.1 Q1.2] , [P1.1 P1.2 J N2 Q2.1 Q2.2] ] }

Take special care:
If N1 === J, don't include J in the joined paths
// If N2 === D2, don't include N2 in the joined paths
-->
</html>
 

