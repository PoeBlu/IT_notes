<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>architecture map (alpha)</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->
<table>
<tr>
  <td>
  <a href="http://www.ehcache.org/">Ehcache</a><br/>
  open source, standards-based cache that boosts performance, offloads I/O.<br/>
   Integrates with other popular libraries and frameworks.<br/>
  It scales from in-process caching, all the way to mixed in-process/out-of-process
  deployments with terabyte-sized caches
<pre xxxsmall zoom { >

Coding to Ehcache 3 API:
<pre xxxsmall { >
CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()
    .withCache("preConfigured",
         CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class,
             ResourcePoolsBuilder.heap(100))
         .build())
    .build(true);

Cache<Long, String> preConfigured
    = cacheManager.getCache("preConfigured", Long.class, String.class);

Cache<Long, String> myCache = cacheManager.createCache("myCache",
    CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class,
                                  ResourcePoolsBuilder.heap(100)).build());

myCache.put(1L, "da one!");
String value = myCache.get(1L);

cacheManager.close();
</pre }>
(simpler/lighter solution but not so escalable could be to use Google Guava Cache)
  </td>

  <td>
  [log]<a href="https://www.fluentd.org/">FluentD</a><br/>
  (Improved "logstat")
<pre xxxsmall zoom { >
Open Source data collector for unified logging layer.

Fluentd allows you to unify data collection and consumption for
a better use and understanding of data.

Syslog                      Elasticsearch
Apache/Nginx logs    → → →  MongoDB
Mobile/Web app logs  → → →  Hadoop
Sensors/IoT                 AWS, GCP, ...
  </td>
  <td>
  Kafka: log and events collection, streaming platform, ...
<pre xxxsmall zoom { >
Each broker in the Kafka cluster has an identity which can be used to find other
brokers in the cluster. The brokers also need some type of a database to 
store partition logs. It's important to configure a Persistent Volume (PV) for 
Kafka, otherwise you will lose the logs.
</pre } >
  </td>
  <td>
  <a href="https://prometheus.io/">Prometheus</a> , 
  <a href="https://github.com/prometheus/prometheus">Git</a>
<pre xxxsmall zoom { >
Power your metrics and alerting with a leading open-source monitoring solution.
- Prometheus fundamentally stores all data as time series: streams of 
  timestamped values belonging to the same metric and the same set of labeled 
  dimensions. Besides stored time series, Prometheus may generate temporary 
  derived time series as the result of queries.
- Prometheus provides a functional expression language that lets the user 
  select and aggregate time series data in real time. The result of an expression
  can either be shown as a graph, viewed as tabular data in Prometheus's 
  expression browser, or consumed by external systems via the HTTP API.
- Grafana supports querying Prometheus. The Grafana data source for Prometheus 
  is included since Grafana 2.5.0 (2015-10-28).
- Prometheus includes a local on-disk time series database, but also optionally
  integrates with remote storage systems.
- Alerting rules allow you to define alert conditions based on Prometheus 
  expression language expressions and to send notifications about firing alerts
  to an external service.
</pre } >
  </td>
  <td>
  Apache Spark:</br>
<pre xxxsmall zoom { >
  general framework for large-scale data processing that supports lots of 
different programming languages and concepts such as MapReduce, in-memory
processing, stream processing, graph processing, and Machine Learning. This can
also be used on top of Hadoop. Data can be ingested from many sources like 
Kafka, Flume, Kinesis, or TCP sockets, and can be processed using complex 
algorithms expressed with high-level functions like map, reduce, join and window.

Common applications for Spark include real-time marketing campaigns, online 
product recommendations, cybersecurity analytics and machine log monitoring.
</pre } >
<br/>
Kafka vs Spark Streaming: <a href="https://dzone.com/articles/spark-streaming-vs-kafka-stream-1">REF</a>
<pre xxxsmall zoom { >
""" If event time is very relevant and latencies in the seconds range are
completely unacceptable, Kafka should be your first choice. Otherwise, 
Spark works just fine. 
...
Apache Spark can be used with Kafka to stream the data, but if you are 
deploying a Spark cluster for the sole purpose of this new application, that is
definitely a big complexity hit.
...
Conclusion
I believe that Kafka Streams is still best used in a "Kafka > Kafka" context, 
while Spark Streaming could be used for a "Kafka > Database" or 
"Kafka > Data science model" type of context.
</pre } >
  </td>
  <td>
  Hadoop:
  Hadoop "vs" Spark
  <a href="https://www.infoworld.com/article/3014440/big-data/five-things-you-need-to-know-about-hadoop-v-apache-spark.html">REF</a>
<pre xxxsmall zoom>
Hadoop is essentially a distributed data infrastructure: 
 -It distributes massive data collections across multiple nodes 
  within a cluster of commodity servers
 -It also indexes and keeps track of that data, enabling
  big-data processing and analytics far more effectively
  than was possible previously. 
Spark, on the other hand, is a data-processing tool that operates on those 
distributed data collections; it doesn't do distributed storage.

You can use one without the other: 
  - Hadoop includes not just a storage component, known as the 
  Hadoop Distributed File System, but also a processing component called 
  MapReduce, so you don't need Spark to get your processing done.
  - Conversely, you can also use Spark without Hadoop. Spark does not come with
  its own file management system, though, so it needs to be integrated with one
  -- if not HDFS, then another cloud-based data platform. Spark was designed for
  Hadoop, however, so many agree they're better together.

Spark is generally a lot faster than MapReduce because of the way it processes 
data. While MapReduce operates in steps, Spark operates on the whole data set 
in one fell swoop:
   "The MapReduce workflow looks like this: read data from the cluster, perform
    an operation, write results to the cluster, read updated data from the 
    cluster, perform next operation, write next results to the cluster, etc.," 
    explained Kirk Borne, principal data scientist at Booz Allen Hamilton. 
    Spark, on the other hand, completes the full data analytics operations 
    in-memory and in near real-time: 
    "Read data from the cluster, perform all of the requisite analytic 
    operations, write results to the cluster, done," Borne said.
Spark can be as much as 10 times faster than MapReduce for batch processing and 
p to 100 times faster for in-memory analytics, he said.
  You may not need Spark's speed. MapReduce's processing style can be just fine 
if your data operations and reporting requirements are mostly static and you 
can wait for batch-mode processing. But if you need to do analytics on 
streaming data, like from sensors on a factory floor, or have applications that
require multiple operations, you probably want to go with Spark.
 Most machine-learning algorithms, for example, require multiple operations. 

Recovery: different, but still good. 
Hadoop is naturally resilient to system faults or failures since data 
are written to disk after every operation, but Spark has similar built-in
resiliency by virtue of the fact that its data objects are stored in something 
called resilient distributed datasets distributed across the data cluster. 
"These data objects can be stored in memory or on disks, and RDD provides full 
recovery from faults or failures," Borne pointed out.
</pre>
  </td>
  <td>
  <a href="https://grafana.com/">Grafana</a><br/>
  time series analytics
  </td>
  <td>
  Graphite monitoring tool 
<pre xxxsmall zoom>
runs equally well on cheap hardware or Cloud infrastructure. Teams use Graphite
to track the performance of their websites, applications, business services, 
and networked servers. It marked the start of a new generation of monitoring 
tools, making it easier than ever to store, retrieve, share, and visualize 
time-series data.
</pre>
  </td>
</tr>
</table>
<br/>
<b>Network and SDN</b>
<table>
<tr>
  <td>
  <a href="https://www.onap.org/">Open Network Automation Platform</a>
  <a href="https://www.lightreading.com/nfv/containers/onap-cncf-come-together-on-containers/d/d-id/741790">ONAP, CNCF Come Together on Containers</a>
  </td>
  <td>
  <a href="https://www.cncf.io/">Cloud Native Computing Foundation</a><br/>
  CNCF serves as the vendor-neutral home for many of the fastest-growing projects on GitHub,
  including Kubernetes, Prometheus and Envoy, fostering collaboration between the 
  industry's top developers, end users, and vendors.
  </td>
  <td>
  <a href="https://www.envoyproxy.io/">Envoy</a><br/>
  Open Source edge and service proxy, designed for cloud-native applications 
  </td>
  <td>
<pre xxxsmall zoom { >
  As on the ground microservice practitioners quickly realize, the majority of 
  operational problems that arise when moving to a distributed architecture are
  ultimately grounded in two areas: networking and observability. It is simply 
  an orders of magnitude larger problem to network and debug a set of 
  intertwined distributed services versus a single monolithic application.
  
  Originally built at Lyft, Envoy is a high performance C++ distributed proxy 
  designed for single services and applications, as well as a communication bus
  and “universal data plane” designed for large microservice “service mesh” 
  architectures. Built on the learnings of solutions such as NGINX, HAProxy, 
  hardware load balancers, and cloud load balancers, Envoy runs alongside every
  application and abstracts the network by providing common features in a 
  platform-agnostic manner. When all service traffic in an infrastructure flows
  via an Envoy mesh, it becomes easy to visualize problem areas via consistent
  observability, tune overall performance, and add substrate features in a 
  single place.


  Out of process architecture
  
  Envoy is a self contained, high performance server with a small memory 
  footprint. It runs alongside any application language or framework.

  HTTP/2 and gRPC support
  Envoy has first class support for HTTP/2 and gRPC for both incoming and 
  outgoing connections. It is a transparent HTTP/1.1 to HTTP/2 proxy.

  Advanced load balancing
  Envoy supports advanced load balancing features including automatic retries, 
  circuit breaking, global rate limiting, request shadowing, zone local load 
  balancing, etc.

  APIs for configuration management
  Envoy provides robust APIs for dynamically managing its configuration.

  Observability
  Deep observability of L7 traffic, native support for distributed tracing, and
  wire-level observability of MongoDB, DynamoDB, and more.
</pre } >
  </td>
  <td>
  Utilising Linux BPF:
<pre xxxsmall zoom { >
https://www.infoq.com/news/2018/03/cilium-linux-bpf?utm_medium=SpecialNL_EditorialContent&utm_cam
Cilium is open source software for transparently securing the network 
connectivity between application services deployed using Linux container 
management platforms like Docker and Kubernetes. Cilium 1.0.0-rc4 has recently 
been released, which includes: the Cloud Native Computing Foundation 
(CNCF)-hosted Envoy configured as the default HTTP/gRPC proxy; the addition of 
a simple health overview for connectivity and other errors; and an improved 
scalable kvstore interaction layer.

Microservices applications tend to be highly dynamic, and this presents both a 
challenge and an opportunity in terms of securing connectivity between 
microservices. Modern approaches to overcoming this issue have coalesced around
the CNCF-hosted Container Network Interface (CNI) and the increasingly popular 
"service mesh" technologies, such as Istio and Conduit. According to the Cilium
documentation, traditional Linux network security approaches (such as iptables)
filter on IP address and TCP/UDP ports. However, the highly volatile life cycle
of containers and IP addresses cause these approaches to struggle to scale 
alongside the application as the large number of load balancing tables and 
access control lists must be updated continually.

Cilium attempts to address the issue with scaling by utilising a (relatively) 
new technology called Berkeley Packet Filter (BPF). BPF is a Linux kernel 
bytecode interpreter that was originally introduced to filter network packets, 
as seen in tcpdump and socket filters. It has been extended with additional 
data structures such as hash tables and arrays as well as additional actions to
support packet mangling, forwarding, encapsulation, etc. An in-kernel verifier 
ensures that BPF programs are safe to run and a JIT compiler converts the 
bytecode to CPU architecture specific instructions for native execution 
efficiency. For readers keen to explore BPF in further detail, performance Guru
Brendan Gregg has written and talked extensively about "Linux BPF Superpowers".
</pre }>
  </td>
</tr>
</table>
</body>
<!--

____________________
https://thenewstack.io/5-things-to-know-before-adopting-microservice-and-container-architectures/
____________________
TOPICS:
We now deploy software applications by stringing together services that run on a distributed set of computing resources and communicate over different networking protocols: A typical application can include:
- web servers
- application servers
- memory-based caching systems
- task queues
- message queues
- SQL databases
- NoSQL datastores
- load balancers

We also need to make sure we have:
 - redundancies 
 - logging
 - monitoring
 - analytics
 - third-party services:
   - REST APIs
   - infrastructure-as-a-service (IaaS) endpoints

 - configuration management:
   - Ansible playbooks, (Chef, Puppet, Salt,..)
 - Infrastructure as code: Jenkins "scripts" , ...
________________
Alan Kay’s maxim: "Simple things should be simple; complex things should be possible."

-->

</html>
