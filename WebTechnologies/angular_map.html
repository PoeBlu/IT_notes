<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Angular map <!-- draft --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<a href="https://angular.io/docs">[Angular]</a>
<body>
<table>
<tr>
<td>
  <a href="https://angular.io/guide/architecture">Architecture</a>
<pre xxxsmall zoom bgorange>
<b>
View     =  @Compoment                        + Template</b>
^^^^        ^^^^^^^^^^                          ^^^^^^^^  
screen      Compoment = Class +                 HTML + Directives   + data binding markup
element     ^           metadata-decorators            ^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^
on target   |           ^^^^^^^^^^^^^^^^^^^            provide        DOM changes  <->  program data
environ.    |           include pointer to             program logic  Binding types:
            |           associated template                           - Event   : user input  -> data update
          - Typically a component defines many                        - Property: data update -> DOM
            views, arranged hierarchically and                        
            the <b>Router service</b> defines                         Template Evaluation:
            navigation paths among them.                              tpl  
          - At least one *root component*                              -> evaluate directives 
            is needed by App, connecting a                              -> resolve binding syntax 
            component hierarchy with the                                 -> modify HTML elem. + DOM
            page document object model (DOM). 
          - *Service* (providers) are injected                        Template Pipes
            (@Injectable() decorator) to provide                      -  Ex: date data -> pipe -> locale-date
            needed non-visual functionality                           -  predefined pipes are provided for
          - When a component is instantiates,                            common transforms
            it's associated directly with
            the (root) host view.

IMPORTANT: hierarchical structure of views is a key factor in the way Angular detects and responds to changes 
           in the DOM and app data.

The host view can be the root of a view hierarchy, which can contain embedded views, which 
are in turn the host views of other components.

<b>Router NgModule Service</b>
  MAP of:
  URL-like paths  ← → views
  ^^^^^^^^                     
  also integrates 
  program data

- When a user performs an action (clicking a link, select drop box, ...)
  the router intercepts the browser's behavior, and shows
  or hides view hierarchies, lazy-loading new modules on demand


<b>View/Component tree</b>
view root    ← NgModule1.rootComponent
 +- view1    ← NgModule1.component1
 +- view2    ← NgModule2.rootComponent
   +- view2  ← NgModule2.component3
               ^^^^^^^^^^^^^^^^^^^^
               A view hierarchy can include
               views from components in the
               same or different NgModule



</td>
<td>
<b><a href="https://angular.io/guide/architecture-modules">Modules</a></b>
<pre xxxsmall zoom>
- NgModule == container (scope) set of components, service providers, ... 
              offerent  a cohesive block of code dedicated to
              an application domain/workflow/capabilities set. 
- They can import / export functionality from/to other NgModules
- Allows for lazy-loading.
- provides a *compilation context* for components:
- Angular app == tree of NgModules 
                 (bootstrapping root module plus others)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^             
                 ex. app.module.ts:
                 import { <b orange>NgModule</b> }      from '@angular/core';   ←  Javascript input
                 import { <b blue>BrowserModule</b> } from '@angular/platform-browser'; ← Javascript input
                 @NgModule({                         ← Decorator function.
                   imports:      [ <b blue>BrowserModule</b> ],  ← Imported modules
                   providers:    [ Logger ],         ← Creators of services that this NgModule
                                                       contributes to the global collection of
                                                       services, accessible in all parts of the
                                                       app.
                                                       (providers at component level can also
                                                       be specified , which is often preferred. 
                   declarations: [ AppComponent ],   ← components,directives,pipes
                                                       of this NgModule
                   exports:      [ AppComponent ],   ← (optional) Subset of declarations visible
                                                       and usable in the templates of
                                                       other NgModules
                   bootstrap:    [ AppComponent ]    ← main app view (root component)
                                                       hosting all other app views.
                                                       Only the root NgModule should set
                                                       the bootstrap property.

                 })
                 export class AppModule { }          ← Javascript export (vs NgModule export)

</pre>
</td>
<td>
  <a href="https://angular.io/guide/architecture-components">Components</a>
<pre xxxsmall zoom>
- A component controls a patch of screen called a view.
- Developers define the component as a typescript class
  with the application logic:
  - The class interacts with the view through an API of
    properties and methods.

Ex: src/app/hero-list.component.ts


@Component({
  selector:    'app-hero-list', ← instantiates a new component for each
                                  HTML &lt;app-here-list&gt; tag
  templateUrl: './hero-list.component.html',  ← Links component with module relate html tpl
                                                (it can be set programatically by setting
                                                 the template property)
  providers:  <b blue>[HeroService]</b>       ← Serv.prov. array required by component.
                                                Size must match constructor arg. size

})
export class HeroListComponent implements <b>OnInit</b> {
  heroes: Hero[];      ← data app property
  selectedHero: Hero;  ← data app property

  constructor<b blue>(private service:HeroService)</b> { }
  //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //          will be Dep.Injected

  <b>ngOnInit()</b> {
//^^^^^^^^
//Angular lifeCycle hook
    this.heroes = this.service.getHeroes();
  }

  selectHero(hero: Hero) { this.selectedHero = hero; }
}
</pre>

  <a href="https://angular.io/guide/architecture-components">Template syntax</a>
<pre xxxsmall zoom>
- A template looks like regular HTML plus <b orange>Angular template syntax. </b>
Ex.: src/app/hero-list.component.html
&lt;h2>Hero List&lt;/h2>

&lt;p>&lt;i>Pick a hero from the list&lt;/i>&lt;/p>
&lt;ul>
  &lt;li <b orange>*ngFor</b>="let hero of heroes" <b orange>(click)</b>="selectHero(hero)">
    <b orange>{{hero.name | UpperCase}}</b>


  &lt;/li>
&lt;/ul>

 &lt;<b orange>app-hero-detail</b> <b orange>*ngIf="selectedHero" <b orange>[hero]</b>="selectedHero">&lt;/<b orange>app-hero-detail</b>>

- *ngFor : iterate over a list.
- {{hero.name}}: binding
  [hero]
  (click) 
- | UpperCase  : pipe
</pre>

<b>DATA BINDING</b>
<pre xxxsmall zoom>
          {{value}}
     ←────────────────────
        [property]="value"    
DOM  ←────────────────────   COMPONENT
       (event)="handler"
      ────────────────────→
      [(ng-model)]="property  ← Two-way data binding 
     ←────────────────────→     (used mainly in template-driven forms)
                                Ex.:
                                &lt;input [(ngModel)]="hero.name">

    
Angular processes all data bindings once for each JavaScript event cycle, 
from the root of the application component tree through all child components.
</pre>

  @Directive()
<pre xxxsmall zoom>
- Angular transform HTML templates according to the instructions in directives. 

- Directive types:
  - Component  :
  - structural : alter layout by adding|removing|replacing elements in the DOM.
                 Example:
                 &lt;li             <b orange>*ngFor</b>="let hero of heroes">&lt;/li>
                 &lt;app-hero-detail<b orange> *ngIf</b>="selectedHero">&lt;/app-hero-detail>
                 *ngFor is an iterative; stamp out one <li> per hero in the heroes list.
                 *ngIf is a conditional; includes HeroDetail component only if a selected
                                         hero exists.
  - attribute  : alter the appearance or behavior of an existing element.
                 Ex:                
                 &lt;input [(ngModel)]="hero.name">
                 ngModel: modifies &lt;input> behavior by setting its display value
                          property and responding to change events.
</pre>
</td>
<td>
  Services and Dep.Inj.
 <pre xxxsmall zoom>
Service: broad category encompassing any value, function, or
         feature that an app needs.
         - Typically a class with a narrow, well-defined purpose.
           (do one thing and do it right)

Ex Service:
src/app/logger.service.ts
@Injectable()
export class Logger {
  log  (msg: any) { console.log  (msg); }
  error(msg: any) { console.error(msg); }
  warn (msg: any) { console.warn (msg); }
}
Note: Other than services a dependency can be a function or value.

<b orange>Injection Seq. Diagram</b>

for each injectable service/function/value create at least one provider:
The provider can be part of the service's own metadata, making that service
available everywhere, or you can register providers with specific modules 
or components. 
Providers are registed in the the metadata of the service 
(@Injectable(), @NgModule() or @Component() decorators)
Registering the provider in the @Injectable() metadata also allows Angular
to optimize an app by removing the service from the compiled app if it
isn't used.

App Bootstrap -> +app-wide inj.: create App.wide injector
app-wide inj. ->  app-wide inj.: creates container of
                                 dependency instances (reuses when possible)
...
  ???           -> +provider : Create provider
                                      ^^^^^^^^
                                    - tells an injector how to obtain|create a dependency.
                                    - (Usually the service class itself for service providers)
  
  ???           -> app.wide inj.: register provider 
  ...
angular       -> +Component class instance:
injector      ->  injector: determines which services (and extra deps) 
                            are needed by *looking at the constructor parameter types.*

injector      ->  injector: checks if the injector has any existing instances of
                            requested service or instantiate new one using the registered
                            provider.
injector      ->  angluar : returning service
angular       ->  Component class instance: call component constructor


$ ng generate service # By default registers a provider with the root injector 
                        for your service by including provider metadata in the
</pre>

  REGISTER SCOPE:
<pre xxxsmall zoom>

 | ROOT LEVEL:                    | NgModule LEVEL:                | Component LEVEL:
 |                                |                                | 
 | Angular creates a single,      | same instance of a service     | A new instance of the service
 | shared instance of the         | available to all components in | is created for each new new
 | service and injects it into    | the NgModule.                  | instance of the component. 
 | any class that asks for it.    |                                | 
 |                                |                                | 
 | @Injectable() decorator like:  | @NgModule({                    | @Component({
 | @Injectable({                  |   providers: [                 |   selector:    'app-hero-list',
 |  providedIn: 'root', ←         |   BackendService,              |   templateUrl: './hero-list.component.html',
 | })                             |   Logger                       |   providers:  [ HeroService ]
 |                                |  ],                            | })
 |                                |  ...                           |
 |                                | })                             |
</pre>
</td>
<td TODO>
  <a href="https://angular.io/api?type=pipe">Predefined Pipes</a>
<pre xxxsmall zoom>
AsyncPipe
CurrencyPipe
DatePipe
DecimalPipe
DeprecatedCurrencyPipe
DeprecatedDatePipe
DeprecatedDecimalPipe
DeprecatedPercentPipe
I18nPluralPipe
I18nSelectPipe
JsonPipe
KeyValuePipe
LowerCasePipe
PercentPipe
SlicePipe
TitleCasePipe
UpperCasePipe 
</pre>
</td>

</tr>
</table>

<table>
<tr>
<td>
  Responsive Programming
  <hr/>
<a href="https://angular.io/guide/lifecycle-hooks">Component Lifecycle hooks</a>:
<pre xxxsmall zoom>
Component and Directives have the same lifecycle
(Remember that a component is a type of directive)

- One interface exist for each existing life-cycle defined on the Angular lib.
- The hook name is the interface name prefixed with ng (OnInit iface -> ngOnInit)
  
Ex:
<b orange></b>
export class PeekABook implements <b orange>OnInit</b> {
  constructor(private logger: LoggerService) { }

  // implement OnInit's `ngOnInit` method to tap into life-cycle
  <b orange>ngOnInit()</b> { this.logIt(`OnInit`); }

  logIt(msg: string) {
    this.logger.log(`#${nextId++} ${msg}`);
  }
}

Main Hooks: 
Hook                    Purpose and Timing
ngOnChanges()           (re)sets data-bound input properties.
ngOnInit()              Initialize directive/component after first displays
                        the data-bound properties and sets the
                        directive/component's input properties.
ngDoCheck()             Detect and act upon changes that Angular 
                        can't or won't detect on its own.
ngAfterContentInit()    Respond after Angular projects external content 
                        into the component's view 
ngAfterContentChecked() ...
ngAfterViewInit()       ...
ngAfterViewChecked()    ... 
ngOnDestroy()           tap into Cleanup just before Angular destroy 
                        Use it to Unsubscribe Observables and detach
                        event handlers to avoid memory leaks.

Other hooks:
- Angular sub-systems
- 3rd party libraries may add new hooks.

<b>Lifecycle examples</b>
@Component...

  @Input() hero: Hero;
  @Input() power: string;
  ...
  ngOnChanges(changes: SimpleChanges) {
              ^^^^^^^^^^^^^^^^^^^^^^
          //  object mapping each changed property
          //  name to a SimpleChange object holding
          //  the current and previous property values.
    for (let propName in changes) {
      let chng = changes[propName];
      let cur  = JSON.stringify(chng.currentValue);
      let prev = JSON.stringify(chng.previousValue);
      this.changeLog.push(
         '${propName}: currentValue = ${cur}, previousValue = ${prev}');
    }
  }

<on-changes [hero]="hero" [power]="power"></on-changes>

Check <a href="https://angular.io/guide/lifecycle-hooks">Component Lifecycle hooks</a> for detailed examples.
</pre>

<a TODO href="https://angular.io/guide/observables">Observables,event processing</a>
<pre xxxsmall zoom>
Observables provide publishers/subscriber messaging pattern support 

Messages can be of any type: literals, messages or events depending on the context.

Publisher -> +"Subcriber-func01" : defines "subcriber function" defining the messages
                                   to be published.
                                   executed when a consumer calls the subscribe() method.
Publisher  -> +Observable01 : Creates Observable instance associated to the "Subcriber-func01"

Subscriber ->  Observable01 : subscribe(observer)
                                        ^^^^^^^^ 
                                  object implementing the
                                  <<Observer>> Interface
                                  defining handlers
                                  for arriving notifications
Subscriber <- Observable01 :  subscription01
.... subscriber start consuming values ...
Subscriber -> subscription01 : unsubscribe()

Ex: Using an observable to provide geolocation updates.
| // Create an Observable that will start listening to geolocation updates
| // when a consumer subscribes.
| const <b orange>locationsObservable</b> = new Observable((observer) => {
|   const {next, error} = observer; // get next,error callbacks, passed-in 
|                                   // when consumer subscribes.
|
|   let watchId = navigator.geolocation.watchPosition(next, error);
|  
|   return { // reset when consumer unsubscribes
|     unsubscribe() { navigator.geolocation.clearWatch(watchId); }
|   };
| });
|  
| const <b blue>locationsSubscription</b> = 
|           <b orange>locationsObservable</b>.subscribe({
|           <b orange>                   </b>.^^^^^^^^^  
|           <b orange>                 </b>// start listening 
|           <b orange>                 </b>// for updates
|                                             
|   next(position) { console.log(position *1);       },
|   error(msg)     { console.log('Error: ', msg); }
| });
|  
| ...
| locationsSubscription.unsubscribe();
|
| *1: message strings, event object, numeric value or structures
|

<<Observer>>
Notification type   Description
next     (req)      handler for each delivered value.
error    (opt)      handler for error notification. 
                    An error halts execution of the observable instance.
complete (opt)      A handler for the execution-complete
                    notification.

MULTICASTING

- each subscription/observer gets the same value
- With a multicasting observable, you don't register multiple listeners
  on the document, but instead re-use the first listener and send
  values out to each subscriber.

Ex: // @ma

    function sequenceSubscriber(observer) {
      const seq = [1, 2, 3];
      let timeoutId;
     
      // Will run through an array of numbers, emitting one value
      // per second until it gets to the end of the array.
      function doSequence(arr, idx) {
        timeoutId = setTimeout(() => {
          observer.next(arr[idx]);
          if (idx === arr.length - 1) {
            observer.complete();
          } else {
            doSequence(arr, ++idx);
          }
        }, 1000);
      }
     
      doSequence(seq, 0);
     
      // Unsubscribe should clear the timeout to stop execution
      return {unsubscribe() {
        clearTimeout(timeoutId);
      }};
    }
     
    // Create a new Observable that will deliver the above sequence
    const sequence = new Observable(sequenceSubscriber);
     
    sequence.subscribe({
      next(num) { console.log(num); },
      complete() { console.log('Finished sequence'); }
    });
     
    // Logs:
    // (at 1 second): 1
    // (at 2 seconds): 2
    // (at 3 seconds): 3
    // (at 3 seconds): Finished sequence


    

Notice that if you subscribe twice, there will be two separate streams, each emitting values every second. It looks something like this:
Two subscriptions

      

    // Subscribe starts the clock, and will emit after 1 second
    sequence.subscribe({
      next(num) { console.log('1st subscribe: ' + num); },
      complete() { console.log('1st sequence finished.'); }
    });
     
    // After 1/2 second, subscribe again.
    setTimeout(() => {
      sequence.subscribe({
        next(num) { console.log('2nd subscribe: ' + num); },
        complete() { console.log('2nd sequence finished.'); }
      });
    }, 500);
     
    // Logs:
    // (at 1 second): 1st subscribe: 1
    // (at 1.5 seconds): 2nd subscribe: 1
    // (at 2 seconds): 1st subscribe: 2
    // (at 2.5 seconds): 2nd subscribe: 2
    // (at 3 seconds): 1st subscribe: 3
    // (at 3 seconds): 1st sequence finished
    // (at 3.5 seconds): 2nd subscribe: 3
    // (at 3.5 seconds): 2nd sequence finished


    

Changing the observable to be multicasting could look something like this:
Create a multicast subscriber

      

    function multicastSequenceSubscriber() {
      const seq = [1, 2, 3];
      // Keep track of each observer (one for every active subscription)
      const observers = [];
      // Still a single timeoutId because there will only ever be one
      // set of values being generated, multicasted to each subscriber
      let timeoutId;
     
      // Return the subscriber function (runs when subscribe()
      // function is invoked)
      return (observer) => {
        observers.push(observer);
        // When this is the first subscription, start the sequence
        if (observers.length === 1) {
          timeoutId = doSequence({
            next(val) {
              // Iterate through observers and notify all subscriptions
              observers.forEach(obs => obs.next(val));
            },
            complete() {
              // Notify all complete callbacks
              observers.slice(0).forEach(obs => obs.complete());
            }
          }, seq, 0);
        }
     
        return {
          unsubscribe() {
            // Remove from the observers array so it's no longer notified
            observers.splice(observers.indexOf(observer), 1);
            // If there's no more listeners, do cleanup
            if (observers.length === 0) {
              clearTimeout(timeoutId);
            }
          }
        };
      };
    }
     
    // Run through an array of numbers, emitting one value
    // per second until it gets to the end of the array.
    function doSequence(observer, arr, idx) {
      return setTimeout(() => {
        observer.next(arr[idx]);
        if (idx === arr.length - 1) {
          observer.complete();
        } else {
          doSequence(observer, arr, ++idx);
        }
      }, 1000);
    }
     
    // Create a new Observable that will deliver the above sequence
    const multicastSequence = new Observable(multicastSequenceSubscriber());
     
    // Subscribe starts the clock, and begins to emit after 1 second
    multicastSequence.subscribe({
      next(num) { console.log('1st subscribe: ' + num); },
      complete() { console.log('1st sequence finished.'); }
    });
     
    // After 1 1/2 seconds, subscribe again (should "miss" the first value).
    setTimeout(() => {
      multicastSequence.subscribe({
        next(num) { console.log('2nd subscribe: ' + num); },
        complete() { console.log('2nd sequence finished.'); }
      });
    }, 1500);
     
    // Logs:
    // (at 1 second): 1st subscribe: 1
    // (at 2 seconds): 1st subscribe: 2
    // (at 2 seconds): 2nd subscribe: 2
    // (at 3 seconds): 1st subscribe: 3
    // (at 3 seconds): 1st sequence finished
    // (at 3 seconds): 2nd subscribe: 3
    // (at 3 seconds): 2nd sequence finished


    

Multicasting observables take a bit more setup, but they can be useful for certain applications. Later we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.
Error handling

Because observables produce values asynchronously, try/catch will not effectively catch errors. Instead, you handle errors by specifying an error callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values. An observable can either produce values (calling the next callback), or it can complete, calling either the complete or error callback.

      

myObservable.subscribe({
  next(num) { console.log('Next num: ' + num)},
  error(err) { console.log('Received an errror: ' + err)}
});

    

Error handling (and specifically recovering from an error) is covered in more detail in a later section.:
</pre>
</td>
<td TODO>
  Client-server interaction
  <hr/>
  <a TODO href="https://angular.io/guide/http">HTTP</a>
<pre xxxsmall zoom>
  Communicate with a server to get data, save data, and invoke server-side actions with an HTTP client.
</pre>
  <a TODO href="https://angular.io/guide/universal">Server-side Rendering</a>
<pre xxxsmall zoom>
  Angular Universal generates static application pages on the server through server-side rendering (SSR). This allows you to run your Angular app on the server in order to improve performance and show the first page quickly on mobile and low-powered devices, and also facilitate web crawlers.
</pre>
   <a TODO href="https://angular.io/guide/service-worker-intro">Service Workers</a>
<pre xxxsmall zoom>
Use a service worker to reduce dependency on the network
significantly improving the user experience.
</pre>
</td>
<td colsep></td>
<td TODO>
  Domain-specific libs
  <hr/>
  <a TODO href="https://angular.io/guide/animations">Animations</a>
<pre xxxsmall zoom>
 Use Angular's animation library to animate component behavior
without deep knowledge of animation techniques or CSS.
</pre>
  <a TODO href="https://angular.io/guide/forms">Forms</a>
<pre xxxsmall zoom>
Support complex data entry scenarios with HTML-based validation and dirty checking.
</pre>
</td>
<td colsep></td>
<td TODO>
  Dev.cycle
  <hr/>
  <a TODO href="https://angular.io/guide/aot-compiler">Compilation</a>
<pre xxxsmall zoom>
 Angular provides just-in-time (JIT) compilation for the development environment, and ahead-of-time (AOT) compilation for the production environment.
</pre>
  <a TODO href="https://angular.io/guide/testing">Testing platform</a>
<pre xxxsmall zoom>
 Run unit tests on your application parts as they interact with the Angular framework.
</pre>
<a TODO href="https://angular.io/guide/i18n">Internationalization</a>
<pre xxxsmall zoom>
  Make your app available in multiple languages with Angular's internationalization (i18n) tools.
</pre>
  <a TODO href="https://angular.io/guide/security">Security guidelines</a>
<pre xxxsmall zoom>
 Learn about Angular's built-in protections against common web-app vulnerabilities and attacks such as cross-site scripting attacks.
</pre>
</td>
<td colsep></td>

<td TODO>
   Setup, build, and deployment config
  <a TODO href="https://angular.io/cli">CLI Command Reference</a>
<pre xxxsmall zoom>
 The Angular CLI is a command-line tool that you use to create projects, generate application and library code, and perform a variety of ongoing development tasks such as testing, bundling, and deployment.
</pre>
  <a TODO href="https://angular.io/guide/file-structure">Workspace and File Structure</a>
<pre xxxsmall zoom>
 Understand the structure of Angular workspace and project folders. 
</pre>
  <a TODO href="https://angular.io/guide/npm-packages">npm Packages</a>
<pre xxxsmall zoom>
 The Angular Framework, Angular CLI, and components used by Angular applications are packaged as <a href="https://docs.npmjs.com/">npm</a> packages and distributed via the npm registry. The Angular CLI creates a default <code>package.json</code> file, which specifies a starter set of packages that work well together and jointly support many common application scenarios.
</pre>
  <a TODO href="https://angular.io/guide/typescript-configuration">TypeScript configuration</a>
<pre xxxsmall zoom>
 TypeScript is the primary language for Angular application development.
</pre>
  <a TODO href="https://angular.io/guide/browser-support">Browser support</a>
<pre xxxsmall zoom>
 Make your apps compatible across a wide range of browsers.
</pre>
  <a TODO href="https://angular.io/guide/build">Building and Serving</a>
<pre xxxsmall zoom>
 Learn to define different build and proxy server configurations for your project, such as development, staging, and production.
</pre>
  <a TODO href="https://angular.io/guide/deployment">Deployment</a>
<pre xxxsmall zoom>
 Learn techniques for deploying your Angular application to a remote server.
</pre>
</td>
</tr>
</table>

</body>
<!--
TODO_START: {
}
-->

</html>
