<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Git map (draft) <!-- ignore --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>

<table>
<tr>
<td>
  <spam xsmall>Setup git client</a>
<pre zoom>
*Make git branch appear on the shell prompt :* (☜strongly recomended)
 - Next trick works only on bash-alike shells.

 - Add a line similar to next one into your $HOME/.bashrc:
   # Ex 1:  Us git branch in your prompt
   export PS1="\\w:\$(git branch 2>/dev/null | grep '^*')\$ " 
                    └───     show git branch ───────────┘

   # Ex 2: "complex" PS1.
   PS1="\h[\$(git branch 2>/dev/null | grep ^\* | sed 's/\*/branch:/')]@\$(pwd |rev| awk -F / '{print \$1,\$2}' | rev | sed s_\ _/_) \$ "
            └─────────────     show git branch    ───────────────────┘   └────────────── show current and parent dir. only ────────┘

  NOTE: The bash syntax $(... command ...) will replace  
        the standard output of the ...command... inside parenthesis
        as the value of the variable (PS1 in this case)


*Set Remote ssh git repository with custom SSH settings (port, keys, ...)*
 <a href="https://stackoverflow.com/questions/5767850/git-on-custom-ssh-port/50854760#50854760">REF@stackoverflow</a> 
 - Use *GIT_SSH_COMMAND* environment variable to add non-standard
   options needed by the ssh client (port, priv.key, IPv6, PKCS#11 device, ...).
 
 - Ex: access ssh on non-standard o*1234* port and g*~/.ssh/myGitPrivate_rsa.key* private key
   $ export GIT_SSH_COMMAND="ssh o*-oPort=1234* g*-i ~/.ssh/myGitPrivate_rsa.key*"
   $ git clone myuser@myGitRemoteServer:/my/remote/git_repo/path
</pre>

  <a xsmall href="XXX">Init bare ("origin") repo</a>
<pre zoom>
$ cd anyPathInFileSystem      ← Probably one used for git "origin" repos, where backups have 
                                been setup properly
$ mkdir myRepo.git            
$ chgrp workGroup myRepo.git  ← Group of users accesing this repository.
$ cd myRepo.git               ← .git extension is a convention for bare dirs
$ <b>git init --bare  \ </b>         ← --bare : will not contain working copy of source files.
  <b>  ← --shared=group</b>                     only used to share with (remote|local) origin
                               : --shared=group fixed permissions for group.
</pre>
  
  <a xsmall href="XXX"> Init working copy</a>
<pre zoom>
$ cd $HOME/...pathToMyProject
$ git clone ..../myRepo.git          ← Clone local file-system bare repository
            ^^^^^^^^^^^^^^^
            path to bare ("origin") directory
$ git clone https://..../myRepo.git  ← Clone remote https repository (gogs, github, ...)
</pre>
  <a xsmall href="XXX">Common flow</a>
<pre zoom>
  Flow 1: no one else pushed changed before our push)
"edit" ─→ git status ─→ git add . ─→ git commit ─→ git push
  Flow 2: someone else pushed changed before our push, no conflicts
"edit" ─→ git status ─→ git add . ─→ git commit ─→ git pull  ─→ git push
  Flow 3: someone else pushed changed before our push, with conflicts
"edit" ─→ git status ─→ git add . ─→ git commit ─→ git pull  ─→ "fix conflicts" ─→ git add ─→ git commit ─→ git push
              ^             ^              ^            ^          ^                   ^          ^             ^
              │             │              │            │          │                   │          │             │
              │         add file/s         │        pull remote    │             once fixed       │    push to remote 
              │         to next commit     │        changes from   │             add again for    │    repository
              │                            │        other users    │             next commit      │    (origin,...)
              │                            │                       │                              │                
          display changes               commit                   manually edit                 Commit to
          pending to commit             new version              conflicting changes           merge

  Flow 4: Amend local commit
"edit" ─→ git status ─→ git add . ─→ git commit ─→ git commit ─amend ─→ ... ─→ git commit ─→ git push
</pre>
  <a xsmall TODO href="XXX">History</a>
<pre zoom>
$ git log  
$ git log -p "path/to/some/given/file" 
$ git blame "path/to/some/given/file"  ← Who changed what, when in some file
</pre>


  <a xsmall TODO href="XXX">branching</a>
<pre zoom>
Change branch (checkout)
$ git checkout -b newBranch       ← -b: creates branch
$ git checkout    existingBranch     
$ git branch -av                  ←  List (-a)ll existing branches
$ git branch -d branchToDelete    ← -d: Delete branch

$ git checkout --track "remote/branch"  ← Create  new tracking branch (TODO)


</pre>


</td>
<td>
  
  <a xsmall TODO href="XXX">Comparing diffs</a>  
<pre zoom>
</pre>
</td>
<td>
<a xsmall TODO href="https://gogs.io/">git grep</a>
<pre zoom>
- how to use it to locate information within a Git repository.
</pre>
</td>

<td>
<a xsmall TODO href="">Tags</a>
<pre zoom>

$ git tag                 ← List tags
→ ...
→ v2.1.0-rc.2
→ v2.1.1
→ v2.1.2
→ ...
$ git tag -a v1.4 -m "..." ← Create annotated tag (recomended)
                                    ^^^^^^^^^
                                - stored as full objects in Git database.
                                - They’re checksummed; contain the tagger name,
                                - email, and date; have a tagging message (-m).
                                - can be signed and verified with GPG.

$ git tag v1.4-lw          ← Create lightweight tag
                                    ^^^^^^^^^^^    
                                  - "alias" for a commit checksum stored in a file
                                  - No other info is kept.

$ git tag -a v1.2 9fceb02  ← Tag some commit in history

<b>Sharing Tags</b>
WARN: git push command doesn’t transfer tags to remote servers. 


$ git push origin v1.5    ← Share/push tag to remote repo

$ git push origin --tags  ← Share/push all the tags

$ git tag -d v1.4-lw      ← Delete local tag (remote tags will persist)

$ git push origin --delete v1.4-lw    ← Delete remote tag. Alt 1
$ git push origin :refs/tags/v1.4-lw  ← Delete remote tag. Alt 2
                  ^^^^^^^^^^^^^^^^^^
                  null value before the colon is
                  being pushed to the remote tag name,
                  effectively deleting it.


$ git checkout v1.4-lw          ← Move back to (DETACHED) commit

$ git show-ref --tags    ← Map tag to commit
→ ...
→ 75509731d28ddbbb6f6cbec6e6b50aeaa413df69 refs/tags/v2.1.0-rc.2
→ 8fc0a3af313d9372fc9b8d3e5dc57b804df0588e refs/tags/v2.1.1
→ 3e1f5b0d4d081db7b40f9817c060ee7220a51633 refs/tags/v2.1.2
→ ...
</pre>
</td>
<td>
  <a xsmall todo href="xxx">Filter-branch</a>
<pre zoom>
- rewrite history in Git using several of the built-in filters that the command provides.   
  - rev-list command, which provides a way to list out revisions based on a range or criteria.
  - filter-branch: split a subdirectory into a separate repository
  - how to use to use filter-branch to delete a file from all versions in a repository 
    and change the email address on versions in Git history
</pre>
</td>
<td>
<a xsmall TODO href="https://opensource.com/article/18/11/gitbase">gitbase</a>
<pre zoom>
</pre>
</td>
<td>
<a xsmall TODO href="https://www.systutorials.com/2845/how-to-revert-changes-in-git/">Revert Changes</a>
<pre zoom>
</pre>
</td>



</tr>
</table>
 DevOps
<table>
</tr>
<td>
<a xsmall TODO href="https://gogs.io/">painless self-hosted Git service</a>
<pre zoom>
</pre>
</td>
<td>
<a xsmall TODO href="https://git-lfs.github.com/">Git LFS (Large Files extension)</a>
<pre zoom>
- Git Large File Storage (LFS) replaces large files such as audio samples,
  videos, datasets, and graphics with text pointers inside Git, while storing 
  the file contents on a remote server like GitHub.com or GitHub Enterprise
</pre>
</td>
<td>
<a xsmall TODO href="https://www.linuxtoday.com/security/4-secrets-management-tools-for-git-encryption-190219145031.html">4 secrets encryption tools </a>
<pre zoom>
</pre>
</td>


</tr>
</table>

 Advanced
<table>
</tr>
<td>
  <a xsmall TODO href="XXX">revert/rerere</a>
<pre zoom>
</pre>
</td>
<td>
  <a xsmall todo href="xxx">bisect</a>
<pre zoom>
</pre>
</td>
<td>
  <a xsmall todo href="xxx">Submodules</a>
<pre zoom>
</pre>
</td>
<td>
  <a xsmall todo href="xxx">Subtrees</a>
<pre zoom>
- TODO: how subtrees differ from submodules
   - how to use the subtree to create a new project from split content
</pre>
</td>

<td>
  <a xsmall todo href="xxx">Interactive rebase:</a>
<pre zoom>
-  how to rebase functionality to alter commits in various ways.
   - how to squash multiple commits down into one. 
</pre>
</td>
<td>
<a xsmall TODO href="XXX">Supporting files:</a>
<pre zoom>
- Git attributes file and how it can be used to identify binary files,
  specify line endings for file types, implement custom filters, and 
  have Git ignore specific file paths during merging.
</pre>
</td>
<td>
<a xsmall TODO href="https://www.linux.com/blog/2018/11/cregit-token-level-blame-information-linux-kernel">Cregit token level blame</a>
<pre zoom>
cregit: Token-Level Blame Information for the Linux Kernel
Blame tracks lines not tokens, cgregit blames on tokens (inside a line)
</pre>
</td>


</tr>
</table>
<pre zoom>
<span xsmall>Encrypt Git repos</span>
@[https://www.atareao.es/como/cifrado-de-repositorios-git/]
</pre>


<pre zoom>
<span xsmall>JGit</span>
- https://wiki.eclipse.org/JGit/User_Guide
- Eclipse Distribution License - v 1.0
- lightweight, pure Java library implementing the Git version control system
  - repository access routines
  - network protocols
  - core version control algorithms

- suitable for embedding in any Java application
</pre>

<pre zoom>
<span xsmall>Client Hooks</span>
@[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks]

Client-Side Hooks
- not copied when you clone a repository
  - to enforce a policy do on the server side
- committing-workflow hooks:
  -*pre-commit*hook:
    - First script to be executed.
    - used to inspect the snapshot that's about to be committed.
      - Check you’ve NOT forgotten something
      - make sure tests run
      - Exiting non-zero from this hook aborts the commit
    (can be bypassed with git commit --no-verify flag)
  -*prepare-commit-msg*hook:
    - Params:
      - commit_message_path (template for final commit message)
      - type of commit
      - commit SHA-1 (if this is an amended commit)
    - run before the commit message editor is fired up 
      but after the default message is created.
    - It lets you edit the default message before the
      commit author sees it.
    - Used for non-normal-commits with auto-generated messages
      - templated commit messages
      - merge commits
      - squashed commits
      - amended commits
  -*commit-msg*hook:
      - commit_message_path (written by the developer)
  -*post-commit*hook:
    - (you can easily get the last commit by running git log -1 HEAD)
    - Generally, this script is used for notification or something similar.

-*email-workflow* hooks:
  - invoked by *git am*
                ^^^^^^
                Apply a series of patches from a mailbox
                prepared by git format-patch

  -*applypatch-msg*: 
    - Params:
      - temp_file_path containing the proposed commit message.
  -*pre-applypatch*:
    - confusingly, it is run after the patch is 
      applied but before a commit is made.
    - can be used it to inspect the snapshot before making the commit,
      run tests,  inspect the working tree with this script.
  -*post-applypatch*:
    - runs after the commit is made.
    - Useful to notify a group or the author of the patch
      you pulled in that you’ve done so. 

- Others:
  -*pre-rebase*hook:
    - runs before you rebase anything
    - Can be used to disallow rebasing any commits
      that have already been pushed.
  -*post-rewrite*hook:
    - Params:
      - command_that_triggered_the_rewrite: 
        - It receives a list of rewrites on stdin.
    - run by commands that replace commits
      such as 'git commit --amend' and 'git rebase'
      (though not by git filter-branch).
    - This hook has many of the same uses as the
      post-checkout and post-merge hooks.
  -*post-checkout*hook:
    - Runs after successful checkout
    - you can use it to set up your working directory
      properly for your project environment.
      This may mean moving in large binary files that 
      you don't want source controlled, auto-generating
      documentation, or something along those lines.
  -*post-merge*hook:
    - runs after a successful merge command.
    - You can use it to restore data in the working tree
      that Git can't track, such as permissions data.
      It can likewise validate the presence of files 
      external to Git control that you may want copied 
      in when the working tree changes.
  -*pre-push*hook:
    - runs during git push, after the remote refs
      have been updated but before any objects have
      been transferred.
    - It receives the name and location of the remote
      as parameters, and a list of to-be-updated refs
      through stdin.
    - You can use it to validate a set of ref updates before
      a push occurs (a non-zero exit code will abort the push).
</pre>

<pre zoom>
<span xsmall>Server-Side Hooks</span>
(system administrator only)
- Useful to enforce nearly any kind of policy for your project.

- can exit non-zero at any time to reject the push 
  as well as print an error message back to the client; 

- you can set up a push policy that's as complex as you wish.

*pre-receive* hook:
 - first script to run 
 - takes a list of references that are being pushed from stdin;
   if it exits non-zero, none of them are accepted. 
 - You can use this hook to do things like make sure none of the updated 
   references are non-fast-forwards, or to do access control for all the refs 
   and files they’re modifying with the push.

*update*
 - very similar to the pre-receive script, except that 
  *it's run once for each branch the pusher is trying to update*.
 - If the pusher is trying to push to multiple branches, pre-receive runs only once,
   whereas update runs once per branch they're pushing to.
 - Instead of reading from stdin, this script takes three arguments:
   - the name of the reference (branch),
   - the SHA-1 that reference pointed to before the push, 
   - the SHA-1 the user is trying to push.
 - If the update script exits non-zero, only that reference is rejected; 
   other references can still be updated.

*post-receive*
 - runs after the entire process is completed 
 - can be used to update other services or notify users.
 - It takes the same stdin data as the pre-receive hook.
 - Examples include emailing a list, notifying a CI server,
   or updating a ticket-tracking system 
   You can even parse the commit messages to see if any
   tickets need to be opened, modified, or closed.
 - This script can't stop the push process, but the client 
   doesn't disconnect until it has completed, so be careful
   if you try to do anything that may take a long time.
</pre>

</body>
<!--
TODO_START: {
https://github.com/Microsoft/VFSForGit
https://vfsforgit.org/
Virtual File System for Git: Enable Git at Enterprise Scale 

}
____________________________

Git occasionally does garbage collection as part of its normal operation, by invoking git gc --auto. The pre-auto-gc hook is invoked just before the garbage collection takes place, and can be used to notify you that this is happening, or to abort the collection if now isn’t a good time.

-->

</html>
