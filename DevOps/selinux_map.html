<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Security Enhanced Linux (SELinux) map (alpha)</title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>
<table>
<tr>
<td>
  <span xsmall>Ext.Refs</span>
<pre xxxsmall zoom>
- <a href="https://github.com/SELinuxProject/selinux/wiki">[Selinux WiKi@GitHub]</a>,
- <a href="https://github.com/SELinuxProject/setools/wiki">[Setools WiKi@GitHub]</a>,
- <a href="https://github.com/SELinuxProject/cil/wiki"    >[CIL     WiKi@GitHub]</a>,

- <a href="https://github.com/SELinuxProject/refpolicy"   >[Ref.Policy]</a>,
- <a href="http://selinuxbyexample.com/">[(Book) SELinux by Example]</a>
- <a href="http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html">[(Book) The SELinux Notebook - The Foundations]</a>
- <a href="https://www.youtube.com/watch?v=cNoVgDqqJmM&feature=youtu.be">[Stop disabling SELinux</a>
</pre>
</td>
<td>
  <span xsmall>Summary</span>
<pre xxxsmall zoom { >
┌──────────────────────────┬──────────────────────────────────────────────────────────────┐ ┌────────────────────────────┬──────────────────────────────────────┐
│*SE─LINUX GLOBAL SUMMARY*:│                                                              │ │*INITIAL PRE─SETUP SUMMARY:*│                                      │   
├──────────────────────────┘                                                              │ ├────────────────────────────┘                                      │
│b*KERNEL OBJECTS CLASSES*                                                                │ │ Define SE-Linux System policy with a flow similar to:             │
│  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑                                                                 │ │                                                                   │
│  Represent type─of─resources                                                            │ │ create modules → load into kernel → Init bitmap─"matrix"          │
│  handled by kernel (vs apps)  *HARDCODED* list of g*actions* defined  command line      │ │                                     context1─to─[context2,action] │
│  that must be protected        for each se─linux kernel object class  management        │ │                                     ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ │  
│  ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓       ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓     ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  │ │                                               Access Vector  (AV) │
│b*File            class*    ←→ [append, create, lock,         ... ] ← semanage fcontext  │ └───────────────────────────────────────────────────────────────────┘
│b*Process         class*    ←→ [dyntransition, ptrace, fork,  ... ]                      │        
│b*INET Socket     class*    ←→ [bind, read, ...               ... ] ← semanage port│node │ ┌─────────────────────────────────────────────────┬───────────────────────────────────────────────┐
│b*login           class*    ←→ [action1, action2, ...         ... ] ← semanage login     │ │*STANDARD SElinux TYPE─ENFORCEMENT FLOW SUMMARY:*│                                               │
│b*user            class*    ←→ [action1, action2, ...         ... ] ← semanage user      │ │(Once the policy has been loaded into kernel)    │                                               │
│  ...                                                                        ...         │ ├─────────────────────────────────────────────────┘                                               │
│                                                                                         │ │   PROCESS     →      System call           →  SECURITY             →  SELinux                   │
│"Full" list of object classes and actions can be found at:                               │ │               →  (Kernel entry point)      →  SERVER@Kernel        →  AV (AV─Cache actually)    │
│https://github.com/SELinuxProject/refpolicy/blob/master/policy/flask/access_vectors      │ │ ↑↑↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑↑↑↑↑          ↑↑↑↑↑↑↑↑                  │
│                                                                                         │ │   RUNNING         request (hardcoded)        Query if *type1*       Q:Iso*type1* allowed        │
│                               ┌────────── SELinux  4─tuple context ───────────────┐     │ │  SE─CONTEXT     g*action1*over targeted      is allowed g*action1*      g*action1* over         │
│*All*(Kernel Object classes) → " user ":" role "               :"o*type*":" level "      │ │...:o*type1*:.     object (labeled with       over b*type2*              b*type2* targeted object│
│*instances* are*labeled*with    Role Based Access Control:         ^^^^                  │ │                   SEContext b*type2*)                               A:*YES*│r*NO*               │
│ an*SELINUX─CONTEXT*:           ─ SELinux users are associated     USED FOR:             │ │                                                                               ↑↑                │
│        ↑                         to one or more roles,          o*TYPE─ENFORCEMENT*     │ │                                                                             r*abort and audit*  │
│        │                       ─ each role may be associated                            │ │                                                                          ☝                      │
│        │                         to one or more Domain types.                           │ │                                                                      At this point is when      │
│        │                       ─ Note: SElinux users are not                            │ │                                                                      SELinuxo*TYPE─ENFORCEMENT* │
│        │                         normal linux users: Most                               │ │                                                                      is actually processed      │
│        │                         users are mapped to a single                           │ └─────────────────────────────────────────────────────────────────────────────────────────────────┘
│        │                         SELinux user.                                          │
│        │                                                                                │ ┌─────────────────────┬────────────────────────┐
│─ Files and directories labeling is managed through extended file─system attributes      │ │ DAC,MAC FLOW SUMMARY│                        │
│─ Processes, ports, ... labeling is managed by the kernel.                               │ ├─────────────────────┘                        │
└─────────────────────────────────────────────────────────────────────────────────────────┘ │ USER   ┌─────────→ ┌─────────┐               │
 ┌────────────────────────────────────────────────┬──────────────────────────────────────┐  │ SPACE  │ ┌───────→ │ PROCESS │ ←────────┐    │
 │*DISPLAYING SELINUX RELATED CONTEXT ATTRIBUTES:*│                                      │  │        │ │ ┌─────→ │"SUBJECT"│          │    │
 ├────────────────────────────────────────────────┘                                      │  │        │ │ ┌─────→ └─────────┘          │    │
 │- Use "─Z" flag to shell commands                                                      │  │        │ │ │            │               │    │
 │ ┌────────────────────────────────────────────┬───────────────────────────────────────┐│  │        │ │ │            ↓               │    │
 │ │FILE SYSTEM OBJECT                          │SUBJECTS                               ││  │ ────── │ │ │ ───── system─call ──────── │ ───│
 │ │(files, dirs,..)                            │(running processes)                    ││  │ KERNEL │ │ │            │               │    │
 │ │$*ls ─ldZ*                                  │                                       ││  │ SPACE  │ │ │            ↓               │    │
 │ │  /usr/sbin/httpd   → o*httpd_exec_t       *│$*ps axZ │ grep [h]ttpd*               ││  │        │ │ │          Lookup            │    │
 │ │  /var/www/html/    → o*httpd_sys_content_t*│unconfined_u:system_r:o*httpd_*t:s0 ...││  │        │ │ │           data             │    │
 │ │  /etc/apache2/     → o*httpd_config_t     *│                                       ││  │        │ │ │            │               │Sys.│
 │ │  /var/log/httpd/   → o*httpd_log_t        *│                                       ││  │        │ │ │ r*KO*      ↓               │call│
 │ │  /etc/init.d/httpd → o*httpd_initrc_exec_t*│                                       ││  │        │ │ └─────────  Error            │Res.│
 │ ├────────────────────────────────────────────┼───────────────────────────────────────┤│  │        │ │            Checks            │    │
 │ │SOCKET                                      │  PORT                                 ││  │        │ │              │               │    │
 │ │$ sudo netstat ─tnlpZ │ grep httpd          │  $ sudo semanage port ─l │ grep http  ││  │        │ │              │g*OK*          │    │
 │ │....  unconfined_u:system_r:o*httpd_*t:s0 ..│  http_cache_port_t  tcp 3128,8080, ...││  │        │ │              ↓               │    │
 │ │                                            │  ...                                  ││  │        │ │   r*KO*     DAC              │    │
 │ │                                            │o*http_port_t*       tcp 80, 443       ││  │        │ └───────── permission          │    │
 │ └────────────────────────────────────────────┴───────────────────────────────────────┘│  │        │              checks            │    │
 └───────────────────────────────────────────────────────────────────────────────────────┘  │        │                │               │    │
                                                                                            │        │                │               │    │
                                                                                            │        │     r*KO*      ↓   g*OK*       │    │
                                                                                            │        └─────────────  LSM  ────────────┘    │
                                                                                            │                       hooks                  │
                                                                                            │                        │ ^                   │
                                                                                            │                  Action│ │g*OK*              │
                                                                                            │                allowed?│ │r*KO*              │
                                                                                            │                        ↓ │                   │
                                                                                            │                       Linux                  │
                                                                                            │                      Security                │
                                                                                            │                       Module                 │
                                                                                            │                    (e.g.SELinux)             │
                                                                                            └──────────────────────────────────────────────┘
</pre }>
</td>
<td>
  <span xsmall>Nomenclature</span>
<pre xxxsmall zoom>
┌─────────────────┬────────┬────────────────────────────────────────────────────────────────────────┐
│ TERMINOLOGY     │ACRONYM │    DESCRIPTION                                                         │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Access  Vector  │AV      │ - bit map representing a set of permissions such as open, read, ...    │
│                 │        │ - Each policy defines a different AV.                                  │
│                 │        │ - Actually is implemented as a hash table where the key is the tuple   │
│                 │        │   (source-type, targeted-type, targeted-kernel-object-class)           │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Access Vector   │AVC     │ ─ SELinux Security  Server can take a time to calculate                │
│ Cache           │        │   access decissions based on SE─rules.                                 │
│                 │        │ ─ The AVC stores such decissions to speed up following                 │
│                 │        │   access avoiding to recompute.                                        │
│                 │        │ ─ two AVCs exists:                                                     │
│                 │        │   ─ 1.kernel AVC caching decisions from Security Server                │
│                 │        │       on behalf of kernel based object managers.                       │
│                 │        │   ─ 2.userspace AVC built into libselinux that caches                  │
│                 │        │       decisions when SELinux─aware applications use                    │
│                 │        │       avc_open(3) with avc_has_perm (3) or avc_has_perm_noaudit(3)     │
│                 │        │       function calls saving kernel calls after first                   │
│                 │        │       decision has been made.                                          │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Bell─La Padula  │BLP     │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Common  Criteria│CC      │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Common          │CIL     │                                                                        │
│ Intermediate    │        │                                                                        │
│ Language        │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Discretionary   │DAC     │                                                                        │
│ Access          │        │                                                                        │
│ Control         │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ SELinux         │        │ ─ consists of one or more processes associated                         │
│ Domain          │        │   to the type component of a Security Context.                         │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Flux  Advanced  │FLASK   │ ─ See Flux  Research  Group  (http://www.cs.utah.edu/flux/)            │
│ Security Kernel │        │   μ─kernel Environment (Fluke)                                         │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Linux Security  │LSM     │ ─ framework providing hooks into kernel components                     │
│ Module          │        │   (e.g. disk, net─services,...) used by                                │
│                 │        │   security modules (SELinux, ....) to perform                          │
│                 │        │   access control checks.                                               │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Mandatory Access│MAC     │ ─ access control mechanism enforced by the system,                     │
│ Control         │        │   e.g. 'hard─wiring' the OS and applications or                        │
│                 │        │   via policies enforced by the administrator.                          │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Multi─Category  │MCS     │                                                                        │
│ Security        │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Multi─Level     │MLS     │ ─ Based on Bell─La Padula model for                                    │
│ Security        │        │   confidentiality in that (for example) a                              │
│                 │        │   process running at a 'Confidential' level                            │
│                 │        │   can read / write at their current level but                          │
│                 │        │   only read down levels or write up levels.                            │
│                 │        │ ─ "Today" it is more commonly used for                                 │
│                 │        │   application separation utilising the                                 │
│                 │        │   Multi─Category Security variant.                                     │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ SELinux Policy  │        │ - Set of (thousands of) rules that define the type-enforcement rules   │
│                 │        │   in the AV bitmap matrix/hashtable                                    │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Object  Manager │OM      │ ─ Userspace&amp;kernel components responsible                          │
│                 │        │   management (object labeling, creation, access, destruction)          │
│                 │        │   of SELinux object under their control.                               │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Security        │SID     │                                                                        │
│ Identifier      │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Simplified      │SMACK   │                                                                        │
│ Mandatory       │        │                                                                        │
│ Access Control  │        │                                                                        │
│ Kernel          │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Super─user      │SUID    │                                                                        │
│ Identifier      │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Type Enforcement│TE      │ ─ set of rules declared in Policy describe                             │
│                 │        │   how the domain will interact with objects                            │
│                 │        │ ─ In practice: the AV bit─map used to check                            │
│                 │        │   where type1 is allowed actionN over type2                            │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ User  Identifier│UID     │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ X(window) Access│XACE    │                                                                        │
│ Control         │        │                                                                        │
│ Extension       │        │                                                                        │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Security Server │        │   A sub─system in the Linux kernel that makes access decisions         │
│                 │        │   and computes security contexts based on Policy on behalf of          │
│                 │        │   SELinux─aware applications and Object Managers.                      │
│                 │        │   The Security Server does not enforce a decision, it merely           │
│                 │        │   states whether the operation is allowed or not according to the      │
│                 │        │   Policy. It is  the  SELinux─aware  application  or Object            │
│                 │        │   Manager responsibility to enforce the decision.                      │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Security Context│        │   An SELinux Security Context is a variable length string that         │
│                 │        │   consists  of  the  following  mandatory  components                  │
│                 │        │   user:role:type and an optional [:range] component.                   │
│                 │        │   Generally abbreviated  to 'context', and sometimes  called a         │
│                 │        │   'label'.                                                             │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Security        │SID     │   SIDs are unique opaque integer values mapped by the kernel           │
│ Identifier      │        │   Security Server and userspace AVC that represent a Security Context. │
│                 │        │   The SIDs generated by the kernel Security Server are u32             │
│                 │        │   values that are  passed via the Linux Security Module                │
│                 │        │   hooks to/from the kernel Object Managers.                            │
│─────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
│ Type Enforcement│        │   SELinux makes use of a specific style of type enforcement            │
│                 │        │   (TE) to enforce Mandatory Access Control. This is where all          │
│                 │        │   subjects and objects have a type identifier associated to them       │
│                 │        │   that can then be used to enforce rules laid down by                  │
│                 │        │   Policy                                                               │
│ ────────────────┼────────┼────────────────────────────────────────────────────────────────────────│
</pre>
</td>
<td>
  <span xsmall>Object Classes</span>
<pre xxxsmall zoom>
SELinux Kernel Object Classes:
Summary extracted from
https://raw.githubusercontent.com/SELinuxProject/refpolicy/master/policy/flask/access_vectors
*│common file       │class dir      │class file       │class lnk_file │class chr_file   │class blk_file *       │ *NETWORK─RELATED OBJECTS.*
 │                  │inherits file  │inherits file    │inherits file  │inherits file    │inherits file          │ *│common socket           │class socket               │class rawip_socket    │class unix_stream_socket* 
 │                  │               │                 │               │                 │                       │  │                        │ inherits socket           │inherits socket       │inherits socket           
 │ioctl             │add_name       │execute_no_trans │open           │execute_no_trans │open                   │  │                       *│class netlink_socket*      │                      │
 │read              │remove_name    │entrypoint       │audit_access   │entrypoint       │audit_access           │  │# inherited from file   │inherits socket            │node_bind             │connectto               
 │write             │reparent       │execmod          │execmod        │execmod          │execmod                │  │ioctl                  *│class packet_socket        │                      │newconn                 
 │create            │search         │open             │               │open             │                       │  │read                    │inherits socket                                   │acceptfrom               
 │getattr           │rmdir          │audit_access                     │audit_access                             │  │write                  *│class key_socket*                                 │                            
 │setattr           │open           │                                 │                                         │  │create                  │inherits socket             
 │lock              │audit_access                                                                               │  │getattr                *│class unix_dgram_socket*    
 │relabelfrom       │execmod                                                                                    │  │setattr                 │inherits socket             
 │relabelto         │                                                                                           │  │lock                
 │append                                                                                                        │  │relabelfrom            *│class tcp_socket     │class udp_socket      │class node       │class netif*
 │map              *│class sock_file   │class fifo_file   │class fd*                                            │  │relabelto               │inherits socket      │inherits socket       │                 │
 │unlink            │inherits file     │inherits file     │                                                     │  │append                  │                     │                      │tcp_recv         │tcp_recv
 │link              │                  │                  │use                                                  │  │map                     │connectto            │node_bind             │tcp_send         │tcp_send
 │rename            │open              │open              │                                                     │  │# socket─specific       │newconn              │                      │udp_recv         │udp_recv
 │execute           │audit_access      │audit_access                                                            │  │bind                    │acceptfrom                                  │udp_send         │udp_send
 │swapon            │execmod           │execmod                                                                 │  │connect                 │node_bind                                   │rawip_recv       │rawip_recv
 │quotaon           │                  │                                                                        │  │listen                  │name_connect                                │rawip_send       │rawip_send
 │mounton                                                                                                       │  │accept                  │                                            │enforce_dest     │dccp_recv
 │                                                                                                              │  │getopt                                                               │dccp_recv        │dccp_send
                                                                                                                │  │setopt                                                               │dccp_send        │ingress
                                                                                                                │  │shutdown                                                             │recvfrom         │egress
                                                                                                                │  │recvfrom                                                             │sendto          
                                                                                                                │  │sendto
                                                                                                                │  │recv_msg             
                                                                                                                │  │send_msg             
                                                                                                                │  │name_bind       


*│common ipc       │common database    │common x_device         │class filesystem*           │ *PROCESS─RELATED OBJECTS*                   │ *CAPABILITY RELATED*                        │ *SYSTEM OPERATIONS*    *│SERVICES*
 │                 │                   │                        │                            │                                             │                                             │                         │
 │create           │create             │/*pointer,keyboard*/    │mount                       │   *│class process*    *│class process2*     │   *│common cap*           *│common cap2*    │   *│class system*       *│class service*
 │destroy          │drop               │getattr                 │remount                     │    │                   │                    │    │                       │                │    │                     │
 │getattr          │getattr            │setattr                 │unmount                     │    │fork               │nnp_transition      │    │chown                  │mac_override    │    │ipc_info         │start
 │setattr          │setattr            │use                     │getattr                     │    │transition         │nosuid_transition   │    │dac_override           │mac_admin       │    │syslog_read      │stop
 │read             │relabelfrom        │read                    │relabelfrom                 │    │sigchld            │                    │    │dac_read_search        │syslog          │    │syslog_mod       │status
 │write            │relabelto          │write                   │relabelto                   │    │sigkill                                 │    │fowner                 │wake_alarm      │    │syslog_console   │reload
 │associate        │                   │getfocus                │transition                  │    │sigstop                                 │    │fsetid                 │block_suspend   │    │module_request   │enable
 │unix_read                            │setfocus                │associate                   │    │signull                                 │    │kill                   │audit_read      │    │module_load      │disable
 │unix_write                           │bell                    │quotamod                    │    │signal                                  │    │setgid                 │                │    │halt             │
 │                                     │force_cursor            │quotaget                    │    │ptrace                                  │    │setuid                                  │    │reboot
                                       │freeze                                               │    │getsched                                │    │setpcap                                 │    │status
                                       │grab                                                 │    │setsched                                │    │linux_immutable                         │    │start
                                       │manage                                               │    │getsession                              │    │net_bind_service                        │    │stop
                                       │list_property                                        │    │getpgid                                 │    │net_broadcast                           │    │enable
                                       │get_property                                         │    │setpgid                                 │    │net_admin                               │    │disable
                                       │set_property                                         │    │getcap                                  │    │net_raw                                 │    │reload
                                       │add                                                  │    │setcap                                  │    │ipc_lock                                │        
                                       │remove                                               │    │share                                   │    │ipc_owner                               │        
                                       │create                                               │    │getattr                                 │    │sys_module                              
                                       │destroy                                              │    │setexec                                 │    │sys_rawio                               
                                                                                             │    │setfscreate                             │    │sys_chroot            
                                                                                             │    │noatsecure                              │    │sys_ptrace            
                                                                                             │    │siginh                                  │    │sys_pacct             
                                                                                             │    │setrlimit                               │    │sys_admin             
                                                                                             │    │rlimitinh                               │    │sys_boot              
                                                                                             │    │dyntransition                           │    │sys_nice              
                                                                                             │    │setcurrent                              │    │sys_resource          
                                                                                             │    │execmem                                 │    │sys_time              
                                                                                             │    │execstack                               │    │sys_tty_config        
                                                                                             │    │execheap                                │    │mknod                 
                                                                                             │    │setkeycreate                            │    │lease                 
                                                                                             │    │setsockcreate                           │    │audit_write           
                                                                                             │    │getrlimit                               │    │audit_control         
                                                                                                                                           │    |setfcap               

*OTHERS*
   security, capability, X-Windows, Netlink, D-BUS,  nscd, IPSEC, dccp, memprotect
   db_database/db_table/db_column/..., (network) peer, tun_socket, binder
   infiniband*, ...
- ...
</pre>
</td>
<td>
  <span xsmall>FS-LABELING</span>
<pre xxxsmall zoom>
- When a new file-alike object is created its contexts
  is copied (by default) from its parent's directory
  by default. 
- This behaviour can be modified with a type_transition rule
  in the policy.

$ sudo*chcon*--type <b orange>var_t</b> index.html  ← Changes context *temporarely*
                                                         (FS relabel will revert changes)

$ sudo*restorecon* -v index.html
$ sudo*restorecon* reset index.html                 ← similar to fixfiles(8) suited
  unconfined_u:object_r:o*var_t*:s0 →                 for individual file or dir. relabeling
  unconfined_u:object_r:o*httpd_sys_content_t*:s0

OTHERS:
*fixfiles(8)     *  Relabels FS objects. By default         
                    relabel all mounted FSs that support    
                    SELinux unless mounted with the         
                    context mount option, automatically     
                    detemining the file sec.ctx specs       
                    to use for the labeling.                
 
*genhomedircon(8)*  Script for generating correct file ctx 
                    specs for user's home directories.
 
*matchpathcon(8) *  Returns the default ctx for a path
                    based on the active policy's file ctx file

See also:[[Troubleshooting+restorecon?]]
</pre>
</td> 
<td> 
  <span xsmall TODO>Process LABELING FLOW</span>
<pre xxxsmall zoom>
- Login process sets a default context (unconfined for targeted policy)
</pre>
</td>
<td>
  <code xsmall> /etc/selinux/config</code>
<pre xxxsmall zoom>
# This file controls the state of SELinux on the system.
# SELINUX := enforcing permissive  ← permissive must be used to test changes/debug only.
disabled
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
#     <b>targeted</b>: Only list of targeted processes are protected (default)
#                     In deny-by-default every access is denied unless approved by policy
#     <b>minimum </b>: Modification of targeted policy. Only selected processes are protected. 
#     <b>mls     </b>: Multi Level Security protection.
SELINUXTYPE=targeted
</pre>
</td>
<td>
  <span xsmall>SELinux bootup sequence</span>
<pre xxxsmall zoom>
- When an SELinux-enabled system starts, the policy is loaded
  into memory organized in modules.
  "semodule" can be used for a number other tasks like installing,
  removing, reloading, upgrading, enabling and disabling SELinux policy modules.
        
#~ <b>se</b>module -l # lists modules currently loaded
(output will be similar to ...)
abrt    1.2.0
accountsd       1.0.6
acct    1.5.1
afs     1.8.2
...


- SELinux context for remote FS can be specified at mount time.
</pre>
</td>

<td>
  <span xsmall>Booleans</span>
<pre xxxsmall zoom>
<a href="https://linux.die.net/man/8/booleans">man 8 booleans</a>
- Allow to customize a given policy at runtime.
- Common to-many-apps actions that can be allowed/denied are "grouped"
  into booleans
  Ex:
  - """ Do we allow  the ftp server access to home directories? """
  - """ Can httpd use mod_auth_ntlm_winbind ? """
  - ...

$ sudo*getsebool -a*                     ← Show all booleans

$*setsebool* -P "mySELinuxBoolean" 0|1   ← Set boolean
              ☝(opt.flag.)
              Persist reboot

$*togglesebool* -P "mySELinuxBoolean"    ← toggle 1⇿0 value

*List Booleans Set*
- Take a look at the "booleans.local" file under
  /etc/selinux/targeted/modules/active/
  Ex:
  | # This file is auto-generated by libsemanage
  | # Do not edit directly.

  | httpd_read_user_content=1
  | httpd_enable_homedirs=1


</pre>
</td>
<td>
  <span xsmall>Troubleshooting</span>
<pre xxxsmall zoom>
*Q: What an SELinux error means?*
 A: It means:
   *A.1: file-system labeling is wrong*
      Fix examples:
      Ex 1:
        # sudo *chcon* --reference /var/www/html /var/www/html/index.html
      Ex 2:
        #*restorecon*-vR /var/www/html 
          ^^^^^^^^^^
          uses info from /etc/selinux/targeted/contexts/files/file_contexts, ...
          to determine what a file or dir's ctx should be
      Ex 3:
        #*semanage* fcontext -a -e /var/www/ /my/alternative/www/
                    ^^^^^^^^ 
           WARN: we are just defining what the context is,
                 we are not writing what the 
                 extended attributes are. It just means:
                 "On relable it must look like this"
        # restorecon -vR /my/alternative/www
          ^^^^^^^^^^ 
          must be run to actually proceed with relabeling

   *A.2: Policy needs to be tweaked*
     - booleans
     - policy modules
   *A.3: A bug in the policy*
     - App vendors must supply policy modules for SELinux systems.
       You must submit a ticket to the app vendor following next steps:
       - STEP 1:
         # setenforce 0 ← change to "permissive" mode and run
                          the application through all its paces
                          to log *all SELinux denials*
       - STEP 2:
         From /var/log/messages Copy&amp;Paste the proposed solution:
         # grep httpd /var/log/audit/audit.log | \
          *audit2allow* -Mo*quirrellocal*
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           generate  new policy file

       - STEP 3:
         #*semodule -i* o*squirrellocal.pp* ← Import the new module

       - STEP 4:
         # setenforce 1                     ← Re-enable enforcement

  r*A.4: You have been, or are being, broken into!!*

*BUG FIXING GENERAL PROCEDURE*

 *STEP 01: Check /var/log/messages*
  ...
  ...  setroubleshoot: SELinux is preventing /usr/bin/httpd from getattr access on the directory /home/fred. *For complet SELinux messages, run sealert -l 37acc7d8-e955-4333-123a-1d027dbcea72*
 
 *STEP 02: Run the indicated command*
  ~# sealert -l 37acc7d8-e955-4333-123a-1d027dbcea72
  → SELinux is preventing /usr/sbin/httpd from search access on the directory /home/fred
  → ...<b orange>
  → Do
  → setsebool -P httpd_read_user_content 1
  → ...
  → setsebool -P httpd_enable_homedirs 1</b>

Stackoverflow Ex:<a href="http://stackoverflow.com/questions/23851452/cant-resolve-domain-names-in-php-under-apache/24019910#24019910">Fix Apache DNS problem:</a>
   $ setsebool -P nis_enabled 0  
   $ setsebool -P httpd_can_network_connect 1
                ☝ 
                -P flag: change also boot-time default
                         otherwise, changes are lost 
                         after reboot

*AUDITING SELINUX ERROR MESSAGES.*
#~ ausearch   -m *avc*          -c httpd  
   ☝              ☝ 
   standard       filter by 
   linux          AVC related 
   audit          messaged
   framework
   tool
   (auditd daemon
    must be running)
→ ...
→ time → Thu Aug 21 16:42:17 2014
→ type=AVC msg=audit(1408603337.115:914): avc:  denied  { getattr } for  pid=10204 comm="httpd" path="/www/html/index.html" dev="dm-0" ino=8445484 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:default_t:s0 tclass=file
  ☝ translates to:
    type=AVC: ...: avc: The message comes from the AVC log and it's an AVC event.
    denied { getattr }: The permission that was attempted and the result it got.
                        In this case the get attribute operation was denied.
    pid=10204           process id of the process that attempted the access.
    comm="httpd"        shows the process command for the pid 
    path:               resource trying to be accessed. 
    dev :               device
    ino :               inode
    scontext:           source security context of the process.
    tcontext:           target security context of the resource.
    tclass:             target resource class.

*sealert tool*
#~ cat /var/log/messages | grep "SELinux is preventing"
→ ...
→ ... setroubleshoot: SELinux is preventing /usr/bin/su from using the setuid capability \
      For complete SELinux messages. run sealert -l o*e9e6c6d8-f217-414c-a14e-4bccb70cfbce*
#~ sealert -l o*e9e6c6d8-f217-414c-a14e-4bccb70cfbce*
→ SELinux is preventing /usr/bin/su from using the setuid capability.
→ ...
→ Raw Audit Messages
→ type=AVC msg=audit(1408931985.387:850): avc:  denied  { setuid } for  pid=5855 comm="sudo" capability=7  scontext=user_u:user_r:user_t:s0 tcontext=user_u:user_r:user_t:s0 tclass=capability
→ type=SYSCALL msg=audit(1408931985.387:850): arch=x86_64 syscall=setresuid success=no exit=EPERM a0=ffffffff a1=1 a2=ffffffff a3=7fae591b92e0 items=0 ppid=5739 pid=5855 auid=1008 uid=0 gid=1008 euid=0 suid=0 fsuid=0 egid=0 sgid=1008 fsgid=0 tty=pts2 ses=22 comm=sudo exe=/usr/bin/sudo subj=user_u:user_r:user_t:s0 key=(null)
→ 
→ Hash: su,user_t,user_t,capability,setuid
→ 
</pre>
</td>
<td colsep></td>
<td>
  <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-selinux-on-centos-7-part-3-users">SELinux users fine-tunning</a>
<pre xxxsmall zoom>
An important concept of SELinux is that TE rules associate privileges and accesses with programs, not users.
Users are not entirely ignored by SELinux. It is possible for the policy to specify multiple domain types (and thus differing sets of privilege) for the same program based on the user who runs the program. This allows for the concept of roles, which we discuss further in Chapter 6, “Roles and Users.” Nonetheless, the level of access control is still based on the program’s domain type and not the user’s privileges.


You do not create an SELinux user with a command, 
nor does it have its own login access to the server.
SELinux users are defined in the policy loaded into
memory at boot time, and there are only a few of these users. 

Linux User ← N-to-1 → SELinux user ← 1-to-N →  roles → process domain (*_t)

* Check linux_user N-to-1 SELinux_user relationship:
  #~ semanage login -l   
  (Example CentOS 7 output)
  → Login Name           SELinux User         MLS/MCS Range        Service
  → 
  → __default__          unconfined_u         s0-s0:c0.c1023       *
  → root                 unconfined_u         s0-s0:c0.c1023       *
  → system_u             system_u             s0-s0:c0.c1023       *
  → ^^^^^^^^^^^          ^^^^^^^^^^^^         ^^^^^^^^^^^          
  → ^ linux user 1 ←→ 1  SE user              Multi Level/Category Sec.

* Check SELinux_user 1-to-N SElinux_role relationship:
  #~ semanage user -l
  (Example CentOS 7 output)
  →                 Labeling  ... 
  → SELinux User    Prefix    ...    SELinux Roles
  → 
  → guest_u         user      ...    guest_r
  → root            user      ...    staff_r sysadm_r system_r unconfined_r
  → staff_u         user      ...    staff_r sysadm_r system_r unconfined_r
  → sysadm_u        user      ...    sysadm_r
  → system_u        user      ...    system_r unconfined_r
  → unconfined_u    user      ...    system_r unconfined_r
  → user_u          user      ...    user_r
  → xguest_u        user      ...    xguest_r
    
- A user "enters a roll"           when policy grants it.
- A role "access a process domain" when policy grants it. 

<b>Ex 1: Restricting su/sudo </b>
regularuser@localhost ~]$ su - switcheduser
Password: XXXX
→ [switcheduser@localhost ~]$

#~ semanage login -a -s user_u regularuser # Remap linux_user to user_u user
[regularuser@localhost ~]$ su - switcheduser
Password: XXXX
→ su: Authentication failure

[regularuser@localhost ~]$ id -Z
user_u:user_r:user_t:s0

<b>Ex 2: Restricting Permissions to Run Scripts</b>
By default, SELinux allows users mapped to the guest_t account to exec $HOME/* scripts 
#~ getsebool allow_guest_exec_content
→ guest_exec_content - -> on

#~ semanage login -a -s guest_u guestuser
semanage login -l

[guestuser@localhost ~]$ ~/myscript.sh
→ This is a test script

#~ setsebool allow_guest_exec_content off
[guestuser@localhost ~]$ ~/myscript.sh
 → bash: /home/guestuser/myscript.sh: Permission denied

<b>Ex 3: SELinux in Action 3: Restricting Access to Services</b>
Let's now how roles also play a part in restricting user access.

#~ service httpd stop
[restricteduser@localhost ~]$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[restricteduser@localhost ~]$ service httpd start
→ Redirecting to /bin/systemctl start  httpd.service
→ Failed to issue method call: Access denied

#~ visudo
+ restricteduser ALL=(ALL)      ALL
[restricteduser@localhost ~]$ sudo service httpd start
→ ...
→ [sudo] password for restricteduser:
→ Redirecting to /bin/systemctl start  httpd.service
Keep sudo permissions but restrict apache start/stop control.
#~ semanage login -a -s user_u restricteduser
#~ seinfo -uuser_u -x # shows the roles user_u can assume 
→  user_u
→     default level: s0
→     range: s0
→     roles:
→        object_r   ←
→        user_r     ←

#~ seinfo -ruser_r -x #  check what domains the user_r role is authorized to enter:
→  user_r                                 
→     Dominated Roles:                    
→        user_r                           
→     Types:                              
→        git_session_t                    
→        sandbox_x_client_t               
→        git_user_content_t               
→        virt_content_t                   
→        policykit_grant_t                
→        httpd_user_htaccess_t            
→        telepathy_mission_control_home_t 
→        qmail_inject_t                   
→        gnome_home_t                     
→        ...                              
→        ...                              
#~ seinfo -ruser_r -x | grep httpd
→        ...                              
→        httpd_user_htaccess_t
→        httpd_user_script_exec_t
→        httpd_user_ra_content_t
→        httpd_user_rw_content_t
→        httpd_user_script_t
→        httpd_user_content_t
<b>httpd_t is missing!!! => Can NOT start/stop the service
[restricteduser@localhost ~]$ sudo service httpd start
→ sudo: PERM_SUDOERS: setresuid(-1, 1, -1): Operation not permitted

SELinux Audit Logs

- auditd  : userspace component of the Linux auditing system
  /var/log/audit/audit.log used if auditd is running.
                           Records keep detailed information 
  /var/log/messages        used if auditd is stopped (and rsyslogd is running)
                           Records keep easy-to-read version

- rsyslogd: system utility providing support for message logging.
</pre>
  <br/>

  <a href="http://blog.siphos.be/2015/07/restricting-even-root-access-to-a-folder/">Restricting root access to F.S.</a> 
<pre xxxsmall zoom>
(Date Sat 11 July 2015 By Sven Vermeulen Category SELinux)

- The use of a pre-existing policy means that some roles are already 
  identified and privileges are already granted to users - often these
  higher privileged roles are assigned to the Linux root user as not
  to confuse users. But that does mean that restricting root access to
  a folder means that some additional countermeasures need to be implemented.

STEP 01: Create new policy restricting access to /etc/private:
 policy_module(myprivate, 1.0)
 
 type <b orange>etc_private_t</b>;                 ← type allowed to be used for files 
 fs_associate(<b orange>etc_private_t</b>)         ← associate with file system
                                       Do NOT use the files_type() interface
                                       as this would assign a set of attributes
                                       that many user roles get read access on.
  allow sysadm_t <b orange>etc_private_t</b>:{dir file} relabelto;  *1

 *1: sysadm_t is now allowed to change ctx to etc_private_t:
     - administrator can label resources as etc_private_t 
       without having read access to these resources afterwards.
       Also, as long as there are no relabelfrom privileges assigned,
       the administrator cannot revert the context back to a
       type that he has read access to:
       ~ sudo chcon -t <b orange>etc_private_t</b> /etc/private


STEP 02:
- Administrators can still disable SELinux controls. Ex:
  # cat /etc/private/README
  → cat: /etc/private/README: Permission denied
  # setenforce 0
  # cat /etc/private/README
  → Hello World!

To prevent this:
  # setsebool secure_mode_policyload on
              ^                      ^
          prevent any policy and SELinux state manipulation
          !!!including permissive mode!!!, but also including
          loading additional SELinux policies or changing booleans.
          (experiment with this setting without persisting (-P)

WARN: Admin cannot access /etc/private location directly,
        but he might be able to access it indirectly, remounting the
        (non-critical) system and remounting with the context= option,
        overriding file-level contexts.
WARN: Admin can still reboot the system in a mode where he
      can access the file system regardless of SELinux controls 
      bootin with enforcing=0, editing /etc/selinux/config, ....
WARN: Admin can still access the block device files on which the 
      resources are directly. Specialized tools can allow for 
      extracting files and directories without actually (re)mounting
      the device.

You can still un-grant users and/oradmins the permissions to reboot the system,
    (re)mount file systems, access block devices, etc. 
    without leaving behind the policy that is already active.
</pre>

  <a href="http://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/">Protecting CA priv.keys</a>
<pre xxxsmall zoom>
Ex CA script:

$ certcli.sh -r genfic                # Create a root CA key for "genfic"
$ certcli.sh -p genfic -c genfic-user # Create a subkey, signed by "genfic"
$ certcli.sh -p genfic-user           # Create a user certificate
   -R /var/db/ca/myUserId 
$ certcli.sh -p genfic-user \         # Sign a certificate
  -s /var/db/ca/requests/someUser.csr
$ certcli.sh -p genfic-user \         # Revoke a certificate
  -x myuser@genfic.com


CONTEXT TRANSITION:
-------------------
    ENTRYPOINT         DOMAIN         FILE TYPES
  → ca_cli_exec_t  →  ca_cli_t    →   ca_private_key_t (priv.keys)
                     (certcli.sh)     ca_misc_t        (certs, revo.list, serial,...)
                                      ca_misc_tmp_t    (temporal files)
    

ca.te:
| policy_module(ca, 1.0.0)
| 
| # CA management script and domain
| type ca_cli_exec_t;         # ENTRYPOINT
| type ca_cli_t;              # CA HANDLING DOMAIN
| domain_base_type(ca_cli_t)
| fs_associate(ca_cli_exec_t)  ← Making it through files_type() iface would
|                                would assign the `file_type` attribute to it,
|                                and other domains might have access to
|                                `file_type`. So all I do here is to allow the
|                                type `ca_cli_exec_t` to be associated on a
|                                file system.
|
|
| type ca_private_key_t;         # FILE TYPE FOR PRIV.KEYS
| fs_associate(ca_private_key_t)
| 
|
| type ca_misc_tmp_t;            # FILE TYPE FOR CERTS, REVOCATION LIST, SERIAL, ...
| fs_associate(ca_misc_tmp_t)
| fs_associate_tmpfs(ca_misc_tmp_t)
| 
|
| type ca_misc_t;                # FILE TYPE FOR TEMP. FILES
| fs_associate(ca_misc_t)
|
| # GRANT ca_cli_t PROPER ACCESS TO NEW TYPES {
| allow ca_cli_t ca_misc_t:dir create_dir_perms;          
| manage_files_pattern(ca_cli_t, ca_misc_t, ca_misc_t)     
| allow ca_cli_t ca_private_key_t:dir create_dir_perms;
| manage_files_pattern(ca_cli_t, ca_private_key_t, ca_private_key_t)
| # }
|
| - certcli.sh makes use of a directory '.../private',
|   so  proper rights to asign `ca_private_key_t` to dirs must be in place.
| - /private directory's parent dir is labeled as `ca_misc_t` to allow
|   file transitions.
| - SELinux policy will automatically assign the `ca_private_key_t`
|   type to a directory, created in a `ca_misc_t`  directory.
| -  if created by the `ca_cli_t` domain:
| 
| filetrans_pattern(ca_cli_t, ca_misc_t, ca_private_key_t, dir, "private")
| 
| # certcli.sh also requires the following permissions: {
| allow ca_cli_t self:fifo_file rw_fifo_file_perms;            ← Handling pipes between commands
| corecmd_exec_shell(ca_cli_t)                                 ← Shell script.
| corecmd_exec_bin(ca_cli_t)                                   ← allow to invoke regular binaries
| getty_use_fds(ca_cli_t) userdom_use_user_terminals(ca_cli_t) ← allow output on the screen
| # }
|
| allow ca_cli_t ca_cli_exec_t:file entrypoint;                      ← - mark `ca_cli_exec_t` as entrypoint for `ca_cli_t`.
| allow ca_cli_t ca_cli_exec_t:file { mmap_file_perms ioctl lock };      `ca_cli_t` domain can only be reached (transitioned to) 
|                                                                         through the execution of a `ca_cli_exec_t` file
|                                                                         `ca_cli_exec_t`:
|                                                                      - Normally, this is granted through 
|                                                                        application_domain(ca_cli_t, ca_cli_exec_t) but
|                                                                        this would also assign attributes we want to
|                                                                        explicitly prevent
|
|
|
| # ADD REQUIRED PERMISSION FOR certcli.sh CHILDREN PROCESSES
| #  (openssl) RUNNING IN ca_cli_t DOMAIN {
| kernel_read_system_state(ca_cli_t)  ← Read access on /proc files
| dev_read_rand(ca_cli_t)             ← Access to random devices
| dev_read_urand(ca_cli_t)            ← Regular files
| files_read_etc_files(ca_cli_t)
| miscfiles_read_localization(ca_cli_t)
| fs_getattr_tmpfs(ca_cli_t)          ← /tmp access
|
| files_tmp_filetrans(ca_cli_t, ca_misc_tmp_t, file) ←  when OpenSSL creates a file in `/tmp`
|                                                       it should immediately be assigned the
|                                                       `ca_misc_tmp_t` type
| # }
| # NOTE: At this point  the application should works fine
|
| An  ca_role() interface will be created to allow user domains 
| to use the CA script. Let's first create the ca_roles role attribute
| used by such interface: {
| attribute_role ca_roles; 
| role ca_roles types ca_cli_t;
| # }



NEXT: all that needed is to have an initial location marked as `ca_misc_t`
      For now, none of the users have the rights to do so, so I create
      three additional interfaces to be used against other user domains:


| allows to run the command                          | allows regular sysadmins rights to create ca_misc_t dirs | allow relabel *from* rights to change the 
|                                                    |                                                          | type of private keys to a regular file
|                                                    |                                                          | (if Linux allows it and the 
|                                                    |                                                          |  operation type goes to/from is allowed)
|                                                    |                                                          | This one should *only* be assigned to a
|                                                    |                                                          | rescue user (if any). 
|                                                    |                                                          | Also, this interface is allowed to label
|                                                    |                                                          | CA management scripts.
+----------------------------------------------------+----------------------------------------------------------+----------------------------------------------
| grant CA handling roles ca_role()                  |  ca_sysadmin(sysadm_t)                                   |  ca_admin(secadm_t) would only be granted on 
| ca_role(certadmin_r, certadmin_t)                  |  ca_sysadmin(setfiles_t)                                 |  the rescue/super-admin
+----------------------------------------------------+----------------------------------------------------------+----------------------------------------------
|                                                    |                                                          |
| interface(`ca_role','                              | interface(`ca_sysadmin',                                 | interface(`ca_admin',`
|   gen_require(`                                    |   gen_require( type ca_misc_t; type ca_private_key_t; )  |   gen_require(`
|     attribute_role ca_roles;                       |   # Allow the user relabel rights on ca_misc_t           |     type ca_misc_t, ca_private_key_t;
|     type ca_cli_t, ca_cli_exec_t;                  |   allow $1 ca_misc_t:dir relabel_dir_perms;              |     type ca_cli_exec_t;
|     type ca_misc_t;                                |   allow $1 ca_misc_t:file relabel_file_perms;            |   ')
|   ')                                               |   # Allow the user to label /to/ ca_private_key_t        | 
|                                                    |   # (but not vice versa)                                 |   allow $1 { ca_misc_t ca_private_key_t }:dir relabel_dir_perms;
|   # Allow the user role (like sysadm_r) the types  |   allow $1 ca_private_key_t:dir relabelto_dir_perms;     |   allow $1 { ca_misc_t ca_private_key_t }:file relabel_file_perms;
|   # granted to ca_roles                            |   allow $1 ca_private_key_t:file relabelto_file_perms;   | 
|   roleattribute $1 ca_roles;                       |   # Look at regular file/dir info                        |   allow $1 ca_cli_exec_t:file relabel_file_perms;
|                                                    |   allow $1 ca_misc_t:dir list_dir_perms;                 | ')
|   # Read the non-private key files and directories |   allow $1 ca_misc_t:file read_file_perms; '             
|   allow $2 ca_misc_t:dir  list_dir_perms;          | )                                                        
|   allow $2 ca_misc_t:file read_file_perms;         |                                                          
|                                                    | NOTE: The 'ca_sysadmin()' interface can also be assigned 
|   # Allow to transition to ca_cli_t by executing   |       to the `setfiles_t` command so that relabel        
|   # a ca_cli_exec_t file                           |       operations (and file system relabeling) works      
|   domtrans_pattern($2, ca_cli_exec_t, ca_cli_t)    |       correctly.                                         
|                                                    |
|   # Look at the process info                       |
|   ps_process_pattern($2, ca_cli_t)                 |
|                                                    |
|   # Output (and redirect) handling                 |
|   allow ca_cli_t $2:fd use;                        |
| ')                                                 |

  - application domains are granted through interface
    application_type(), application_domain() or
    even userdom_user_application_domain(). 
    Election depends on the privileges you want to grant on the domain,
    but also which existing privileges should also be applicable to
    the domain. 
  
  ????.if:
  
  | seshowif application_domain
  | 
  | interface(`application_type', 
  |   gen_require(`attribute application_domain_type;')
  | 
  |   typeattribute $1 application_domain_type;   ← associate attr. ($1 == ca_cli_t)
  | 
  |   # start with basic domain
  |   domain_type($1)                             ← assign lowest posible 'domain' attributes 
  |                                                 to handle certs ($1 == ca_cli_t)
  | 
  | ')
</pre>
</td>
<td colsep></td>
<td>
  <span xsmall>SEL status info</span>
<pre xxxsmall zoom>
avcstat(8)                   Shows statistics&counters (AVC cache hits, ...)
getenforce(8)                Display current mode string ("permissive", "enforcing")
selinuxenabled(1)            help-utility for shell scripts

sestatus(8)                  Return various status info, such as
                             enforcing mode, current policy version
                             and name, Boolean status
  $ sudo *sestatus*  
  → SELinux status:                 enabled
  → SELinuxfs mount:                /sys/fs/selinux
  → SELinux root directory:         /etc/selinux
  → Loaded policy name:             targeted
  → Current mode:                   permissive
  → Mode from config file:          error (Success)
  → Policy MLS status:              enabled
  → Policy deny_unknown status:     allowed
  → Max kernel policy version:      28
</pre>

  <span xsmall>Switch Enforcement</span>
<pre xxxsmall zoom>
#*setenforce* permissive ← Useful for fixing new apps
#*setenforce* enforcing
</pre>

  <span xsmall>Process</span>
<pre xxxsmall zoom>
*runcon(1)*   run command with given ctx (user, role and domain)

*secon(1) *   See ctx from a file|program|user-input 

*newrole(1)*  creates new shell running with new sec.ctx.
              Use must specify new role and/or type.
              type is derived from role if not specified.

*run_init(9)* Runs initrc script using the sec.ctx.
              found in current policy's ctx/initrc_context 
              file. Ussually used to restart system
              services in new intended domain
</pre>


   <span xsmall>Policy</span>
<pre xxxsmall zoom>
<b>se</b>search:
- search access allowed for source/target domains:
#~ sesearch --allow \
   --source <b orange>httpd_t</b>              # domain for apache process
   --target <b orange>httpd_sys_content_t</b>  # type   for /var/www/html files
   --class <b blue>file</b> 
(output will be similar to...)
Found 4 semantic av rules:
   allow o*httpd_t httpd_sys_content_t* : b*file* <b green>{ ioctl read getattr lock open }</b> ;
   allow o*httpd_t httpd_content_type * : b*file* <b green>{ ioctl read getattr lock open }</b> ;
   allow o*httpd_t httpd_content_type * : b*file* <b green>{ ioctl read getattr lock open }</b> ;
   allow o*httpd_t httpdcontent       * : b*file* <b green>{ ioctl read write create getattr setattr lock append unlink link rename execute open }</b> ;

checkpolicy(8)           policy compiler generating kernel       
                         loadable version. Can be used to debug  
                         a policy in that it can mimimc some of  
                         the capabilities of the SEL sec.server. 


semanage(8)              configure certain policy elements      
                         without editing/recompiling source:    
                         - mapping user to se_users             
                         - mapping ctx for network ports,       
                           interfaces, and nodes(hosts),        
                           file context mapping.                    

load_policy(8)           load policy into the kernel. 
                         In enforcing mode, it must be run in a
                         domain with load_policy permissions.

audit2allow(1)           Takes the AVC audit denial messages and
                         outputs allow policy rules that, if added,
                         will allow further attemps.

audit2why(1)             Tries to provide a by comparing with
                         policy rules. (useful to identify
                         constrain violations.

ausearch(8)              Basic interpretation of audti messages.
                         -m avc pull out just AVC messages.
</pre>

</td>

<td>
  <a href="https://github.com/TresysTechnology/setools/wiki">policy analysis tools</a>
<pre xxxsmall zoom>
|<a ____="                                    ">Tool Name   </a>| Use
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/apol"    >apol (GUI)  </a>| perform various types of analyses
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sediff"  >sediff      </a>| Compare two policies to find differences.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">sedta       </a>| Perform domain transition analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/seinfo"  >seinfo      </a>| List policy components.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">seinfoflow  </a>| Perform information flow analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sesearch">sesearch(8) </a>|policy query tool, Search rules (allow, type_transition, etc.)
|<t                                           />------------</t>|----------------------------------
</pre>
</td>
</table>

Creating new Policies
<table>
<tr>
<td>
  <span xsmall>Policy RULES</span>
<pre xxxsmall zoom>
- The set of (possibly thousands of) rules define a given policy.
  ┌──────────────────────────┬─────────────────────────────────────────────────────────────┐
  │*ACCESS VECTOR(AV) RULES*:│                                                             │
  ├──────────────────────────┘                                                             │
  │- Define the AV bitmap from source types to*existing*[target+type:kernel-class] objects │
  ├────────────────────────────────────────────────────────────────────────────────────────┤
  │ SYNTAX:                                                                                │
  │ *allow*       o*src_domain*       g*target_type*:b*class* { g*permissions* };          │
  │  ↑↑↑↑↑          ↑↑↑↑↑↑↑↑↑↑          ↑↑↑↑↑↑↑↑↑↑↑    ↑↑↑↑↑      ↑↑↑↑↑↑↑↑↑↑↑              │  
  │  allow          running process     TODO??????     files      sub─list of              │
  │  dontaudit      domain ("type")                    socket     class─actions            │
  │  auditallow                                        IPC        allowed for              │
  │  neverallow                                        ...        source─to─target         │
  │                                                               types                    │
  │              (o*src_domain*   ,   g*target_type*, b*class*)   types                    │
  │              └─── tuple used as key in AV hashtable  ─────┘                            │
  │                 ─ Two rules matching the same triplet key will                         │
  │                   "merge" their permissions.                                           │
  │                 ─ Permissions can NOT be deleted, only added                           │
  └────────────────────────────────────────────────────────────────────────────────────────┘
  ┌─────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │*TYPE RULES*:│                                                                                                                                │ 
  ├─────────────┘                                                                                                                                │ 
  │─ control default labeling decisions when*new objects*are created*AT RUNTIME*                                                                 │
  ├──────────────────────────────────────────────────────┬──────────────────┬────────────────────────────────────────────────────┬───────────────┤
  │ TYPE─TRANSITION─SYNTAX:(new running─process labeling)│                  │ OBJECT─TRANSITION─SYNTAX (new file─object labeling)│               │
  ├──────────────────────────────────────────────────────┘                  ├────────────────────────────────────────────────────┘               │
  │                                                                         │ (default to "parent")                                              │
  │ *type_transition* g*user_t*  b*passwd_exec_t*:o*process* *passwd_t*;    │ *type_transition* passwd_t tmp_t : file passwd_tmp_t;              │
  │                                ^^^^^^^^^^^^^    ^^^^^^^                 │                   ^^^^^    ^^^^^                                   │
  │                                targeted type    source object─class     │            object class    implicitly associated with              │
  │                       implicitely associated    associated with source  │       refers to default    dir─object class(only one               │
  │                       with file─object─class    (g*user_t*) and default │     type (passwd_tmp_t)    that can contain files)                 │
  │                                                  types.                 │                                                                    │
  │ └───────────────────────────────────────────────────────────────────┘   │ └───────────────────────────────────────────────────┘              │
  │     ☝This rules means:                                                  │           ☝This rules means:                                       │
  │      """when a *oprocess* of type g*user_t* executes a                  │  """ when a process of type passwd_t creates an                    │
  │         file of type b*passwd_exec_t*, the process type                 │    ordinary file (file object class) in a directory of             │
  │         will attempt to transition, by default, to                      │    type tmp_t the file, by default, should have the                │
  │         *passwd_t* unless otherwise requested.  """                     │    type passwd_tmp_t if allowed by the policy. """                 │
  │                                                                         │  NOTICE:                                                           │
  │ Ex:                                                                     │                                                                    │
  │ *type_transition* g*init_t* b*apache_exec_t* :o*process* *apache_t*;    │  ─ AV rules must also allow the access for the default             │
  │                                                                         │    labeling to occur. (add_name, write, and search for             │
  │  allow g*init_t*  b*apache_exec_t*   : file    execute;                 │    directories of type tmp_t, and write and create for             │
  │  allow g*init_t*   *apache_t*        : process transition;              │    files of type passwd_tmp_t).                                    │
  │  allow  *apache_t*b*apache_exec_t*   : file    entrypoint;              │                                                                    │
  └─────────────────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────┘
</pre>
</td>

<td>
  Compiling new policy:
<a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file">REF</a>

<pre xxxsmall zoom>
WARN: In some cases, you might need to update your policy to be compatible 
      with upstream SELinux policy changes. 

Tipical policy module (*.pp file) looks like:

localpolicy.pp 
*.te: type enforcement
*.fc: file contexts (optional)
*.if: interfaces (optional)


PRE-SETUP:
 $ sudo yum install -y selinux-policy-devel


<b>STEP 01: vim localpolicy.te:</b>

policy_module(localpolicy, 1.0)  ← localpolicy must match localpolicy.te prefix
gen_require(`                    ← backtick (`) denotes the start/end of the block 
  type user_t;                   ← gen_require block is used to "reuse"reference policy,
  type var_log_t;                  and will be translated during the make -f ... command 
')                                 earlier on towards SELinux rules. 

allow user_t var_log_t:dir { getattr search open read };

<b>STEP 02: create SELinux policy module localpolicy.pp:</b>
# sudo make -f /usr/share/selinux/devel/Makefile localpolicy.pp

                                                          ^must "match"
                                                           localpolicy.te prefix


<b>STEP 03: Load the file:</b>
# sudo setenforce permissive
# sudo semodule -i /path/to/localpolicy.pp  
WARN: semodule does NOT need "-P". Will remain loaded after reboots.
(to disable use # sudo semodule -d localpolicy)

# sudo 
</pre>
</td>

<td>
  Context Transition
<pre xxxsmall zoom >
proc_a @ contexta_t   → run app_x     → proc_b running @ contextb_t
                            ↑
                        entrypoint to
                         new context 

Ex:
#~ ls -Z /usr/sbin/vsftpd 
-r-x------ root root system_u:object_r:<b orange>ftpd_exec_t</b>:s0 /usr/sbin/vsftpd
                                       <b orange>^entrypoint</b> 
                                       <b orange>to  new    </b> 
                                       <b orange>context    </b>

#~ps -eZ  | egrep "(init_t|vsftpd)"
system_u:system_r:<b orange>init_t</b>:s0 ... systemd
system_u:system_r:<b orange>ftpd_t</b>:s0 ... vsftpd

 <b>Domain transition rules:</b>
 - source context "proc_a" must have execute permission for entrypoint (app_x)
 - "app_x" file context must be identified as an entrypoint for the target domain
 - original domain (contexta_t) must be allowed to transition to the target domain (contextb_t)
  In the previous example:
  STEP 01: Check source domain <b orange>init_t</b> have execute permission on
  ftpd_exec_t entrypoint:
    #~ sesearch -s init_t -t ftpd_exec_t -c file -p execute -Ad
    → allow init_t ftpd_exec_t : file { read getattr execute open } ;
   
  STEP 02: Check binary file is entrypoint for the target domain <b orange>ftpd_t</b>:
    #~ <b>se</b>search -s <b orange>ftpd_t</b> \
         -t <b orange>ftpd_exec_t</b> -c file \
         -p <b green>entrypoint</b> -Ad
    → allow ftpd_t ftpd_exec_t : file { ioctl read getattr lock execute execute_no_trans <b green>entrypoint</b> open } ;

  STEP 03: Check source domain init_t have transition permission to target ftpd_t:
    #~ <b>se</b>search -s <b orange>init_t</b> -t <b orange>ftpd_t</b> \
          -c process -p transition -Ad
    → allow init_t ftpd_t : process transition ;
</pre>

  Workflow
<pre xxxsmall zoom>
- Switch to permisive mode.
- Test new policy.
- Check violations in logs (See troubleshooting with audit2allow to produce new rules)
</pre>
    

  Verify current file  against file_context(.local) ddbb 
<pre xxxsmall zoom >
#~ matchpathcon -V /www/html/index.html # -V: Verify
In case of mismatch an error similar to next one will be displayed:
/www/html/index.html has context unconfined_u:object_r:default_t:s0, should be system_u:object_r:httpd_sys_content_t:s0 
</pre>

  Computing SE context output
<pre xxxsmall zoom>
The table shows how the components from the source context scon, target context tcon and class tclass are used to compute the new context newcon (referenced by SIDs for  avc_compute_create(3)).
<b>avc_compute_create and security_compute_create</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | IF there is a valid role_transition rule THEN | IF there is a valid type_transition rule THEN | IF there is a valid range_transition rule THEN
  use tcon user                         |    use the rules new_role                     |   use the rules default_type                  |   use the rules new_range
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source low rule THEN
  use scon user                         |    use scon role                              |   use scon type                               |   use scon low
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source high rule THEN 
                                        |    use tcon role                              |   use tcon type                               |   use scon high
                                        | OR IF tclass is process or *socket  THEN      | OR IF tclass is process or *socket THEN       | OR IF default_range tclass source low_high rule THEN
                                        |    use scon role                              |   use scon type                               |   use scon range
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target low rule THEN 
                                        |    Use object_r                               |   use tcon type                               |   use tcon low
                                                                                                                                        | OR IF default_range tclass target high rule THEN
                                                                                                                                        |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   use scon low
_______________________________________________________________________________________________________________________________________________________________________________________________
<b>avc_compute_member and security_compute_member</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | If there is a valid role_transition rule THEN | If there is a valid type_transition rule THEN | If default_range tclass source low rule THEN
  use tcon user                         |   use the rules new_role                      |   use the rules default_type                  |   use scon low
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source high rule THEN 
  Use scon user                         |   use scon role                               |   use scon type                               |   use scon high
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source low_high rule THEN
                                        |   use tcon role                               |   use tcon type                               |   use scon range
                                        | OR IF tclass is process or *socket , THEN     | OR IF tclass is process or *socket , THEN     | OR IF default_range tclass target low rule THEN
                                        |   use scon role                               |   use scon type                               |   use tcon low
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target high rule THEN
                                        |   Use object_r                                |   use tcon type                               |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket , THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   Use scon low
</pre>
</td>

<td>
  Who is Who
<pre xxxsmall zoom>
SELinux By Example  authors:
Frank Mayer is cofounder and Chief Technology Officer of 
Tresys Technology, and has 23 years of experience in the 
design, development, and analysis of secure operating 
systems. He has been an active contributor to SELinux for 
six years, and has initiated and participated in the 
development of many new SELinux innovations and tools. He 
also chairs the annual SELinux Symposium. Frank has 
published many papers on secure and trustworthy operating 
systems, and has also explored security in parallel 
computing, networks, and enterprise applications.


Karl MacMillan is an active contributor in the SELinux 
community and has led the development of many important 
SELinux features. He is also a sought after speaker and 
consultant, and has helped many individuals and 
organizations understand and apply strong computer 
security with SELinux. Previous to his work on SELinux, 
Karl made important contributions in the fields of 
pattern recognition and evolutionary computing as applied 
to document and audio recognition, where he has numerous 
published papers.

David Caplan is a senior security engineer at Tresys 
Technology with over 20 years of experience in computer 
security and a wide range of other programming- and 
software-related areas. He has worked with SELinux for 
six years as a contributor to many of the SELinux-related 
open source projects and has led multiple efforts in 
analyzing and constructing SELinux policy for a variety 
of systems.

Sven Vermeulen, author of SELinux Cookbook
</pre>


</td>


</table>

</body>


<!--
TODO_START: {
 SELinux    cached information on access-decisions via the Access Vector Cache (AVC)
________________________
<code TODO>system-config-selinux</code> (Gtk GUI for SELinux)
_________________________
https://docs.fedoraproject.org/en-US/Fedora/13/html/SELinux_FAQ/
______________________________
http://oss.tresys.com/
Projects hosted on GitHub:
  --------------------------
- SETools Policy Analysis Suite : SETools is a suite of open source tools that allow a policy developer or tester to perform detailed analysis and debugging of an SELinux policy
- Certifiable Linux Integration Platform (CLIP) : a toolkit for creating a secure computing environment suitable for hosting U.S. Government applications
- Reference Policy : makes it easier to maintain and apply baseline security policy for Security Enhanced Linux (SELinux)
_______________________________
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index
____________________________
https://debian-handbook.info/browse/en-US/stable/sect.selinux.html
____________________________
<td>
Multilevel Security (MLS)
<pre xxxsmall zoom>
~ ls -Z /etc/vsftpd/vsftpd.conf
-rw-------. root root system_u:object_r:etc_t:s0       /etc/vsftpd/vsftpd.conf

The sensitivity is part of the hierarchical multilevel security mechanism. By hierarchy, we mean the levels of sensitivity can go deeper and deeper for more secured content in the file system. Level 0 (depicted by s0) is the lowest sensitivity level, comparable to say, "public." There can be other sensitivity levels with higher s values: for example, internal, confidential, or regulatory can be depicted by s1, s2, and s3 respectively. This mapping is not stipulated by the policy: system administrators can configure what each sensitivity level mean.

When a SELinux enabled system uses MLS for its policy type (configured in the /etc/selinux/config file), it can mark certain files and processes with certain levels of sensitivity. The lowest level is called "current sensitivity" and the highest level is called "clearance sensitivity".

Going hand-in-hand with sensitivity is the category of the resource, depicted by c. Categories can be considered as labels assigned to a resource. Examples of categories can be department names, customer names, projects etc. The purpose of categorization is to further fine-tune access control. For example, you can mark certain files with confidential sensitivity for users from two different internal departments.

For SELinux security contexts, sensitivity and category work together when a category is implemented. When using a range of sensitivity levels, the format is to show sensitivity levels separated by a hyphen (for example, s0-s2). When using a category, a range is shown with a dot in between. Sensitivity and category values are separated by a colon (:).

Here is an example of sensitivity / category pair:

user_u:object_r:etc_t:s0:c0.c2  

There is only one sensitivity level here and that's s0. The category level could also be written as c0-c2.

So where do you assign your category levels? Let's find the details from the /etc/selinux/targeted/setrans.conf file:

cat /etc/selinux/targeted/setrans.conf

#
# Multi-Category Security translation table for SELinux
#
#
# Objects can be categorized with 0-1023 categories defined by the admin.
# Objects can be in more than one category at a time.
# Categories are stored in the system as c0-c1023.  Users can use this
# table to translate the categories into a more meaningful output.
# Examples:
# s0:c0=CompanyConfidential
# s0:c1=PatientRecord
# s0:c2=Unclassified
# s0:c3=TopSecret
# s0:c1,c3=CompanyConfidentialRedHat
s0=SystemLow
s0-s0:c0.c1023=SystemLow-SystemHigh
s0:c0.c1023=SystemHigh

We won't go into the details of sensitivities and categories here. Just know that a process is allowed read access to a resource only when its sensitivity and category level is higher than that of the resource (i.e. the process domain dominates the resource type). The process can write to the resource when its sensitivity/category level is less than that of the resource.
Conclusion

We have tried to cover a broad topic on Linux security in the short span of this three-part-series. If we look at our system now, we have a simple Apache web server installed with its content being served from a custom directory. We also have an FTP daemon running in our server. There were a few users created whose access have been restricted. As we went along, we used SELinux packages, files, and commands to cater to our security needs. Along the way we also learned how to look at SELinux error messages and make sense of them.

Entire books have been written on the SELinux topic and you can spend hours trying to figure out different packages, configuration files, commands, and their effects on security. So where do you go from here?

One thing I would do is caution you not to test anything on a production system. Once you have mastered the basics, start playing with SELinux by enabling it on a test replica of your production box. Make sure the audit daemons are running and keep an eye on the error messages. Check any denials preventing services from starting. Play around with the boolean settings. Make a list of possible steps for securing your system, like creating new users mapped to least-privilged SELinux accounts or applying the right context to non-standard file locations. Understand how to decipher an error log. Check the ports for various daemons: if non-standard ports are used, make sure they are correctly assigned to the policy.

It will all come together with time and practice. :)
</pre>
</td>
___________________________
 As processes and objects are created and destroyed, they either:
1.  Inherit their labels from the parent process or object.
2.  The policy type, role and range transition statements allow a different label to
     be assigned as discussed in the Domain and Object Transitions section.
3.  SELinux-aware   applications   can   enforce   a   new   label   
    (with   the   policies approval of course) using the libselinux API functions.
4.  An object manager (OM) can enforce a default label that can either be built
    into the OM or obtained via a configuration file (such as those used by X-Windows).
5.  Use an 'initial security identifier' (or initial SID). These are defined in all 
    base and monolithic policies and are used to either set an initial context during the
    boot process, or if an object requires a default (i.e. the object does not already
    have a valid context).


The labeling of file systems that implement extended attributes
is supported by SELinux using:
1.  The  fs_use_xattr statement   within   the   policy   to   identify   what   file
  systems use extended attributes. This statement is used to inform the security
  server how to label the filesystem.
2.  A 'file contexts' file that defines what the initial contexts should be for each
   file and directory within the filesystem. The format of this file is described in
   the modules/active/file_contexts.template file section.
3.  A method to initialise the filesystem with these extended attributes. This is
   achieved by SELinux utilities such as fixfiles(8) and setfiles(8) .
   There   are   also   commands   such   as  chcon(1),  restorecon(8) and
   restorecond(8) that can be used to relabel files

______________________________________
<a href="https://www.youtube.com/watch?v=MxjenQ31b70&t=2790s">SELinux for mere mortals</a>
______________
   Preserve context in file copy
<pre xxxsmall zoom >
#~ cp <b>--preserver=context</b> /var/www/html/index.html ~/html
(context is preserved with "mv")
</pre>
___________________
TODO: Add attributes notes: (How to avoid duplacting rules for different convinations
 of types)
https://www.safaribooksonline.com/library/view/selinux-by-example/0131963694/ch05.html#ch05
}
_____________________
http://oss.tresys.com/archive/slide.php
Tresys IDE:
SELinux Policy IDE (SLIDE) is an integrated development environment for 
SELinux developed by Tresys Technology. Some basic features of SLIDE include:

    Graphical user interface for policy development
    Integration with Reference Policy
    Project creation wizards
    Auto-completion of interface names
    Policy syntax highlighting
    Easily compile and build module packages
    Hook into standard Eclipse search
    Basic refactoring features including adding and removing ifdef, optional and tunable blocks
    Integrated remote policy installation and audit log monitoring 
______________________
https://github.com/mairin/selinux-coloring-book
______________________
--SE aware Process API ------  
setcon(3)                      
getcon(3)                      
getpidcon(3)                   
getpidcon(3)                   

-->

</html>
