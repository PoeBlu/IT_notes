<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>SELinux map <!-- alpha --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->


</body>

<table>
<tr>
  <th colspan=6 header_delimit><a href="https://github.com/SELinuxProject/selinux/wiki">SELinux Mandatory Access Control (MAC)</a>, <a href="https://github.com/SELinuxProject/refpolicy">Ref.Policy</a>,  <a href="http://selinuxbyexample.com/">(Book) SELinux by Example</a> </th>
  <th colspan=6 header_delimit>Creating new Policies</th>
</tr>
<tr>
<td>
0.4 Abbreviations
<pre xxxsmall zoom>
AV Access Vector
AVC Access Vector Cache
BLP Bell-La Padula
CC Common Criteria
CIL Common Intermediate Language
CMW Compartmented Mode Workstation
DAC Discretionary Access Control
FLASK Flux Advanced Security Kernel
Fluke Flux μ-kernel Environment
Flux The Flux Research Group (http://www.cs.utah.edu/flux/)
ID Identification
LSM Linux Security Module
LAPP Linux, Apache, PostgreSQL, PHP / Perl / Python
LSPP Labeled Security Protection Profile
MAC Mandatory Access Control
MCS Multi-Category Security
MLS Multi-Level Security
NSA National Security Agency
OM Object Manager
OTA over the air
PAM Pluggable Authentication Module
RBAC Role-based Access Control
rpm Red Hat Package Manager
SELinux Security Enhanced Linux
SID Security Identifier
SMACK Simplified Mandatory Access Control Kernel
SUID Super-user Identifier
TE Type Enforcement
UID User Identifier
XACE X (windows) Access Control Extension
</pre>

  Terminology
<pre xxxsmall zoom>
Term                        Description
Access Vector (AV)          A bit map representing a set of permissions (such as open, read, write)

Access Vector Cache (AVC)    A   component   that   stores   access   decisions   made   by   the
                            SELinux  Security   Server for   subsequent   use   by  Object Managers.
                            This  allows   previous   decisions   to be  retrieved
                            without the overhead of re-computation.
                            Within the core SELinux services there are two Access Vector Caches:
                            1.  A kernel AVC that caches decisions by the  Security Server
                                on behalf of kernel based object managers.
                            2.  A userspace AVC built into libselinux that caches
                                decisions   when   SELinux-aware   applications   use
                                avc_open (3) with   avc_has_perm (3) or avc_has_perm_noaudit (3)
                                function calls. This will save kernel calls after the first decision has been
                                made.

Domain                      For SELinux this consists of one or more processes associated
                            to   the   type   component   of   a  Security   Context.  

Type Enforcement            rules   declared   in   Policy   describe   how   the
                            domain will interact with objects (see Object Class).

Linux Security Module       A  framework   that   provides  hooks   into  kernel  components
(LSM)                       (such as disk and network services) that can be utilised by
                            security   modules   (e.g.   SELinux   and   SMACK)   to   perform
                            access control checks.
                            Currently only one LSM module can be loaded, however work
                            is in progress to stack multiple modules).

Mandatory Access Control    An access control mechanisim enforced by the system. This
                            can be achieved by 'hard-wiring' the operating system and
                            applications (the bad old days - well good for some) or via a
                            policy that conforms to a  Policy. Examples of policy based
                            MAC are SELinux and SMACK.

Multi-Level Security (MLS)  Based   on   the   Bell-La   &   Padula   model   (BLP)   for
                            confidentiality in that (for example) a process running at a
                            'Confidential' level can read / write at their current level but
                            only read down levels or write up levels. While still used in
                            this way, it  is more commonly used for application separation
                            utilising the Multi-Category Security variant.

Object Class                Describes a resource such as files, sockets or services.
                            Each 'class' has relevant permissions associated to it such as
                            read,  write or export. This allows access to be enforced on the
                            instantiated object by their 

Object Manager              Userspace and kernel components that are responsible for the     
                            labeling, management (e.g. creation, access, destruction)  and
                            enforcement   of   the   objects   under   their   control.
                            Object Managers call the  Security Server for an access decision
                            based on a source and target Security Context (SID)), 
                            an Object Class and a set of permissions (or AV s). 
                            The Security Server will base its decision on whether the currently loaded Policy
                            will allow or deny access.  An  Object Manager may also call the   Security Server
                            to compute a new Security Context or SID for an object.
Policy                      A set of rules determining access rights. In SELinux these
                            rules are generally written in a kernel policy language using
                            either m4 (1) macro support (e.g. Reference Policy) or the
                            new CIL language. The Policy is then compiled into a binary
                            format for loading into the Security Server.

Role Based Access Control   SELinux users are associated to one or more roles, each role
                            may then be associated to one or more Domain types.

Security Server             A sub-system in the Linux kernel that makes access decisions
                            and computes security contexts based on Policy on behalf of
                            SELinux-aware applications and Object Managers.
                            The Security Server does not enforce a decision, it merely
                            states whether the operation is allowed or not according to the
                            Policy. It is  the  SELinux-aware  application  or Object
                            Manager responsibility to enforce the decision.

Security Context            An SELinux Security Context is a variable length string that
                            consists  of  the  following  mandatory  components
                            user:role:type and an optional [:range] component.
                            Generally abbreviated  to 'context', and sometimes  called a
                            'label'.

Security Identifier (SID)   SIDs are unique opaque integer values mapped by the kernel
                            Security Server and userspace AVC that represent a Security Context.
                            The SIDs generated by the kernel Security Server are u32
                            values that are  passed via the Linux Security Module
                            hooks to/from the kernel Object Managers.

Type Enforcement            SELinux makes use of a specific style of type enforcement
                            (TE) to enforce Mandatory Access Control. This is where all
                            subjects and objects have a type identifier associated to them
                            that can then be used to enforce rules laid down by 
                            Policy

</pre>
</td>
<td>
Auditing/Deciphering SELinux Error Messages.:
<pre xxxsmall zoom>
<b>ausearch tool</b>
#~ ausearch -m avc -c httpd  # auditd daemon must be running
→ ...
→ time->Thu Aug 21 16:42:17 2014
→ type=AVC msg=audit(1408603337.115:914): avc:  denied  { getattr } for  pid=10204 comm="httpd" path="/www/html/index.html" dev="dm-0" ino=8445484 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:default_t:s0 tclass=file
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  type=AVC: ...: avc: The message comes from the AVC log and it's an AVC event.
  denied { getattr }: The permission that was attempted and the result it got.
                      In this case the get attribute operation was denied.
  pid=10204           process id of the process that attempted the access.
  comm="httpd"        shows the process command for the pid 
  path:               resource trying to be accessed. 
  dev :               device
  ino :               inode
  scontext:           source security context of the process.
  tcontext:           target security context of the resource.
  tclass:             target resource class.
______________________________________________
<b>sealert tool</b> 
#~ cat /var/log/messages | grep "SELinux is preventing"
→ ...
→ ... setroubleshoot: SELinux is preventing /usr/bin/su from using the setuid capability \
      For complete SELinux messages. run sealert -l <b orange>e9e6c6d8-f217-414c-a14e-4bccb70cfbce</b>
#~ sealert -l <b orange>e9e6c6d8-f217-414c-a14e-4bccb70cfbce</b>
→ SELinux is preventing /usr/bin/su from using the setuid capability.
→ ...
→ Raw Audit Messages
→ type=AVC msg=audit(1408931985.387:850): avc:  denied  { setuid } for  pid=5855 comm="sudo" capability=7  scontext=user_u:user_r:user_t:s0 tcontext=user_u:user_r:user_t:s0 tclass=capability
→ type=SYSCALL msg=audit(1408931985.387:850): arch=x86_64 syscall=setresuid success=no exit=EPERM a0=ffffffff a1=1 a2=ffffffff a3=7fae591b92e0 items=0 ppid=5739 pid=5855 auid=1008 uid=0 gid=1008 euid=0 suid=0 fsuid=0 egid=0 sgid=1008 fsgid=0 tty=pts2 ses=22 comm=sudo exe=/usr/bin/sudo subj=user_u:user_r:user_t:s0 key=(null)
→ 
→ Hash: su,user_t,user_t,capability,setuid
→ 
→ 
→ 
→ 
</pre>
</td>

<td>
  <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-selinux-on-centos-7-part-3-users">SELinux users fine-tunning</a>
<pre xxxsmall zoom>
You do not create an SELinux user with a command, 
nor does it have its own login access to the server.
SELinux users are defined in the policy loaded into
memory at boot time, and there are only a few of these users. 

Linux User ← N-to-1 → SELinux user ← 1-to-N →  roles → process domain (*_t)

* Check linux_user N-to-1 SELinux_user relationship:
  #~ semanage login -l   
  (Example CentOS 7 output)
  → Login Name           SELinux User         MLS/MCS Range        Service
  → 
  → __default__          unconfined_u         s0-s0:c0.c1023       *
  → root                 unconfined_u         s0-s0:c0.c1023       *
  → system_u             system_u             s0-s0:c0.c1023       *
  → ^^^^^^^^^^^          ^^^^^^^^^^^^         ^^^^^^^^^^^          
  → ^ linux user 1 ←→ 1  SE user              Multi Level/Category Sec.

* Check SELinux_user 1-to-N SElinux_role relationship:
  #~ semanage user -l
  (Example CentOS 7 output)
  →                 Labeling  ... 
  → SELinux User    Prefix    ...    SELinux Roles
  → 
  → guest_u         user      ...    guest_r
  → root            user      ...    staff_r sysadm_r system_r unconfined_r
  → staff_u         user      ...    staff_r sysadm_r system_r unconfined_r
  → sysadm_u        user      ...    sysadm_r
  → system_u        user      ...    system_r unconfined_r
  → unconfined_u    user      ...    system_r unconfined_r
  → user_u          user      ...    user_r
  → xguest_u        user      ...    xguest_r
    
- A user "enters a roll"           when policy grants it.
- A role "access a process domain" when policy grants it. 

<b>Ex 1: Restricting su/sudo </b>
regularuser@localhost ~]$ su - switcheduser
Password: XXXX
→ [switcheduser@localhost ~]$

#~ semanage login -a -s user_u regularuser # Remap linux_user to user_u user
[regularuser@localhost ~]$ su - switcheduser
Password: XXXX
→ su: Authentication failure

[regularuser@localhost ~]$ id -Z
user_u:user_r:user_t:s0

<b>Ex 2: Restricting Permissions to Run Scripts</b>
By default, SELinux allows users mapped to the guest_t account to exec $HOME/* scripts 
#~ getsebool allow_guest_exec_content
→ guest_exec_content - -> on

#~ semanage login -a -s guest_u guestuser
semanage login -l

[guestuser@localhost ~]$ ~/myscript.sh
→ This is a test script

#~ setsebool allow_guest_exec_content off
[guestuser@localhost ~]$ ~/myscript.sh
 → bash: /home/guestuser/myscript.sh: Permission denied

<b>Ex 3: SELinux in Action 3: Restricting Access to Services</b>
Let's now how roles also play a part in restricting user access.

#~ service httpd stop
[restricteduser@localhost ~]$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[restricteduser@localhost ~]$ service httpd start
→ Redirecting to /bin/systemctl start  httpd.service
→ Failed to issue method call: Access denied

#~ visudo
+ restricteduser ALL=(ALL)      ALL
[restricteduser@localhost ~]$ sudo service httpd start
→ ...
→ [sudo] password for restricteduser:
→ Redirecting to /bin/systemctl start  httpd.service
Keep sudo permissions but restrict apache start/stop control.
#~ semanage login -a -s user_u restricteduser
#~ seinfo -uuser_u -x # shows the roles user_u can assume 
→  user_u
→     default level: s0
→     range: s0
→     roles:
→        object_r   ←
→        user_r     ←

#~ seinfo -ruser_r -x #  check what domains the user_r role is authorized to enter:
→  user_r                                 
→     Dominated Roles:                    
→        user_r                           
→     Types:                              
→        git_session_t                    
→        sandbox_x_client_t               
→        git_user_content_t               
→        virt_content_t                   
→        policykit_grant_t                
→        httpd_user_htaccess_t            
→        telepathy_mission_control_home_t 
→        qmail_inject_t                   
→        gnome_home_t                     
→        ...                              
→        ...                              
#~ seinfo -ruser_r -x | grep httpd
→        ...                              
→        httpd_user_htaccess_t
→        httpd_user_script_exec_t
→        httpd_user_ra_content_t
→        httpd_user_rw_content_t
→        httpd_user_script_t
→        httpd_user_content_t
<b>httpd_t is missing!!! => Can NOT start/stop the service
[restricteduser@localhost ~]$ sudo service httpd start
→ sudo: PERM_SUDOERS: setresuid(-1, 1, -1): Operation not permitted

SELinux Audit Logs

- auditd  : userspace component of the Linux auditing system
  /var/log/audit/audit.log used if auditd is running.
                           Records keep detailed information 
  /var/log/messages        used if auditd is stopped (and rsyslogd is running)
                           Records keep easy-to-read version

- rsyslogd: system utility providing support for message logging.
</pre>
</td>


<td>
  <span bgorange>Object Classes</span>
<pre xxxsmall zoom>
SELinux Classes represent "core" linux objects and provide
fine grained access to linux operations on such objects. 
(The apol GUI tool can be used to examine in detail SELinux classes
 and assigned security permissions)
+------------------------+-----------------------------------------  +
|SELinux Class           | SELinux permission                        |
+------------------------+-----------------------------------------  +
| Files                  | append            lock                    |
|                        | create            mounton                 |
|                        | entrypoint        quotaon                 |
|                        | entrypoint        read                    |
|                        | execmod           relabelfrom             |
|                        | execute           rename                  |
|                        | execute_no_trans  setattr                 |
|                        | getattr           swapon                  |
|                        | ioctl             unlink                  |
|                        | link              write                   |
+------------------------+-----------------------------------------  +
| Process                | dyntransition     getsession    setsched  |
|                        | execcheap         noatsecure    share     |
|                        | execmem           ptrace        siginh    |
|                        | execmem           rlimitnh      sigkill   |
|                        | execstack         setcap        sigchld   |
|                        | fork              setcurrent    signal    |
|                        | getattr           setexec       signull   |
|                        | getcap            setfscreate   sigstop   |
|                        | getpgid           setpgid       transition|
|                        | getsched          setrlimit               |
+------------------------+-----------------------------------------  +
| Filesystems            |                                           |
| Mouting                |                                           |
| Quotas                 |                                           |
| - Network File Systems |                                           |
+------------------------+-----------------------------------------  +
|  INET Sockets          |                                           |
+------------------------+-----------------------------------------  +
| IPC                    |                                           |
+------------------------+-----------------------------------------  +
| Message Queues         |                                           |
+------------------------+-----------------------------------------  +
| Semaphores             |                                           |
+------------------------+-----------------------------------------  +
| Shared Memory          |                                           |
+------------------------+-----------------------------------------  +
| Keys                   |                                           |
+------------------------+-----------------------------------------  +
| Capability             |                                           |
+------------------------+-----------------------------------------  +
| Security               |                                           |
+------------------------+-----------------------------------------  +
| System ("as a whole")  |                                           |
+------------------------+-----------------------------------------  +

- ...
</pre>

  Building blocks:
  <span bgorange>LABELING</span>
<pre xxxsmall zoom>
- Files, directories, processes, ports, ... are ALL labeled with an SELinux context
  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^
  extended FS         labels managed by
  attributes used     kernel

"user":"role":"type":"level"
                ^      ^
               core  optional
         "type enforcement"

ls -ldZ            <b orange>SELinux type</b>          | Suffix Naming Conventions
/usr/sbin/httpd    <b orange>httpd</b>_exec_t          | "_u" -> user
/var/www/html/     <b orange>httpd</b>_sys_content_t   | "_r" -> role 
/etc/apache2/      <b orange>httpd</b>_config_t        | "_t" -> types (for files)
/var/log/httpd/    <b orange>httpd</b>_log_t
/etc/init.d/httpd  <b orange>httpd</b>_initrc_exec_t

# ps axZ | grep [h]ttpd
unconfined_u:system_r:<b orange>httpd_</b>t:s0 ...

# netstat -tnlpZ | grep httpd
....         :::80  ....  unconfined_u:system_r:<b orange>httpd_</b>t:s0 ...

# semanage port -l | grep http
http_cache_port_t  tcp 3128,8080, 8118, 8123, 10001-10010
http_cache_port_t  udp 3130
<b orange>http_port_t        tcp 80, 443</b>
...
</pre>
   Juggling with labels
<pre xxxsmall zoom>
- SELinux aware tools (chcon, restorecon, ...)
- Contexts are set when file are created based on parent's directory
  by default. A Policy can define: 
  - """when app labeled 'foo_t'creates a
       file in a directory labeled 'bar_t', 
       transition to 'baz_t' label."""
    Ex. dhclient ('dhclient_t') creates a file /etc/resolv.conf
       labeled 'net_conf_t' in /etc ('etc_t')
- RPMs can set context at install time
- Login process sets a default context (unconfined for targeted policy)
- semanage can be used to maange settings for:
  - login, user, port, interface, module
  - node, file context, boolean, permissive state, dontaudit
</pre>

  <span bgorange>TYPE ENFORCEMENT</span>
<pre xxxsmall zoom>
- "Part of the policy that says:
   a process running with the label httpd_t can have read access
   to a file labeled httpd_config_t"
</pre>

  /etc/selinux/config
<pre xxxsmall zoom>
# This file controls the state of SELinux on the system.
# SELINUX := enforcing permissive  ← permissive must be used to test changes/debug only.
disabled
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
#     <b>targeted</b>: Only list of targeted processes are protected (default)
#                     In deny-by-default every access is denied unless approved by policy
#     <b>minimum </b>: Modification of targeted policy. Only selected processes are protected. 
#     <b>mls     </b>: Multi Level Security protection.
SELINUXTYPE=targeted
</pre>

  SELinux bootup sequence
<pre xxxsmall zoom>
- When an SELinux-enabled system starts, the policy is loaded
  into memory organized in modules.
  "semodule" can be used for a number other tasks like installing,
  removing, reloading, upgrading, enabling and disabling SELinux policy modules.
        
#~ <b>se</b>module -l # lists modules currently loaded
(output will be similar to ...)
abrt    1.2.0
accountsd       1.0.6
acct    1.5.1
afs     1.8.2
...


- SELinux context for remote FS can be specified at mount time.
</pre>

</td>
<td>
  <span bgorange>Troubleshooting</span>
  <hr xxxsmall />
  Q: What an SELinux error means?:
<pre xxxsmall zoom>
 -A: It means:
     - labeling is wrong. 
       Fix examples:
       # chcon --reference /var/www/html /var/www/html/index.html
       ________________________________________________________
       # restorecon -vR    /var/www/html
         ^uses info from /etc/selinux/targeted/contexts/files/file_contexts, ... to determine what a file or dir's ctx should be
       ________________________________________________________
       # semanage fcontext -a -e /var/www/ /my/alternative/www/
       # restorecon -vR /my/alternative/www
       WARN: When we use semanage fcontext ctx we are just defining 
         what the context is, we are not writing what the extended 
         attributes are. We are just saying "when we do relable it 
         must look like this". restorecon must be run against the 
         directory to really relabel the new context.

     - Policy needs to be tweaked
       - booleans
        - policy modules
     - A bug in the policy (Open a ticket)
        STEP 1: put SELinux into "permissive" mode and run
                the application through all its paces to log all
                SELinux denials.
        # setenforce 0
        STEP 2: From /var/log/messages C&P proposed solution:
        # grep httpd /var/log/audit/audit.log | audit2allow -Mquirrellocal
                                                             ^generate new
                                                              policy file
        STEP 3: Import the new module
        # semodule -i squirrellocal.pp
        STEP 4: Re-enable SELinux enforcement
        # setenforce 1

     - You have been, or are being, broken into!!
</pre>

  Bug fixing general procedure
<pre xxxsmall zoom>

STEP 01: Check /var/log/messages
 ...
 ...  setroubleshoot: SELinux is preventing /usr/bin/httpd from getattr access on the directory /home/fred. <b>For complet SELinux messages, run sealert -l 37acc7d8-e955-4333-123a-1d027dbcea72</b>

STEP 02: Run the indicated command:
~# sealert -l 37acc7d8-e955-4333-123a-1d027dbcea72
→ SELinux is preventing /usr/sbin/httpd from search access on the directory /home/fred
→ ...<b orange>
→ Do
→ setsebool -P httpd_read_user_content 1
→ ...
→ setsebool -P httpd_enable_homedirs 1</b>
→
→
</pre>

  Ex:<a href="http://stackoverflow.com/questions/23851452/cant-resolve-domain-names-in-php-under-apache/24019910#24019910">Fix Apache DNS problem:</a>
<pre xxsmall zoom>
# -P => change also boot-time default
$ setsebool -P nis_enabled 0  
$ setsebool -P httpd_can_network_connect 1
</pre>

</td>
<td>
  <span bgorange>Booleans</span>
<pre xxxsmall zoom>
  Ex:
  - """ Do we allow  the ftp server access to home directories? """
  - """ Can httpd use mod_auth_ntlm_winbind ? """
  - ...
</pre>
  Show all booleans
<pre xxxsmall zoom>
  $ sudo getsebool -a
</pre>

  Set boolean
<pre xxxsmall zoom>
  $ setsebool "mySELinuxBoolean" 0|1  [-P]
</pre>

 List Booleans Set
<pre xxxsmall zoom>
 - Take a look at the booleans.local file under
  /etc/selinux/targeted/modules/active/

  Ex:
  # This file is auto-generated by libsemanage
  # Do not edit directly.

  httpd_read_user_content=1
  httpd_enable_homedirs=1
</pre>
</td>

<td>
  <a href="http://blog.siphos.be/2015/07/restricting-even-root-access-to-a-folder/">Restricting root access to F.S.</a> 
<pre xxxsmall zoom>
(Date Sat 11 July 2015 By Sven Vermeulen Category SELinux)

- The use of a pre-existing policy means that some roles are already 
  identified and privileges are already granted to users - often these
  higher privileged roles are assigned to the Linux root user as not
  to confuse users. But that does mean that restricting root access to
  a folder means that some additional countermeasures need to be implemented.

STEP 01: Create new policy restricting access to /etc/private:
 policy_module(myprivate, 1.0)
 
 type <b orange>etc_private_t</b>;                 ← type allowed to be used for files 
 fs_associate(<b orange>etc_private_t</b>)         ← associate with file system
                                       Do NOT use the files_type() interface
                                       as this would assign a set of attributes
                                       that many user roles get read access on.
  allow sysadm_t <b orange>etc_private_t</b>:{dir file} relabelto;  *1

 *1: sysadm_t is now allowed to change ctx to etc_private_t:
     - administrator can label resources as etc_private_t 
       without having read access to these resources afterwards.
       Also, as long as there are no relabelfrom privileges assigned,
       the administrator cannot revert the context back to a
       type that he has read access to:
       ~ sudo chcon -t <b orange>etc_private_t</b> /etc/private


STEP 02:
- Administrators can still disable SELinux controls. Ex:
  # cat /etc/private/README
  → cat: /etc/private/README: Permission denied
  # setenforce 0
  # cat /etc/private/README
  → Hello World!

To prevent this:
  # setsebool secure_mode_policyload on
              ^                      ^
          prevent any policy and SELinux state manipulation
          !!!including permissive mode!!!, but also including
          loading additional SELinux policies or changing booleans.
          (experiment with this setting without persisting (-P)

WARN: Admin cannot access /etc/private location directly,
        but he might be able to access it indirectly, remounting the
        (non-critical) system and remounting with the context= option,
        overriding file-level contexts.
WARN: Admin can still reboot the system in a mode where he
      can access the file system regardless of SELinux controls 
      bootin with enforcing=0, editing /etc/selinux/config, ....
WARN: Admin can still access the block device files on which the 
      resources are directly. Specialized tools can allow for 
      extracting files and directories without actually (re)mounting
      the device.

You can still un-grant users and/oradmins the permissions to reboot the system,
    (re)mount file systems, access block devices, etc. 
    without leaving behind the policy that is already active.
</pre>

  <a href="http://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/">Protecting CA priv.keys</a>
<pre xxxsmall zoom>
Ex CA script:

$ certcli.sh -r genfic                # Create a root CA key for "genfic"
$ certcli.sh -p genfic -c genfic-user # Create a subkey, signed by "genfic"
$ certcli.sh -p genfic-user           # Create a user certificate
   -R /var/db/ca/myUserId 
$ certcli.sh -p genfic-user \         # Sign a certificate
  -s /var/db/ca/requests/someUser.csr
$ certcli.sh -p genfic-user \         # Revoke a certificate
  -x myuser@genfic.com


             -->     certcli.sh --> ca_private_key_t
                       ^^^^
        ca_cli_exec_t  ca_cli_t
        entry point    domain

From a security point of view focus on two types:
----------------+--------------------------------------------------------
ca_private_key_t|for private key, should not be
                |accessible only to certcli.sh running as 'ca_cli_t'
----------------+--------------------------------------------------------
ca_misc_t       |is for the other related files, such as certificates,
                |revocation lists, serial information, etc. If this would be "for
                |real" I'd probably make a bit more types for this depending on the
                |accesses, but for this post this suffices.
----------------+--------------------------------------------------------
ca_misc_tmp_t   | temporary files should still be well protected
----------------+--------------------------------------------------------

ca.te:
| policy_module(ca, 1.0.0)
| 
| # CA management script and domain
| type ca_cli_t;
| type ca_cli_exec_t;
| domain_base_type(ca_cli_t)    
| fs_associate(ca_cli_exec_t)

Then, two non-standard approaches were followed.
   application domains are granted through application_type(),
   application_domain() or even userdom_user_application_domain(). 
   Which interface you use depends on the privileges you want to
   grant on the domain, but also which existing privileges should
   also be applicable to the domain. Make sure you review the interfaces. 
   For instance:
  | seshowif application_domain
  | 
  | interface(`rapplication_type`, 
  |       gen_require(` attribute application_domain_type; `)
  | 
  |     typeattribute $1 application_domain_type;
  | 
  |     # start with basic domain
  |     domain_type($1)
  | 
  | ')
  
This means that the assigned domain (`ca_cli_t` in our example) would be
assigned the `application_domain_type` attribute, as well as the
`domain` attribute and other privileges. If we really want to prevent
any access to the `ca_cli_t` domain for handling the certificates, we
need to make sure that the lowest possible privileges are assigned.

The same is true for the file type `ca_cli_exec_t`. Making it through
`files_type()` interface would assign the `file_type` attribute to it,
and other domains might have access to `file_type`. So all I do here is
to allow the type `ca_cli_exec_t` to be associated on a file system.

Similarly, I define the remainder of file types:

  | type ca_private_key_t;
  | fs_associate(ca_private_key_t)
  | 
  | type ca_misc_tmp_t;
  | fs_associate(ca_misc_tmp_t)
  | fs_associate_tmpfs(ca_misc_tmp_t)
  | 
  | type ca_misc_t;
  | fs_associate(ca_misc_t)

NEXT: grant the script (ca_cli_t domain) proper access to these types:

  | allow ca_cli_t ca_misc_t:dir create_dir_perms;
  | manage_files_pattern(ca_cli_t, ca_misc_t, ca_misc_t)
  | allow ca_cli_t ca_private_key_t:dir create_dir_perms;
  | manage_files_pattern(ca_cli_t, ca_private_key_t, ca_private_key_t)

This of course heavily depends on the script itself.
Mine creates a directory "private", so needs the proper rights on the
`ca_private_key_t` type for directories as well.

 The "private" directory is created in a generic directory
(which is labeled as `ca_misc_t`) so I can also create a file transition.

 This means that the SELinux policy will automatically assign the
`ca_private_key_t` type to a directory, created in a directory with
label `ca_misc_t`, if created by the `ca_cli_t` domain:

  | filetrans_pattern(ca_cli_t, ca_misc_t, ca_private_key_t, dir, "private")

Now, ca_cli_t is a domain used for a shell script, which in my case
also requires the following permissions:

  | # Handling pipes between commands
  | allow ca_cli_t self:fifo_file rw_fifo_file_perms;
  | # Shell script...
  | corecmd_exec_shell(ca_cli_t)
  | # ...which invokes regular binaries
  | corecmd_exec_bin(ca_cli_t)
  | # Allow output on the screen
  | getty_use_fds(ca_cli_t) userdom_use_user_terminals(ca_cli_t)

Now I still need to mark `ca_cli_exec_t` as an entrypoint for
`ca_cli_t`, meaning that the `ca_cli_t` domain can only be accessed
(transitioned to) through the execution of a file with label
`ca_cli_exec_t`:
  | allow ca_cli_t ca_cli_exec_t:file entrypoint;
  | allow ca_cli_t ca_cli_exec_t:file { mmap_file_perms ioctl lock };

Normally, the above is granted through the invocation of the
 application_domain(ca_cli_t, ca_cli_exec_t) but as mentioned before, 
this would also assign attributes that I explicitly want to prevent in 
this example.

Next, the openssl application, which the script uses extensively, 
also requires additional permissions. As the openssl command just runs
in the ca_cli_t domain, I extend the privileges for this domain more:

  | # Read access on /proc files
  | kernel_read_system_state(ca_cli_t)
  | # Access to random devices
  | dev_read_rand(ca_cli_t)
  | dev_read_urand(ca_cli_t)
  | # Regular files
  | files_read_etc_files(ca_cli_t)
  | miscfiles_read_localization(ca_cli_t)
  | # /tmp access
  | fs_getattr_tmpfs(ca_cli_t)

Also, the following file transition is created: when OpenSSL creates a
temporary file in `/tmp`, this file should immediately be assigned the
`ca_misc_tmp_t` type:

  | # File transition in /tmp to ca_misc_tmp_t
  | files_tmp_filetrans(ca_cli_t, ca_misc_tmp_t, file)

With this in place, the application works just fine.

NEXT: all that needed is to have an initial location marked as ca_misc_t.
For now, none of the users have the rights to do so, so I create
three additional interfaces to be used against other user domains:

   - The first one is to allow user domains to use the CA script.
     This is handled by the ca_role() interface. In order to support
     such an interface, let's first create the ca_roles role attribute
     in the .te file:

   | attribute_role ca_roles; 
   | role ca_roles types ca_cli_t;

Now I can define the `ca_role()` interface:

   | interface('ca_role','
   |   gen_require(`
   |     attribute_role ca_roles;
   |     type ca_cli_t, ca_cli_exec_t;
   |     type ca_misc_t;
   |   ')
   |   # Allow the user role (like sysadm_r) the types granted to ca_roles
   |   roleattribute $1 ca_roles;
   |   
   |   # Read the non-private key files and directories
   |   allow $2 ca_misc_t:dir list_dir_perms;
   |   allow $2 ca_misc_t:file read_file_perms;
   |   
   |   # Allow to transition to ca_cli_t by executing a ca_cli_exec_t file
   |   domtrans_pattern($2, ca_cli_exec_t, ca_cli_t)
   |   
   |   # Look at the process info
   |   ps_process_pattern($2, ca_cli_t)
   |   
   |   # Output (and redirect) handling
   |   allow ca_cli_t $2:fd use;
   | ')

This role allows to run the command, but we still don't have the rights
to create a ca_misc_t directory. So another interface is created, which 
is granted to regular system administrators (as the ca_role() might be
granted to non-admins as well, who can invoke the script through sudo).

   | interface('ca_sysadmin',gen_require( type ca_misc_t; type ca_private_key_t; ')
   |  # Allow the user relabel rights on ca_misc_t
   |  allow $1 ca_misc_t:dir relabel_dir_perms;
   |  allow $1 ca_misc_t:file relabel_file_perms;
   |  # Allow the user to label /to/ ca_private_key_t (but not vice versa) 
   |  allow $1 ca_private_key_t:dir relabelto_dir_perms;
   |  allow $1 ca_private_key_t:file relabelto_file_perms;
   |  # Look at regular file/dir info 
   |  allow $1 ca_misc_t:dir list_dir_perms;
   |  allow $1 ca_misc_t:file read_file_perms; '
   | )

The 'ca_sysadmin()' interface can also be assigned to the `setfiles_t`
command so that relabel operations (and file system relabeling) works
correctly.

Finally, a real administrative interface is created that also has
relabel *from* rights (so any domain granted this interface will be able
  - if Linux allows it and the type the operation goes to/from is allowed
  - to change the type of private keys to a regular file). 
This one should *only* be assigned to a rescue user (if any). 
Also, this interface is allowed to label CA management scripts.

   | interface(`ca_admin',`
   |   gen_require(`
   |     type ca_misc_t, ca_private_key_t;
   |     type ca_cli_exec_t;
   |   ')
   | 
   |   allow $1 { ca_misc_t ca_private_key_t }:dir relabel_dir_perms;
   |   allow $1 { ca_misc_t ca_private_key_t }:file relabel_file_perms;
   | 
   |   allow $1 ca_cli_exec_t:file relabel_file_perms;
   | ')

So regular system administrators would be assigned the ca_sysadmin() 
interface as well as the setfiles_t domain; 
CA handling roles would be granted the ca_role() interface.

The ca_admin() interface would only be granted on the rescue (or super-admin).

* Regular system administrators:
    ca_sysadmin(sysadm_t) ca_sysadmin(setfiles_t)
  
* Certificate administrator:
    ca_role(certadmin_r, certadmin_t)
  
* Security administrator
    ca_admin(secadm_t)
</pre>
</td>
<td>
  CLI
  <hr xxxsmall />
  runcon
<pre xxxsmall zoom>
- "runcon" allows to launch processes into a specified context (user, role and domain) 
</pre>
  sestatus
<pre xxxsmall zoom>
→ SELinux status:                 enabled
→ SELinuxfs mount:                /sys/fs/selinux
→ SELinux root directory:         /etc/selinux
→ Loaded policy name:             targeted
→ Current mode:                   permissive
→ Mode from config file:          error (Success)
→ Policy MLS status:              enabled
→ Policy deny_unknown status:     allowed
→ Max kernel policy version:      28
</pre>

  Switch permissive/enforce:
<pre xxxsmall zoom>
#~ setenforce permissive: Temporarely change enforce status.
#~ setenforce enforcing
</pre>

  man pages
<pre xxxsmall zoom>
|<t                                               />--------- File System--------<t/>|<t                                               />--Process (Subject) --------<t/>
|<a href="https://linux.die.net/man/8/restorecon"  >restorecon(8)                </a>|<a href="https://linux.die.net/man/1/runcon"      >runcon(1)                    </a>
|<t                                               />  restore file(s) default ctx<t/>|<t                                               />  run command with given ctx <t/>
|<a href="https://linux.die.net/man/8/restorecond" >restorecond(8)               </a>|<t                                               />--------- Common  ----------<t/>
|<t                                               />  watchs for file creation   <t/>|<a href="https://linux.die.net/man/1/secon"       >secon(1)                     </a>
|<t                                               />  and then sets default ctx  <t/>|<t                                               />See ctx from a file|program| <t/>
|<t                                               />  ("mv" will keep proper ctx <t/>|<t                                               />user-input                   <t/>
|<t                                               />   from new parent dir.     )<t/>|<t                                               />--SE aware Process API ------<t/>
|<a href="https://linux.die.net/man/8/fixfiles"    >fixfiles(8)                  </a>|<a href="https://linux.die.net/man/3/setcon"     />setcon(3)                    </a>
|<t                                               />  fix file security ctxs     <t/>|<a href="https://linux.die.net/man/3/getcon"     />getcon(3)                    </a>
|<a href="https://linux.die.net/man/1/chcon"       >chcon(1)                     </a>|<a href="https://linux.die.net/man/3/getpidcon"  />getpidcon(3)                 </a>
|<t                                               /> change file security context<t/>|<a href="https://linux.die.net/man/3/getpidcon"  />getpidcon(3)                 </a>
|<a href="https://linux.die.net/man/8/setfiles"    >setfiles(8)                  </a>
|<t                                               />  set file security ctxs     <t/> 

|<t                                               />---------- Policy  ----------<t/><b bgorange>
|<a href="https://linux.die.net/man/8/semanage"    >semanage(8)                  </a></b>
|<t                                               />  configure certain policy elements  <t/>
|<t                                               />  without editing/recompiling source:<t/>
|<t                                               />  - mapping user to se_users         <t/>
|<t                                               />  - mapping ctx for network ports,   <t/>
|<t                                               />    interfaces, and nodes(hosts),    <t/>
|<t                                               />    file context mapping.            <t/>
|<a href="https://linux.die.net/man/8/load_policy" >load_policy(8)               </a>
|<t                                               />  load policy into the kernel<t/>
|<t                                               />---------- Booleans  --------<t/>
|<a href="https://linux.die.net/man/8/booleans"    >booleans(8)                  </a>
|<a href="https://linux.die.net/man/8/getsebool"   >getsebool(8)                 </a>
|<a href="https://linux.die.net/man/8/setsebool"   >setsebool(8)                 </a>
|<a href="https://linux.die.net/man/8/togglesebool">togglesebool(8)              </a>
</pre>

  <a href="https://github.com/TresysTechnology/setools/wiki">policy analysis tools</a>
<pre xxxsmall zoom>
|<a ____="                                    ">Tool Name   </a>| Use
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/apol"    >apol (GUI)  </a>| perform various types of analyses
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sediff"  >sediff      </a>| Compare two policies to find differences.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">sedta       </a>| Perform domain transition analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/seinfo"  >seinfo      </a>| List policy components.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">seinfoflow  </a>| Perform information flow analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sesearch">sesearch(8) </a>|policy query tool, Search rules (allow, type_transition, etc.)
|<t                                           />------------</t>|----------------------------------
</pre>

</td>
</table>

<table>
<tr>
  <th colspan=6 header_delimit>Creating new Policies</th>
</tr>
<tr>
<td>
  Compiling new policy:
<a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file">REF</a>

<pre xxxsmall zoom>
WARN: In some cases, you might need to update your policy to be compatible 
      with upstream SELinux policy changes. 

Tipical policy module (*.pp file) looks like:

localpolicy.pp 
*.te: type enforcement
*.fc: file contexts (optional)
*.if: interfaces (optional)


PRE-SETUP:
 $ sudo yum install -y selinux-policy-devel


<b>STEP 01: vim localpolicy.te:</b>

policy_module(localpolicy, 1.0)  ← localpolicy must match localpolicy.te prefix
gen_require(`                    ← backtick (`) denotes the start/end of the block 
  type user_t;                   ← gen_require block is used to "reuse"reference policy,
  type var_log_t;                  and will be translated during the make -f ... command 
')                                 earlier on towards SELinux rules. 

allow user_t var_log_t:dir { getattr search open read };

<b>STEP 02: create SELinux policy module localpolicy.pp:</b>
# sudo make -f /usr/share/selinux/devel/Makefile localpolicy.pp

                                                          ^must "match"
                                                           localpolicy.te prefix


<b>STEP 03: Load the file:</b>
# sudo setenforce permissive
# sudo semodule -i /path/to/localpolicy.pp  
WARN: semodule does NOT need "-P". Will remain loaded after reboots.
(to disable use # sudo semodule -d localpolicy)

# sudo 
</pre>
</td>
<td>
    OBJECT("FILE") SECURITY CONTEXT:
<pre xxxsmall zoom >
Ej:
#~ ls -Z /etc/logrotate.conf
... <b green>system_u</b> : <b brown>object_r</b> :<b orange>etc_t    </b>: <b blue>s0   </b>    /etc/logrotate.conf
    <b green>^       </b>   <b brown>^       </b>  <b orange> ^       </b>  <b blue>^    </b>
    <b green>user    </b>   <b brown>role    </b>  <b orange>*type*   </b>  <b blue>MLS  </b>
    <b green>context </b>                          <b orange>"classif.</b>  <b blue>level</b>
                                                   <b orange>attribute</b>
</pre>
    SUBJECT(PROCESS) CONTEXTS:
<pre xxxsmall zoom >
#~  ps -efZ | grep 'httpd'
<b green>system_u</b>:<b brown>system_r</b>:<b orange>httpd_t</b>:<b blue>s0 </b> root   ... /usr/sbin/httpd
<b green>system_u</b>:<b brown>system_r</b>:<b orange>httpd_t</b>:<b blue>s0 </b> apache ... /usr/sbin/httpd
<b green>...     </b>
<b green>^       </b> <b brown>^       </b> <b orange>^      </b> <b blue>^  </b>
<b green>user    </b> <b brown>role    </b> <b orange>domain </b> <b blue>MLS</b> 
</pre>
    How Processes Access Resources
    <ul xxxsmall zoom>
      <li> A process/subject (tries to) perform some action (open, read, modify, or execute) on files.
        SELinux access rules follow a standard allow statement structure:
<pre xxxsmall>     
allow <b orange>&lt;domain&gt; &lt;type&gt;</b>:<b blue>&lt;class&gt;</b> { <b green>&lt;permissions&gt;</b> };

<b blue>class := (file, directory, symbolic link, device, ports, cursor ...</b>
</pre>
     Must be read as:<br/>
     <span cite> """ If a process is of certain <b orange>domain</b>
      And the resource object it's trying to access is of certain <b blue>class</b> and <b orange>type</b><br/>
      Then allow the access</br>
      Else deny access """</span>
      </li>
    </ul>
    <code><b>se</b>search</code>:
<pre xxxsmall zoom>
search access allowed for source/target domains:
#~ <b>se</b>search --allow \
   --source <b orange>httpd_t</b>              # domain for apache process
   --target <b orange>httpd_sys_content_t</b>  # type   for /var/www/html files
   --class <b blue>file</b> 
(output will be similar to...)
Found 4 semantic av rules:
   allow <b  orange>httpd_t httpd_sys_content_t</b> : <b blue>file</b> <b green>{ ioctl read getattr lock open }</b> ;
   allow <b  orange>httpd_t httpd_content_type </b> : <b blue>file</b> <b green>{ ioctl read getattr lock open }</b> ;
   allow <b  orange>httpd_t httpd_content_type </b> : <b blue>file</b> <b green>{ ioctl read getattr lock open }</b> ;
   allow <b  orange>httpd_t httpdcontent       </b> : <b blue>file</b> <b green>{ ioctl read write create getattr setattr lock append unlink link rename execute open }</b> ;
</pre }>
    Preserve context in file copy
<pre xxxsmall zoom >
#~ cp <b>--preserver=context</b> /var/www/html/index.html ~/html
(context is preserved with "mv")
</pre>
    changing context of file temporally:
<pre xxxsmall zoom >
# (file system relabel will revert to original context)
#~ chcon --type <b orange>var_t</b> /var/www/html/index.html
# Restore with:
#~ restorecon -v /var/www/html/index.html
restorecon reset /var/www/html/index.html context unconfined_u:object_r:<b orange>var_t</b>:s0->unconfined_u:object_r:<b orange>httpd_sys_content_t</b>:s0
</pre>
  </td>
<td>
  Context Transition
<pre xxxsmall zoom >
proc_a @ contexta_t   → run app_x     → proc_b running @ contextb_t
                            ↑
                        entrypoint to
                         new context 

Ex:
#~ ls -Z /usr/sbin/vsftpd 
-r-x------ root root system_u:object_r:<b orange>ftpd_exec_t</b>:s0 /usr/sbin/vsftpd
                                       <b orange>^entrypoint</b> 
                                       <b orange>to  new    </b> 
                                       <b orange>context    </b>

#~ps -eZ  | egrep "(init_t|vsftpd)"
system_u:system_r:<b orange>init_t</b>:s0 ... systemd
system_u:system_r:<b orange>ftpd_t</b>:s0 ... vsftpd

 <b>Domain transition rules:</b>
 - source context "proc_a" must have execute permission for entrypoint (app_x)
 - "app_x" file context must be identified as an entrypoint for the target domain
 - original domain (contexta_t) must be allowed to transition to the target domain (contextb_t)
  In the previous example:
  STEP 01: Check source domain <b orange>init_t</b> have execute permission on
  ftpd_exec_t entrypoint:
    #~ sesearch -s init_t -t ftpd_exec_t -c file -p execute -Ad
    → allow init_t ftpd_exec_t : file { read getattr execute open } ;
   
  STEP 02: Check binary file is entrypoint for the target domain <b orange>ftpd_t</b>:
    #~ <b>se</b>search -s <b orange>ftpd_t</b> \
         -t <b orange>ftpd_exec_t</b> -c file \
         -p <b green>entrypoint</b> -Ad
    → allow ftpd_t ftpd_exec_t : file { ioctl read getattr lock execute execute_no_trans <b green>entrypoint</b> open } ;

  STEP 03: Check source domain init_t have transition permission to target ftpd_t:
    #~ <b>se</b>search -s <b orange>init_t</b> -t <b orange>ftpd_t</b> \
          -c process -p transition -Ad
    → allow init_t ftpd_t : process transition ;
</pre>

  Workflow
<pre xxxsmall zoom>
- Switch to permisive mode.
- Test new policy.
- Check violations in logs (See troubleshooting with audit2allow to produce new rules)
</pre>
    

  Verify current file  against file_context(.local) ddbb 
<pre xxxsmall zoom >
#~ matchpathcon -V /www/html/index.html # -V: Verify
In case of mismatch an error similar to next one will be displayed:
/www/html/index.html has context unconfined_u:object_r:default_t:s0, should be system_u:object_r:httpd_sys_content_t:s0 
</pre>

  Computing SE context output
<pre xxxsmall zoom>
The table shows how the components from the source context scon, target context tcon and class tclass are used to compute the new context newcon (referenced by SIDs for  avc_compute_create(3)).
<b>avc_compute_create and security_compute_create</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | IF there is a valid role_transition rule THEN | IF there is a valid type_transition rule THEN | IF there is a valid range_transition rule THEN
  use tcon user                         |    use the rules new_role                     |   use the rules default_type                  |   use the rules new_range
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source low rule THEN
  use scon user                         |    use scon role                              |   use scon type                               |   use scon low
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source high rule THEN 
                                        |    use tcon role                              |   use tcon type                               |   use scon high
                                        | OR IF tclass is process or *socket  THEN      | OR IF tclass is process or *socket THEN       | OR IF default_range tclass source low_high rule THEN
                                        |    use scon role                              |   use scon type                               |   use scon range
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target low rule THEN 
                                        |    Use object_r                               |   use tcon type                               |   use tcon low
                                                                                                                                        | OR IF default_range tclass target high rule THEN
                                                                                                                                        |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   use scon low
_______________________________________________________________________________________________________________________________________________________________________________________________
<b>avc_compute_member and security_compute_member</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | If there is a valid role_transition rule THEN | If there is a valid type_transition rule THEN | If default_range tclass source low rule THEN
  use tcon user                         |   use the rules new_role                      |   use the rules default_type                  |   use scon low
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source high rule THEN 
  Use scon user                         |   use scon role                               |   use scon type                               |   use scon high
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source low_high rule THEN
                                        |   use tcon role                               |   use tcon type                               |   use scon range
                                        | OR IF tclass is process or *socket , THEN     | OR IF tclass is process or *socket , THEN     | OR IF default_range tclass target low rule THEN
                                        |   use scon role                               |   use scon type                               |   use tcon low
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target high rule THEN
                                        |   Use object_r                                |   use tcon type                               |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket , THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   Use scon low
</pre>
</td>

<td>
  Who is Who
<pre xxxsmall zoom>
SELinux By Example  authors:
Frank Mayer is cofounder and Chief Technology Officer of 
Tresys Technology, and has 23 years of experience in the 
design, development, and analysis of secure operating 
systems. He has been an active contributor to SELinux for 
six years, and has initiated and participated in the 
development of many new SELinux innovations and tools. He 
also chairs the annual SELinux Symposium. Frank has 
published many papers on secure and trustworthy operating 
systems, and has also explored security in parallel 
computing, networks, and enterprise applications.


Karl MacMillan is an active contributor in the SELinux 
community and has led the development of many important 
SELinux features. He is also a sought after speaker and 
consultant, and has helped many individuals and 
organizations understand and apply strong computer 
security with SELinux. Previous to his work on SELinux, 
Karl made important contributions in the fields of 
pattern recognition and evolutionary computing as applied 
to document and audio recognition, where he has numerous 
published papers.

David Caplan is a senior security engineer at Tresys 
Technology with over 20 years of experience in computer 
security and a wide range of other programming- and 
software-related areas. He has worked with SELinux for 
six years as a contributor to many of the SELinux-related 
open source projects and has led multiple efforts in 
analyzing and constructing SELinux policy for a variety 
of systems.
</pre>


</td>


</table>



<!--
TODO_START: {
 SELinux    cached information on access-decisions via the Access Vector Cache (AVC)
________________________
<code TODO>system-config-selinux</code> (Gtk GUI for SELinux)
_________________________
https://docs.fedoraproject.org/en-US/Fedora/13/html/SELinux_FAQ/
______________________________
http://oss.tresys.com/
Projects hosted on GitHub:
  --------------------------
- SETools Policy Analysis Suite : SETools is a suite of open source tools that allow a policy developer or tester to perform detailed analysis and debugging of an SELinux policy
- Certifiable Linux Integration Platform (CLIP) : a toolkit for creating a secure computing environment suitable for hosting U.S. Government applications
- Reference Policy : makes it easier to maintain and apply baseline security policy for Security Enhanced Linux (SELinux)
_______________________________
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index
____________________________
https://debian-handbook.info/browse/en-US/stable/sect.selinux.html
____________________________
<td>
Multilevel Security (MLS)
<pre xxxsmall zoom>
~ ls -Z /etc/vsftpd/vsftpd.conf
-rw-------. root root system_u:object_r:etc_t:s0       /etc/vsftpd/vsftpd.conf

The sensitivity is part of the hierarchical multilevel security mechanism. By hierarchy, we mean the levels of sensitivity can go deeper and deeper for more secured content in the file system. Level 0 (depicted by s0) is the lowest sensitivity level, comparable to say, "public." There can be other sensitivity levels with higher s values: for example, internal, confidential, or regulatory can be depicted by s1, s2, and s3 respectively. This mapping is not stipulated by the policy: system administrators can configure what each sensitivity level mean.

When a SELinux enabled system uses MLS for its policy type (configured in the /etc/selinux/config file), it can mark certain files and processes with certain levels of sensitivity. The lowest level is called "current sensitivity" and the highest level is called "clearance sensitivity".

Going hand-in-hand with sensitivity is the category of the resource, depicted by c. Categories can be considered as labels assigned to a resource. Examples of categories can be department names, customer names, projects etc. The purpose of categorization is to further fine-tune access control. For example, you can mark certain files with confidential sensitivity for users from two different internal departments.

For SELinux security contexts, sensitivity and category work together when a category is implemented. When using a range of sensitivity levels, the format is to show sensitivity levels separated by a hyphen (for example, s0-s2). When using a category, a range is shown with a dot in between. Sensitivity and category values are separated by a colon (:).

Here is an example of sensitivity / category pair:

user_u:object_r:etc_t:s0:c0.c2  

There is only one sensitivity level here and that's s0. The category level could also be written as c0-c2.

So where do you assign your category levels? Let's find the details from the /etc/selinux/targeted/setrans.conf file:

cat /etc/selinux/targeted/setrans.conf

#
# Multi-Category Security translation table for SELinux
#
#
# Objects can be categorized with 0-1023 categories defined by the admin.
# Objects can be in more than one category at a time.
# Categories are stored in the system as c0-c1023.  Users can use this
# table to translate the categories into a more meaningful output.
# Examples:
# s0:c0=CompanyConfidential
# s0:c1=PatientRecord
# s0:c2=Unclassified
# s0:c3=TopSecret
# s0:c1,c3=CompanyConfidentialRedHat
s0=SystemLow
s0-s0:c0.c1023=SystemLow-SystemHigh
s0:c0.c1023=SystemHigh

We won't go into the details of sensitivities and categories here. Just know that a process is allowed read access to a resource only when its sensitivity and category level is higher than that of the resource (i.e. the process domain dominates the resource type). The process can write to the resource when its sensitivity/category level is less than that of the resource.
Conclusion

We have tried to cover a broad topic on Linux security in the short span of this three-part-series. If we look at our system now, we have a simple Apache web server installed with its content being served from a custom directory. We also have an FTP daemon running in our server. There were a few users created whose access have been restricted. As we went along, we used SELinux packages, files, and commands to cater to our security needs. Along the way we also learned how to look at SELinux error messages and make sense of them.

Entire books have been written on the SELinux topic and you can spend hours trying to figure out different packages, configuration files, commands, and their effects on security. So where do you go from here?

One thing I would do is caution you not to test anything on a production system. Once you have mastered the basics, start playing with SELinux by enabling it on a test replica of your production box. Make sure the audit daemons are running and keep an eye on the error messages. Check any denials preventing services from starting. Play around with the boolean settings. Make a list of possible steps for securing your system, like creating new users mapped to least-privilged SELinux accounts or applying the right context to non-standard file locations. Understand how to decipher an error log. Check the ports for various daemons: if non-standard ports are used, make sure they are correctly assigned to the policy.

It will all come together with time and practice. :)
</pre>
</td>
___________________________
 As processes and objects are created and destroyed, they either:
1.  Inherit their labels from the parent process or object.
2.  The policy type, role and range transition statements allow a different label to
     be assigned as discussed in the Domain and Object Transitions section.
3.  SELinux-aware   applications   can   enforce   a   new   label   
    (with   the   policies approval of course) using the libselinux API functions.
4.  An object manager (OM) can enforce a default label that can either be built
    into the OM or obtained via a configuration file (such as those used by X-Windows).
5.  Use an 'initial security identifier' (or initial SID). These are defined in all 
    base and monolithic policies and are used to either set an initial context during the
    boot process, or if an object requires a default (i.e. the object does not already
    have a valid context).


The labeling of file systems that implement extended attributes
is supported by SELinux using:
1.  The  fs_use_xattr statement   within   the   policy   to   identify   what   file
  systems use extended attributes. This statement is used to inform the security
  server how to label the filesystem.
2.  A 'file contexts' file that defines what the initial contexts should be for each
   file and directory within the filesystem. The format of this file is described in
   the modules/active/file_contexts.template file section.
3.  A method to initialise the filesystem with these extended attributes. This is
   achieved by SELinux utilities such as fixfiles(8) and setfiles(8) .
   There   are   also   commands   such   as  chcon(1),  restorecon(8) and
   restorecond(8) that can be used to relabel files

______________________________________
<a href="https://www.youtube.com/watch?v=MxjenQ31b70&t=2790s">SELinux for mere mortals</a>
}
-->

</html>
