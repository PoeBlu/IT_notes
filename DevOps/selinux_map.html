<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Security Enhanced Linux (SELinux) map (alpha) <!-- ignore --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>
Creating new Policies
<table>
<tr>
<td>
  <span xsmall>Policy RULES</span>
<pre zoom>
- The set of (possibly thousands of) rules define a given policy.
  ┌──────────────────────────┬─────────────────────────────────────────────────────────────┐
  │*ACCESS VECTOR(AV) RULES*:│                                                             │
  ├──────────────────────────┘                                                             │
  │- Define the AV bitmap from source types to*existing*[target+type:kernel-class] objects │
  ├────────────────────────────────────────────────────────────────────────────────────────┤
  │ SYNTAX:                                                                                │
  │ *allow*       o*src_domain*       g*target_type*:b*class* { g*permissions* };          │
  │  ↑↑↑↑↑          ↑↑↑↑↑↑↑↑↑↑          ↑↑↑↑↑↑↑↑↑↑↑    ↑↑↑↑↑      ↑↑↑↑↑↑↑↑↑↑↑              │  
  │  allow          running process     TODO??????     files      sub─list of              │
  │  dontaudit      domain ("type")                    socket     class─actions            │
  │  auditallow                                        IPC        allowed for              │
  │  neverallow                                        ...        source─to─target         │
  │                                                               types                    │
  │              (o*src_domain*   ,   g*target_type*, b*class*)   types                    │
  │              └─── tuple used as key in AV hashtable  ─────┘                            │
  │                 ─ Two rules matching the same triplet key will                         │
  │                   "merge" their permissions.                                           │
  │                 ─ Permissions can NOT be deleted, only added                           │
  └────────────────────────────────────────────────────────────────────────────────────────┘
  ┌─────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │*TYPE RULES*:│                                                                                                                                │ 
  ├─────────────┘                                                                                                                                │ 
  │─ control default labeling decisions when*new objects*are created*AT RUNTIME*                                                                 │
  ├──────────────────────────────────────────────────────┬──────────────────┬────────────────────────────────────────────────────┬───────────────┤
  │ TYPE─TRANSITION─SYNTAX:(new running─process labeling)│                  │ OBJECT─TRANSITION─SYNTAX (new file─object labeling)│               │
  ├──────────────────────────────────────────────────────┘                  ├────────────────────────────────────────────────────┘               │
  │                                                                         │ (default to "parent")                                              │
  │ *type_transition* g*user_t*  b*passwd_exec_t*:o*process* *passwd_t*;    │ *type_transition* passwd_t tmp_t : file passwd_tmp_t;              │
  │                                ^^^^^^^^^^^^^    ^^^^^^^                 │                   ^^^^^    ^^^^^                                   │
  │                                targeted type    source object─class     │            object class    implicitly associated with              │
  │                       implicitely associated    associated with source  │       refers to default    dir─object class(only one               │
  │                       with file─object─class    (g*user_t*) and default │     type (passwd_tmp_t)    that can contain files)                 │
  │                                                  types.                 │                                                                    │
  │ └───────────────────────────────────────────────────────────────────┘   │ └───────────────────────────────────────────────────┘              │
  │     ☝This rules means:                                                  │           ☝This rules means:                                       │
  │      """when a *oprocess* of type g*user_t* executes a                  │  """ when a process of type passwd_t creates an                    │
  │         file of type b*passwd_exec_t*, the process type                 │    ordinary file (file object class) in a directory of             │
  │         will attempt to transition, by default, to                      │    type tmp_t the file, by default, should have the                │
  │         *passwd_t* unless otherwise requested.  """                     │    type passwd_tmp_t if allowed by the policy. """                 │
  │                                                                         │  NOTICE:                                                           │
  │ Ex:                                                                     │                                                                    │
  │ *type_transition* g*init_t* b*apache_exec_t* :o*process* *apache_t*;    │  ─ AV rules must also allow the access for the default             │
  │                                                                         │    labeling to occur. (add_name, write, and search for             │
  │  allow g*init_t*  b*apache_exec_t*   : file    execute;                 │    directories of type tmp_t, and write and create for             │
  │  allow g*init_t*   *apache_t*        : process transition;              │    files of type passwd_tmp_t).                                    │
  │  allow  *apache_t*b*apache_exec_t*   : file    entrypoint;              │                                                                    │
  └─────────────────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────┘
</pre>
</td>
<td>
  Workflow
<pre zoom>
- Switch to permisive mode.
- Test new policy.
- Check violations in logs (See troubleshooting with audit2allow to produce new rules)
</pre>
</td>
 
<td>
  Compiling new policy:
<a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file">REF</a>

<pre zoom>
WARN: In some cases, you might need to update your policy to be compatible 
      with upstream SELinux policy changes. 

Tipical policy module (*.pp file) looks like:

localpolicy.pp 
*.te: type enforcement
*.fc: file contexts (optional)
*.if: interfaces (optional)


PRE-SETUP:
 $ sudo yum install -y selinux-policy-devel


<b>STEP 01: vim localpolicy.te:</b>

policy_module(localpolicy, 1.0)  ← localpolicy must match localpolicy.te prefix
gen_require(`                    ← backtick (`) denotes the start/end of the block 
  type user_t;                   ← gen_require block is used to "reuse"reference policy,
  type var_log_t;                  and will be translated during the make -f ... command 
')                                 earlier on towards SELinux rules. 

allow user_t var_log_t:dir { getattr search open read };

<b>STEP 02: create SELinux policy module localpolicy.pp:</b>
# sudo make -f /usr/share/selinux/devel/Makefile localpolicy.pp

                                                          ^must "match"
                                                           localpolicy.te prefix


<b>STEP 03: Load the file:</b>
# sudo setenforce permissive
# sudo semodule -i /path/to/localpolicy.pp  
WARN: semodule does NOT need "-P". Will remain loaded after reboots.
(to disable use # sudo semodule -d localpolicy)

# sudo 
</pre>
</td>
<td>
  <a href="http://blog.siphos.be/2015/07/restricting-even-root-access-to-a-folder/">Restricting root access to F.S.</a> 
<pre zoom>
(Date Sat 11 July 2015 By Sven Vermeulen Category SELinux)

- Ussually a policy grants some privileges to "root" users.

- Let's try to restrict root-access to a folder:

STEP 01:*Create new policy*restricting access to /etc/private:
 policy_module(myprivate, 1.0)
 
 type <b orange>etc_private_t</b>;                 ← type allowed to be used for files 
 fs_associate(<b orange>etc_private_t</b>)         ← associate with file system
                                       Do NOT use the files_type() interface
                                       as this would assign a set of attributes
                                       that many user roles get read access on.
  allow sysadm_t <b orange>etc_private_t</b>:{dir file} relabelto;  *1

 *1: sysadm_t is now allowed to change ctx to etc_private_t:
     - administrator can label resources as etc_private_t 
       without having read access to these resources afterwards.
       Also, as long as there are no relabelfrom privileges assigned,
       the administrator cannot revert the context back to a
       type that he has read access to:
       ~ sudo chcon -t <b orange>etc_private_t</b> /etc/private


STEP 02:
- Administrators can still disable SELinux controls. Ex:
  # cat /etc/private/README
  → cat: /etc/private/README: Permission denied
  # setenforce 0
  # cat /etc/private/README
  → Hello World!

To prevent this:
  # setsebool secure_mode_policyload on
              ^                      ^
          prevent any policy and SELinux state manipulation
          !!!including permissive mode!!!, but also including
          loading additional SELinux policies or changing booleans.
          (experiment with this setting without persisting (-P)

WARN: Admin cannot access /etc/private location directly,
        but he might be able to access it indirectly, remounting the
        (non-critical) system and remounting with the context= option,
        overriding file-level contexts.
WARN: Admin can still reboot the system in a mode where he
      can access the file system regardless of SELinux controls 
      bootin with enforcing=0, editing /etc/selinux/config, ....
WARN: Admin can still access the block device files on which the 
      resources are directly. Specialized tools can allow for 
      extracting files and directories without actually (re)mounting
      the device.

You can still un-grant users and/oradmins the permissions to reboot the system,
    (re)mount file systems, access block devices, etc. 
    without leaving behind the policy that is already active.
</pre>

  <a href="http://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/">Protecting CA priv.keys</a>
<pre zoom>
Ex CA script:

$ certcli.sh -r genfic                # Create a root CA key for "genfic"
$ certcli.sh -p genfic -c genfic-user # Create a subkey, signed by "genfic"
$ certcli.sh -p genfic-user           # Create a user certificate
   -R /var/db/ca/myUserId 
$ certcli.sh -p genfic-user \         # Sign a certificate
  -s /var/db/ca/requests/someUser.csr
$ certcli.sh -p genfic-user \         # Revoke a certificate
  -x myuser@genfic.com


CONTEXT TRANSITION:
-------------------
    ENTRYPOINT         DOMAIN         FILE TYPES
  → ca_cli_exec_t  →  ca_cli_t    →   ca_private_key_t (priv.keys)
                     (certcli.sh)     ca_misc_t        (certs, revo.list, serial,...)
                                      ca_misc_tmp_t    (temporal files)
    

ca.te:
| policy_module(ca, 1.0.0)
| 
| # CA management script and domain
| type ca_cli_exec_t;         # ENTRYPOINT
| type ca_cli_t;              # CA HANDLING DOMAIN
| domain_base_type(ca_cli_t)
| fs_associate(ca_cli_exec_t)  ← Making it through files_type() iface would
|                                would assign the `file_type` attribute to it,
|                                and other domains might have access to
|                                `file_type`. So all I do here is to allow the
|                                type `ca_cli_exec_t` to be associated on a
|                                file system.
|
|
| type ca_private_key_t;         # FILE TYPE FOR PRIV.KEYS
| fs_associate(ca_private_key_t)
| 
|
| type ca_misc_tmp_t;            # FILE TYPE FOR CERTS, REVOCATION LIST, SERIAL, ...
| fs_associate(ca_misc_tmp_t)
| fs_associate_tmpfs(ca_misc_tmp_t)
| 
|
| type ca_misc_t;                # FILE TYPE FOR TEMP. FILES
| fs_associate(ca_misc_t)
|
| # GRANT ca_cli_t PROPER ACCESS TO NEW TYPES {
| allow ca_cli_t ca_misc_t:dir create_dir_perms;          
| manage_files_pattern(ca_cli_t, ca_misc_t, ca_misc_t)     
| allow ca_cli_t ca_private_key_t:dir create_dir_perms;
| manage_files_pattern(ca_cli_t, ca_private_key_t, ca_private_key_t)
| # }
|
| - certcli.sh makes use of a directory '.../private',
|   so  proper rights to asign `ca_private_key_t` to dirs must be in place.
| - /private directory's parent dir is labeled as `ca_misc_t` to allow
|   file transitions.
| - SELinux policy will automatically assign the `ca_private_key_t`
|   type to a directory, created in a `ca_misc_t`  directory.
| -  if created by the `ca_cli_t` domain:
| 
| filetrans_pattern(ca_cli_t, ca_misc_t, ca_private_key_t, dir, "private")
| 
| # certcli.sh also requires the following permissions: {
| allow ca_cli_t self:fifo_file rw_fifo_file_perms;            ← Handling pipes between commands
| corecmd_exec_shell(ca_cli_t)                                 ← Shell script.
| corecmd_exec_bin(ca_cli_t)                                   ← allow to invoke regular binaries
| getty_use_fds(ca_cli_t) userdom_use_user_terminals(ca_cli_t) ← allow output on the screen
| # }
|
| allow ca_cli_t ca_cli_exec_t:file entrypoint;                      ← - mark `ca_cli_exec_t` as entrypoint for `ca_cli_t`.
| allow ca_cli_t ca_cli_exec_t:file { mmap_file_perms ioctl lock };      `ca_cli_t` domain can only be reached (transitioned to) 
|                                                                         through the execution of a `ca_cli_exec_t` file
|                                                                         `ca_cli_exec_t`:
|                                                                      - Normally, this is granted through 
|                                                                        application_domain(ca_cli_t, ca_cli_exec_t) but
|                                                                        this would also assign attributes we want to
|                                                                        explicitly prevent
|
|
|
| # ADD REQUIRED PERMISSION FOR certcli.sh CHILDREN PROCESSES
| #  (openssl) RUNNING IN ca_cli_t DOMAIN {
| kernel_read_system_state(ca_cli_t)  ← Read access on /proc files
| dev_read_rand(ca_cli_t)             ← Access to random devices
| dev_read_urand(ca_cli_t)            ← Regular files
| files_read_etc_files(ca_cli_t)
| miscfiles_read_localization(ca_cli_t)
| fs_getattr_tmpfs(ca_cli_t)          ← /tmp access
|
| files_tmp_filetrans(ca_cli_t, ca_misc_tmp_t, file) ←  when OpenSSL creates a file in `/tmp`
|                                                       it should immediately be assigned the
|                                                       `ca_misc_tmp_t` type
| # }
| # NOTE: At this point  the application should works fine
|
| An  ca_role() interface will be created to allow user domains 
| to use the CA script. Let's first create the ca_roles role attribute
| used by such interface: {
| attribute_role ca_roles; 
| role ca_roles types ca_cli_t;
| # }



NEXT: all that needed is to have an initial location marked as `ca_misc_t`
      For now, none of the users have the rights to do so, so I create
      three additional interfaces to be used against other user domains:


| allows to run the command                          | allows regular sysadmins rights to create ca_misc_t dirs | allow relabel *from* rights to change the 
|                                                    |                                                          | type of private keys to a regular file
|                                                    |                                                          | (if Linux allows it and the 
|                                                    |                                                          |  operation type goes to/from is allowed)
|                                                    |                                                          | This one should *only* be assigned to a
|                                                    |                                                          | rescue user (if any). 
|                                                    |                                                          | Also, this interface is allowed to label
|                                                    |                                                          | CA management scripts.
+----------------------------------------------------+----------------------------------------------------------+----------------------------------------------
| grant CA handling roles ca_role()                  |  ca_sysadmin(sysadm_t)                                   |  ca_admin(secadm_t) would only be granted on 
| ca_role(certadmin_r, certadmin_t)                  |  ca_sysadmin(setfiles_t)                                 |  the rescue/super-admin
+----------------------------------------------------+----------------------------------------------------------+----------------------------------------------
|                                                    |                                                          |
| interface(`ca_role','                              | interface(`ca_sysadmin',                                 | interface(`ca_admin',`
|   gen_require(`                                    |   gen_require( type ca_misc_t; type ca_private_key_t; )  |   gen_require(`
|     attribute_role ca_roles;                       |   # Allow the user relabel rights on ca_misc_t           |     type ca_misc_t, ca_private_key_t;
|     type ca_cli_t, ca_cli_exec_t;                  |   allow $1 ca_misc_t:dir relabel_dir_perms;              |     type ca_cli_exec_t;
|     type ca_misc_t;                                |   allow $1 ca_misc_t:file relabel_file_perms;            |   ')
|   ')                                               |   # Allow the user to label /to/ ca_private_key_t        | 
|                                                    |   # (but not vice versa)                                 |   allow $1 { ca_misc_t ca_private_key_t }:dir relabel_dir_perms;
|   # Allow the user role (like sysadm_r) the types  |   allow $1 ca_private_key_t:dir relabelto_dir_perms;     |   allow $1 { ca_misc_t ca_private_key_t }:file relabel_file_perms;
|   # granted to ca_roles                            |   allow $1 ca_private_key_t:file relabelto_file_perms;   | 
|   roleattribute $1 ca_roles;                       |   # Look at regular file/dir info                        |   allow $1 ca_cli_exec_t:file relabel_file_perms;
|                                                    |   allow $1 ca_misc_t:dir list_dir_perms;                 | ')
|   # Read the non-private key files and directories |   allow $1 ca_misc_t:file read_file_perms; '             
|   allow $2 ca_misc_t:dir  list_dir_perms;          | )                                                        
|   allow $2 ca_misc_t:file read_file_perms;         |                                                          
|                                                    | NOTE: The 'ca_sysadmin()' interface can also be assigned 
|   # Allow to transition to ca_cli_t by executing   |       to the `setfiles_t` command so that relabel        
|   # a ca_cli_exec_t file                           |       operations (and file system relabeling) works      
|   domtrans_pattern($2, ca_cli_exec_t, ca_cli_t)    |       correctly.                                         
|                                                    |
|   # Look at the process info                       |
|   ps_process_pattern($2, ca_cli_t)                 |
|                                                    |
|   # Output (and redirect) handling                 |
|   allow ca_cli_t $2:fd use;                        |
| ')                                                 |

  - application domains are granted through interface
    application_type(), application_domain() or
    even userdom_user_application_domain(). 
    Election depends on the privileges you want to grant on the domain,
    but also which existing privileges should also be applicable to
    the domain. 
  
  ????.if:
  
  | seshowif application_domain
  | 
  | interface(`application_type', 
  |   gen_require(`attribute application_domain_type;')
  | 
  |   typeattribute $1 application_domain_type;   ← associate attr. ($1 == ca_cli_t)
  | 
  |   # start with basic domain
  |   domain_type($1)                             ← assign lowest posible 'domain' attributes 
  |                                                 to handle certs ($1 == ca_cli_t)
  | 
  | ')
</pre>
</td>

<td>
  Who is Who
<pre zoom>
SELinux By Example  authors:
Frank Mayer is cofounder and Chief Technology Officer of 
Tresys Technology, and has 23 years of experience in the 
design, development, and analysis of secure operating 
systems. He has been an active contributor to SELinux for 
six years, and has initiated and participated in the 
development of many new SELinux innovations and tools. He 
also chairs the annual SELinux Symposium. Frank has 
published many papers on secure and trustworthy operating 
systems, and has also explored security in parallel 
computing, networks, and enterprise applications.


Karl MacMillan is an active contributor in the SELinux 
community and has led the development of many important 
SELinux features. He is also a sought after speaker and 
consultant, and has helped many individuals and 
organizations understand and apply strong computer 
security with SELinux. Previous to his work on SELinux, 
Karl made important contributions in the fields of 
pattern recognition and evolutionary computing as applied 
to document and audio recognition, where he has numerous 
published papers.

David Caplan is a senior security engineer at Tresys 
Technology with over 20 years of experience in computer 
security and a wide range of other programming- and 
software-related areas. He has worked with SELinux for 
six years as a contributor to many of the SELinux-related 
open source projects and has led multiple efforts in 
analyzing and constructing SELinux policy for a variety 
of systems.

Sven Vermeulen, author of SELinux Cookbook
</pre>


</td>
<td>
  <a href="https://github.com/TresysTechnology/setools/wiki">policy analysis tools</a>
<pre zoom>
|<a ____="                                    ">Tool Name   </a>| Use
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/apol"    >apol (GUI)  </a>| perform various types of analyses
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sediff"  >sediff      </a>| Compare two policies to find differences.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">sedta       </a>| Perform domain transition analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/seinfo"  >seinfo      </a>| List policy components.
|<t                                           />------------</t>|----------------------------------
|<a href="                                    ">seinfoflow  </a>| Perform information flow analyses.
|<t                                           />------------</t>|----------------------------------
|<a href="https://linux.die.net/man/1/sesearch">sesearch(8) </a>|policy query tool, Search rules (allow, type_transition, etc.)
|<t                                           />------------</t>|----------------------------------
</pre>
</td>


</table>

</body>


<!--
TODO_START: {
 SELinux    cached information on access-decisions via the Access Vector Cache (AVC)
________________________
<code TODO>system-config-selinux</code> (Gtk GUI for SELinux)
_________________________
https://docs.fedoraproject.org/en-US/Fedora/13/html/SELinux_FAQ/
______________________________
http://oss.tresys.com/
Projects hosted on GitHub:
  --------------------------
- SETools Policy Analysis Suite : SETools is a suite of open source tools that allow a policy developer or tester to perform detailed analysis and debugging of an SELinux policy
- Certifiable Linux Integration Platform (CLIP) : a toolkit for creating a secure computing environment suitable for hosting U.S. Government applications
- Reference Policy : makes it easier to maintain and apply baseline security policy for Security Enhanced Linux (SELinux)
_______________________________
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index
____________________________
https://debian-handbook.info/browse/en-US/stable/sect.selinux.html
____________________________
<td>
Multilevel Security (MLS)
<pre zoom>
~ ls -Z /etc/vsftpd/vsftpd.conf
-rw-------. root root system_u:object_r:etc_t:s0       /etc/vsftpd/vsftpd.conf

The sensitivity is part of the hierarchical multilevel security mechanism. By hierarchy, we mean the levels of sensitivity can go deeper and deeper for more secured content in the file system. Level 0 (depicted by s0) is the lowest sensitivity level, comparable to say, "public." There can be other sensitivity levels with higher s values: for example, internal, confidential, or regulatory can be depicted by s1, s2, and s3 respectively. This mapping is not stipulated by the policy: system administrators can configure what each sensitivity level mean.

When a SELinux enabled system uses MLS for its policy type (configured in the /etc/selinux/config file), it can mark certain files and processes with certain levels of sensitivity. The lowest level is called "current sensitivity" and the highest level is called "clearance sensitivity".

Going hand-in-hand with sensitivity is the category of the resource, depicted by c. Categories can be considered as labels assigned to a resource. Examples of categories can be department names, customer names, projects etc. The purpose of categorization is to further fine-tune access control. For example, you can mark certain files with confidential sensitivity for users from two different internal departments.

For SELinux security contexts, sensitivity and category work together when a category is implemented. When using a range of sensitivity levels, the format is to show sensitivity levels separated by a hyphen (for example, s0-s2). When using a category, a range is shown with a dot in between. Sensitivity and category values are separated by a colon (:).

Here is an example of sensitivity / category pair:

user_u:object_r:etc_t:s0:c0.c2  

There is only one sensitivity level here and that's s0. The category level could also be written as c0-c2.

So where do you assign your category levels? Let's find the details from the /etc/selinux/targeted/setrans.conf file:

cat /etc/selinux/targeted/setrans.conf

#
# Multi-Category Security translation table for SELinux
#
#
# Objects can be categorized with 0-1023 categories defined by the admin.
# Objects can be in more than one category at a time.
# Categories are stored in the system as c0-c1023.  Users can use this
# table to translate the categories into a more meaningful output.
# Examples:
# s0:c0=CompanyConfidential
# s0:c1=PatientRecord
# s0:c2=Unclassified
# s0:c3=TopSecret
# s0:c1,c3=CompanyConfidentialRedHat
s0=SystemLow
s0-s0:c0.c1023=SystemLow-SystemHigh
s0:c0.c1023=SystemHigh

We won't go into the details of sensitivities and categories here. Just know that a process is allowed read access to a resource only when its sensitivity and category level is higher than that of the resource (i.e. the process domain dominates the resource type). The process can write to the resource when its sensitivity/category level is less than that of the resource.
Conclusion

We have tried to cover a broad topic on Linux security in the short span of this three-part-series. If we look at our system now, we have a simple Apache web server installed with its content being served from a custom directory. We also have an FTP daemon running in our server. There were a few users created whose access have been restricted. As we went along, we used SELinux packages, files, and commands to cater to our security needs. Along the way we also learned how to look at SELinux error messages and make sense of them.

Entire books have been written on the SELinux topic and you can spend hours trying to figure out different packages, configuration files, commands, and their effects on security. So where do you go from here?

One thing I would do is caution you not to test anything on a production system. Once you have mastered the basics, start playing with SELinux by enabling it on a test replica of your production box. Make sure the audit daemons are running and keep an eye on the error messages. Check any denials preventing services from starting. Play around with the boolean settings. Make a list of possible steps for securing your system, like creating new users mapped to least-privilged SELinux accounts or applying the right context to non-standard file locations. Understand how to decipher an error log. Check the ports for various daemons: if non-standard ports are used, make sure they are correctly assigned to the policy.

It will all come together with time and practice. :)
</pre>
</td>
___________________________
 As processes and objects are created and destroyed, they either:
1.  Inherit their labels from the parent process or object.
2.  The policy type, role and range transition statements allow a different label to
     be assigned as discussed in the Domain and Object Transitions section.
3.  SELinux-aware   applications   can   enforce   a   new   label   
    (with   the   policies approval of course) using the libselinux API functions.
4.  An object manager (OM) can enforce a default label that can either be built
    into the OM or obtained via a configuration file (such as those used by X-Windows).
5.  Use an 'initial security identifier' (or initial SID). These are defined in all 
    base and monolithic policies and are used to either set an initial context during the
    boot process, or if an object requires a default (i.e. the object does not already
    have a valid context).


The labeling of file systems that implement extended attributes
is supported by SELinux using:
1.  The  fs_use_xattr statement   within   the   policy   to   identify   what   file
  systems use extended attributes. This statement is used to inform the security
  server how to label the filesystem.
2.  A 'file contexts' file that defines what the initial contexts should be for each
   file and directory within the filesystem. The format of this file is described in
   the modules/active/file_contexts.template file section.
3.  A method to initialise the filesystem with these extended attributes. This is
   achieved by SELinux utilities such as fixfiles(8) and setfiles(8) .
   There   are   also   commands   such   as  chcon(1),  restorecon(8) and
   restorecond(8) that can be used to relabel files

______________________________________
<a href="https://www.youtube.com/watch?v=MxjenQ31b70&t=2790s">SELinux for mere mortals</a>
______________
   Preserve context in file copy
<pre zoom >
#~ cp <b>--preserver=context</b> /var/www/html/index.html ~/html
(context is preserved with "mv")
</pre>
___________________
TODO: Add attributes notes: (How to avoid duplacting rules for different convinations
 of types)
https://www.safaribooksonline.com/library/view/selinux-by-example/0131963694/ch05.html#ch05
}
_____________________
http://oss.tresys.com/archive/slide.php
Tresys IDE:
SELinux Policy IDE (SLIDE) is an integrated development environment for 
SELinux developed by Tresys Technology. Some basic features of SLIDE include:

    Graphical user interface for policy development
    Integration with Reference Policy
    Project creation wizards
    Auto-completion of interface names
    Policy syntax highlighting
    Easily compile and build module packages
    Hook into standard Eclipse search
    Basic refactoring features including adding and removing ifdef, optional and tunable blocks
    Integrated remote policy installation and audit log monitoring 
______________________
https://github.com/mairin/selinux-coloring-book
______________________
--SE aware Process API ------  
setcon(3)                      
getcon(3)                      
getpidcon(3)                   
getpidcon(3)                   
_____________________
  command line      
  management        
   ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓  
← semanage fcontext  
                     
← semanage port│node 
← semanage login     
← semanage user      
          ...        

 Role Based Access Control:    
 ─ SELinux users are associated
   to one or more roles,       
 ─ each role may be associated 
   to one or more Domain types.
 ─ Note: SElinux users are not 
   normal linux users: Most    
   users are mapped to a single
   SELinux user.               
__________________________________
checkpolicy(8)           policy compiler generating kernel       
                         loadable version. Can be used to debug  
                         a policy in that it can mimimc some of  
                         the capabilities of the SEL sec.server. 

load_policy(8)           load policy into the kernel. 
                         In enforcing mode, it must be run in a
                         domain with load_policy permissions.
____________________
$ sudo dnf install setools-console 
$ dnf repoquery -l setools-console
...
/usr/bin/*sediff*
/usr/bin/*seinfo*
/usr/bin/*sesearch*
/usr/share/man/man1/sediff.1.gz
/usr/share/man/man1/seinfo.1.gz
/usr/share/man/man1/seinfoflow.1.gz
/usr/share/man/man1/sesearch.1.gz
____________________

  Computing SE context output
<pre zoom>
The table shows how the components from the source context scon, target context tcon and class tclass are used to compute the new context newcon (referenced by SIDs for  avc_compute_create(3)).
<b>avc_compute_create and security_compute_create</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | IF there is a valid role_transition rule THEN | IF there is a valid type_transition rule THEN | IF there is a valid range_transition rule THEN
  use tcon user                         |    use the rules new_role                     |   use the rules default_type                  |   use the rules new_range
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source low rule THEN
  use scon user                         |    use scon role                              |   use scon type                               |   use scon low
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source high rule THEN 
                                        |    use tcon role                              |   use tcon type                               |   use scon high
                                        | OR IF tclass is process or *socket  THEN      | OR IF tclass is process or *socket THEN       | OR IF default_range tclass source low_high rule THEN
                                        |    use scon role                              |   use scon type                               |   use scon range
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target low rule THEN 
                                        |    Use object_r                               |   use tcon type                               |   use tcon low
                                                                                                                                        | OR IF default_range tclass target high rule THEN
                                                                                                                                        |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   use scon low
_______________________________________________________________________________________________________________________________________________________________________________________________
<b>avc_compute_member and security_compute_member</b>
USER                                    | ROLE                                          | TYPE                                          | RANGE
----------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------------
                                        |                                               |                                               | 
IF default_user tclass target rule THEN | If there is a valid role_transition rule THEN | If there is a valid type_transition rule THEN | If default_range tclass source low rule THEN
  use tcon user                         |   use the rules new_role                      |   use the rules default_type                  |   use scon low
ELSE                                    | OR IF default_role tclass source rule THEN    | OR IF default_type tclass source rule THEN    | OR IF default_range tclass source high rule THEN 
  Use scon user                         |   use scon role                               |   use scon type                               |   use scon high
                                        | OR IF default_role tclass target rule THEN    | OR IF default_type tclass target rule THEN    | OR IF default_range tclass source low_high rule THEN
                                        |   use tcon role                               |   use tcon type                               |   use scon range
                                        | OR IF tclass is process or *socket , THEN     | OR IF tclass is process or *socket , THEN     | OR IF default_range tclass target low rule THEN
                                        |   use scon role                               |   use scon type                               |   use tcon low
                                        | ELSE                                          | ELSE                                          | OR IF default_range tclass target high rule THEN
                                        |   Use object_r                                |   use tcon type                               |   use tcon high
                                                                                                                                        | OR IF default_range tclass target low_high rule THEN
                                                                                                                                        |   use tcon range
                                                                                                                                        | OR IF tclass is process or *socket , THEN
                                                                                                                                        |   use scon range
                                                                                                                                        | ELSE
                                                                                                                                        |   Use scon low
</pre>

-->

</html>
