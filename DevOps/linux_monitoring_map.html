<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Linux Monitoring Map <!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>

<table style='width:100%'{>
<tbody>
<td>
  <span TODO>TODO</span>
  <ul xxxsmall zoom>
  <li><a href="http://en.wikipedia.org/wiki/LTTng">LTTng</a></li>
  <li><a href="http://www.cyberciti.biz/tips/top-linux-monitoring-tools.html">top-linux-monitoring-tools</a></li>
  <li>Nagios</li>
  <li><a href="http://linux-mm.org/">Linux MM</a></li>
  <li><a hre="http://venturebeat.com/2015/03/12/mozilla-releases-open-source-memory-scanning-technology-for-servers-not-brains/">Mozilla Memory Scanning</a>
""" Mozilla just announced a new security technology that will let you look into your server’s memory processes and it’s called Masche.  As you’d expect the code is open-source.  The tool scans memory processes, while allowing for normal unabated operations. Masche acts as a complement to Mozilla’s existing digital forensics and threat response platform Mozilla InvestiGator or MIG. The platform views information from thousands of hosts simultaneously, but cannot see into memory processes.  Masche’s technology makes up for this handicap. Mozilla says that while Masche provides fast memory scans, it doesn’t offer advanced forensic features, like Volatility or Rekall (two advanced forensics frameworks)."
"""
</li>
  <li><a href="https://code.google.com/p/volatility/">Google Volatility</a>
We moved to github.com/volatilityfoundation. For new releases also see Volatility Framework 2.4 Volatility supports memory dumps from all major 32- and 64-bit Windows versions and service packs including XP, 2003 Server, Vista, Server 2008, Server 2008 R2, Seven, 8, 8.1, Server 2012, and 2012 R2.  Whether your memory dump is in raw format, a Microsoft crash dump, hibernation file, or virtual machine snapshot, Volatility is able to work with it. We also now support Linux memory dumps in raw or LiME format and include 35+ plugins for analyzing 32- and 64-bit Linux kernels from 2.6.11 - 3.16 and distributions such as Debian, Ubuntu, OpenSuSE, Fedora, CentOS, and Mandrake. We support 38 versions of Mac OSX memory dumps from 10.5 to 10.9.4 Mavericks, both 32- and 64-bit.  Android phones with ARM processors are also supported.  "
</li>
  <li><a href="http://www.serverwatch.com/server-news/linuxcon-how-facebook-monitors-hundreds-of-thousands-of-servers-with-netconsole.html">How Facebook Monitors Hundreds of Thousands of Servers with Netconsole </a><br/>

"""""" He added that Facebook had a system in the past for monitoring
that used syslog-ng, but it was less than 60 percent reliable. 
In contrast, Owens stated netconsole is highly scalable and can 
handle enormous log volume with greater than 99.99 percent 
reliability.  """""""
</li>
  <li><a href="https://www.tecmint.com/bcc-best-linux-performance-monitoring-tools/">BCC – Dynamic Tracing Tools for Linux Performance Monitoring, Networking and More</a>
filetop, filelife, fileslower, vfscount, vfsstat, cachestat, dcstat, ...
</li>
  </ul>
  <a href="http://ls.pwd.io/2013/06/linux-monitoring-tools/">
   Standard Linux Monitoring Tools</a>
<pre xxxsmall zoom>
strace
netstat
perf
top / htop / iotop strace / lsof
   + (non-standard) nmon: "advanced htop": allows, amongst others, to visualize kernel context switches and interruptions per second
pidstat
mpstat
dstat
perf
vmstat
slabtop
dstat
free
...
</li>

</pre>


</td>
<td>
  <a href="https://sysdig.com/opensource/sysdig/">SysDig (ps and Container monitoring)</a>
<pre xxxsmall zoom>
  <a href="http://xmodulo.com/monitor-troubleshoot-linux-server-sysdig.html">How to monitor and troubleshoot a Linux server using sysdig</a>
Last updated on October 13, 2014 Authored by Gabriel Cánepa 
What is the first thing that comes to mind when you need to track system calls made and received by a process? 
You'll probably think of strace, and you are right. What tool would you use to monitor raw network traffic from the command line? 
If you thought about tcpdump, you made an excellent choice again. And if you ever run into the need to having to keep track of open files
(in the Unix sense of the word: everything is a file), chances are you'll use lsof.

strace, tcpdump, and lsof are indeed great utilities that should be part of every sysadmin's toolset, and that is precisely the reason why you
will love sysdig, a powerful open source tool for system-level exploration and troubleshooting, introduced by its creators as ""strace + tcpdump + lsof + awesome 
sauce with a little Lua cherry on top."" Humor aside, one of the great features of sysdig resides in its ability not only to analyze the ""live"" state of a Linux system, 
but also to save the state in a dump file for offline inspection. What's more, you can customize sysdig's behavior or even enhance its capabilities by using built-in
 (or writing your own) small scripts called chisels. Individual chisels are used to analyze sysdig-captured event streams in various script-specific fashions.
"   
"In this tutorial we'll explore the installation and basic usage of sysdig to perform system monitoring and troubleshooting on Linux.

Installing Sysdig
For this tutorial, we will choose to use the automatic installation process described in the official website for the sake of simplicity, brevity, and
distribution agnosticity. In the automatic process, the installation script automatically detects the operating system and installs all the necessary dependencies.

Run the following command as root to install sysdig from the official apt/yum repository:
# curl -s https://s3.amazonaws.com/download.draios.com/stable/install-sysdig | bash

Once the installation is complete, we can invoke sysdig as follows to get a feel for it:
# sysdig
Our screen will be immediately filled with all that is going on in our system, not allowing us to do much more with that information. For that reason, we will run:

# sysdig -cl | less
to see a list of available chisels. The following categories are available by default, each of which is populated by multiple built-in chisels.
CPU Usage, Errors, I/O, Logs, Misc, Net, Performance, Security, System State, 
"   
"
To display information (including detailed command-line usage) on a particular chisel, run:
# sysdig -cl [chisel_name]
For example, we can check information about spy_port chisel under ""Net"" category by running:
# sysdig -i spy_port

Chisels can be combined with filters (which can be applied to both live data or a trace file) to obtain more useful output.

Filters follow a ""class.field"" structure. For example:

fd.cip: client IP address.
evt.dir: event direction can be either '>' for enter events or '<' for exit events.
The complete filter list can be displayed with:

# sysdig -l
In the rest of the tutorial, I will demonstrate several use cases of sysdig.

Sysdig Example: Troubleshooting Server Performance
Suppose your server is experiencing performance issues (e.g., unresponsiveness or significant delays in responding). You can use the bottlenecks chisel
to display a list of the 10 slowest systems calls at the moment.
 
"   
"Use the following command to check up on a live server in real time. The ""-c"" flag followed by a chisel name tells sysdig to run the specified chisel.

# sysdig -c bottlenecks
Alternatively, you can conduct a server performance analysis offline. In that case, you can save a complete sysdig trace to a file, and run the bottlenecks chisel against the trace as follows.

First, save a sysdig trace (use Ctrl+c to stop the collection):

# sysdig -w trace.scap
Once the trace is collected, you can check the slowest systems calls that were performed during the capture interval by running:

# sysdig -r trace.scap -c bottlenecks


You want to pay attention fo columns #2, #3, and #4, which indicate execution time, process name, and PID, respectively.

Sysdig Example: Monitoring Interactive User Activities
Suppose you as a sysadmin want to monitor interactive user activities in a system (e.g., what command a user typed from the command line, 
and what directories the user went to). That is when spy_user chisel comes in handy.

Let's first collect a sysdig trace with a couple of extra options.

# sysdig -s 4096 -z -w /mnt/sysdig/$(hostname).scap.gz
""-s 4096"" tells sysdig to capture up to 4096 bytes of each event.
""-z"" (used with ""-w"") enables compression for a trace file.
""-w <trace-file>"" saves sysdig traces to a specified file.
In the above, we customize the name of the compressed trace file on a per-host basis. Remember that you can interrupt the execution of sysdig at any 
moment by pressing Ctrl + c.

Once we've collected a reasonable amount of data, we can view interactive activities of every user in a system by running:

# sysdig -r /mnt/sysdig/debian.scap.gz -c spy_users


The first column in the above output indicates the PID of the process associated with a given user's activity.

What if you want to target a specific user, and monitor the user's activities only? You can filter the results of the spy_users chisel by username:

# sysdig -r /mnt/sysdig/debian.scap.gz -c spy_users ""user.name=xmodulo""


Sysdig Example: Monitoring File I/O
We can customize the output format of sysdig traces with ""-p"" flag, and indicate desired fields (e.g., user name, process name, and file or socket name) 
enclosed inside double quotes. In this example, we will create a trace file that will only contain writing events in home directories (which we can inspect later with ""sysdig -r writetrace.scap.gz"").

# sysdig -p ""%user.name %proc.name %fd.name"" ""evt.type=write and fd.name contains /home/"" -z -w writetrace.scap.gz


Sysdig Example: Monitoring Network I/O
As part of server troubleshooting, you may want to snoop on network traffic, which is typically done with tcpdump. With sysdig, traffic sniffing can be done as easily, but in more user friendly fashions.

For example, you can inspect data (in ASCII) that has been exchanged with a particular IP address, served by a particular process (e.g., apache2):

# sysdig -s 4096 -A -c echo_fds fd.cip=192.168.0.100 -r /mnt/sysdig/debian.scap.gz proc.name=apache2
If you want to monitor raw data transfer (in binary) instead, replace ""-A"" with ""-X"":

# sysdig -s 4096 -X -c echo_fds fd.cip=192.168.0.100 -r /mnt/sysdig/debian.scap.gz proc.name=apache2
For more information, examples, and case studies, you can check out the project website. Believe me, the possibilities are limitless. But don't just take my word for it.
 Install sysdig and start digging today!
</pre>
</td>
<td>
  <a href="https://mmonit.com/monit/">Monit:</a><br/>(Service Monitoring)
  <ul xxxsmall zoom>
  <li>With all features needed for system monitoring and error recovery. It's like 
  <li>How to install Monit and monitor the performance of your linux server:
  https://techarena51.com/blog/how-to-install-monit-monitoring-service-on-your-linux-vps-server/?utm_source=devopswiki</li>
having a watchdog with a toolbox on your server</li>
  </ul>
</td>
<td>
 <a href="http://collectl.sourceforge.net/">Collectl</a>
  <ul xxxsmall zoom>
  <li>Collect:Unlike most monitoring tools that either focus on a small set of statistics, format their output in only one way, run either interatively or as a daemon but not both, collectl tries to do it all. You can choose to monitor any of a broad set of subsystems which currently include buddyinfo, cpu, disk, inodes, infiniband, lustre, memory, network, nfs, processes, quadrics, slabs, sockets and tcp.     
</li>
  </ul>
</td>

</tr>
</table>

<table>
<tr>

<td>
  Memory Monitoring
<pre xxxsmall zoom>
sudo slabtop

"Ref: http://xmodulo.com/visualize-memory-usage-linux.html
In the presence of virtual memory abstraction, accurately quantifying physical memory usage of a process is actually 
not straightforward.  
The virtual memory size of a process is not meaningful because it does not tell how much of it is actually allocated
 physical memory.
Resident set size (RSS), reported by top command, is one 
popular metric which captures what portion of a process' reported memory is residing in RAM.  However, aggregating RSS
 of existing processes can easily overestimate the overall 
physical memory usage of the Linux system because the same 
physical memory page can be shared by different processes.  

Proportional set size (PSS) is a more accurate measurement of
 effective memory usage of Linux processes since PSS properly
 discounts the memory page shared by more than one process.
  Unique set size (USS) of a process is a subset of the 
process' PSS, which is not shared by any other processes.

The command-line tool smem can generate a variety of reports 
related to memory PSS/USS usage by pulling information from 
/proc.  It comes with built-in graphical chart generation 
capabilities
Install:
Debian/Ubuntu:
  $ sudo apt-get install smem
Mint:
  $ sudo apt-get install smem python-matplotlib python-tk
Fedora or CentOS/RHEL:
Step 1: enable EPEL repository first.
Step 2: $ sudo yum install smem python-matplotlib

Check Memory Usage with Smem
When you run smem as a unprivileged user, it will report physical memory usage of every process launched by the current user, in an increasing order of PSS.

If you want to check the overall system memory usage for all users, run smem as the root:
$ sudo smem

To view per-user memory usage:
$ sudo smem -u
</pre>
</td>
<td>
  Process Monitoring
  <ul xxxsmall zoom>
  <li>/proc/"PID"/*</li>
  <li>http://www.linux-magazine.com/Online/News/Timechart-Zoom-in-on-Operating-System
   Intel developer Arjan van de Ven is working on a new tool named Timechart that records Linux system performance in detailed graphics.

Van de Ven, who also worked on the energy-saving tool Powertop, wants to enhance tools such as Oprofile, LatencyTOP and Perf with Timechart. The new program provides graphical results, reminiscent of Bootchart, in fact going beyond the boot process analysis tool used as its model by tying in all the other processes on the system.
The Timechart analysis tool outputs graphics in SVG format in this release that can put programs such as Inkscape almost literally under the microscope.

Timechart renders graphics using the SVG vector format and the developer recommends using Inkscape to view the output, which in van de Ven's terms makes them "infinitely zoomable." Easily identifiable graphically are, for example, operating sytem details such as the waiting process for the scheduler -- a contribution the Intel developer can make to the current discussion about schedulers on the kernel mailing list.

Timechart also diagnoses the results of power management settings. The program supports multiprocessor machines. Further details are in van de Ven's blog entry, where he interprets some of the graphical results. The source code is currently posted as patches on the linux-kernel mailing list. A downloadable and installable version is not yet available because of changes still to be made to the kernel infrastructure to make Timechart work.

Timechart developer van de Ven still has some misgivings about the program's name and is thus looking for suggestions in his blog.

  </li>
  </ul>


  Shared Library management
  <ul xxxsmall zoom>
  <li>"Linux Commands For Shared Library Management & Debugging Problems:
    http://www.cyberciti.biz/tips/linux-shared-library-management.html"</li>
  </ul>
</td>

<td>
  Network Monitoring
  <ul xxxsmall zoom>
  <li>
<pre>
Nethogs is a command line utility for linux that displays the network
 bandwidth used by each application or process in realtime. It is useful
 in situations when a certain process uses up too much of the bandwidth 
and needs to be caught

$ sudo nethogs
...
  PID USER     PROGRAM                      DEV        SENT      RECEIVED       
2367  enlighten/opt/google/chrome/chrome    eth0       3.341      20.948 KB/sec
2196  enlighten/usr/lib/firefox-7.0.1/fire  eth0       0.871       0.422 KB/sec
3723  enlighten/usr/bin/pidgin              eth0       0.028       0.098 KB/sec
2206  enlighten/usr/bin/skype               eth0       0.033       0.025 KB/sec
2380  enlighten/usr/lib/chromium-browser/c  eth0       0.000       0.000 KB/sec
0     root     unknown TCP                             0.000       0.000 KB/sec

  TOTAL                                                4.274      21.493 KB/sec"
</pre>
</li>
  <li>
<pre>
sudo netstat -ntlp
</pre>
  </li>
  <li>nettop</li>
  <li>
<pre>
* vnstat: se ejecuta como servicio o mediante tareas programadas, su ventaja es  que es útil para controlar en tiempo real el tráfico enviado y recibido y también hacerlo en un periodo de tiempo. Una de mis favoritas, está  paquetizada en casi todas las distribuciones.
iptraf: al igual que la anterior es un clásico, se caracteriza por su interfaz ncurses desde el que se configura interactivamente. Ampliamente  distribuida.
iftop: últimamente es una de la que más veo usar. Trata de ser el 'top' de cpu para las conexiones de red. Su interfaz es sencilla y se incluye en la  gran mayoría de distribuciones. Otra indispensable.
bwm-ng: es más simple que otras herramientas similares, su gran ventaja es que además de funcionar en modo interactivo, permite exportar la salida a un archivo CSV o html

ibmonitor: en concepto es parecida a bwm-ng o vnstat, muestra el tráfico total por interfaz, tanto el enviado como el recibido.

nload: herramienta interactiva que muestra el consumo acumulado y además dibuja en modo texto gráficas (en ASCII claro).

dstat: tiene formato similar a los conocidos iostat, vmstat con soporte de colores. Está incluida en múltiples distribuciones.

tcptrack: aplicación que muestra el consumo por conexión. No está tan extendida como otras. herramientas similares.

ipband: también orientado a obtener datos por conexión. 

speedometer: más gráficas en ASCII para ver el tráfico en grandes números, permite obtener estadísticas de velocidad en la red."
</pre>
  </li>
  </ul>
</td>
<td>
  File System Monitoring
  <ul xxxsmall zoom>
  <li>File Integrity Monitoring at scale: (RSA Conf)
    https://www.rsaconference.com/writable/presentations/file_upload/csv-r14-fim-and-system-call-auditing-at-scale-in-a-large-container-deployment.pdf
  </li>
  </ul>

</td>


</tr>
</table>

<table>
<tr>
<td>
  Kernel monitoring/debugging
  <ul xxxsmall zoom>
  <li>Ftrace
<pre>
Debugging the kernel with ftrace:1  http://lwn.net/Articles/365835/
Debugging the kernel with ftrace:2  http://lwn.net/Articles/366796/
Debugging the kernel with ftrace:3  http://lwn.net/Articles/370423/
<pre>
  </li>
  <li>Linux input ecosystem   http://joeshaw.org/2010/10/01/681</li>
  <li>ptrace, uditd, dTrace, OProfile or SystemTap, audtctl</li>
  <li>Systemtap/Dtrace/LTTng/perf Comparison:  http://sourceware.org/systemtap/wiki/SystemtapDtraceComparison</li>
  <li>"http://people.redhat.com/srostedt/kernelshark/HTML/:
KernelShark is a front end reader of trace-cmd(1) output. ""trace-cmd record"" and ""trace-cmd extract"" create
a trace.dat (trace-cmd.dat(5)) file. kernelshark can read this file and produce a graph and list view of its data."
  </li>
  </ul>
</td>
<td>
  <a href="https://sourceware.org/systemtap/">SystemTap Kernel Monit</a>
  <ul xxxsmall zoom>
  <li>Eclipse SystemTap Integration
   https://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.linuxtools.docker.docs%2FLinux_Tools_Project%2FDocker_Tooling%2FUser_Guide%2FUser-Guide.html&cp=15_0
</li>
  <li>https://sourceware.org/systemtap/tutorial/</li>
  <li>http://phoronix.com/scan.php?page=news_item&px=SystemTap-3.0-Released
https://sourceware.org/ml/systemtap/2016-q1/msg00179.html</li>
  <li>SystemTap, a DTrace-like means of dynamically profiling Linux with a scripting language and tool, is out with version 3.0.
    SystemTap 3.0 was announced on Sunday and it ships with experimental monitor and interactive modes, 
    optimized associative arrays, function overloading, new scripting samples, scripting language changes, and more.
</li>
  </ul>
</td>


<td>
Monitoring uninterruptible (blocking) system calls.
<pre xxxsmall zoom>
KISS script to list any process that could have trouble beeing blocked by an uninterruptible system call.

# while true; do ps -e fo stat,cmd | grep ^D && echo "-------"; sleep 0.1 ; done

D<    \_ [scsi_eh_0]
D         \_ hald-addon-storage: polling /dev/sr0 (every 2 sec)
-------
D         \_ hald-addon-storage: polling /dev/sr0 (every 2 sec)
-------
D<    \_ [md0_raid1]
D<    \_ [kjournald]
-------
D<    \_ [md0_raid1]
-------
D<    \_ [md0_raid1]
-------
D<    \_ [md0_raid1]
The output in this case is normal [md0_raid1],kjournald and syslogd are making frequent disk writes.
</pre>
</td>
</tr>
</table>

</body>
<!--
TODO_START:



    ____________________________
"apt-cache show psmisc
Package: psmisc
Priority: optional
Section: admin
Installed-Size: 688
Maintainer: Craig Small <csmall@debian.org>
Architecture: amd64
Version: 22.11-1
Replaces: procps (<< 1:1.2)
Depends: libc6 (>= 2.7), libncurses5 (>= 5.7+20100313)
Filename: pool/main/p/psmisc/psmisc_22.11-1_amd64.deb
Size: 118940
MD5sum: c617da8fd211a70f1ac932075706f85e
SHA1: 2b982d51635ab7f4ed08ae31757ca8eb248646cb
SHA256: 74664bf4045d473c1448d9f319ad356eac60a4ab5b0a68ab78efc197323b3073
Description: utilities that use the proc file system
 This package contains miscellaneous utilities that use the proc FS:
 .
  - fuser: identifies processes that are using files or sockets.
  - killall: kills processes by name (e.g. ""killall -HUP named"").
  - peekfd: shows the data traveling over a file descriptor.
  - pstree: shows currently running processes as a tree.
  - prtstat: print the contents of /proc/<pid>/stat
Homepage: http://psmisc.sf.net/
    ____________________________
"Ex:
~# netstat -ntlp | grep ssh
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1031/sshd       
~# peekfd -8 -c 1031"
    ____________________________
"Dump process memory in real time:
http://www.forensicswiki.org/wiki/Tools%3aMemory_Imaging#Linux"
}}}
_______________________________
File System: {{{
"inotifywatch(1) inotifywait(1) dnotify(1)"
df -kh,  du -sch *
lsof 
    ____________________________
"http://www.linuxask.com/questions/how-to-check-if-a-file-is-locked-in-linux:
Suppose a file test.txt is being locked by a program, e.g. using the flock system call, how can we know if this file is really being locked?

# lsof test.txt
COMMAND  PID USER   FD   TYPE DEVICE SIZE   NODE NAME
perl    5654 john 3uW  REG    8,1    1 983057 test.txt

The W means the file is currently held by an exclusive lock. You can find more information in the link below:

http://linux.die.net/man/2/flock"
    ____________________________
"SRC: http://unix.stackexchange.com/questions/22120/how-to-trace-file-locks-per-directory
How to trace file locks (per directory):
Make sure that the auditd daemon is started, then use auditctl to configure what you want to log. For ordinary filesystem accesses, you would do:

auditctl -w /path/to/directory
auditctl -a exit,always -S fnctl -S open -S flock -F dir=/path/to/directory

The -S option can be used to restrict the logging to specific syscalls. The logs appear in /var/log/audit/audit.log on Debian, and probably on Fedora as well."   
    ____________________________
}}}
_______________________________
Hardware Monitoring: {{{
    PowerTOP
    udev
    lsusb
    lspci
    hwinfo: http://www.binarytides.com/linux-hwinfo-command/
}}}
_______________________________


_ A tour of the Linux Graphics Stack  http://cworth.org/talks/lca_2009/html/lca-2009-001.html
_  IPv6 in Linux  http://linuxdevices.com/articles/AT7843301253.html
_ 10 things you should know about IPv6    http://blogs.techrepublic.com.com/10things/?p=1893
_ RedHat documentation    http://docs.redhat.com/docs/en-US/index.html
_     Magic SysRq key - Wikipedia http://en.wikipedia.org/wiki/Magic_SysRq_key
_ Linux Tips: Limiting the CPU usage of applications on Linux http://blog.dipinkrishna.info/2009/07/limiting-cpu-usage-of-applications-on.html 
_ Advanced Routing&Traff.Control (Francés)    http://www.linux-france.org/prj/inetdoc/guides/Advanced-routing-Howto/
_ TODO ConsoleKit 0.4.1 Documentation http://www.freedesktop.org/software/ConsoleKit/doc/ConsoleKit.html
_ KernelNewbies.org/ un proyecto social ideado para ayudad a la gente a aprender cómo funciona el núcleo de un sistema operativo. http://www.kernelnewbies.org/
_ Correo muy intesante "quejandose" de las diferentes soluciones de sistemas de fichero Cluster   http://zgp.org/linux-tists/20040101205016.E5998@shaitan.lightconsulting.com.html"
_ Soluciones Open Source de Computer Associated (CA)  http://www.ca.com/technologies/subsolution.jsp?id=4900
_ Circle ID: Revista de informática y telecomunicaciones muy interesante  http://www.circleid.com/
_ JAM is a software build tool that makes building simple things simple and building complicated things manageable.   http://www.perforce.com/jam/jam.html
_ The open sharedroot project provides abilities to boot multiple linux systems with the same root filesystem providing a single system filesystem based cluster. (NFS, GFS,...)  http://fedoraproject.org/wiki/Features/Opensharedroot
_ Using TCT To Recover Lost Data On Linux Or Unix http://linuxshellaccount.blogspot.com/2009/05/using-tct-to-recover-lost-data-on-linux.html
_ Introducing TimeChart   http://blog.fenrus.org/?p=5
_ Unetbotin: Arranque de Linux desde USB  http://www.howtoforge.com/creating-usb-startup-disks-from-various-linux-distributions-with-unetbootin
_     
_     
_     
_______________________
Magic SysRq key - Wikipedia http://en.wikipedia.org/wiki/Magic_SysRq_key
__________________
Linux Tips: Limiting the CPU usage of applications on Linux http://blog.dipinkrishna.info/2009/07/limiting-cpu-usage-of-applications-on.html 

 Circle ID: Revista de informática y telecomunicaciones muy interesante  http://www.circleid.com/
______________________________
[profiling][debugging][throubleshooting]
Offline analysis of complex issues

    Real-time deadline investigation
    Latency analysis
    Log correlation with operating system traces
    Network packet correlation accross layers
    Identification of relevant information in large amounts of trace data
    Causes of high processor usage and memory leaks
    Correlation of hardware and software components execution traces
    Symbol name resolution using debug information
    Additional analyses available with the Trace Compass Incubator
    ...


Multiple trace formats supported
    Common Trace Format (CTF), including but not limited to:
        Linux LTTng kernel traces
        Linux LTTng-UST userspace traces
        Linux Perf traces converted to CTF
        Bare metal traces
        Integration with the LTTng-Analyses scripts
    Hardware traces (e.g. IEEE Nexus 5001 CTF conversion). See also this link.
    GDB traces for debugging
    The Best Trace Format (BTF) for OSEK
    The libpcap (Packet CAPture) format, for network traces
    Custom text or XML parsers that can be added right from the graphical interface by the user
    Can be extended to support various log or trace files.
    Provided by the TraceCompass Incubator:
        Linux FTrace raw textual format
        Google's trace event json format
        Additional Linux Perf2ctf traces features
        Android traces
        UFtrace format

For more information, see the Trace Compass datasheet. 
__________________________________________


</html>
