<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Shell Script map <!-- ignore --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>
<div groupv>
<pre zoom>
<span xsmall>Init Vars</span>
complete Shell parameter expansion list available at:
- @[http://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html]
var1=$1 # init var $1 with first param 
var1=$# # init var $1 with number of params
var1=${parameter:-word} # init $var1 with $parameter value or 'word'(or word expansion) if parameter unset or null
var1=${parameter:=word} # init $var1 with $parameter value or 'word'(or word expansion) if parameter unset or null. Also asign word to $parameter
var1=${parameter:?word} # If parameter is null/unset word (or word expansion) is written to the STDERR and exits.
var1=${parameter:+word} # If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted.
${parameter:offset}
${parameter:offset:length}
# Substring Expansion. It expands to up to length characters of the value
  of parameter starting at the character specified by offset. 
  If parameter is '@', an indexed array subscripted by '@' or '*', or an
  associative array name, the results differ as described below. 
</pre>

<pre zoom labels="">
<span xsmall>Parse arguments</span>
#Oº$#º number of arguments
while [Oº$#º -gt 0 ]; do  
  echo $1
  case "$1" in
    -l|--list)
      echo "list arg"
      shift 1  # ºconsume arg         ← Oº$# = $#-1º
      ;;
    -p|--port)
      export PORT="${2}:"
      echo "port: $PORT"
      shift 2  # ºconsume arg+valueº  ← Oº$# = $#-2º
      ;;
    *)
      echo "non-recognised option"
      shift 1  # ºconsume argº        ← Oº$# = $#-1º
  esac  
done
</pre>

<pre zoom labels="">
<span xsmall>Barrier synchronization</span>
Wait for background jobs to complete example:
(
  ( sleep 3 ; echo "job 1 ended" ) &
  ( sleep 1 ; echo "job 2 ended" ) &
  ( sleep 1 ; echo "job 3 ended" ) &
  ( sleep 9 ; echo "job 4 ended" ) &
  wait ${!}       # alt.1: Wait for all background jobs to complete
# wait %1 %2 %3   # alt.2: Wait for jobs 1,2,3. Do not wait for job 4
  echo "All subjobs ended"
) &
</pre>



<pre zoom>
<span xsmall>bash REPL loop</span>
REPL stands for Read-eval-print loop: More info at:
@[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop]
    # Define the list of a menu item
   ºselectºOºlanguageººinºC# Java PHP Python Bash Exit
   ºdoº
      #Print the selected value
      if [[ Oº$languageº == "Exit" ]] ; then
        exit 0 
      fi
      echo "Selected language is $language"
   ºdoneº
</pre>

<pre zoom labels="">
<span xsmall>trap: Exit script cleanly</span>
@[https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html]
</pre>

<pre zoom>
<span xsmall>Bash-it</span>
@[https://www.tecmint.com/bash-it-control-shell-scripts-aliases-in-linux/]
- bundle of community Bash commands and scripts for Bash 3.2+, 
  which comes with autocompletion, , aliases, custom functions, .... 
- It offers a useful framework for developing, maintaining and 
  using shell scripts and custom commands for your daily work.
</pre>


<pre zoom labels="">
<span xsmall>Bash 4+ Maps</span>
#!/usr/bin/env bash

declare -A animals                             # STEP !: declare associative array "animals"
animals=( ["key1"]="value1" ["key2"]="value2") # Init with some elements


Then use them just like normal arrays. Use animals['key']='value' to set value, "${animals[@]}" to expand the values, and "${!animals[@]}" (notice the !) to expand the keys. Don't forget to quote them:

echo "${animals[moo]}"
for sound in "${!animals[@]}"; do echo "$sound - ${animals[$sound]}"; done

Bash 3
</pre>

<pre zoom labels="">
<span xsmall>test</span>
(man test summary from GNU coreutils)

test 

  EXPRESSION  # ← EXPRESSION true/false sets the exit status.
[ EXPRESSION ]

-n STRING                  # STRING length ˃0
                           # (or just STRING)
-z STRING                  #  STRING length == 0
STRING1 = STRING2          # String equality
STRING1 != STRING2         # String in-equality


INTEGER1 -eq INTEGER2      # ==
INTEGER1 -ge INTEGER2      # ˂=
INTEGER1 -gt INTEGER2
INTEGER1 -le INTEGER2
INTEGER1 -lt INTEGER2
INTEGER1 -ne INTEGER2
^^^^^^^^ 
BºNOTE:º INTEGER can be -l STRING (length of STRING)

ºFILE TEST/COMPARISIONº
RºWARN:º Except -h/-L, all FILE-related tests dereference symbolic links.
-e FILE                    #ºFILE existsº
-f FILE                    # FILE exists and is a1regular fileº
-h FILE                    # FILE exists and is aºsymbolic linkº (same as -L)
-L FILE                    #                                     (same as -h)
-S FILE                    # FILE exists and is aºsocketº
-p FILE                    #ºFILE exists and is a named pipeº
-s FILE                    # FILE exists and has aºsize greater than zeroº


-r FILE                    # FILE exists andºread  permissionºis granted
-w FILE                    # FILE exists andºwrite permissionºis granted
-x FILE                    # FILE exists andºexec  permissionºis granted

FILE1  -ef FILE2           # ← same device and inode numbers
FILE1 -nt FILE2            # FILE1 is newer (modification date) than FILE2
FILE1 -ot FILE2            # FILE1 is older (modification date) than FILE2
-b FILE                    # FILE exists and is block special
-c FILE                    # FILE exists and is character special
-d FILE                    #ºFILE exists and is a directoryº
-k FILE                    # FILE exists and has its sticky bit set


-g FILE                    # FILE exists and is set-group-ID
-G FILE                    # FILE exists and is owned by the effective group ID
-O FILE                    # FILE exists and is owned by the effective user ID
-t FD   file descriptor FD is opened on a terminal
-u FILE FILE exists and its set-user-ID bit is set

BOOLEAN ADITION
RºWARNº: inherently ambiguous.  Use 
EXPRESSION1 -a EXPRESSION2 # AND # 'test EXPR1 ⅋⅋ test EXPR2' is prefered
EXPRESSION1 -o EXPRESSION2 # OR  # 'test EXPR1 || test EXPR2' is prefered


RºWARN,WARN,WARNº: your shell may have its own version of test and/or '[',
                   which usually supersedes the version described here.
                   Use /usr/bin/test to force non-shell ussage.

Full documentation at: @[https://www.gnu.org/software/coreutils/]


</pre>
</div>

</body>
<!--
TODO_START:
Next: Introduction,  Up: (dir)

GNU Coreutils Index
*******************
(Summary output from $ info coreutils)

Output of entire files
* cat      # Con(cat)enate, dump files
* tac      # reversed-cat
* nl       # Number lines
* od       # Write files in octal,.. formats
* base32   # Transform data into printable data
* base64   # Transform data into printable data

Formatting file contents
* fmt   # Reformat paragraph text
* pr    # Paginate or columnate for printing
* fold  # Wrap input lines to fit width-columns

Output of parts of files
* head invocation              Output the first part of files
* tail invocation              Output the last part of files
* split invocation             Split a file into fixed-size pieces
* csplit invocation            Split a file into context-determined pieces

Summarizing files

* wc invocation                Print newline, word, and byte counts
* sum invocation               Print checksum and block counts
* cksum invocation             Print CRC checksum and byte counts
* b2sum invocation             Print or check BLAKE2 digests
* md5sum invocation            Print or check MD5 digests
* sha1sum invocation           Print or check SHA-1 digests
* sha2 utilities               Print or check SHA-2 digests

Operating on sorted files

* sort invocation              Sort text files
* shuf invocation              Shuffle text files
* uniq invocation              Uniquify files
* comm invocation              Compare two sorted files line by line
* ptx invocation               Produce a permuted index of file contents
* tsort invocation             Topological sort

‘ptx’: Produce permuted indexes
* General options in ptx       Options which affect general program behavior
* Charset selection in ptx     Underlying character set considerations
* Input processing in ptx      Input fields, contexts, and keyword selection
* Output formatting in ptx     Types of output format, and sizing the fields
* Compatibility in ptx         The GNU extensions to ‘ptx’

Operating on (csv,...)fields
* cut invocation               Print selected parts of lines
* paste invocation             Merge lines of files
* join invocation              Join lines on a common field

Operating on characters
* tr invocation                Translate, squeeze, and/or delete characters

‘tr’: Translate, squeeze, and/or delete characters

ºprintfº                      Format and print data

‘expr’: Evaluate expression
* String  expressions  # + : match substr index length
* Numeric expressions  # + - * / %
* Relations for expr   # | & < <= = == != >= >
* Examples of expr     # Examples of using ‘expr’

ºFile name manipulationº
* basename   # Strip directory and suffix from a file name
* dirname    # Strip last file name component
* pathchk    # Check file name validity and portability
* mktemp     # Create temporary file or directory
* realpath   # Print resolved file names

Working context
* pwd       # Print working directory
* printenv  # Print all|some env.vars
* tty       # Print file name of terminal

User information
* id      # Print user identity
* logname # Print current login name
* whoami  # Print effective user ID
* groups  # Print group names a user is in
* users   # Print login names of users currently logged in
* who     # Print who is currently logged in

SELinux context
* chcon   # Change SELinux context of file
* runcon  # Run in specified SELinux context

Modified command invocation
* chroot  #  Run process with different root directory
* env     #  Run process in modified environment
* nice    #  Run process with modified niceness
* nohup   #  Run process immune to hangups
* stdbuf  #  Run process with modified I/O buffering
* timeout #  Run process with a time limit

Process control
* kill 

Delaying
* sleep

Numeric operations
* factor (print prime factors)
* numfmt (Num. Formatting)
* seq    (Sequence number)


* who 
* cut 
* sort
* uniq

_______________________
https://www.ostechnix.com/test-your-bash-skills-by-playing-command-line-games/
_________________
https://medium.com/cameron-nokes/working-with-json-in-bash-using-jq-13d76d307c4
_____________________
-->

</html>
