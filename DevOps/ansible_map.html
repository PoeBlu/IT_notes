<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Ansible map (v1.0) <!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>
<a href="https://docs.ansible.com/ansible/latest/user_guide/index.html">User Guide</a>
<table { >
<tr {>
<td col1 colspan=1>
  Summary
<pre xxxsmall zoom>
ANSIBLE MAIN OBJECTIVE:
  Write <b>declaratively</b> (vs programatically) the <b>desired</b> final state of install 
  (correct packages, conf. files, permissions, running services,...) avoiding custom-scripts
  "pitfalls"

VOCABULARY
  - <b>Controller</b> 
    <b>Machine</b>  : machine where Ansible is installed, responsible for orchestating provisioning
  - <b>Inventory</b>: INI file with servers and group of server being targeted 
  - <b>Playbook</b> : Main provisioning (YAML) file, defining tasks to be executed
  - <b>Task</b>     : block of yaml config defined <b>a single procedure to be executed</b> ( e.g.: install a package)
  - <b>Module</b>   : typically <b>abstracts a recurrent system task</b>, (dealing with packages, handling files,...)
  - <b>Role</b>     : <b>pre-defined way for organizing playbooks</b> and other files in order to
    <b></b>           facilitate <b>sharing and reusing</b> portions of a provisioning
  - <b>Play</b>     : a provisioning executed from start to finish 
  - <b>Facts</b>    : global variables with info about the system (network interfaces, volumes, ...)
  - <b>Handlers</b> : Handle async events triggered by ansible tasks (Used to restart OS services, ...)


- Detailed help: $ ansible-doc "module_name"

- Ansible can execute arbitrary shell commands on remote servers,
    but real power comes from the collection of modules it ships with 

- Ansible modules are declarative: describe desired state<br/>
    For example invoke the user module like this to ensure there was
    an account named <b blue>deploy</b> in the <b orange>web</b> group:
    user: name=<b blue>deploy</b> group=<b orange>web</b>

- Modules are also idempotent (warrants always same results)

- The primary unit of reuse in the Ansible community is the module.

- Ansible has excellent support for templating, as well as defining
    variables at different scopes.

- Ansible uses the YAML file format and the Jinja2 templating languages.
</pre>

  <hr xxxsmall />

  <a href="https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html">Command line tools</a>
<pre xxxsmall zoom>
<a href="https://docs.ansible.com/ansible/latest/cli/ansible.html"          >ansible          </a> define and run a single task ‘playbook’ against a set of hosts
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-config.html"   >ansible-config   </a> view, edit, and manage ansible configuration 
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-console.html"  >ansible-console  </a> interactive console for executing ansible tasks
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-doc.html"      >ansible-doc      </a> plugin documentation tool
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html"   >ansible-galaxy   </a> command to manage Ansible roles in shared repostories, the default of which is Ansible Galaxy https://galaxy.ansible.com 

<a href="https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html">ansible-inventory</a> used to display or dump the configured inventory as Ansible sees it
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html" >ansible-playbook </a> runs Ansible playbooks, executing the defined tasks on the targeted hosts.
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-pull.html"     >ansible-pull     </a> pulls playbooks from a VCS repo and executes them for the local host
<a href="https://docs.ansible.com/ansible/latest/cli/ansible-vault.html"    >ansible-vault    </a> encryption/decryption utility for Ansible data files
</pre>
    <hr xxxsmall/>
  <b><code><a href="http://docs.ansible.com/ansible/latest/intro_configuration.html">ansible.cfg</a>:</code></b>
<pre xxxsmall zoom {>
Location order:
$ANSIBLE_CONFIG → ./ansible.cfg → ~/.ansible.cfg → /etc/ansible/ansible.cfg
Ex:
[defaults]
inventory = hosts
remote_user = vagrant
private_key_file = ~/.ssh/private_key
host_key_checking = False
</pre }

    <b><code>command</code> module</b>
<pre xxxsmall zoom { >
$ ansible testserver -m command -a uptime
$ ansible testserver -a uptime # (command is the default module)

testserver | success | rc=0 &gt;&gt;
17:14:07 up  1:16,  1 user, load average: 0.16, ...
</pre } >
</td>
<td>
 Ansible File layout Best practices
<pre xxxsmall zoom bgorange>
(Recommended, non-mandatory) best practice file layout approach:
----------------------------------------------------------------
production                # inventory file for production servers
staging                   # inventory file for staging environment

group_vars/               # here we assign variables to particular groups. Ex:
   all.yml                # 
   webservers.yml         # all.yml            webservers.yml                     ddbbs.yml
   dbservers.yml          # |---               |---                             | ---            
                          # |ntp: ntp.ex1.com  |apacheMaxClients: 900           | maxConnectionPool: 100
                          # |backup: bk.ex1.com|apacheMaxRequestsPerChild: 3000 | ...

host_vars/
   hostname1.yml          # here we assign variables to particular systems
   hostname2.yml

library/                  # (optional) if any custom modules, put them here 
module_utils/             # (optional) if any custom module_utils to support modules, put them here
filter_plugins/           # (optional) if any custom filter plugins, put them here

webservers.yml            # playbook for webserver tier. Maps webservers group config to webserver roles:
                          # ---
                          # | # file: webservers.yml
                          # | - hosts: webservers
                          # |   roles:
                          # |     - common
                          # |     - webtier

dbservers.yml             # playbook for dbserver tier
site.yml                  # master playbook defines entire infraestructure. Ex:
                          # ---
                          # | # file: site.yml
                          # | - import_playbook: webservers.yml
                          # | - import_playbook: dbservers.yml
roles/
    common/               # this hierarchy represents a "role"
        tasks/            #
            main.yml      #  ← tasks file can include smaller files if warranted
        handlers/         #
            main.yml      #  ← handlers file
        templates/        #  ← files for use with the template resource
            ntp.conf.j2   #  ←----- templates end in .j2
        files/            #
            bar.txt       #  ← files for use with the copy resource
            foo.sh        #  ← script files for use with the script resource
        vars/             #
            main.yml      #  ← variables associated with this role
        defaults/         #
            main.yml      #  ← default lower priority variables for this role
        meta/             #
            main.yml      #  ← role dependencies
        library/          # roles can also include custom modules
        module_utils/     # roles can also include custom module_utils
        lookup_plugins/   # or other types of plugins, like lookup in this case

    webtierRole/          # same kind of structure as "common" was above, done for the webtier role
    monitoringRole/       # ""
    ...
</pre>

  <b>(Conditional) include</b><br/>
<pre xxxsmall zoom { >
Ussually we use facts for conditionals:
<a href="https://docs.ansible.com/ansible/2.4/playbooks_reuse_includes.html">Reminder:</a>
   "include"               is evaluated during playbook parsing
   "import"         (2.4+) is evaluated during playbook execution
   "import_playbook"(2.4+) plays&and;tasks in each playbook 
   "include_tasks"  (2.4+?) 
   "import_tasks"   (2.4+?) 

- <b orange>include</b>: Redhat.yml
  <b orange>when</b>: ansible_os_family == 'Redhat'

- <b orange>include</b>: Debian.yml
  <b orange>when</b>: ansible_os_family == 'Debian'
</pre }>

</td>
<td>
  <b>Ansible yaml layout<br/>
    (Tasks "vs" Roles)</b><br/>
<pre xxxsmall zoom bgorange { >
|playbook| 1←→N |Play| 1←→N |Hosts|
                 ↑
                1└──────→N |Task|→|Module|

<b>IMPORTANT:</b>
- Ansible runs each task in parallel across all hosts in the order provided by the yaml file.
- Ansible waits until all hosts have completed a task before moving to the next task.
  (See schedule "serial"/"free" execution to change default execution strategy)
-------------------------------------------------------------+-------------------------------------------------------------------
PLAYBOOK YAML LAYOUT WITH TASKS:                             | PLAYBOOK YAML LAYOUT WITH <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html">ROLES</a>:
                                                             | role: primary mechanism for breaking playbooks into reusable parts
-------------------------------------------------------------+-------------------------------------------------------------------
---                                                          | <b>based on a well known file structure</b>.
- hosts: webservers         ← targeted (ssh) servers         | ---
  connection: ssh           ← :=ssh, localhost,. ..          | - name : my list  of Task name
                                                             |   hosts: database
  vars:                     ← yaml-file-scoped var.list      |   vars_files:
   - myYmlVar01 : "myVal01"                                  |    - secrets.yml
                                                             | 
  enviroment:               ← runtime-scoped env.var.list    |   <span blue># pre_tasks execute before roles </span>
   - myEnvVar01 : "myEnv01"                                  |   <span blue>pre_tasks</span>:
                                                             |     - name: update the apt cache
  tasks:                    ← ordered task list to           |       apt: update_cache=yes
                              be executed                    | 
   - name: install apache2  ← task1                          |   roles:
     apt: |                                                  |    - role: <b blue>databaseRole</b>
        name=apache2                                         |      # next vars override those in (vars|defaults)/main.yml
        update_cache=yes                                     |      database_name: " {{ myProject_ddbb_name }}"
        state=lates                                          |      database_user: " {{ myProject_ddbb_user }}"
     notify:                                                 |    - { role: consumer, when: tag | default('provider') == 'consumer'}
       - <b>restart-apache2-id</b>                                  |    - { role: provider, when: tag | default('provider') == 'provider'}
   - name: next_task_to_exec                                 | 
     "module": ...                                           | 
                                                             |   <span blue># post_tasks execute after roles </span>
  handlers:                ←  tasks triggered by events      |   <span blue>post_tasks</span>:
   - name: restart-apache2 ←  <b>name as a Unique-ID</b>            |     - name: notify Slack
     service: name=apache2 state=restarted                   |       local_action: &gt;
                                                             |         slack
- hosts: localhost                                           |         domain=acme.slack.com
  connection: local                                          |         token={{ slack_token }}
  gather_facts: False                                        |         msg="database {{ inventory_hostname }} configured"
                                                             | 
  vars:                                                      |   ...
  ...                                                        | ===========================
                                                             | roles search path: ./roles → /etc/ansible/roles
                                                             | role file layout: 
                                                             | roles/<b blue>databaseRole</b>/tasks/main.yml 
                                                             | roles/<b blue>databaseRole</b>/files/
                                                             | roles/<b blue>databaseRole</b>/templates/
                                                             | roles/<b blue>databaseRole</b>/handlers/main.yml
                                                             | roles/<b blue>databaseRole</b>/vars/main.yml     # should NO be overrriden
                                                             | roles/<b blue>databaseRole</b>/defaults/main.yml # can be       overrriden
                                                             | roles/<b blue>databaseRole</b>/meta/main.yml     # dependency info about role
-------------------------------------------------------------+-------------------------------------------------------------------
</pre }>

<b>Ex: Installing nginx</b>
<pre xxxsmall zoom>
web-tls.yml
- name: wait in control host for ssh server to be running
  local_action: wait_for port=22 host="{{ inventory_hostname }}"
    search_regex=OpenSSH

- name: Configure nginx
  <b xbig>hosts:</b> webservers
  become: True
  <b xbig>vars:</b>
    <span orange>key_file</span>: /etc/nginx/ssl/nginx.key
    <span green>cert_file</span>: /etc/nginx/ssl/nginx.crt
    <span blue>conf_file</span>: /etc/nginx/sites-available/default
    server_name: localhost
  <b xbig>tasks:</b>
    - name: install nginx
      <b>apt</b>: <b>name</b>=nginx <b>update_cache</b>=yes

    - name: create directories for ssl certificates
      <b>file</b>: <b>path</b>=/etc/nginx/ssl <b>state</b>=directory

    - name: copy TLS key
      <b>copy</b>: <b>src</b>=files/nginx.key <b>dest</b>={{ <span orange>key_file</span> }} owner</b>=root <b>mode</b>=0600
      <b>notify</b>: restart nginx

    - name: copy TLS certificate
      <b>copy</b>: <b>src</b>=files/nginx.crt <b>dest</b>={{ <span green>cert_file</span> }}
      <b>notify</b>: restart nginx

    - name: copy config file
      <b>copy</b>: <b>src</b>=files/nginx.conf<b>.j2</b> <b>dest</b>={{ <span blue>conf_file</span> }}

    - name: enable configuration
      # set attributes of file, symlink or directory
      <b>file</b>: <b>dest</b>=/etc/nginx/sites-enabled/default <b>src</b>={{ <span blue>conf_file</span> }} state=link
    - name: copy index.html
      # template -> new file -> remote host      
      <b>template</b>: <b>src</b>=templates/index.html.j2 <b>dest</b>=/usr/share/nginx/html/index.html
        mode=0644

    - name: show a debug message
      debug: "msg='Example debug message: conf_file {{ <span blue>conf_file</span> }} included!'"

    - name: Example to register new ansible variable
      command: whoami
      register: login
    # (first debug helps to know who to write the second debug)
    - debug: var=login
    - debug: msg="Logged in as user {{ login.stdout }}"

    - name: Example to <b>ignore errors</b>
      command: /opt/myprog
      register: result
      ignore_errors: <b>True</b>
    - debug: var=result

  <b xbig>handlers:</b>
    - name: restart nginx
      <b>service</b>: <b>name</b>=nginx <b>state</b>=restarted
</pre>
</td>  
<td>  
    <b>"hosts" inventory file</b>
<pre xxxsmall zoom>
Defaults to /etc/ansible/hosts
if "hosts" is marked as executable (+x) it's executed and the output json taken as inventory.
This executable script must support the --host=... and --list command line flags

Ex: .../playbooks/hosts
---------------------------
<span green># development</span>
<span brown># stagin</span>
<span orange># production</span>

[all:vars]
ntp_server=ntp.ubuntu.com

[<span orange>production</span>:vars]
db_primary_host=rhodeisland.example.com
db_primary_port=5432
db_replica_host=virginia.example.com
db_name=widget_production
db_user=widgetuser
db_password=pFmMxcyD;Fc6)6
rabbitmq_host=pennsylvania.example.com
rabbitmq_port=5672


[<span brown>staging</span>:vars]
db_primary_host=quebec.example.com
db_primary_port=5432
db_name=widget_staging
db_user=widgetuser
db_password=L@4Ryz8cRUXedj
rabbitmq_host=quebec.example.com
rabbitmq_port=5672

[<span green>vagrant</span>:vars]
db_primary_host=vagrant3
db_primary_port=5432
db_name=widget_vagrant
db_user=widgetuser
db_password=password
rabbitmq_host=vagrant3
rabbitmq_port=5672

[<span brown>stagin</span>]
<span brown>ontario.example.com</span>
<span brown>quebec.example.com</span>

[<span green>vagrant</span>]
<span green>vagrant1 ansible_host=127.0.0.1 ansible_port=2222</span>
<span green>vagrant2 ansible_host=127.0.0.1 ansible_port=2200</span>
<span green>vagrant3 ansible_host=127.0.0.1 ansible_port=2201</span>

[lb]
<span orange>delaware.example.com</span>

[web]
<span orange>georgia.example.com</span>
<span orange>newhampshire.example.com</span>
<span orange>newjersey.example.com</span>
<span brown>ontario.example.com</span>
<span green>vagrant1</span>

[task]
<span orange>newyork.example.com</span>
<span orange>northcarolina.example.com</span>
<span orange>maryland.example.com</span>
<span brown>ontario.example.com</span>
<span green>vagrant2</span>

[rabbitmq]
<span orange>pennsylvania.example.com</span>
<span brown>quebec.example.com</span>
<span green>vagrant3</span>

[db]
<span orange>rhodeisland.example.com</span>
<span orange>virginia.example.com</span>
<span brown>quebec.example.com</span>
<span green>vagrant3</span>

# group of gruops:
[django:children]
web
task

# ranges
[webgroup2]
web[01:20].example.com
web-[a-t].example.com

</pre>
  test host file "pinging" to the ssh host server:
<pre xxxsmall zoom>
  $ ansible testserver -i hosts -m ping # Test ssh connection works
</pre>
</td>
<td>
  <b>Error Handling</b><br/>
  <ul xxxsmall zoom >
  <li>error scenarios has always been a challenge. 
        Historically, Ansible has been error agnostic in the sense 
        that errors and failures may occur on a host.
  </li>
  <li>default behavior is to take a host out of the play
       if a task fails and continue as long as there are hosts
       remaining that haven’t encountered errors.
  </li>
  <li><code orange>serial</code> and <code orange>max_fail_percentage</code><a href="https://docs.ansible.com/ansible/2.5/user_guide/playbooks_delegation.html#maximum-failure-percentage">REF</a> gives some control over when a play has to be declared as failed.

  <li>With the blocks clause as shown in Example 8-27, Ansible advances error handling a bit further and lets us automate recovery and rollback of tasks in case of a failure.
<pre { >
"try-catch-finally"
- hosts: app-servers
  <code orange>max_fail_percentage</code>: "10%"        ← Max. number of failed servers for tasks before aborting
  tasks:
  - name: Take VM out of the load balancer
  - name: Create a VM snapshot before the app upgrade

  - block:
    - name: Upgrade the application
    - name: Run smoke tests

  <b>rescue:</b>
    - name: Revert a VM to the snapshot after a failed upgrade

  <b>always:</b>
    - name: Re-add webserver to the loadbalancer
    - name: Remove a VM snapshot
</pre } >
  </li>
  </ul>
  
</td>
</tr>  
</table>  
<table>
<tr>  
<td>
<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html">Playbook Vars</a>
  <hr xxxsmall />
  Gathering (host) facts</br>
  ($ <code orange>setup</code> module)
  example/ref. output</code>
<pre xxxsmall zoom { >
(Use also to force facts reloading)
  tasks:
    - ...
    - name: re-read facts after adding custom fact<b blue>
      setup</b>: filter=ansible_local     ← re-run <b blue>setup module</b> to make
           </b>                           


$ ansible "hostname" -m <b orange>setup</b>
(Ansible 1.4, Ubuntu 12.04)
Next facts are available with:
- hosts: ...<b blue>
  gather_facts: yes</b> ← Will execute the module "setup"

{<b blue>
    "ansible_os_family": "Debian",
    "ansible_pkg_mgr": "apt",
    "ansible_architecture": "x86_64",
    "ansible_nodename": "ubuntu2.example.com",</b>
    "ansible_all_ipv4_addresses": [ "REDACTED IP ADDRESS" ],
    "ansible_all_ipv6_addresses": [ "REDACTED IPV6 ADDRESS" ],
    "ansible_bios_date": "09/20/2012",
    "ansible_bios_version": "6.00",
    "ansible_cmdline": {
        "BOOT_IMAGE": "/boot/vmlinuz-3.5.0-23-generic",
        "quiet": true,
        "ro": true,
        "root": "UUID=4195bff4-e157-4e41-8701-e93f0aec9e22",
        "splash": true
    },
    "ansible_date_time": {
        "date": "2013-10-02",
        "day": "02",
        "epoch": "1380756810",
        "hour": "19",
        "iso8601": "2013-10-02T23:33:30Z",
        "iso8601_micro": "2013-10-02T23:33:30.036070Z",
        "minute": "33",
        "month": "10",
        "second": "30",
        "time": "19:33:30",
        "tz": "EDT",
        "year": "2013"
    },<b orange>
    "ansible_default_ipv4": {
        "address": "REDACTED",
        "alias": "eth0",
        "gateway": "REDACTED",
        "interface": "eth0",
        "macaddress": "REDACTED",
        "mtu": 1500,
        "netmask": "255.255.255.0",
        "network": "REDACTED",
        "type": "ether"
    },</b>
    "ansible_default_ipv6": {},
    "ansible_devices": {
        "sda": {
            "holders": [],
            "host": "SCSI storage controller: ...Dual Ultra320 SCSI,
            "model": "VMware Virtual S",
            "partitions": {
                "sda1": {
                    "sectors": "39843840",
                    "sectorsize": 512,<b orange>
                    "size": "19.00 GB",</b>
                    "start": "2048"
                }
            },
            ...
            "sectorsize": "512",<b orange>
            "size": "20.00 GB",</b>
            "support_discard": "0",
            "vendor": "VMware,"
        },
        ...
    },
    "ansible_distribution": "Ubuntu",
    "ansible_distribution_release": "precise",
    "ansible_distribution_version": "12.04",
    "ansible_domain": "",<b>
    "ansible_env": {
        "COLORTERM": "gnome-terminal",
        "DISPLAY": ":0",
        "HOME": "/home/mdehaan",
        "LANG": "C",
        "LESSCLOSE": "/usr/bin/lesspipe %s %s",
        "LESSOPEN": "| /usr/bin/lesspipe %s",
        "LOGNAME": "root",
        "LS_COLORS": "rs=0:di=01;...*.xspf=00;36:",
        "MAIL": "/var/mail/root",
        "OLDPWD": "/root/ansible/docsite",
        "PATH": "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
<b orange>        "PWD": "/root/ansible",</b>
        "SHELL": "/bin/bash",
        "SHLVL": "1",
        "SUDO_COMMAND": "/bin/bash",
        "SUDO_GID": "1000",
        "SUDO_UID": "1000",
        "SUDO_USER": "mdehaan",
        "TERM": "xterm",
        "USER": "root",
        "USERNAME": "root",
        "XAUTHORITY": "/home/mdehaan/.Xauthority",
        "_": "/usr/local/bin/ansible"
    },</b>
    "ansible_eth0": {
        "active": true,
        "device": "eth0",
        "ipv4": {
            "address": "REDACTED",
            "netmask": "255.255.255.0",
            "network": "REDACTED"
        },
        "ipv6": [ ...  ],
        "macaddress": "REDACTED",
        "module": "e1000",
        "mtu": 1500,
        "type": "ether"
    },
    "ansible_form_factor": "Other",<b orange>
    "ansible_fqdn": "ubuntu2.example.com",
    "ansible_hostname": "ubuntu2",</b>
    "ansible_interfaces": [
        "lo",
        "eth0"
    ],
    "ansible_kernel": "3.5.0-23-generic",
    "ansible_lo": { ...  },
    "ansible_lsb": {<b orange>
        "codename": "precise",
        "description": "Ubuntu 12.04.2 LTS",</b>
        "id": "Ubuntu",
        "major_release": "12",
        "release": "12.04"
    },<b orange>
    "ansible_machine": "x86_64",</b>
    "ansible_memfree_mb": 74,
    "ansible_memtotal_mb": 991,
    "ansible_mounts": [
        {
            "device": "/dev/sda1",
            "fstype": "ext4",
            "mount": "/",
            "options": "rw,errors=remount-ro",
            "size_available": 15032406016,
            "size_total": 20079898624
        }
    ],
    "ansible_processor": [ "Intel(R) Core(TM) i7 CPU ..."
    ],
    "ansible_processor_cores": 1,
    "ansible_processor_count": 1,
    "ansible_processor_threads_per_core": 1,
    "ansible_processor_vcpus": 1,
    "ansible_product_name": "VMware Virtual Platform",
    "ansible_product_serial": "REDACTED",
    "ansible_product_uuid": "REDACTED",
    "ansible_product_version": "None",
    "ansible_python_version": "2.7.3",
    "ansible_selinux": false,
    "ansible_ssh_host_key_dsa_public": "REDACTED KEY VALUE",
    "ansible_ssh_host_key_ecdsa_public": "REDACTED KEY VALUE",
    "ansible_ssh_host_key_rsa_public": "REDACTED KEY VALUE",
    "ansible_swapfree_mb": 665,
    "ansible_swaptotal_mb": 1021,
    "ansible_system": "Linux",
    "ansible_system_vendor": "VMware, Inc.",
    "ansible_user_id": "root",
    "ansible_userspace_architecture": "x86_64",
    "ansible_userspace_bits": "64",
    "ansible_virtualization_role": "guest",
    "ansible_virtualization_type": "VMware"
}
</pre>

  <code>"/etc/ansible/facts.d"</code><br/>
  (Local provided facts, 1.3+)
<pre xxxsmall zoom>
Way to provide "locally supplied user values" as opposed to 
               "centrally supplied user values"  or 
               "locally dynamically determined values"

If 
any files inside /etc/ansible/facts.d (@remotely managed host)
ending in *.fact (JSON, INI, execs generating JSON, ...) can supply local facts 

Ex: /etc/ansible/facts.d/preferences.fact contains:
[general] 
asdf=1    ← Will be available as {{ ansible_local.preferences.general.asdf }}
bar=2       (keys are always converted to lowercase)


To copy local facts and make the usable in current play:
- hosts: webservers
  tasks:
    - name: create directory for ansible custom facts
      file: state=directory recurse=yes path=/etc/ansible/facts.d

    - name: install custom ipmi fact
      copy: src=ipmi.fact dest=/etc/ansible/facts.d ← Copy local facts

    - name: re-read facts after adding custom fact<b blue>
      setup</b>: filter=ansible_local     ← re-run <b blue>setup module</b> to make
           </b>                           ← locals facts available in current play

</pre>

  assign command ouput to var
<pre xxxsmall zoom>
Results will vary from module to module.
Use -v to show possible values for the results.

- hosts: web_servers
  tasks:
     - shell: /usr/bin/foo<b blue>
       register: foo_result</b>   
       ignore_errors: True

     - shell: /usr/bin/bar
       when: foo_result.rc == 5  ← Using foo_result
</pre>

  Playbook variable "scopes":
<pre xxxsmall zoom>
Variable Main Scopes

- Global: set by config, ENV.VARS and cli
- Play  : each play and contained structures,
          vars|vars_files|vars_prompt entries 
          role defaults 
- Host  : directly associated to a host,
          like inventory, include_vars,
          facts or registered task outputs


Variable scope Overrinding rules:

- The more explicit you get in scope, the more precedence
  1    command line values (eg “-u user”) <b>(SMALLEST PRECEDENCE)</b>
  2    role defaults
  3 *1 inventory file || script group vars 
  4 *2 inventory group_vars/all
  5 *2 playbook  group_vars/all
  6 *2 inventory group_vars/* 
  7 *2 playbook  group_vars/* 
  8 *1 inventory file or script host vars 
  9 *2 inventory host_vars/*
 10 *2 playbook  host_vars/* 
 11 *4 host facts || cached set_facts 
 12    play vars
 13    play vars_prompt
 14    play vars_files
 15    role vars  (defined in role/vars/main.yml)
 16    block vars (only for tasks in block)
 17    task vars  (only for the task)
 18    include_vars
 19    set_facts || registered vars
 20    role (and include_role) params
 21    include params
 22    (-e) extra vars                     <b>(BIGEST PRECEDENCE)</b>
    ↑  
   *1 Vars defined in inventory file or dynamic inventory
   *2 Includes vars added by ‘vars plugins’ as well as 
      host_vars and group_vars which are added by the default 
      vars plugin shipped with Ansible.
   *4 When created with set_facts’s cacheable option, 
      variables will have the high precedence in the play,
      but will be the same as a host facts precedence when
      they come from the cache.
</pre>


</td>  
<td>  
  <b>"Jinja2" template ex.</b><br/>
  <code>nginx.conf<b>.j2</b>:</code>
<pre xxxsmall zoom { >
server {
        listen 80 default_server;
        listen [::]:80 default_server ipv6only=on;

        listen 443 ssl;

        root /usr/share/nginx/html;
        index index.html index.htm;

        server_name <b>{{</b> server_name <b>}}</b>;
        ssl_certificate <b>{{</b> cert_file <b>}}</b>;
        ssl_certificate_key <b>{{</b> key_file <b>}}</b>;

        location / {
                try_files $uri $uri/ =404;
        }
}
</pre } >

  <code>templates/default.conf.tpl</code>
<pre xxxsmall zoom>
templates/000_default.conf.tpl</code>
|<VirtualHost *:80>
|    ServerAdmin webmaster@localhost
|    DocumentRoot {{ doc_root }}
|
|    <Directory {{ doc_root }}>
|        AllowOverride All
|        Require all granted
|    </Directory>
|</VirtualHost>

Task:
|  - name: Setup default virt.host 
|    template: src=templates/default.conf.tpl dest=/etc/apache2/sites-available/000-default.conf
</pre>




</td>
<td>
  <b>changed_when / failed_when</b>
  <ul xxxsmall zoom>
  <li>Used to handle non idempotent tasks.<br/>
    Example <code>django_manage</code> always returns  changed: False for
    some "external" ddbb commands. <span orange>changed_when</span> is used to give hints to ansible:
<pre { >
- name: initialize the database
  django_manage:
    command: createdb --noinput --nodata
    app_path: "{{ proj_path }}"
    virtualenv: "{{ venv_path }}"
  failed_when: False # &lt; avoid stoping execution
  register: <b green>result</b>
  <span orange>changed_when</span>: <b green>result</b>.out is defined and '"Creating tables" in <b green>result</b>.out'

- debug: var=result

- fail:
</pre }>
  </li>
  </ul>
  <hr xxxsmall />
  <b>(j2) filters</b>
  <code orange>|</code> must be interpreted as the "pipe" (input) to filter, not the "or" symbol.
<pre xxxsmall zoom { >
# default if undefined:
- ...
  "HOST": "{{ database_host <b orange>| default('localhost')</b> }}"

# fail after some debuging
- ...
  register: result
  <b orange>ignore_errors: True</b>
  ...
  failed_when: result<b orange>| failed</b>
...
<b orange>failed </b>    True if registered value is a failed    task
<b orange>changed</b>    True if registered value is a changed   task
<b orange>success</b>    True if registered value is a succeeded task
<b orange>skipped</b>    True if registered value is a skipped   task
</pre }>
  <b>path filters</b>
<pre xxxsmall zoom { >
<b orange>basename  </b> 
<b orange>dirname   </b>
<b orange>expanduser</b>  '~' replaced by home dir.
<b orange>realpath  </b>  resolves sym.links
Ej:
  vars:
    homepage: /usr/share/nginx/html/index.html
  tasks:
  - name: copy home page
    copy: &lt; 
      src={{ homepage <b orange>| basename</b> }}
      dest={{ homepage }}
</pre }>
  
  <b>Custom filters</b>
<pre xxxsmall zoom { >
filter_plugins/surround_by_quotes.py
# From http://stackoverflow.com/a/15515929/742
def surround_by_quote(a_list):
    return ['"%s"' % an_element for an_element in a_list]

class FilterModule(object):
    def filters(self):
        return {'surround_by_quote': surround_by_quote}
</pre }>
  <hr/>  
  <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html"><code>Lookups</code></a> Quering extern. data (files, shells, key/val ddbbs,...)
<pre xxxsmall zoom { >
Lookups modules allows to query data from external sources.
  ...
  vars:
    motd_value: "{{ <b>lookup(<b blue>'file'</b>, '/etc/motd') }}</b>"

Existing lookup modules:
  file     Contents of a file
  password Randomly generate a password
  pipe     Output of locally executed command
  env      Environment variable
  template Jinja2 template after evaluation
  csvfile  Entry in a .csv file
  dnstxt   DNS TXT record
  redis_kv Redis key lookup
  etcd     etcd key lookup
  Ex:
  ...
</pre }>
</td>  
<td>
    <b>group patterns</b><br/>
<pre xxxsmall zoom { >
Other patterns:A
All hosts       <b orange>all</b>
All             <b orange>*</b>
Union           dev<b orange>:</b>staging
Intersection    staging<b orange>:&amp;</b>database
Exclusion       dev<b orange>:!</b>queue
Wildcard        <b orange>*</b>.example.com
Range           web<b orange>[5:10]</b>
Regex           <b orange>~web\d+\.example\.(com|org)</b>
</pre }>
  <hr/>
  <b>Schedule "Serial" execution</b> 
<pre xxxsmall zoom { >
- name: serialized execution
  hosts: hostTargetGroup
  # Run first in one host, if it works, runs 10% at a time, then 30 hosts in parallel
  <b orange>serial:
    - 1
    - "10%"
    - 30
  </b>

  tasks:
    ...
</pre }>
    <br/>
    <b>Schedule "free" strategy</b>(Don't wait for other hosts)
<pre xxxsmall zoom { >
- hosts: all
  connection: local
  <b orange>strategy: free</b>
    ...
</pre }>

</td>  
 
</tr }>
</table } >
<table } >
<tr>
<td>
   <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_vault.html">Handling secrets with vaults</a>
<pre xxxsmall zoom>
- (helps to) keep secrets in (symetric password)encrypted 
files that can be distributed/added to SCM.

<b>RUNNING ANSIBLE-PLAYBOOK AGAINST VAULT PROTECTED YML</b>           | <b>RUNNING ANSIBLE-PLAYBOOK CONTAINING VAULT PROTECTED VARIABLE (Password, secret,...)</b>
                                                               | 
<b>STEP 1: Create the Vault protected playbook :                  | STEP 1:  Create vaulted variable:</b>
   (or role or "embedded file")
$ ansible-vault create myVaultProtectedPlaybook.yml            | $  ansible-vault <b>encrypt_string</b>
                                                               | → mySecretToEncrypt                      Copy&amp;Paste to a yml file:
                                                               | → bla bla blah(Ctrl+D)→ !vault |       ←  vars:
                                                               | →           $ANSIBLE_VAULT;1.1;AES256     - mySecret: !vault |                 
                                                               | →           66386439653236336462...                $ANSIBLE_VAULT;1.1;AES256
                                                               | →           64316265363035303763...                66386439653236336462...
                                                               | →           ...                                    64316265363035303763...
                                                               |                                                    ...
                                                               |
<b>STEP 2: Use the Vault:</b>                                         | <b>STEP 2: (Similar to the vault protected playbook using</b>                     
$ ansible-playbook myVaultProtectedPlaybook.yml \              | <b>--ask-vault-pass|--vault-password-file|ANSIBLE_VAULT_PASSWORD_FILE</b>)
   <b>--ask-vault-pass</b>                                            | 
   ^ prompt user for pass                                      |
     Currently requires all files to                           |
     be encrypted with same password                           |
     Alternative1: use <b>--vault-password-file ~/.vault_pass.txt</b> |
                       <b>                      ~/.vault_pass.py</b>  |
                       </>            ^ password should be a      |
                                string stored as a single line |
     Alternative2:                                             |
      export ANSIBLE_VAULT_PASSWORD_FILE=~/.vault_pass.txt     |
</pre>
</td>
<td>  
  Ex 1: (yum) apache install localhost
<pre xxxsmall zoom>
---
# file: ansible.yml
- hosts: localhost                                                                                                                
  connection: local
  gather_facts: False
  
  vars:
    var_yum_prerequisites: [ 'httpd24'      , 'vim', 'tmux' ]
    var_apt_prerequisites: [ 'apache-server', 'vim', 'tmux' ]

  vars_files:
    - /vars/vars_not_in_git.yml   ←  add to .gitignore
                                     avoid sharing sensitive data 
                                     /vars/vars_not_in_git.yml will look like:
                                     password: !vault |
                                               $ANSIBLE_VAULT;1.1;AES256
                                               ...
                                     


  
  tasks:
   - name: install yum pre-requisites
     when: ansible_os_family == "RedHat"
     become: true
     yum:
       name: {{ var_yum_prerequisites }}
       state: present
     notify:
     - restart-apache2

   - name: install apt pre-requisites
     when: ansible_os_family == "Debian"
     become: true
     apt:
       name: {{ var_apt_prerequisites }}
       state: latest
     notify:
     - restart-apache2

  
  handlers:
  - name: restart-apache2
    service: name=httpd state=restarted
</pre>
</td>  
<td>
  <a href="https://gist.github.com/marktheunissen/2979474">Insanely complet Ansible playbook</a>
<pre xxxsmall zoom>
---
# ^^^ YAML documents must begin with the document separator "---"
#
#### Example docblock, I like to put a descriptive comment at the top of my 
#### playbooks.
#
# Overview: Playbook to bootstrap a new host for configuration management.
# Applies to: production
# Description: 
#   Ensures that a host is configured for management with Ansible.
# 
###########
#
#
# Note:
# YAML, like Python, cares about whitespace.  Indent consistently throughout.
# Be aware! Unlike Python, YAML refuses to allow the tab character for
# indentation, so always use spaces.
#
# Two-space indents feel comfortable to me, but do whatever you like.
# vim:ff=unix ts=2 sw=2 ai expandtab
#
# If you're new to YAML, keep in mind that YAML documents, like XML
# documents, represent a tree-like structure of nodes and text. More
# familiar with JSON?  Think of YAML as a strict and more flexible JSON
# with fewer significant characters (e.g., :, "", {}, [])
#
# The curious may read more about YAML at:
# http://www.yaml.org/spec/1.2/spec.html
#


### 
# Notice the minus on the line below -- this starts the playbook's record
# in the YAML document. Only one playbook is allowed per YAML file.  Indent
# the body of the playbook.
-

  hosts: all
  ###########
  # Playbook attribute: hosts
  # Required: yes
  # Description:
  #   The name of a host or group of hosts that this playbook should apply to.
  #
  ## Example values:
  #   hosts: all -- applies to all hosts
  #   hosts: hostname -- apply ONLY to the host 'hostname'
  #   hosts: groupname -- apply to all hosts in groupname
  #   hosts: group1,group2 -- apply to hosts in group1 & group2
  #   hosts: group1,host1 -- mix and match hosts
  #   hosts: *.mars.nasa.gov wildcard matches work as expected
  #
  ## Using a variable value for 'hosts'
  #
  # You can, in fact, set hosts to a variable, for example:
  #
  #   hosts: $groups -- apply to all hosts specified in the variable $groups
  #
  # This is handy for testing playbooks, running the same playbook against a
  # staging environment before running it against production, occasional
  # maintenance tasks, and other cases where you want to run the playbook
  # against just a few systems rather than a whole group.
  #
  # If you set hosts as shown above, then you can specify which hosts to
  # apply the playbook to on each run as so:
  #
  #   ansible-playbook playbook.yml --extra-vars="groups=staging"
  #
  # Use --extra-vars to set $groups to any combination of groups, hostnames,
  # or wildcards just like the examples in the previous section.
  #

  sudo: True
  ###########
  # Playbook attribute: sudo
  # Default: False
  # Required: no
  # Description:
  #   If True, always use sudo to run this playbook, just like passing the
  #   --sudo (or -s) flag to ansible or ansible-playbook.

  user: remoteuser
  ###########
  # Playbook attribute:  user
  # Default: "root'
  # Required: no
  # Description
  #   Remote user to execute the playbook as

  ###########
  # Playbook attribute: vars
  # Default: none
  # Required: no
  # Description:
  #  Set configuration variables passed to templates & included playbooks
  #  and handlers.  See below for examples.
  vars:
    color: brown

    web:
      memcache: 192.168.1.2
      httpd: apache
    # Tree-like structures work as expected, but be careful to surround
    #  the variable name with ${} when using.
    #
    # For this example, ${web.memcache} and ${web.apache} are both usable
    #  variables.

    ########
    # The following works in Ansible 0.5 and later, and will set $config_path
    # "/etc/ntpd.conf" as expected.
    #
    # In older versions, $config_path will be set to the string "/etc/$config"
    #
    config: ntpd.conf
    config_path: /etc/$config

    ########
    # Variables can be set conditionally. This is actually a tiny snippet
    # of Python that will get filled in and evaluated during playbook execution.
    # This expressioun should always evaluate to True or False.
    #
    # In this playbook, this will always evaluate to False, because 'color'
    #  is set to 'brown' above.
    #
    # When ansible interprets the following, it will first expand $color to
    # 'brown' and then evaluate 'brown' == 'blue' as a Python expression.
    is_color_blue: "'$color' == 'blue'"

    #####
    # Builtin Variables
    #
    # Everything that the 'setup' module provides can be used in the
    # vars section.  Ansible native, Facter, and Ohai facts can all be
    # used.
    #
    # Run the setup module to see what else you can use:
    # ansible -m setup -i /path/to/hosts.ini host1
    main_vhost: ${ansible_fqdn}
    public_ip:  ${ansible_eth0.ipv4.address}
    
    # vars_files is better suited for distro-specific settings, however...
    is_ubuntu: "'${ansible_distribution}' == 'ubuntu'"


  ##########
  # Playbook attribute: vars_files
  # Required: no
  # Description:
  #   Specifies a list of YAML files to load variables from.
  #
  #   Always evaluated after the 'vars' section, no matter which section
  #   occurs first in the playbook.  Examples are below.
  #
  #   Example YAML for a file to be included by vars_files:
  #   ---
  #   monitored_by: phobos.mars.nasa.gov
  #   fish_sticks: "good with custard"
  #   # (END OF DOCUMENT)
  #
  #   A 'vars' YAML file represents a list of variables. Don't use playbook
  #   YAML for a 'vars' file.
  #
  #   Remove the indentation & comments of course, the '---' should be at
  #   the left margin in the variables file.
  #
  vars_files:
    # Include a file from this absolute path
    - /srv/ansible/vars/vars_file.yml

    # Include a file from a path relative to this playbook
    - vars/vars_file.yml

    # By the way, variables set in 'vars' are available here.
    - vars/$hostname.yml

    # It's also possible to pass an array of files, in which case
    # Ansible will loop over the array and include the first file that
    # exists.  If none exist, ansible-playbook will halt with an error.
    #
    # An excellent way to handle platform-specific differences.
    - [ vars/$platform.yml, vars/default.yml ]

    # Files in vars_files process in order, so later files can
    # provide more specific configuration:
    - [ vars/$host.yml ]

    # Hey, but if you're doing host-specific variable files, you might
    # consider setting the variable for a group in your hosts.ini and
    # adding your host to that group. Just a thought.


  ##########
  # Playbook attribute: vars_prompt
  # Required: no
  # Description:
  #   A list of variables that must be manually input each time this playbook
  #   runs.  Used for sensitive data and also things like release numbers that
  #   vary on each deployment.  Ansible always prompts for this value, even
  #   if it's passed in through the inventory or --extra-vars.
  #
  #   The input won't be echoed back to the terminal.  Ansible will always
  #   prompt for the variables in vars_prompt, even if they're passed in via
  #   --extra-vars or group variables.
  #
  #   TODO: I think that the value is supposed to show as a prompt but this
  #   doesn't work in the latest devel
  #
  vars_prompt:
    passphrase: "Please enter the passphrase for the SSL certificate"

    # Not sensitive, but something that should vary on each playbook run.
    release_version: "Please enter a release tag"

  ##########
  # Playbook attribute: tasks
  # Required: yes
  # Description:
  # A list of tasks to perform in this playbook.
  tasks:
    ##########
    # The simplest task
    # Each task must have a name & action.
    - name: Check that the server's alive
      action: ping

    ##########
    # Ansible modules do the work!
    - name: Enforce permissions on /tmp/secret
      action: file path=/tmp/secret mode=0600 owner=root group=root
    #
    # Format 'action' like above:
    # <modulename> <module parameters>
    #
    # Test your parameters using:
    #   ansible -m <module> -a "<module parameters>"
    #
    # Documentation for the stock modules:
    # http://ansible.github.com/modules.html

    ##########
    # Use variables in the task!
    #
    # Variables expand in both name and action
    - name: Paint the server $color
      action: command echo $color


    ##########
    # Trigger handlers when things change!
    #
    # Ansible detects when an action changes something.  For example, the
    # file permissions change, a file's content changed, a package was
    # just installed (or removed), a user was created (or removed).  When 
    # a change is detected, Ansible can optionally notify one or more
    # Handlers.  Handlers can take any action that a Task can. Most
    # commonly they are used to restart a service when its configuration
    # changes. See "Handlers" below for more about handlers.
    #
    # Handlers are called by their name, which is very human friendly.

    # This will call the "Restart Apache" handler whenever 'copy' alters
    # the remote httpd.conf.
    - name: Update the Apache config
      action: copy src=httpd.conf dest=/etc/httpd/httpd.conf
      notify: Restart Apache

    # Here's how to specify more than one handler
    - name: Update our app's configuration
      action: copy src=myapp.conf dest=/etc/myapp/production.conf
      notify:
        - Restart Apache
        - Restart Redis

    ##########
    # Include tasks from another file!
    #
    # Ansible can include a list of tasks from another file. The included file
    # must represent a list of tasks, which is different than a playbook.
    #
    # Task list format:
    #   ---
    #   - name: create user
    #     action: user name=$user color=$color
    #
    #   - name: add user to group
    #     action: user name=$user groups=$group append=true
    #   # (END OF DOCUMENT)
    #
    #   A 'tasks' YAML file represents a list of tasks. Don't use playbook
    #   YAML for a 'tasks' file.
    #
    #   Remove the indentation & comments of course, the '---' should be at
    #   the left margin in the variables file.

    # In this example $user will be 'sklar'
    #  and $color will be 'red' inside new_user.yml
    - include: tasks/new_user.yml user=sklar color=red

    # In this example $user will be 'mosh'
    #  and $color will be 'mauve' inside new_user.yml
    - include: tasks/new_user.yml user=mosh color=mauve

    # Variables expand before the include is evaluated:
    - include: tasks/new_user.yml user=chris color=$color


    ##########
    # Run a task on each thing in a list!
    #
    # Ansible provides a simple loop facility. If 'with_items' is provided for
    # a task, then the task will be run once for each item in the 'with_items'
    # list.  $item changes each time through the loop.
    - name: Create a file named $item in /tmp
      action: command touch /tmp/$item
      with_items:
        - tangerine
        - lemon

    ##########
    # Choose between files or templates!
    #
    # Sometimes you want to choose between local files depending on the
    # value of the variable.  first_available_file checks for each file
    # and, if the file exists calls the action with $item={filename}.
    #
    # Mostly useful for 'template' and 'copy' actions.  Only examines local
    # files.
    #
    - name: Template a file
      action: template src=$item dest=/etc/myapp/foo.conf
      first_available_file:
        # ansible_distribution will be "ubuntu", "debian", "rhel5", etc.
        - templates/myapp/${ansible_distribution}.conf

        # If we couldn't find a distribution-specific file, use default.conf:
        - templates/myapp/default.conf

    ##########
    # Conditionally execute tasks!
    #
    # Sometimes you only want to run an action when a under certain conditions.
    # Ansible will 'only_if' as a Python expression and will only run the
    # action when the expression evaluates to True.
    #
    # If you're trying to run an task only when a value changes,
    # consider rewriting the task as a handler and using 'notify' (see below).
    #
    - name: "shutdown all ubuntu"
      action: command /sbin/shutdown -t now
      only_if: "$is_ubuntu"

    - name: "shutdown the government"
      action: command /sbin/shutdown -t now
      only_if: "'$ansible_hostname' == 'the_government'"

    ##########
    # Notify handlers when things change!
    # 
    # Each task can optionally have one or more handlers that get called
    # when the task changes something -- creates a user, updates a file,
    # etc.
    #
    # Handlers have human-readable names and are defined in the 'handlers'
    #  section of a playbook.  See below for the definitions of 'Restart nginx'
    #  and 'Restart application'
    - name: update nginx config
      action: file src=nginx.conf dest=/etc/nginx/nginx.conf
      notify: Restart nginx

    - name: roll out new code
      action: git repo=git://codeserver/myapp.git dest=/srv/myapp version=HEAD branch=release
      notify:
        - Restart nginx
        - Restart application


    ##########
    # Run things as other users!
    #
    # Each task has an optional 'user' and 'sudo' flag to indicate which
    # user a task should run as and whether or not to use 'sudo' to switch
    # to that user.
    - name: dump all postgres databases
      action: pg_dumpall -w -f /tmp/backup.psql
      user: postgres
      sudo: False

    ##########
    # Run things locally!
    #
    # Each task also has a 'connection' setting to control whether a local
    # or remote connection is used.  The only valid options now are 'local'
    # or 'paramiko'.  'paramiko' is assumed by the command line tools.
    #
    # This can also be set at the top level of the playbook.
    - name: create tempfile
      action: dd if=/dev/urandom of=/tmp/random.txt count=100
      connection: local

  ##########
  # Playbook attribute: handlers
  # Required: no
  # Description:
  #   Handlers are tasks that run when another task has changed something.
  #   See above for examples.  The format is exactly the same as for tasks.
  #   Note that if multiple tasks notify the same handler in a playbook run
  #   that handler will only run once.
  #
  #   Handlers are referred to by name. They will be run in the order declared
  #   in the playbook.  For example: if a task were to notify the
  #   handlers in reverse order like so:
  #
  #   - task: touch a file
  #     action: file name=/tmp/lock.txt
  #     notify:
  #     - Restart application
  #     - Restart nginx
  #
  #   The "Restart nginx" handler will still run before the "Restart
  #   application" handler because it is declared first in this playbook.
  handlers:
    - name: Restart nginx
      action: service name=nginx state=restarted

    # Any module can be used for the handler action
    - name: Restart application
      action: command /srv/myapp/restart.sh

    # It's also possible to include handlers from another file.  Structure is
    # the same as a tasks file, see the tasks section above for an example.
- include: handlers/site.yml
</pre>
</td> 


</tr }>
</table } >
</body>
<!--
TODO_START:
https://napalm-automation.net/

Napalm is a vendor neutral, cross-platform open source project that provides a unified API to network devices.

https://stackoverflow.com/questions/33931610/ansible-handler-notify-vs-register


https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html


https://docs.ansible.com/ansible/2.5/user_guide/intro_dynamic_inventory.html (EC2, OpenStack,...)S

________________
Ronald Kurr has lot of very-useful and professional Ansible powered code to provide JVM, Python, Desktops, ... machines. For example:
   https://github.com/kurron/aws-open-vpn
____________
TODO: Provisioning new VMs to clods like EC2, Azure, Digital Ocean, 
  Google Compute Engine, Linode, Rackspace, OVH, and any cloud
  supporting OpenStack API (OVH, ...)
___________________
<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#fact-caching">Fact Caching</a>

To benefit from cached facts you will set gather_facts to False in most plays.

Ansible ships with two persistent cache plugins: redis and jsonfile.

To configure fact caching using redis, enable it in ansible.cfg as follows:

[defaults]
gathering = smart
fact_caching = redis
fact_caching_timeout = 86400
__________________________
https://sysadmincasts.com/episodes/46-configuration-management-with-ansible-part-3-4

-->

</html>
