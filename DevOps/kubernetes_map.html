<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Kubernetes map(beta)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<table { >
<tr {>
  <a href="https://kubernetes.io/">Kubernetes</a> ,
<a href="https://serverfault.com/questions/tagged/kubernetes?sort=votes">[k8s]@severfault</a>,
<a href="https://stackoverflow.com/questions/tagged/kubernetes?sort=votes">[k8s]@stackoverflow</a>,
<a href="https://github.com/kubernetes/examples">Real app Examples</a>,
<a TODO href="https://www.nomadproject.io/intro/vs/kubernetes.html">k8s vs Nomad</a>,
<a href="https://labs.play-with-k8s.com/">k8s Playground</a>,
<td xsmall>
  Summary
  <ul xxxsmall zoom>
  <li>k8s orchestates pools of CPUs, storage and networks</li>
  <li><b>Kubernet Master</b> is responsible for managing the cluster, coordinates
     all activities in your cluster, such as scheduling applications, 
     maintaining applications' desired state, scaling applications, and rolling
     out new updates</li>
  <li>orchestation offers:
    <ul>
    <li>Load balancing a set of containers with or without session affinity</li>
    <li>Mounting persistent storage inside of the containers</li>
    <li>Placement and scheduling of containers on the infrastructure</li>
    <li>Rolling deployments and operational considerations that traditional 
        developers are not experts on</li>
    </ul>
  </li>
  <li>A <b>node</b> is a (VM) computer serving as a worker machine. Each node has a Kubelet agent plus tools like Docker or rkt.</li>
  <li>A cluster handling <b>production traffic</b> should have a <b>minimum of three nodes</b>(3,5,..."odd" number) since <a href="https://raft.github.io/">Raft("voting")</a> consensus is used.</li>
  </ul>
  External Links:
  <ul xxxsmall zoom>
  <li><a href="https://www.youtube.com/watch?v=PH-2FfFD2PU">Desired State management"</a></li>
  <li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-kubernetes">Digital Ocean  tutorial</a></li>
  </ul>

  k8s components
<pre xxxsmall zoom>
- Etcd : distributed key-value store
        (can be distributed across multiple nodes).                  
        used for <a href="../Architecture/architecture_map.html?query=service+registration+discovery">Service Registration and discovery</a>

- (REST)API Server: cluster main management point
   + allows users to configure many of K8s workloads
     and organizational units.                                           
                                                                     
- Controller Manager Service:                                        
   + general service handling a number of controllers
     that regulate the state                 
     of the cluster and perform routine tasks                        
     (ensures number of replicas for a service, ...)                 
                                                                     
- Scheduler Service                                                  
   + Assigns workloads to nodes:                                     
   + responsible for tracking resource utilization on hosts
   + It must know the total resources available on each server       
     as well as the resources allocated to existing workloads        
     assigned on each server.                                        
                                                                     
- Nodes
</pre>
  (defaul) TCP Ports
<pre xxxsmall zoom>
|<a href="https://kubernetes.io/docs/tasks/tools/install-kubeadm/">Default (TCP) Ports</a>
|                                       +-------+-------+
|                                       |Master |Worker |
|                                       |node(s)|node(s)|
|+--------------------------------------+-------+-------+
||Port Range   | Purpose                |   X   |       |
|+--------------------------------------+-------+-------+
||6443*        | Kubernetes API server  |   X   |       |
|+--------------------------------------+-------+-------+
||2379-2380    | etcd server client API |   X   |       |
|+--------------------------------------+-------+-------+
||10250        | Kubelet API            |   X   |  X    |
|+--------------------------------------+-------+-------+
||10251        | kube-scheduler         |   X   |       |
|+--------------------------------------+-------+-------+
||10252        | kube-controller-manager|   X   |       |
|+--------------------------------------+-------+-------+
||10255        | Read-only Kubelet API  |   X   |  X    |
|+--------------------------------------+-------+-------+
|| 30000-32767 | NodePort Services      |       |  X    |
|+--------------------------------------+-------+-------+
</pre>

 kubectl CLI
<pre xxxsmall zoom bgorange>
<a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/">JSONPath Support</a>
<a href="https://kubernetes.io/docs/reference/kubectl/overview/">Overview of kubectl</a>
<a href="https://kubernetes.io/docs/reference/kubectl/kubectl/">kubectl</a>
<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/">kubectl Cheat Sheet</a>
<a href="https://kubernetes.io/docs/reference/kubectl/kubectl-cmds/">kubectl Commands</a>
<a href="https://kubernetes.io/docs/reference/kubectl/conventions/">kubectl Usage Conventions</a>
<a href="https://kubernetes.io/docs/reference/kubectl/docker-cli-to-kubectl/">kubectl for Docker Users</a>

<a href="https://kubernetes.io/docs/reference/tools/">Tools</a>


$ kubectl &lt;action&gt; &lt;resource&gt;
<a href='https://github.com/kubernetes/kubernetes/tree/master/docs/user-guide/kubectl'>kubectl manual</a> command line interface to Kubernetes API
 <b>get     </b>: list resources
 <b>describe</b>: show detailed info for resource
 <b>logs    </b>: print container logs 
 <b>exec    </b>: exec command on container

    clusters            │podtemplates               │statefulsets
(cs)componentstatuses   │(rs)replicasets            │(pvc)persistentvolumeclaims
(cm)configmaps          │(rc)replicationcontrollers │(pv) persistentvolumes
(ds)daemonsets          │(quota)resourcequotas      │(po) pods
(deploy)deployments     │cronjob                    │(psp)podsecuritypolicies
(ep)endpoints           │jobs                       │secrets
(ev)event               │(limits)limitranges        │(sa)serviceaccount
(hpa)horizon...oscalers │(ns)namespaces             │(svc)services
(ing)ingresses          │networkpolicies            │storageclasses
                        │(no)nodes                  │thirdpartyresources
</pre>


</td>
<td colsep></td>
<td>
<a href="https://kubernetes.io/docs/concepts/">Concepts</a>
<hr xxxsmall />
Overview
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">What is Kubernetes?</a>
<a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes Components</a>
<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">The Kubernetes API</a>
</pre>
 <span TODO xsmall>Working with k8s Objects</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/">Understanding Kubernetes Objects</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/">Names</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">Namespaces</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">Labels and Selectors</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">Annotations</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/">Field Selectors</a>
<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/">Recommended Labels</a>
</pre>
 <span TODO xsmall>Object Management Using kubectl</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/">Kubernetes Object Management</a>
<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-command/">Managing Kubernetes Objects Using Imperative Commands</a>
<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-config/">Imperative Management of Kubernetes Objects Using Configuration Files</a>
<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/declarative-config/">Declarative Management of Kubernetes Objects Using Configuration Files</a>
</pre>
 <span TODO xsmall>Compute, Storage, and Networking Extensions</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/cluster-administration-overview/">Cluster Administration Overview</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/">Certificates</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/">Cloud Providers</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/">Managing Resources</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/">Cluster Networking</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">Logging Architecture</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/">Configuring kubelet Garbage Collection</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/federation/">Federation</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/proxies/">Proxies in Kubernetes</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/controller-metrics/">Controller manager metrics</a>
<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">Installing Addons</a>
</pre>
</td>
<td>
 <span TODO xsmall>k8s Architecture</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/architecture/nodes/">Nodes</a>
<a href="https://kubernetes.io/docs/concepts/architecture/master-node-communication/">Master-Node communication</a>
<a href="https://kubernetes.io/docs/concepts/architecture/cloud-controller/">Concepts Underlying the Cloud Controller Manager</a>
</pre>
 <span TODO xsmall>Extending Kubernetes</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/extend-cluster/">Extending your Kubernetes Cluster</a>
</pre>
 <span TODO xsmall>Extending the Kubernetes API</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">Extending the Kubernetes API with the aggregation layer</a>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resources</a>
</pre>
 <span TODO xsmall>Compute, Storage, and Networking Extensions</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">Network Plugins</a>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">Device Plugins</a>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/">Service Catalog</a>
</pre>
 <span TODO xsmall>Containers</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/containers/images/">Images</a>
<a href="https://kubernetes.io/docs/concepts/containers/container-environment-variables/">Container Environment Variables</a>
<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/">Container Lifecycle Hooks</a>
</pre>
</td>
<td>
 <span TODO xsmall>Workloads Pods</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod Overview</a>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">Pods</a>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/">Pod Lifecycle</a>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">Init Containers</a>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/podpreset/">Pod Preset</a>
<a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/">Disruptions</a>
</pre>
 <span TODO xsmall>Workloads Controllers</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployments</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/">Garbage Collection</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Jobs - Run to Completion</a>
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>
</pre>
 <span TODO xsmall>Configuration</span>
<pre xxxsmall zoom>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/overview/">Configuration Best Practices</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/">Managing Compute Resources for Containers</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/">Assigning Pods to Nodes</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">Taints and Tolerations</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">Organizing Cluster Access Using kubeconfig Files</a>
<a TODO href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/">Pod Priority and Preemption</a>
</pre>
 <span TODO xsmall>Services, Load Balancing, and Networking</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a>
<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">DNS for Services and Pods</a>
<a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/">Connecting Applications with Services</a>
<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a>
<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Network Policies</a>
<a href="https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/">Adding entries to Pod /etc/hosts with HostAliases</a>
</pre>
 <span TODO xsmall>Storage</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/storage/volumes/">Volumes</a>
<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a>
<a href="https://kubernetes.io/docs/concepts/storage/storage-classes/">Storage Classes</a>
<a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">Dynamic Volume Provisioning</a>
<a href="https://kubernetes.io/docs/concepts/storage/storage-limits/">Node-specific Volume Limits</a>
</pre>
 <span TODO xsmall>Policies</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/">Resource Quotas</a>
<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/">Pod Security Policies</a>
</pre>
</td>
<td colsep></td>
<td>
<ul xsmall zoom>
  <li><a class="item yah"  href="https://kubernetes.io/docs/reference/">Reference</a></li>
  <li><a href="https://kubernetes.io/docs/reference/glossary/">Standardized Glossary</a></li>
  <li>
    Kubernetes Issues and Security
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/reference/issues-security/issues/">Kubernetes Issue Tracker</a>
<a href="https://kubernetes.io/docs/reference/issues-security/security/">Kubernetes Security and Disclosure Information</a>
  </li>
</pre>
</ul>
 <span TODO xsmall>K8s API</span>
<pre xxxsmall zoom>
Using the Kubernetes API
<a href="https://kubernetes.io/docs/reference/using-api/api-overview/">Kubernetes API Overview</a>
<a href="https://kubernetes.io/docs/reference/using-api/api-concepts/">Kubernetes API Concepts</a>
<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/">Client Libraries</a>
<a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">Kubernetes Deprecation Policy</a>

 <span TODO xsmall>Accessing the API</span>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/">Controlling Access to the Kubernetes API</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">Authenticating</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/">Authenticating with Bootstrap Tokens</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Using Admission Controllers</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/">Managing Service Accounts</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">Authorization Overview</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/abac/">Using ABAC Authorization</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">Using Node Authorization</a>
<a href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/">Webhook Mode</a>


 <span TODO xsmall>API Reference</span>
  <a href="https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/">Well-Known Labels, Annotations and Taints</a>
  <a href="https://kubernetes.io/docs/reference/kubernetes-api/">v1.11</a>
  
  
 <span TODO xsmall>Federation API</span>
  <a href="https://kubernetes.io/docs/reference/federation/extensions/v1beta1/definitions/">extensions/v1beta1 Model Definitions</a>
  <a href="https://kubernetes.io/docs/reference/federation/extensions/v1beta1/operations/">extensions/v1beta1 Operations</a>
  <a href="https://kubernetes.io/docs/reference/federation/v1/definitions/">v1 Model Definitions</a>
  <a href="https://kubernetes.io/docs/reference/federation/v1/operations/">v1 Operations</a>
</pre>

 <span TODO xsmall>SETUP TOOLS REF</span>
<pre xxxsmall zoom>
Kubeadm
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">Overview of kubeadm</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-version/">kubeadm version</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/">Implementation details</a>

 <span TODO xsmall>kubefed</span>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed/">kubefed</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed-options/">kubefed options</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed-init/">kubefed init</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed-join/">kubefed join</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed-unjoin/">kubefed unjoin</a>
<a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed-version/">kubefed version</a>
</pre>



 <span TODO xsmall>cli reference</span>
<pre xxxsmall zoom>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/">Feature Gates</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/federation-apiserver/">federation-apiserver</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/federation-controller-manager/">federation-controller-manager</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/">Kubelet authentication/authorization</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/cloud-controller-manager/">cloud-controller-manager</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler</a>
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet</a>
</pre>

 <span TODO xsmall>Config. files</span>
   <ul xxxsmall zoom>
   <li>(documented in the Reference section of the online documentation, under each binary:)</li>
   <li><a href="/docs/admin/kubelet/">kubelet</a></li>
   <li><a href="/docs/admin/kube-apiserver/">kube-apiserver</a></li>
   <li><a href="/docs/admin/kube-controller-manager/">kube-controller-manager</a></li>
   <li><a href="/docs/admin/kube-scheduler/">kube-scheduler</a>.</li>
   </ul>
</td>
<td colsep></td>
<td>
 <span TODO xsmall>Config. files</span>
<a href=https://kubernetes.io/docs/tasks/">Tasks</a>
<hr xxxsmall />

 <span TODO xsmall>Install Tools</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/tools/install-kubectl/">Install and Set Up kubectl</a>
<a href=https://kubernetes.io/docs/tasks/tools/install-minikube/">Install Minikube</a>
</pre>
 <span TODO xsmall>Config Pods/Cont.</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/">Assign Memory Resources to Containers and Pods</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/">Assign CPU Resources to Containers and Pods</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/">Configure Quality of Service for Pods</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/extended-resource/">Assign Extended Resources to a Container</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-volume-storage/">Configure a Pod to Use a Volume for Storage</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">Configure a Pod to Use a PersistentVolume for Storage</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-projected-volume-storage/">Configure a Pod to Use a Projected Volume for Storage</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">Configure a Security Context for a Pod or Container</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Configure Service Accounts for Pods</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">Pull an Image from a Private Registry</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Configure Liveness and Readiness Probes</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/">Assign Pods to Nodes</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/">Configure Pod Initialization</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/">Attach Handlers to Container Lifecycle Events</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">Configure a Pod to Use a ConfigMap</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/">Share Process Namespace between Containers in a Pod</a>
<a href=https://kubernetes.io/docs/tasks/configure-pod-container/translate-compose-kubernetes/">Translate a Docker Compose File to Kubernetes Resources</a>
</pre>
 <span TODO xsmall>kubeadm: Cluster Admin</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-ha/">Upgrading kubeadm HA clusters from 1.9.x to 1.9.y</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-8/">Upgrading kubeadm clusters from 1.7 to 1.8</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-11/">Upgrading kubeadm clusters from v1.10 to v1.11</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-9/">Upgrading/downgrading kubeadm clusters between v1.8 to v1.9</a>
</pre>
 <span TODO xsmall>Manage Mem./CPU/API Resrc.</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">Configure Default Memory Requests and Limits for a Namespace</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">Configure Default CPU Requests and Limits for a Namespace</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">Configure Minimum and Maximum Memory Constraints for a Namespace</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">Configure Minimum and Maximum CPU Constraints for a Namespace</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">Configure Memory and CPU Quotas for a Namespace</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/">Configure a Pod Quota for a Namespace</a>
</pre>
 <span TODO xsmall>Install Net.Pol.Prov</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/">Use Calico for NetworkPolicy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/">Use Cilium for NetworkPolicy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/">Use Kube-router for NetworkPolicy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/">Romana for NetworkPolicy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/">Weave Net for NetworkPolicy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/">Access Clusters Using the Kubernetes API</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-services/">Access Services Running on Clusters</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/extended-resource-node/">Advertise Extended Resources for a Node</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/dns-horizontal-autoscaling/">Autoscale the DNS Service in a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/change-pv-reclaim-policy/">Change the Reclaim Policy of a PersistentVolume</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/">Change the default StorageClass</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/">Cluster Management</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/">Configure Multiple Schedulers</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/">Configure Out Of Resource Handling</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/quota-api-object/">Configure Quotas for API Objects</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/">Control CPU Management Policies on the Node</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/">Customizing DNS Service</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/">Debugging DNS Resolution</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/">Declare Network Policy</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/developing-cloud-controller-manager/">Developing Cloud Controller Manager</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">Encrypting Secret Data at Rest</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/">Guaranteed Scheduling For Critical Add-On Pods</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/ip-masq-agent/">IP Masquerade Agent User Guide</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/">Kubernetes Cloud Controller Manager</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/limit-storage-consumption/">Limit Storage Consumption</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/">Namespaces Walkthrough</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/">Operating etcd clusters for Kubernetes</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/">Reconfigure a Node's Kubelet in a Live Cluster</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/">Reserve Compute Resources for System Daemons</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/">Safely Drain a Node while Respecting Application SLOs</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/">Securing a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">Set Kubelet parameters via a config file</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/highly-available-master/">Set up High-Availability Kubernetes Masters</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/namespaces/">Share a Cluster with Namespaces</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/static-pod/">Static Pods</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/storage-object-in-use-protection/">Storage Object in Use Protection</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/coredns/">Using CoreDNS for Service Discovery</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/">Using a KMS provider for data encryption</a>
<a href=https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/">Using sysctls in a Kubernetes Cluster</a>
</pre>
 <span TODO xsmall>Inject Data Into Apps</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/">Define a Command and Arguments for a Container</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/">Define Environment Variables for a Container</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/">Expose Pod Information to Containers Through Environment Variables</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/">Expose Pod Information to Containers Through Files</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">Distribute Credentials Securely Using Secrets</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/podpreset/">Inject Information into Pods Using a PodPreset</a>
</pre>
</td>
<td>
 <span TODO xsmall>Run Applications</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">Run a Stateless Application Using a Deployment</a>
<a href=https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/">Run a Single-Instance Stateful Application</a>
<a href=https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/">Run a Replicated Stateful Application</a>
<a href=https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/">Update API Objects in Place Using kubectl patch</a>
<a href=https://kubernetes.io/docs/tasks/run-application/scale-stateful-set/">Scale a StatefulSet</a>
<a href=https://kubernetes.io/docs/tasks/run-application/delete-stateful-set/">Delete a StatefulSet</a>
<a href=https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/">Force Delete StatefulSet Pods</a>
<a href=https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/">Perform Rolling Update Using a Replication Controller</a>
<a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">Horizontal Pod Autoscaler</a>
<a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">Horizontal Pod Autoscaler Walkthrough</a>
<a href=https://kubernetes.io/docs/tasks/run-application/configure-pdb/">Specifying a Disruption Budget for your Application</a>
</pre>
 <span TODO xsmall>Run Jobs</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/">Running Automated Tasks with a CronJob</a>
<a href=https://kubernetes.io/docs/tasks/job/parallel-processing-expansion/">Parallel Processing using Expansions</a>
<a href=https://kubernetes.io/docs/tasks/job/coarse-parallel-processing-work-queue/">Coarse Parallel Processing Using a Work Queue</a>
<a href=https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/">Fine Parallel Processing Using a Work Queue</a>
</pre>
 <span TODO xsmall>Access Applications in a Cluster</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Web UI (Dashboard)</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/">Accessing Clusters</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">Configure Access to Multiple Clusters</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/">Use Port Forwarding to Access Applications in a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/load-balance-access-application-cluster/">Provide Load-Balanced Access to an Application in a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/service-access-application-cluster/">Use a Service to Access an Application in a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/connecting-frontend-backend/">Connect a Front End to a Back End Using a Service</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/">Create an External Load Balancer</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/">Configure Your Cloud Provider's Firewalls</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/">List All Container Images Running in a Cluster</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/">Communicate Between Containers in the Same Pod Using a Shared Volume</a>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/configure-dns-cluster/">Configure DNS for a Cluster</a>
</pre>

 <span TODO xsmall>Monitor, Log, and Debug</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/">Application Introspection and Debugging</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/">Auditing</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/core-metrics-pipeline/">Core metrics pipeline</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-init-containers/">Debug Init Containers</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-pod-replication-controller/">Debug Pods and ReplicationControllers</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/">Debug Services</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-stateful-set/">Debug a StatefulSet</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/crictl/">Debugging Kubernetes nodes with crictl</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/">Determine the Reason for Pod Failure</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/">Developing and debugging services locally</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/events-stackdriver/">Events in Stackdriver</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/">Get a Shell to a Running Container</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/logging-elasticsearch-kibana/">Logging Using Elasticsearch and Kibana</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/logging-stackdriver/">Logging Using Stackdriver</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/monitor-node-health/">Monitor Node Health</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/">Tools for Monitoring Resources</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application/">Troubleshoot Applications</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/">Troubleshoot Clusters</a>
<a href=https://kubernetes.io/docs/tasks/debug-application-cluster/troubleshooting/">Troubleshooting</a>
</pre>
 <span TODO xsmall>Extend Kubernetes<br/>
   Use Custom Resources</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/">Extend the Kubernetes API with CustomResourceDefinitions</a>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning/">Versions of CustomResourceDefinitions</a>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/migrate-third-party-resource/">Migrate a ThirdPartyResource to CustomResourceDefinition</a>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/">Configure the Aggregation Layer</a>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/setup-extension-api-server/">Setup an Extension API Server</a>
<a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/">Use an HTTP Proxy to Access the Kubernetes API</a>
</pre>
</td>
<td>

 <span TODO xsmall>TLS</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/tls/certificate-rotation/">Certificate Rotation</a>
<a href=https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/">Manage TLS Certificates in a Cluster</a>
</pre>
 <span TODO xsmall>Federation - Run an App on Multiple Clusters</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/federation/federation-service-discovery/">Cross-cluster Service Discovery using Federated Services</a>
<a href=https://kubernetes.io/docs/tasks/federation/set-up-cluster-federation-kubefed/">Set up Cluster Federation with Kubefed</a>
<a href=https://kubernetes.io/docs/tasks/federation/set-up-coredns-provider-federation/">Set up CoreDNS as DNS provider for Cluster Federation</a>
<a href=https://kubernetes.io/docs/tasks/federation/set-up-placement-policies-federation/">Set up placement policies in Federation</a>
</pre>
 <span TODO xsmall>Manage Cluster Daemons</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/manage-daemon/rollback-daemon-set/">Perform a Rollback on a DaemonSet</a>
<a href=https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/">Perform a Rolling Update on a DaemonSet</a>
</pre>
 <span TODO xsmall>Install Service Catalog</span>
<pre xxxsmall zoom>
<a href=https://kubernetes.io/docs/tasks/service-catalog/install-service-catalog-using-helm/">Install Service Catalog using Helm</a>
<a href=https://kubernetes.io/docs/tasks/service-catalog/install-service-catalog-using-sc/">Install Service Catalog using SC</a>
</pre>
 <span TODO xsmall>Federation - Run an App on Multiple Clusters</span>
<pre xxxsmall zoom>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/cluster/">Federated Cluster</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/configmap/">Federated ConfigMap</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/daemonset/">Federated DaemonSet</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/deployment/">Federated Deployment</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/events/">Federated Events</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/hpa/">Federated Horizontal Pod Autoscalers (HPA)</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/ingress/">Federated Ingress</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/job/">Federated Jobs</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/namespaces/">Federated Namespaces</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/replicaset/">Federated ReplicaSets</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/secret/">Federated Secrets</a>
<a TODO href=https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/">Extend kubectl with plugins</a>
<a TODO href=https://kubernetes.io/docs/tasks/manage-hugepages/scheduling-hugepages/">Manage HugePages</a>
<a TODO href=https://kubernetes.io/docs/tasks/manage-gpus/scheduling-gpus/">Schedule GPUs</a>
</pre>
</td>
 
</tr }>
</table } >

<table { >
<tr {>
  <th colspan=5 header_delimit {   ><a href='https://kubernetes.io/docs/concepts/'>Building Blocks</a></th>
  <th colsep></th>
  <th colspan=1></th>
</tr }>
<tr {>
<td>
  <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">Namespace</a>
  <ul xxxsmall>
  <li TODO><a href='https://kubernetes.io/docs/tasks/administer-cluster/namespaces/'>
    Admin Guide for Namespaces</a>
  </li>
  <li>Kubernetes supports multiple virtual clusters backed by the same physical
      cluster. These virtual clusters are called namespaces</li>
  <li>Provide a scope for names</li>
  <li>Namespaces are intended for use in environments with many users spread 
    across multiple teams, or projects. For clusters with a few to tens of users,
    you should not need to create or think about namespaces at all. Start 
    using namespaces when you need the features they provide.</li>
  <li>use labels, not namespaces, to distinguish resources within the same namespace</li>
  <li>Services are created with DNS entry
    "service-name"."namespace".svc.cluster.local</li>
  </ul>
  <hr/>
  <ul xxxsmall>
  <li> Initial namespaces:
<pre xxxsmall { >
$ kubectl get namespaces
NAME          STATUS    AGE
default       Active    1d 
kube-system   Active    1d 
</pre>
  </li>
  <li>create namespace:
<pre { >
$ kubectl create namespace my-namespace
</pre>
  </li>
  <li>temporarily set the NS for a request:
<pre { >
$ kubectl --namespace=my-namespace \
    run nginx --image=nginx
</pre } >
  </li>
  <li>permanently save the NS:
<pre { >
$ kubectl config set-context \
    $(kubectl config current-context) \
    --namespace=MyFavouriteNS
$ kubectl config view | \
    grep namespace: # Validate
</pre } >
  </li>
  </ul>
</td>
<td>
  <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>


  <ul xxxsmall zoom>
  <li>Kubernetes abstraction that represents a group of one or more application
    containers (such as Docker or rkt), and some shared resources for those 
    containers. Those resources include:
    <ul>
    <li>Shared storage, as Volumes</li>
    <li>Networking, as a unique cluster IP address</li>
    <li>Information about how to run each container, such as the container image
        version or specific ports to use</li>
    </ul>
  </li>
  <li>A Pod models an application-specific "logical host" and can contain 
    different application containers which are relatively tightly coupled. 
    For example, a Pod might include both the container with your Node.js app 
    as well as a different container that feeds the data to be published by the
    Node.js webserver. The containers in a Pod share an IP Address and port 
    space, are always co-located and co-scheduled, and run in a shared context 
    on the same Node.</li>
  <li>Pods are the atomic unit on the Kubernetes platform. When we create a 
    Deployment on Kubernetes, that Deployment creates Pods with containers 
    inside them (as opposed to creating containers directly). Each Pod is tied 
    to the Node where it is scheduled, and remains there until termination 
    (according to restart policy) or deletion. In case of a Node failure, 
    identical Pods are scheduled on other available Nodes in the cluster.</li>
  <li>The containers in a Pod are automatically co-located and co-scheduled 
    on the same physical or virtual machine in the cluster. The containers 
    can share resources and dependencies, communicate with one another, and 
    coordinate when and how they are terminated.</li>
  <li>Note that grouping multiple co-located and co-managed containers in a 
    single Pod is a relatively advanced use case. You should use this pattern 
    only in specific instances in which your containers are tightly coupled. 
    The one container per pod is the recomended use-case.</li>
  <li>Pods do not, by themselves, self-heal. Thus, while it is possible to
    use Pod directly, it’s far more common in Kubernetes to manage your pods 
    using a Controller to implement Pod scaling and healing.</li>
  <li>Largely inmutable, changes cannot be made to the definition while 
    it is running and do NOT maintain state when recreated. Therefore pods
    should usually be managed by higher-level controllers, rather than
    directly by users.</li>
  </ul>
  Pod Life Cicle
<pre xxxsmall zoom>
 DEFINITION                                               END
  defined   → scheduled in node → run → alt1: run until their container(s) exit
                                        alt2: pod removed (for any other reason)
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                  depending on policy and exit code, 
                                                  may be removed after exiting, or
                                                  may be retained in order to enable
                                                  access containers logs.

 


</pre>


  Ex. YAML:
<pre xxxsmall zoom {>
apiVersion: v1
kind: Pod
metadata:
name: test-pd
spec:
containers:
  - image: gcr.io/google_containers/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache    &lt;-- where to mount
      name: cache-volume   &lt;-- volume (name) to mount
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: cache-volume
    emptyDir: {}
  - name: test-volume
    hostPath:
      # directory location on host
      path: /data
      # this field is optional
      type: Directory
</pre } >
   <a TODO href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">RestartPolicy</a><br/>

  Mng. running pod:
<pre xxxsmall { >
$ kubectl logs my-pod (-c my-container) (-f)
                                         ^"tail -f"
$ kubectl run -i --tty busybox --image=busybox -- sh
$ kubectl attach my-pod -i
$ kubectl port-forward my-pod 5000:6000  # Forward port 6000 of Pod -> 5000 local machine
$ kubectl exec my-pod (-c my-container) -- ls / # Run command in existing pod 
$ kubectl top pod POD_NAME --containers
</pre } >


</td>  
<td>
  <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a>
<pre xxxsmall zoom>
(Check link for -many more info- about kube-proxy + iptables +... advanced config settings)
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
  - name: https
    protocol: TCP
    port: 443
    targetPort: 9377

- Defines a logical set of Pods (usually determined by a Label Selector) and
  a policy by which to access them.

- Kubernetes-native applications: K8s offers a simple Endpoints API
- non-native        applications: K8s offers virtual-IP-based-2-Service bridge

ServiceTypes:
 +-------------+---------------------------------+----------------------
 |Type         | Description                     | External Access
 +-------------+---------------------------------+----------------------
 |ClusterIP    | (default) Exposes the service   | (None)
 |             | on a cluster-internal IP.       | 
 +-------------+---------------------------------+----------------------
 |NodePort     |                                 | (each)NodeIP:NodePort
 +-------------+---------------------------------+----------------------
 |LoadBalancer | uses a cloud provider           | ClusterIP:NodePort
 |             | load balancer                   | ^spec.clusterIP
 |             |                                 | 
 |             |                                 | 
 +-------------+---------------------------------+----------------------
 |ExternalName | Maps the service to the contents| foo.bar.example.com
 |             | of the "externalName" field     | 
 |             | by returning a CNAME record.    | 
 +-------------+---------------------------------+----------------------

  
By default, the choice of backend is round robin.
Client-IP based session affinity can be selected
by setting:
    service.spec.sessionAffinity: "ClientIP" 
    service.spec.sessionAffinityConfig.clientIP.timeoutSeconds : 100 (Optional, defaults to 10800)

When a Pod is run on a Node, the kubelet adds a set of ENV.VARs. for each active Service.
This does imply an ordering requirement:
  - any Service that a Pod wants to access must be created before the Pod itself,
    or else the environment variables will not be populated.
    (DNS does not have this restriction)

  Ex: Service "redis-master" @ ClusterIP 10.0.0.11:6379:
  | REDIS_MASTER_SERVICE_HOST=10.0.0.11
  | REDIS_MASTER_SERVICE_PORT=6379
  | REDIS_MASTER_PORT=tcp://10.0.0.11:6379
  | REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
  | REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
  | REDIS_MASTER_PORT_6379_TCP_PORT=6379
  | REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
  
  DNS server: optional (strongly recommended) add-on.
    The DNS server watches the Kubernetes API for new Services and creates a set of DNS records for each.
    For example, if you have a Service called "my-service" in Kubernetes Namespace "my-ns" a DNS record 
    "my-service.my-ns" is created.

</pre>
</td>  

<td>
  <a href="https://kubernetes.io/docs/concepts/storage/volumes/">Volume</a><br/>
  <span xsmall>lifetime of pod (vs docker container)</span>
<pre xxxsmall zoom>
- many types supported, and a Pod can use any number
   of them simultaneously.
- a pod specifies what volumes to provide for the pod (spec.volumes) and 
    where to mount those into each container(spec.containers.volumeMounts).

- Sometimes, it is useful to share one volume for 
  multiple uses in a single pod. The volumeMounts.subPath
  property can be used to specify a sub-path inside the
  referenced volume instead of its root.


</pre>
</td>

<td>
  <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors/">Labels&amp;Selectors</a>
  <ul xxxsmall zoom>
  <li>Labels are key/value pairs attached to objects.</li>
  <li>Unlike names and UIDs, labels do not provide uniqueness. In general, 
    we expect many objects to carry the same label(s)</li>

  <li>at creation time and subsequently added and modified at any time. Each 
    object can have a set of key/value labels defined. Each Key must be unique 
    for a given object.</li>
  <li>intended to be used to specify <b>identifying attributes</b> of objects that are
    <b>meaningful and relevant to users</b>, but do not directly imply semantics to the
    core system</li>
  <li>Normally used to organize and to select subsets of objects.</li>
  <li>Label format:
<pre>
("prefix"/)name
  name : [a-z0-9A-Z\-_.]{1,63}
  prefix : must be a DNS subdomain no longer than 253 chars
</pre>
  </li>
  <li>Example labels:
<pre>  
"release"    : "stable" # "canary" ...
"environment": "dev" # "qa", "pre",  "production"
"tier"       : "frontend" # "backend" "cache"
"partition"  : "customerA", "partition" : "customerB"
"track"      : "daily" # "weekly" "monthly" ...
</pre>
  </li>
  </ul>

  Label selectors
  <ul xxxsmall zoom>
  <li>used by  client/user to identify a set of objects. The 
    label selector is the core grouping primitive in Kubernetes.</li>
  <li>The API currently supports two types of selectors: equality-based and set-based.</li>
  <li>multiple "AND" selectors are comma-separated.</li>
  <li>(in)Equality-based selectors
<pre>
environment=production,tier!=frontend
</pre>
</li>
  <li>Set-based, filtering keys according to a set of values.
      (<code>in, notin and exists</code> )
<pre>
# key equal to environment and value equal to production or qa
environment in (production, qa)
# selects all resources with key equal to "tier" and values other
# than frontend and backend, and all resources with no labels with the tier key
tier notin (frontend, backend)
# selects all resources including a label with key partition
partition
# selects all resources without a label with key "partition"
!partition
# select resources with a "partition" key (no matter the value)
#  and with environment different than  qa 
partition,environment notin (qa)
<pre>
  </li>
  <li>Set-based requirements can be mixed with equality-based requirements.
<pre>
partition in (customerA, customerB),environment!=qa.
</pre>
  </li>
  <li>
Newer resources, such as Job, Deployment, Replica Set, and Daemon Set, support set-based requirements as well.
<pre>
selector:
  # All the requirements from matchLabels +  matchExpressions are ANDed together
  matchLabels:
    component: redis # == matchExpression {key: component, operator: In, values: [redis]}
  matchExpressions:  # list  of pod selector requirements
    - {key: tier, operator: In, values: [cache]}  # In, NotIn, Exists, and DoesNotExist
    - {key: environment, operator: NotIn, values: [dev]}
</pre>
  </li>
  <li>LIST and WATCH operations may specify label selectors to filter the sets 
    of objects returned using a query parameter. Both requirements are permitted
   (presented here as they would appear in a URL query string). Ex:
<pre xxxsmall>
?<b>labelSelector</b>=environment%3Dprod,tier%3Dfrontend ← equality-based:
?<b>labelSelector</b>=environment+in+%28prod%2Cqa%29%2Ctier+in+%28FE%29 ← set-based
</pre>
  </li>
  <li>
<pre>
# targeting apiserver with kubectl 
$ kubectl get pods -l environment=production,tier=frontend # equality-based
$ kubectl get pods -l 'environment in (production),tier in (frontend)' # set-based
$ kubectl get pods -l 'environment in (production, qa)' # "OR" only set-based
$ kubectl get pods -l 'environment,environment notin (frontend)' "NOTIN"
</pre>
  </li>
  </ul>
</td>
<td>
  <a TODO href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMaps</a><br/>
  <spam xsmall>Decouple Image from config</a>
<pre xxxsmall zoom>
</pre>
</td>
<td colsep> </td>
<td>
  <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a> <br/>
  (provisioned by cluster admin)
<pre xxxsmall zoom>
- "hardware" resource applying to the whole cluster (just like a node)
- While Volumes lifecycle is dependent of pod's lifecyles,
  Persistent Volumes lifecycle is independent of any individual pod.
- The k8s API/object captures the details of the implementation of 
  underlying storage (NFS, iSCSI, cloud-provided, ...)
- Pods use it through a volume of type "PersistentVolumeClaim" like:
  Similar to how Pods can request specific levels of resources 
  (CPU and Memory), Claims can request specific size and access modes 
  (e.g., can be mounted once read/write or many times read-only)
  - PV contains max size, PVC contains min size where
    PVC min.size must be &lt; PV max.size

Ex:
Ex. PV using <b orange>local storage</b>:
apiVersion: v1
kind: <b>PersistentVolume</b>
metadata:
  name: example-pv
  annotations:
    "volume.alpha.kubernetes.io/node-affinity": '{
      "requiredDuringSchedulingIgnoredDuringExecution": {
        "nodeSelectorTerms": [
          { "matchExpressions": [
            { "key": "kubernetes.io/hostname",
              "operator": "In",
              "values": ["example-node"]
            }
          ]}
         ]}
        }'
<b>spec:</b>
  capacity:
    storage: 100Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  <b orange>storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1</b>
</pre } >
</td>

</tr }>
</table } >

<table { >
<tr {>
  <th colspan=12 header_delimit {   >Controllers (higher-level abstractions build upon building blocks)</th>
</tr }>
<tr {>
<td>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
<pre xxxsmall zoom>
- ensures that a specified number of pod replicas are running at any given time.
- While ReplicaSets can be used independently, today it's mainly used by 
  Deployments as a mechanism to orchestrate pod creation, deletion and updates.
- "we recommend using Deployments instead of directly using ReplicaSets, unless
   you require custom update orchestration or don't require updates at all."
- Unlike the case where a user directly created pods, a ReplicaSet replaces 
  pods that are deleted or terminated for any reason, such as in the case of 
  node failure or disruptive node maintenance, such as a kernel upgrade. For 
  this reason, we recommend that you use a ReplicaSet even if your 
  application requires only a single pod.
- Use a Job instead of a ReplicaSet for pods that are expected to terminate on their own. 
- Use a DaemonSet instead of a ReplicaSet for pods that provide a machine-level
  function, such as machine monitoring or machine logging. These pods have a 
  lifetime that is tied to a machine lifetime: the pod needs to be running on 
  the machine before other pods start, and are safe to terminate when the 
  machine is otherwise ready to be rebooted/shutdown.

|controllers/frontend.yaml
|
|apiVersion: apps/v1
|kind: ReplicaSet
|metadata:
|  name: frontend
|  labels:
|    app: guestbook
|    tier: frontend
|spec:
|  # modify replicas according to your case
|  replicas: 3   ← Default to 1
|  selector:
|    matchLabels:
|      tier: frontend  ← Matches all pods with labels matching the selector
|    matchExpressions:
|      - {key: tier, operator: In, values: [frontend]}
|  template:  ← Pod template (same schema as a pod, except that it is nested and does not have an apiVersion or kind)
|    metadata:
|      labels:             ← Needed in pod-template, not in isolated pod
|        app: guestbook     .spec.template.metadata.labels must match the .spec.selector
|        tier: frontend
|    spec:
|      restartPolicy: Always ← It's the only allowed value, can be ommited (default).
|      containers:
|      - name: php-redis
|        image: gcr.io/google_samples/gb-frontend:v3
|        resources:
|          requests:
|            cpu: 100m
|            memory: 100Mi
|        env:
|        - name: GET_HOSTS_FROM
|          value: dns
|          # If your cluster config does not include a dns service, then to
|          # instead access environment variables to find service host
|          # info, comment out the 'value: dns' line above, and uncomment the
|          # line below.
|          # value: env
|        ports:
|        - containerPort: 80


$ kubectl create -f (http://k8s.io/examples/controllers/frontend.yaml
→ replicaset.apps/frontend created
→ $ kubectl describe rs/frontend
→ Name:       frontend
→ Namespace:  default
→ Selector:   tier=frontend,tier in (frontend)
→ Labels:     app=guestbook
→         tier=frontend
→ Annotations:    <none>
→ Replicas:   3 current / 3 desired
→ Pods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed
→ Pod Template:
→   Labels:       app=guestbook
→                 tier=frontend
→   Containers:
→    php-redis:
→     Image:      gcr.io/google_samples/gb-frontend:v3
→     Port:       80/TCP
→     Requests:
→       cpu:      100m
→       memory:   100Mi
→     Environment:
→       GET_HOSTS_FROM:   dns
→     Mounts:             <none>
→   Volumes:              <none>
→ Events:
→   FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
→   ---------    --------    -----    ----                -------------    --------    ------            -------
→   1m           1m          1        {replicaset-controller }             Normal      SuccessfulCreate  Created pod: frontend-qhloh
→   1m           1m          1        {replicaset-controller }             Normal      SuccessfulCreate  Created pod: frontend-dnjpy
→   1m           1m          1        {replicaset-controller }             Normal      SuccessfulCreate  Created pod: frontend-9si5l
  
  
$ kubectl get pods
→ NAME             READY     STATUS    RESTARTS   AGE
→ frontend-9si5l   1/1       Running   0          1m
→ frontend-dnjpy   1/1       Running   0          1m
→ frontend-qhloh   1/1       Running   0          1m
</pre>
</td>
<td>
  <ul xxxsmall>
  <li> If you want to scale your application horizontally (e.g., run multiple 
    instances), you should use multiple Pods, one for each instance.</li>
  <li>In Kubernetes, this is generally referred to as replication. Replicated 
    Pods are usually created and managed as a group by an abstraction called a Controller.</li>
  <li>A ReplicaSet ensures that a specified number of pod replicas are running 
    at any given time. However, a Deployment is a higher-level concept that 
    manages ReplicaSets and provides declarative updates to pods along with a 
    lot of other useful features. Therefore, we recommend using Deployments 
    instead of directly using ReplicaSets, unless you require custom update 
    orchestration or don’t require updates at all.</li>
  </ul>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>
  Declarative updates for Pods and ReplicaSets
  <ul xxxsmall>
  <li>Ex. Deployment:
<pre>
# for versions before 1.7.0 use apps/v1beta1
apiVersion: apps/v1beta2 
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
# namespace: production
spec:
  replicas: 3                  ← 3 replicated Pods
  strategy: 
   - type : Recreate           ← Recreate | RollingUpdate*
                               # Alt. strategy example
                               # strategy:
                               #   rollingUpdate:
                               #     maxSurge: 2
                               #     maxUnavailable: 0
                               #   type: RollingUpdate
  selector:
    matchLabels:
      app: nginx
  template:                    ← pod template
    metadata:
      labels:
        app: nginx
    spec:                      ← template pod spec
      containers:                change triggers new rollout
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet:
          path: /heartbeat
          port: 80
          scheme: HTTP

$ kubectl create -f nginx-deployment.yaml

$ kubectl get deployments
NAME             DESIRED CURRENT  ...
nginx-deployment 3       0       

$ kubectl rollout status deployment/nginx-deployment
  Waiting for rollout to finish: 2 out of 3 new replicas
  have been updated...
  deployment "nginx-deployment" successfully rolled out

$ kubectl get deployments
NAME             DESIRED CURRENT ...
nginx-deployment 3       3       
</pre>
  </li>
  <li>To see the ReplicaSet (rs) created by the deployment:
<pre { >
$ kubectl get rs
NAME                     DESIRED ...
nginx-deployment-...4211 3       
^*1
</pre }>
*1:format [deployment-name]-[pod-template-hash-value]
  </li>
  <li>To see the labels automatically generated for each pod
<pre {>
$ kubectl get pods --show-labels
NAME          ... LABELS
nginx-..7ci7o ... app=nginx,...,
nginx-..kzszj ... app=nginx,...,
nginx-..qqcnn ... app=nginx,...,
</pre }>
  </li>
  <li>Update nginx Pods from nginx:1.7.9 to nginx:1.9.1:
<pre {>
$ kubectl set image deployment/nginx-deployment \
   nginx=nginx:1.9.1
</pre }>
  </li>
  <li>Check the revisions of deployment:
<pre {>
$ kubectl rollout history deployment/nginx-deployment
deployments "nginx-deployment"
R CHANGE-CAUSE
1 kubectl create -f nginx-deployment.yaml ---record
2 kubectl set image deployment/nginx-deployment \
                    nginx=nginx:1.9.1
3 kubectl set image deployment/nginx-deployment \
                    nginx=nginx:1.91 

$ kubectl rollout undo deployment/nginx-deployment \
   --to-revision=2
</pre }>
  </li>
  <li>Scale Deployment:
<pre {>
$ kubectl scale deployment \
  nginx-deployment --replicas=10

$ kubectl autoscale deployment nginx-deployment \
  --min=10 --max=15 --cpu-percent=80
</pre }>
  </li>
  </ul>
</td>
<td>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet (v:1.9+)</a><br/>
  Manages stateful apps:
  <ul xxxsmall zoom>
  <li>Useful for apps requiring one+ of: 
    <ul>
    <li>Stable, unique network identifiers.</li>
    <li>persistent storage across Pod (re)scheduling</li>
    <li>Ordered, graceful deployment and scaling.</li>
    <li>Ordered, graceful deletion and termination.</li>
    <li>Ordered, automated rolling updates.</li>
    </ul>
  </li>
  <li>Manages the deploy+scaling of Pods providing
      guarantees about ordering and uniqueness</li>
  <li>Unlike Deployments, a StatefulSet maintains a sticky identity for each 
    of their Pods. These pods are created from the same spec, but are not 
    interchangeable: each has a persistent identifier that it maintains 
    across any rescheduling</li>
  <li>Pod Identity: StatefulSet Pods have a unique identity that is comprised 
    of [ordinal, stable network identity, stable storage] that sticks even
    if Pods is rescheduled on another node.
    <ol>
    <li>Ordinal:Each Pod will be assigned an unique integer ordinal,
       from 0 up through N-1, where N = number of replicas</li>
    <li> Stable Network Pod host-name = <code>$(statefulset name)-$(ordinal)</code>
     Ex. full DNS using Stateless service:
<pre>
Pod full DNS  (web == StatefullSet.name)
<span orange>← pod-host →</span> <span blue>← service ns    →</span> <span brown>←clusterDoma→</span>
<span orange>web-{0..N-1}</span>.<span blue>nginx.default.svc</span>.<span brown>cluster.local</span>
<span orange>web-{0..N-1}</span>.<span blue>nginx.foo    .svc</span>.<span brown>cluster.local</span>
<span orange>web-{0..N-1}</span>.<span blue>nginx.foo    .svc</span>.<span brown>kube.local   </span>

*1: Cluster Domain defaults to cluster.local
</pre>
    </li>
    <li>Pod Name Label: When the controller creates a Pod,
      it adds a label <code>statefulset.kubernetes.io/"pod-name" set to
      the name of the pod, allowing to attach a Service to an unique Pod
    </li>

    </ol>
  </li>
  </ul>

  Limitations
  <ul xxxsmall zoom>
  <li>The storage for a given Pod must either be provisioned by a 
    PersistentVolume Provisioner based on the requested storage class, or 
    pre-provisioned by an admin.</li>
  <li>Deleting and/or scaling a StatefulSet down will not delete the 
      volumes associated with the StatefulSet in order to ensure data safety,
      which is generally more valuable than an automatic purge of all related 
      StatefulSet resources.</li>
  <li>StatefulSets currently require a <span TODO>Headless Service</span> to be
    responsible for the network identity of the Pods. You are responsible for 
    creating this Service.</li>
  </ul>

  Example StatefulSet
<pre xxxsmall zoom>
The <span blue>headless Service (named nginx)</span>, is used to control the network domain
The <span orange>StatefulSet(named web)</orange>, has a Spec that indicates 
that 3 replicas of the nginx container will be launched in unique Pods.
The <span green>volumeClaimTemplates</span> will provide stable storage 
using PersistentVolumes provisioned by a PersistentVolume Provisioner.

<span blue>apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx</span>
---
<span orange>apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  replicas: 3 # by default is 1

  selector:
    matchLabels:
      <span brown>app: nginx # has to match .spec.template.metadata.labels</span>
  serviceName: "nginx"
  template:
    metadata:
      labels:
        <span>app: nginx # has to match .spec.selector.matchLabels</span>
</span>spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
<span green><b>volumeClaimTemplates</b>:
  # Kubernetes creates one PersistentVolume for each VolumeClaimTemplate
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      # each Pod will receive a single PersistentVolume 
      # When a Pod is (re)scheduled onto a node, its volumeMounts mount 
      # the PersistentVolumes associated with its PersistentVolume Claims.
      storageClassName: "my-storage-class"
      resources:
        requests:
          storage: 1Gi</span>
</span>
</pre>
  Deployment and Scaling Guarantees
  <ul xxxsmall zoom>
  <li>Pods are deployed sequentially in order from {0..N-1}.</li>
  <li>When Pods are deleted they are terminated in reverse order, from {N-1..0}</li>
  <li>Before a scaling operation is applied to a Pod, all of its predecessors must be Running and Ready</li>
  <li>Before a Pod is terminated, all of its successors must be completely shutdown</li>
  <li><def>Ordering Policies</def> guarantees can be relaxed via  <code>.spec.podManagementPolicy</code>(K8s 1.7+)
    <ol>
    <li>OrderedReady: Defaults, implements the behavior described above</li>
    <li>Parallel Pod Management: launch/terminate all Pods in parallel, not
       waiting for Pods to become Running and Ready or completely terminated</li>
    <li></li>
    </ol>
  </li>
  <li><def><code>.spec.updateStrategy</code></def> allows to configure and disable
    automated rolling updates for containers, labels, resource request/limits,
    and annotations for the Pods in a StatefulSet.
    <ol>
    <li>"OnDelete" implements the legacy (1.6 and prior) behavior.
      StatefulSet controller will not automatically update the Pods in a StatefulSet.
      Users must manually delete Pods to cause the controller to create new Pods
      that reflect modifications made to a StatefulSet’s .spec.template.</li>
    <li>"RollingUpdate" (default 1.7+) implements automated, rolling update for Pods.
       The StatefulSet controller will delete and recreate each Pod proceeding
       in the same order as Pod termination (largest to smallest ordinal), updating
       each Pod one at a time waiting until an updated Pod is Running and Ready
       prior to updating its predecessor.<br/>
       Partitions
       <ul>
       <li>RollingUpdate strategy can be partitioned, by specifying a
         <code>.spec.updateStrategy.rollingUpdate.partition</li>
       <li>If specified all Pods with an ordinal greater than or equal to
          the partition will be updated when the StatefulSet’s .spec.template
          is updated. All Pods with an ordinal that is less than the partition
          will not be updated, and, even if they are deleted, they will be
          recreated at the previous version.</li>
       <li>If it is greater than its .spec.replicas, updates to its 
          .spec.template will not be propagated to its Pods.
       </li>
       <li>In most cases you will not need to use a partition, but they 
         are useful if you want to stage an update, roll out a canary,
         or perform a phased roll out.</li>
       </ul>
    </ol>
  </li>
  </li>
  </ul>  

  DONT'S
  <ul xxxsmall zoom>
  <li>The StatefulSet should NOT specify a pod.Spec.TerminationGracePeriodSeconds of 0.<br/>
      Unsafe and <b>strongly discouraged</b> </li>
  </ul>  

</td>
<td>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a><br/>
  ensures "N" Nodes run a Pod instance<br/>
  <span xsmall>typical uses include cluster storage, log collection or monitoring</span> 
  <ul xxxsmall zoom>
  <li>As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.</li>
  <li>Ex (simple case): one DaemonSet, covering all nodes, would be used 
    for each type of daemon. A more complex setup might use multiple DaemonSets
    for a single type of daemon, but with different flags and/or different memory
    and cpu requests for different hardware types.</li>
  <li></li>
  </ul>
  Ex.  DaemonSet for <span blue>fluentd-elasticsearch</span>:
<pre xxxsmall> 
$ cat daemonset.yaml 
apiVersion: apps/v1
kind: <b>DaemonSet</b>
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch
  template: # Pod template
    # Pod Template must have RestartPolicy equal to Always (default if un-specified)
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd-elasticsearch
        image: <span blue>k8s.gcr.io/fluentd-elasticsearch:1.20</span>
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
</pre>
  <!--
TODO
The .spec.selector field is a pod selector. It works the same as the .spec.selector of a Job.

As of Kubernetes 1.8, you must specify a pod selector that matches the labels of the .spec.template. The pod selector will no longer be defaulted when left empty. Selector defaulting was not compatible with kubectl apply. Also, once a DaemonSet is created, its spec.selector can not be mutated. Mutating the pod selector can lead to the unintentional orphaning of Pods, and it was found to be confusing to users.

The spec.selector is an object consisting of two fields:

    matchLabels - works the same as the .spec.selector of a ReplicationController.
    matchExpressions - allows to build more sophisticated selectors by specifying key, list of values and an operator that relates the key and values.

When the two are specified the result is ANDed.

If the .spec.selector is specified, it must match the .spec.template.metadata.labels. Config with these not matching will be rejected by the API.

Also you should not normally create any Pods whose labels match this selector, either directly, via another DaemonSet, or via other controller such as ReplicaSet. Otherwise, the DaemonSet controller will think that those Pods were created by it. Kubernetes will not stop you from doing this. One case where you might want to do this is manually create a Pod with a different value on a node for testing.
Running Pods on Only Some Nodes

If you specify a .spec.template.spec.nodeSelector, then the DaemonSet controller will create Pods on nodes which match that node selector. Likewise if you specify a .spec.template.spec.affinity, then DaemonSet controller will create Pods on nodes which match that node affinity. If you do not specify either, then the DaemonSet controller will create Pods on all nodes.
How Daemon Pods are Scheduled

Normally, the machine that a Pod runs on is selected by the Kubernetes scheduler. However, Pods created by the DaemonSet controller have the machine already selected (.spec.nodeName is specified when the Pod is created, so it is ignored by the scheduler). Therefore:

    The unschedulable field of a node is not respected by the DaemonSet controller.
    The DaemonSet controller can make Pods even when the scheduler has not been started, which can help cluster bootstrap.

Daemon Pods do respect taints and tolerations, but they are created with NoExecute tolerations for the following taints with no tolerationSeconds:

    node.kubernetes.io/not-ready
    node.alpha.kubernetes.io/unreachable

This ensures that when the TaintBasedEvictions alpha feature is enabled, they will not be evicted when there are node problems such as a network partition. (When the TaintBasedEvictions feature is not enabled, they are also not evicted in these scenarios, but due to hard-coded behavior of the NodeController rather than due to tolerations).

They also tolerate following NoSchedule taints:

    node.kubernetes.io/memory-pressure
    node.kubernetes.io/disk-pressure

When the support to critical pods is enabled and the pods in a DaemonSet are labeled as critical, the Daemon pods are created with an additional NoSchedule toleration for the node.kubernetes.io/out-of-disk taint.

Note that all above NoSchedule taints above are created only in version 1.8 or later if the alpha feature TaintNodesByCondition is enabled.

Also note that the node-role.kubernetes.io/master NoSchedule toleration specified in the above example is needed on 1.6 or later to schedule on master nodes as this is not a default toleration.
Communicating with Daemon Pods

Some possible patterns for communicating with Pods in a DaemonSet are:

    Push: Pods in the DaemonSet are configured to send updates to another service, such as a stats database. They do not have clients.
    NodeIP and Known Port: Pods in the DaemonSet can use a hostPort, so that the pods are reachable via the node IPs. Clients know the list of node IPs somehow, and know the port by convention.
    DNS: Create a headless service with the same pod selector, and then discover DaemonSets using the endpoints resource or retrieve multiple A records from DNS.
    Service: Create a service with the same Pod selector, and use the service to reach a daemon on a random node. (No way to reach specific node.)

Updating a DaemonSet

If node labels are changed, the DaemonSet will promptly add Pods to newly matching nodes and delete Pods from newly not-matching nodes.

You can modify the Pods that a DaemonSet creates. However, Pods do not allow all fields to be updated. Also, the DaemonSet controller will use the original template the next time a node (even with the same name) is created.

You can delete a DaemonSet. If you specify --cascade=false with kubectl, then the Pods will be left on the nodes. You can then create a new DaemonSet with a different template. The new DaemonSet with the different template will recognize all the existing Pods as having matching labels. It will not modify or delete them despite a mismatch in the Pod template. You will need to force new Pod creation by deleting the Pod or deleting the node.

In Kubernetes version 1.6 and later, you can perform a rolling update on a DaemonSet.
Alternatives to DaemonSet
Init Scripts

It is certainly possible to run daemon processes by directly starting them on a node (e.g. using init, upstartd, or systemd). This is perfectly fine. However, there are several advantages to running such processes via a DaemonSet:

    Ability to monitor and manage logs for daemons in the same way as applications.
    Same config language and tools (e.g. Pod templates, kubectl) for daemons and applications.
    Running daemons in containers with resource limits increases isolation between daemons from app containers. However, this can also be accomplished by running the daemons in a container but not in a Pod (e.g. start directly via Docker).

Bare Pods

It is possible to create Pods directly which specify a particular node to run on. However, a DaemonSet replaces Pods that are deleted or terminated for any reason, such as in the case of node failure or disruptive node maintenance, such as a kernel upgrade. For this reason, you should use a DaemonSet rather than creating individual Pods.
Static Pods

It is possible to create Pods by writing a file to a certain directory watched by Kubelet. These are called static pods. Unlike DaemonSet, static Pods cannot be managed with kubectl or other Kubernetes API clients. Static Pods do not depend on the apiserver, making them useful in cluster bootstrapping cases. Also, static Pods may be deprecated in the future.
Deployments

DaemonSets are similar to Deployments in that they both create Pods, and those Pods have processes which are not expected to terminate (e.g. web servers, storage servers).

Use a Deployment for stateless services, like frontends, where scaling up and down the number of replicas and rolling out updates are more important than controlling exactly which host the Pod runs on. Use a DaemonSet when it is important that a copy of a Pod always run on all or certain hosts, and when it needs to start before other Pods.
-->
</td>
<td>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Job</a><br/>
  reliably run one+ Pod to "N" completions
  <ul xxxsmall zoom>
  <li>creates one+ pods and ensures that a specified number of them successfully terminate</li>
  <li>Jobs are complementary to Deployment Controllers. A Deployment Controller
    manages pods which are not expected to terminate (e.g. web servers), and 
    a Job manages pods that are expected to terminate (e.g. batch jobs).</li>
  <li>As pods successfully complete, the job tracks the successful completions. When a specified number of successful completions is reached, the job itself is complete. Deleting a Job will cleanup the pods it created.</li>
  <li>Pod Backoff failure policy: ifyou want to fail a Job after N retries set 
      <code>.spec.backoffLimit</code> (defaults to 6).</li>
  <li>Pods are not deleted on completion in order to allow view logs/output/errors for completed pods. They will show up with <code>kubectl get pods <b>-a</b></code>. 
    Neither the job object in order to allow viewing its status.</li>
  <li> Another way to terminate a Job is by setting an active deadline
    in <code>.spec.activeDeadlineSeconds</code> or <code>.specs.template.specs.activeDeadlineSeconds</code></li>

  </ul>
  example. Compute  2000 digits of "pi" 
<pre xxxsmall>
$ cat job.yaml

apiVersion: batch/v1
kind: <b>Job</b>
metadata:
  name: pi
spec:
  template: # Required (== Pod template - apiVersion - kind)
    spec:
      containers:
      - name: pi
        <b>image: perl</b>
        <b>command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]</b>
      <b orange>restartPolicy: Never</b> # Only Never/OnFailure allowed
  backoffLimit: 4

# <b>Run job using:</b>
# $ kubectl create -f ./job.yaml

# <b>Check job current status like:</b>
# $ kubectl describe jobs/pi
# output will be similar to:
# Name:             pi
# Namespace:        default
# Selector:         controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
# Labels:           controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
#                   job-name=pi
# Annotations:      <none>
# Parallelism:      1
# Completions:      1
# Start Time:       Tue, 07 Jun 2016 10:56:16 +0200
# Pods Statuses:    0 Running / 1 Succeeded / 0 Failed
# Pod Template:
#   Labels:       controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
#                 job-name=pi
#   Containers:
#    pi:
#     Image:      perl
#     Port:
#     Command:
#       perl
#       -Mbignum=bpi
#       -wle
#       print bpi(2000)
#     Environment:        <none>
#     Mounts:             <none>
#   Volumes:              <none>
# Events:
#   FirstSeen LastSeen  Count From            SubobjectPath  Type    Reason            Message
#   --------- --------  ----- ----            -------------  ------- ------            -------
#   1m        1m        1     {job-controller}               Normal  SuccessfulCreate  Created pod: pi-dtn4q
# 
# <b>To view completed pods of a job, use </b>
# $ kubectl get pods

# <b>To list all pods belonging to job in machine-readable-form</b>:
# 
# $ pods=$(kubectl get pods --selector=<b>job-name=pi</b> --output=<b>jsonpath={.items..metadata.name}</b>)
# $ echo $pods
pi-aiw0a


# <b>View the standard output of one of the pods:</b>
# $ kubectl logs $pods
# 3.1415926535897a....9
</pre>

  Parallel Jobs
  <ul xxxsmall zoom>
  <li>Parallel Jobs with a fixed completion count <code>(.spec.completions greater than zero)</code>. the job is complete when there is one successful pod for each value in the range 1 to .spec.completions.
</li>
  <li>Parallel Jobs with a work queue: do not specify <code>.spec.completions</code>:<br/>
     pods must coordinate with themselves or external service to determine
     what each should work on.<br/>
     each pod is independently capable of determining whether or not all its peers 
     are done, thus the entire Job is done.<br/>
  </li>
  <li>For Non-parallel job, leave both <code>.spec.completions</code> and 
      <code>.spec.parallelism</code> unset.</li>
  <li>Actual parallelism (number of pods running at any instant) may be more or less than requested parallelism, for a variety of reasons</li>
  <li>(read official K8s docs for Job Patterns ussages)</li>
  </ul>
  <hr/>
  <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">Cron Jobs (1.8+)</a>
  <ul xxxsmall zoom>
  <li>written in Cron format (question mark (?) has the same meaning as an asterisk *)</li>
  <li>Concurrency Policy
    <ol>
    <li>Allow (default): allows concurrently running jobs</li>
    <li>Forbid: forbids concurrent runs, skipping next
      if previous still running</li>
    <li>Replace: cancels currently running job and replaces with new one</li>
    </ol>
  </li>
  </ul>
<pre xxxsmall zoom>
$ cat cronjob.yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: <b orange>"*/1 * * * *"</b>
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          <b orange>- name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster</b>
          restartPolicy: OnFailure

# Alternatively:
$ kubectl run hello \
    --schedule="*/1 * * * *"  \
    --restart=OnFailure \
    --image=busybox \
    -- /bin/sh -c "date; echo Hello from the Kubernetes cluster"

# get status:

$ kubectl get cronjob hello
NAME      SCHEDULE      SUSPEND   ACTIVE    LAST-SCHEDULE
hello     */1 * * * *   False     0         <none>

# Watch for the job to be created:
$ kubectl get jobs --watch
NAME               DESIRED   SUCCESSFUL   AGE
hello-4111706356   1         1         2s
</pre>
  

</td>

</tr }>
</table } >

<table { >
<tr {>
  <th colspan=12 header_delimit {   >Monitoring</th>
</tr }>
<tr {>
<td TODO>
  <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/monitor-node-health/">Node Health</a>
</td>
<td TODO>
  <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/">Debug Cluster</a>
</td>
</tr }>
</table } >


<table { >
<tr {>
  <th colspan=12 header_delimit {   >Non-ordered notes</th>
</tr }>
<tr {>
<td>
  <span xsmall>Kubectl Autocomplete</span>
<pre xxxsmall { >
$ source <(kubectl completion bash)
$ source <(kubectl completion zsh)
# use multiple kubeconfig files 
$ KUBECONFIG=~/.kube/config:~/.kube/kubconfig2 \ 
kubectl config view # Show Merged kubeconfig settings.

$ kubectl config current-context
$ kubectl config use-context my-cluster-name 

$ kubectl run nginx --image=nginx
$ kubectl explain pods,svc
</pre } >

get commands with basic output
<pre xxxsmall { >
$ kubectl (get   | describe) (services|pods|deployment)
           ^basic  ^verbose
    --all-namespaces
    -o wide   
    --include-uninitialized
    --sort-by=.metadata.name
    --sort-by='.status.containerStatuses[0].restartCount'
    --selector=app=cassandra  # filter
</pre } >

editing resources
<pre xxxsmall { >
$ KUBE_EDITOR="nano" kubectl edit svc/my-service-1
</pre } >

Get External IPs of all nodes
<pre xxxsmall { >
$ kubectl get nodes -o jsonpath=\
    '{.items[*].status.addresses[?(@.type=="ExternalIP")].address}'
</pre } >
</td>  
<td>  
<a TODO href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">Run stateless app. deployments</a>
</td>  
<td>
  <a TODO href="https://www.infoq.com/news/2018/01/gpu-workflows-kubernetes">GPU and Kubernetes</a>
</td>  
<td>  
  <a TODO href="https://opensource.com/article/17/12/storage-services-kubernetes?elqTrackId=6b7560db7aa24ea28978ac2a7e110c4c&elq=b9bc524fe6af48e38828609c30c593bc&elqaid=45485&elqat=1&elqCampaignId=148699">Running storage services (GlusterFS, iSCSI, ....)</a>
</td>  
<td>  
  <a TODO href="https://github.com/kubernetes/kops/blob/master/README.md">KOPS - KUBERNETES OPERATIONS</a><br/>
  <span cite>The easiest way to get a production grade Kubernetes cluster up and
    running.</span>
  <ul xxxsmall zoom>
  <li>What is kops?  """We like to think of it as kubectl for clusters."""</li>
  <li> kops helps you create, destroy, upgrade and maintain production-grade, 
    highly available, Kubernetes clusters from the command line.<br/>
    AWS is currently officially supported, with GCE in beta support,
    and VMware vSphere in alpha, and other platforms planned.</li>
  </ul>

</td>  
<td>  
  <a TODO href="https://HELM.sh">HELM</a><br/>
    Package manager for Kubernetes
  <hr/>
  <a TODO href="https://kubeapps.com/">Kubeapps</a><br/>
    The Easiest Way to Deploy Applications in Your Kubernetes Cluster 
</td>  
<td>  
  <a TODO href="https://github.com/kubernetes/community/blob/master/sig-apps/README.md">SIG-Apps</a><br/>
  Special Interest Group for deploying and operating apps in Kubernetes.

  <ul xxxsmall zoom>
  <li>They meet each week to demo and discuss tools and projects.</li>
  <li cite>Covers deploying and operating applications in Kubernetes. We focus 
    on the developer and devops experience of running applications in 
    Kubernetes. We discuss how to define and run apps in Kubernetes, demo 
    relevant tools and projects, and discuss areas of friction that can lead 
    to suggesting improvements or feature requests</li>
  </ul>
<td> 
  <a TODO href="https://www.infoq.com/news/2018/03/skaffold-kubernetes">Skaffold</a><br/>
  Tool to facilitate Continuous Development with Kubernetes

</td>  
<td> 
  <a TODO href="https://www.infoq.com/articles/tips-running-scalable-workloads-kubernetes">6 Tips for Running Scalable Workloads on K8s</a><br/>
    
</td>  
<td> 
  <a TODO href="https://github.com/GoogleContainerTools/kaniko">Kanifo</a><br/>
    tool to build container images inside an unprivileged container or
    Kubernetes cluster.
  <ul xxxsmall zoom>
  <li>Although kaniko builds the image from a supplied Dockerfile, it does 
    not depend on a Docker daemon, and instead executes each command completely
    in userspace and snapshots the resulting filesystem changes. 
  </li>
  <li>The majority of Dockerfile commands can be executed with kaniko, with 
    the current exception of SHELL, HEALTHCHECK, STOPSIGNAL, and ARG. 
    Multi-Stage Dockerfiles are also unsupported currently. The kaniko team 
    have stated that work is underway on both of these current limitations.
  </li>
  </ul>
</td>  
<td>  
  <a TODO href="https://www.infoq.com/news/2018/02/dist-system-patterns-burns?utm_source=infoqEmail&utm_medium=SpecialNL_EditorialContent&utm_campaign=04052018_SpecialNL&forceSponsorshipId=1598gtgt">K&A with Kubernetes ...</a><br/>
  <span xxxsmall zoom>
Distributed Systems programming is not for the faint of heart, and despite the evolution of platforms and tools from COM, CORBA, RMI, Java EE, Web Services, Services Oriented Architecture (SOA) and so on, it's more of an art than a science.<br/>

Brendan Burns outlined many of the patterns that enables distributed systems programming in the blog he wrote in 2015. He and David Oppenheimer, both original contributors for Kubernetes, presented a paper at Usenix based around design patterns and containers shortly after.  <br/>
InfoQ caught up with Burns, who recently authored an ebook titled Designing Distributed Systems, Patterns and Paradigms for Scaleable Microservices. He talks about distributed systems patterns and how containers enable it.<br/>
  </span>
</td>  
<td>  
  <a TODO href="https://www.infoq.com/news/2018/02/kubecon-kafka-clusters-kubernete?utm_source=infoqEmail&utm_medium=SpecialNL_EditorialContent&utm_campaign=04052018_SpecialNL&forceSponsorshipId=1598">Kafka on K8s</a><br/>
   <span xxxsmall zoom>
They use Kafka for log and events collection as well as a streaming platform. Each broker in the Kafka cluster has an identity which can be used to find other brokers in the cluster. The brokers also need some type of a database to store partition logs. It's important to configure a Persistent Volume (PV) for Kafka, otherwise you will lose the logs.</span>

</td>  
<td>  
  <a TODO href="https://github.com/containernetworking/cni" colspan=3>Container Network Iface (CNI)</a><br/>
  <ul xxxsmall zoom>
  <li>specification and libraries for writing plugins to configure network interfaces 
in Linux containers, along with a number of supported plugins.</li>
  <li>CNI concerns itself only with network connectivity of containers and removing allocated resources when the container is deleted.</li>
  <li><a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">CNI Spec</a></li>
  </ul>
</td>

<td TODO>
<a href="https://www.slideshare.net/CJCullen/kubernetes-networking-55835829">K8s Networking Explained</td>
</td>


<td TODO>
<a href="https://dzone.com/articles/best-practices-for-advanced-deployment-patterns">Best Practices (Rolling, Blue/Green, Canary, BigBan,...)</a>
</td>
<td TODO>
  <a href="https://github.com/ksonnet/kubecfg">kubecfg</a>, k8s as code
<pre xxxsmall zoom>
<a href="https://www.youtube.com/watch?v=zpgp3yCmXok">[video] Writing less yaml</a>
A tool for managing Kubernetes resources as code.

kubecfg allows you to express the patterns across your infrastructure and reuse
these powerful "templates" across many services, and then manage those templates
as files in version control. The more complex your infrastructure is, the more 
you will gain from using kubecfg.

The idea is to describe as much as possible about your configuration as files 
in version control (eg: git).
</pre>
</td>

<td>
  <a href="https://www.infoq.com/news/2018/05/atlassian-kubernetes-autoscaler">Atlassian escalator</a>
<pre xxxsmall zoom>
In Kubernetes, scaling can mean different things to different users. We 
distinguish between two cases:

  Cluster scaling, sometimes called infrastructure-level scaling, refers to 
the (auto\u2010 mated) process of adding or removing worker nodes based on cluster utilization.
  Application-level scaling, sometimes called pod scaling, refers to the (automated) process
 of manipulating pod characteristics based on a variety of metrics, from low-level signals
 such as CPU utilization to higher-level ones, such as HTTP requests served per 
second, for a given pod. Two kinds of pod-level scalers exist:
  Horizontal Pod Autoscalers (HPAs), which increase or decrease the number
of pod replicas depending on certain metrics.
  Vertical Pod Autoscalers (VPAs), which increase or decrease the resource
requirements of containers running in a pod.

Atlassian <a href="https://developers.atlassian.com/blog/2018/05/introducing-escalator/">released</a>
 their in-house tool <a href="https://github.com/atlassian/escalator/" >Escalator</a> as an open source
 project. It provides configuration-driven preemptive scale-up and faster scale-down
for <a href="https://www.infoq.com/kubernetes/" target="_blank">Kubernetes</a> nodes.

<p>Atlassian adopted containers and built their own 
<a href="https://www.atlassian.com/company/events/summit-us/watch-sessions/2016/build-deploy/scaling-your-first-1000-containers-with-docker">

<p>Kubernetes has two autoscalers 
- <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">horizontal pod autoscaler</a>
  scales pods: an abstraction over a container or a set of related containers - up and down, and thus depends upon the
   availability of underlying compute (usually VM) resources. 
  pods can scale down very quickly, 

- <a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">cluster autoscaler</a>.
  scales the compute infrastructure itself. Understandably, it takes a longer time to scale up and down due to
  the higher provisioning time of virtual machines. Any delays in the cluster autoscaler would translate to delays 
  in the pod autoscaler. 

 Atlassian’s problem was very specific to batch workloads, with a low tolerance for delay in scaling up and down. 
They decided to write their own autoscaling functionality to solve these problems on top of Kubernetes.

   Escalator <a href="https://github.com/atlassian/escalator/blob/master/docs/configuration/advanced-configuration.md">configurable thresholds</a>
for upper and lower capacity of the compute VMs. Some of the configuration properties work by modifying a Kubernetes feature called 
<a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">taint</a>’. A VM node can be ‘tainted’ (marked) with a
certain value so that pods with a related marker are not scheduled onto it. Unused nodes would be 
brought down faster by the Kubernetes standard cluster autoscaler when they are marked. The 
scale-up configuration parameter is a threshold expressed as a percentage of utilization, usually 
less than 100 so that there is a buffer.
 Escalator autoscales the compute VMs when utilization reaches the threshold, thus making room for 
containers that might come up later, and allowing them to boot up fast.
</pre>
</td>
<td TODO>
  Job patterns
<pre xxxsmall zoom>
One example of this pattern would be a Job which starts a Pod which runs a script
that in turn starts a Spark master controller (see spark example), runs a spark 
driver, and then cleans up.
</pre>
</td>

</tr>
</table } >
<br/>
  Understanding K8S Code
<table>
<tr>
<td>
<a href="https://jvns.ca/blog/2017/06/04/learning-about-kubernetes/">K8s Implementation Summary</a> 
<pre xxxsmall zoom>
- <a href="https://jvns.ca/blog/2017/06/04/learning-about-kubernetes/">Julia Evans "A few things I've learned about Kubernetes"</a> 

- """... you can run the kubelet by itself! And if you have a kubelet, you 
can add the API server and just run those two things by themselves! Okay, 
awesome, now let’s add the scheduler!""" 

- the “kubelet” is in charge of running containers on nodes
- If you tell the API server to run a container on a node, it will tell the kubelet to get it done (indirectly)
- The scheduler translates "run a container" to "run a container on node X"

<b>etcd is Kubernetes’ brain</b>
- Every component in Kubernetes (API server, scheduler, kubelets, controller manager, ...) is stateless.
   All of the state is stored in the (key-value store) etcd database.
- Communication between components (often) happens via etcd.
- <b bgorange>basically everything in Kubernetes works by watching etcd for stuff it has to do,
  doing it, and then writing the new state back into etcd</b>

  Ex 1: Run a container on Machine "X":
   Wrong way: ask kubelet@Machine"X" to run the container.
   Right way: kubectl*1 ->(API Server)-> etcd: "This pod should run on Machine X"
              kubelet@Machine"X"      -> etcd: check work to do
              kubelet@Machine"X"      <- etcd: "This pod should run on Machine X"
              kubelet@Machine"X"      <- kubelet@Machine"X": Run pod

  Ex 2: Run a container anywhere on the k8s cluster
    kubectl*1 ->(API Server)-> etcd: "This pod should run somewhere"
    scheduler               -> etcd: Something to run?
    scheduler               <- etcd: "This pod should run somewhere"
    scheduler               -> kuberlet@Machine"Y":  Run pod

 *1 The kubectl is used from the command line.
    In the sequence diagram it can be replaced for any
    of the existing controllers (ReplicaSet, Deployment, DaemonSet, Job,...)

<b>API server roles in cluster:</b>
API Server is responsible for:
1.- putting stuff into etcd

    kubectl    -> API Server : put "stuff" in etcd
    API Server -> API Server : check "stuff" 
    alt 1:
       kubectl <- API Server : error: "stuff" is wrong
    alt 2:
       API Server -> etcd    : set/update "stuff"

2.- Managing authentication:
    ("who is allowed to put what stuff into etcd")
    The normal way is through X509 client certs.


<b>controller manager does a bunch of stuff</b></b>
Responsible for:
- Inspect etcd for pending to schedule pods.
- daemon-set-controllers will inspect etcd for
  pending daemonsets and will call the scheduler 
  to run them on every machine with the given
  pod configuration.
- The "replica set controller" will inspect etcd for
  pending replicasets and will create 5 pods that
  the scheduler will then schedule.
- "deployment controller" ...

<b>Troubleshooting:</b>
something isn’t working? figure out which controller is
responsible and look at its logs

<b>Core K8s components run inside of k8s</b>
- Only 5 things needs to be running before k8s starts up:
  - the scheduler
  - the API server
  - etcd
  - kubelets on every node (to actually execute containers)
  - the controller manager (because to set up daemonsets you
                            need the controller manager)

  Any other core system (DNS, overlay network,... ) can 
  be scheduled by k8s inside k8s
</pre>
</td>
<td>
   Source Code Layout
<pre xxxsmall zoom>
Note: Main k8s are placed in <a href="https://github.com/kubernetes/kubernetes/tree/master/pkg">kubernetes/pkg/</a> 
      (API, kubectl, kubelet, controller, ...)
     
- <a href="https://developer.ibm.com/opentech/2017/06/21/tour-kubernetes-source-code-part-one-kubectl-api-server/">REF: A Tour of the Kubernetes Source Code Part One: From kubectl to API Server</a>

<b>Examining kubectl source</b>

Locating the implementation of kubectl commands in the Kubernetes source code

- <a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/kubectl/cmd">kubectl entry point for all commands</a>
  - Inside there is a name of a go directory that matches the kubectl command:
    Example:
    <a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/kubectl/cmd/create">kubectl create/create.go</a>

<b>K8s loves the Cobra Command Framework</b>
- k8s commands are implemented using the Cobra command framework.
- Cobra provides lot of features for building command line interfaces
  amongst them, Cobra puts the command usage message and command
  descriptions adjacent to the code that runs the command.
  Ex.:
  | // NewCmdCreate returns new initialized instance of create sub command
  | func NewCmdCreate(f cmdutil.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {
  |     o := NewCreateOptions(ioStreams)
  | 
  |     cmd := &cobra.Command{
  |         Use:                   "create -f FILENAME",
  |         DisableFlagsInUseLine: true,
  |         Short:                 i18n.T("Create a resource from a file or from stdin."),
  |         Long:                  createLong,
  |         Example:               createExample,
  |         Run: func(cmd *cobra.Command, args []string) {
  |             if cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames) {
  |                 defaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)
  |                 defaultRunFunc(cmd, args)
  |                 return
  |             }
  |             cmdutil.CheckErr(o.Complete(f, cmd))
  |             cmdutil.CheckErr(o.ValidateArgs(cmd, args))
  |             cmdutil.CheckErr(o.RunCreate(f, cmd))
  |         },
  |     }
  | 
  |     // bind flag structs
  |     o.RecordFlags.AddFlags(cmd)
  | 
  |     usage := "to use to create the resource"
  |     cmdutil.AddFilenameOptionFlags(cmd, &o.FilenameOptions, usage)
  |     ...
  |     o.PrintFlags.AddFlags(cmd)
  | 
  |     // create subcommands
  |     cmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))
  |     ...
  |     return cmd
  | }
  
<b>Builders and Visitors Abound in Kubernetes</b>
  Ex. code:
  | r := f.NewBuilder().
  |     Unstructured().
  |     Schema(schema).
  |     ContinueOnError().
  |     NamespaceParam(cmdNamespace).DefaultNamespace().
  |     FilenameParam(enforceNamespace, &o.FilenameOptions).
  |     LabelSelectorParam(o.Selector).
  |     Flatten().
  |     Do()
  The functions Unstructured, Schema, ContinueOnError,...  Flatten 
  all take in a pointer to a Builder struct, perform some form of
  modification on the Builder struct, and then return the pointer to
  the Builder struct for the next method in the chain to use when it
  performs its modifications defined at:
  <a href="https://github.com/kubernetes/cli-runtime/blob/master/pkg/genericclioptions/resource/builder.go">https://github.com/kubernetes/cli-runtime/blob/master/pkg/genericclioptions/resource/builder.go</a>:

  | ...
  | func (b *Builder) Schema(schema validation.Schema) *Builder {
  |     b.schema = schema
  |     return b
  | }
  | ...
  | func (b *Builder) ContinueOnError() *Builder {
  |     b.continueOnError = true
  |     return b
  | }

 The Do function finally returns a Result object that will be used to drive 
the creation of our resource. It also creates a Visitor object that can be 
used to traverse the list of resources that were associated with this 
invocation of resource.NewBuilder. The Do function implementation is shown below.


  a new DecoratedVisitor is created and stored as part of the Result object 
that is returned by the Builder Do function. The DecoratedVisitor has a Visit 
function that will call the Visitor function that is passed into it.
  |// Visit implements Visitor
  |func (v DecoratedVisitor) Visit(fn VisitorFunc) error {
  |    return v.visitor.Visit(func(info *Info, err error) error {
  |        if err != nil {
  |            return err
  |        }
  |        for i := range v.decorators {
  |            if err := v.decorators[i](info, nil); err != nil {
  |                return err
  |            }
  |        }
  |        return fn(info, nil)
  |    })
  |}


  Create eventually will call the anonymous function that contains the 
  createAndRefresh function that will lead to the code making a REST call
  to the API server.

  The createAndRefresh function invokes the Resource NewHelper 
  function found in ...helper.go returning a new Helper object:
  | func NewHelper(client RESTClient, mapping *meta.RESTMapping) *Helper {
  |     return &Helper{
  |         Resource:        mapping.Resource,
  |         RESTClient:      client,
  |         Versioner:       mapping.MetadataAccessor,
  |         NamespaceScoped: mapping.Scope.Name() == meta.RESTScopeNameNamespace,
  |     }
  | }

  Finally the Create function iwill invoke a createResource function of the
  Helper Create function.
  The Helper createResource function, will performs the actual REST call to
  the API server to create the resource we defined in our YAML file.


<b>Compiling and Running Kubernetes</b>
- we are going to use a special option that informs the Kubernetes build process

$ make WHAT='cmd/kubectl'  # ← compile only kubectl 
Test it like:
On terminal 1 boot up local test hack cluster:
$ PATH=$PATH KUBERNETES_PROVIDER=local hack/local-up-cluster.sh
On terminal 2 execute the compiled kubectl:
$ cluster/kubectl.sh create -f nginx_replica_pod.yaml

<b>Code Learning Tools</b>
Tools and techniques that can really help accelerate your ability to learn the k8s src:
- Chrome Sourcegraph Plugin:
  provides several advanced IDE features that make it dramatically
  easier to understand Kubernetes Go code when browsing GitHub repositories. 
  Ussage:
  - start by looking at an absolutely depressing snippet of code,
    with ton of functions.
  - Hover over each code function with Chrome browser + Sourcegraph extension
    installed:
    It will popup a description of the function, what is passed into it
    and what it returns.
  - It also provides advanced view with the ability to peek into the function
    being invoked. 
- Properly formatted print statements:
  fmt.Println("\n createAndRefresh Info = %#v", info)
- Use of a go panic to get desperately needed stack traces:
  | func createAndRefresh(info *resource.Info) error {
  |     fmt.Println("\n createAndRefresh Info = %#v", info)
  |     <b>panic("Want Stack Trace")</b>
  |     obj, err := resource.NewHelper(info.Client, info.Mapping).Create(info.Namespace, true, info.Object)
  |     if err != nil {
  |         return err
  |     }
  |     info.Refresh(obj, true)
  |     return nil
  | }
- GitHub Blame to travel back in time:
  "What was the person thinking when they committed those lines of code?"
  - GitHub browser interface has a blame option available as a button on the user interface:
      It returns a view of the code that has the commits responsible for each line of code
    in the source file. This allows you to go back in time and look at the commit that added
    a particular line of code and determine what the developer was trying to accomplish when 
    that line of code was added.
</pre>
</td>
</tr>
</table>
</body>
<!--
TODO_Start
__________________
<a href="https://banzaicloud.com/blog/kafka-on-kubernetes/">REF</a>

Local Persistent Volume (k8s 1.10+) leverage local disks and it enables to use
them with Persistent Volume Claims, PVC.
<b>This type of storage is suitable for applications which handles the data
 replication themself. (Kafka, p2p, HDFS, Cassandra, ...)</b>
"""... there are some systems we use or deploy for our customers which are 
already handles replications - like HDFS, Cassandra, etc - and Local Persistent 
Volume is a good fit for that.

To use this as a Persistent Volume, we have some manual steps to do:

    Pre-partition, format and mount disks to nodes

    Create Persistent Volumes
        Manually
        Using a DaemonSet which handles the creation.

    Create Storage Class

    In later Kubernetes release these steps will be omitted.

You may ask, Kubernetes already has a feature hostPath which allows to use local disk as a storage for Pods, why should I use Local Persistent Volume instead? In case of hostPath the storage path has to be set inside the Pod descriptor. On the other hand when a Local Persistent Volume is used, a storage can be preserved through Persistent Volume Claim, so the storage path is not encoded directly in the Pod spec.
______________________
https://docs.containership.io/kubernetes/overview/kubernetes-api
_____________________
https://banzaicloud.com/blog/multi-cloud-k8s/
___________________
https://github.com/banzaicloud/pipeline
___________________
https://www.infoq.com/news/2018/10/kubernetes-1-12

Kubernetes 1.12 Brings Volume Snapshots, TLS Improvements, and More
___________________________
k8s on a Pine64 ARM (4GB RAM)
https://itnext.io/building-an-arm-kubernetes-cluster-ef31032636f9
_________________
https://github.com/ovh/svfs
__________________
Secrets:
<a TODO href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</a>
<a href=https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">Distribute Credentials Securely Using Secrets</a>
<a TODO href=https://kubernetes.io/docs/tasks/administer-federation/secret/">Federated Secrets</a>
    Deployments
__________________
CRDs (Custom Resource Definition)
https://kubernetes.io/blog/page/17/
KubeDirector: The easy way to run complex stateful applications on Kubernetes
 open source project designed to make it easy to run complex stateful scale-out application clusters on Kubernetes. KubeDirector is built using the custom resource definition (CRD) framework and leverages the native Kubernetes API extensions and design philosophy. This enables transparent integration with Kubernetes user/resource management as well as existing clients and tools.
_____________________
https://kubernetes.io/blog/page/12/
Topology-Aware Volume Provisioning in Kubernetes

The multi-zone cluster experience with persistent volumes is improving in Kubernetes 1.12 with the topology-aware dynamic provisioning beta feature. This feature allows Kubernetes to make intelligent decisions when dynamically provisioning volumes by getting scheduler input on the best place to provision a volume for a pod. In multi-zone clusters, this means that volumes will get provisioned in an appropriate zone that can run your pod, allowing you to easily deploy and scale your stateful workloads across failure domains to provide high availability and fault tolerance.
_____________________
https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/
IPVS-Based In-Cluster Load Balancing Deep Dive

What Is IPVS?

IPVS (IP Virtual Server) is built on top of the Netfilter and implements transport-layer load balancing as part of the Linux kernel.

IPVS is incorporated into the LVS (Linux Virtual Server), where it runs on a host and acts as a load balancer in front of a cluster of real servers. IPVS can direct requests for TCP- and UDP-based services to the real servers, and make services of the real servers appear as virtual services on a single IP address. Therefore, IPVS naturally supports Kubernetes Service.
_____________________________
https://www.infoq.com/news/2019/01/kubecon-cloudnativecon-2018?utm_source=infoq&utm_medium=popular_widget&utm_campaign=popular_content_list&utm_content=
_________________________
udits log events (1.11+)
_________________________________
Related k8s must-known
 - Overlay networks (I wrote a container networking overview about this last year)
 - Network namespaces (understanding namespaces in general is really helpful for working with containers)
 - DNS (because Kubernetes has a DNS server)
 - Route tables, how to run ip route list and ip link list
 - Network interfaces
 - Encapsulation (vxlan / UDP)
 - Basics about how to use iptables & read iptables configuration
 - TLS, server certs, client certs, certificate authorities
_____________________
https://sysdig.com/blog/kubernetes-security-rbac-tls/
__________________________
https://www.cncf.io/blog/2018/11/05/34097/
_____________________
https://es.slideshare.net/try_except_/kubernetes-on-aws-at-zalando-failures-learnings-devops-nrw
________________________
k8s plugin for IntelliJ:
https://blog.jetbrains.com/idea/2018/03/intellij-idea-2018-1-kubernetes-support/
_____________
https://www.zdnet.com/article/red-hat-introduces-first-kubernetes-native-ide/?ftag=TRE-03-10aaa6b&bhid=28374205867001011904732094012637
______________________
Azure Kubernetes AKS automatic deployment with Terraform:
https://github.com/jdeiviz/aks-terraform-module
_______________________
https://www.infoq.com/articles/ambassador-api-gateway-kubernetes
_______________________

Advanced Kubernetes in Practice (O'Reilly Course:, Viktor Farcic)

Break : 10 mins

Section 3: Dividing A Cluster Into Namespaces (50 mins)

Applications and corresponding objects often need to be separated from each other to avoid conflicts and other undesired effects.

Break : 10 mins

Section 4: Securing Kubernetes Clusters (1 hour)

Security implementation is a game between a team with a total lock-down strategy and a team that plans to win by providing complete freedom to everyone. You can think of it as a battle between anarchists and totalitarians. The only way the game can be won is if both blend into something new. The only viable strategy is freedom without sacrificing security (too much).

DAY 2

Section 5: Managing Resources (1 hour)

Without an indication how much CPU and memory a container needs, Kubernetes has no other option than to treat all containers equally. That often produces a very uneven distribution of resource usage. Asking Kubernetes to schedule containers without resource specifications is like entering a taxi driven by a blind person.

Break : 10 mins

Section 6: Persisting State (1 hour)

Having fault-tolerance and high-availability is of no use if we lose application state during rescheduling. Having state is unavoidable, and we need to preserve it no matter what happens to our applications, servers, or even a whole datacenter.

Break : 10 mins

Section 7: Deploying Stateful Applications At Scale (1 hour)

Stateless and stateful application are quite different in their architecture. Those differences need to be reflected in Kubernetes as well. The fact that we can use Deployments with PersistentVolumes does not mean that is the best way to run stateful applications.
_____________________________
Hybric Cloud+On-Premise k8s
https://cloud.google.com/blog/products/gcp/going-hybrid-with-kubernetes-on-google-cloud-platform-and-nutanix
____________________
https://cloud.google.com/knative/
Kubernetes-based platform to build, deploy, and manage modern serverless workloads.
Essential base primitives for all

Knative provides a set of middleware components that are essential to build modern, source-centric, and container-based applications that can run anywhere: on premises, in the cloud, or even in a third-party data center. Knative components are built on Kubernetes and codify the best practices shared by successful real-world Kubernetes-based frameworks. It enables developers to focus just on writing interesting code, without worrying about the “boring but difficult” parts of building, deploying, and managing an application.
Developer-friendly software

Knative offers a set of reusable components that focuses on solving many mundane but difficult tasks such as orchestrating source-to-container workflows, routing and managing traffic during deployment, auto-scaling your workloads, or binding running services to eventing ecosystems. Developers can even use familiar idioms, languages, and frameworks to deploy any workload: functions, applications, or containers.
Supports popular development patterns

Knative focuses on an idiomatic developer experience. It supports common development patterns such as GitOps, DockerOps, ManualOps, as well as tools and frameworks such as Django, Ruby on Rails, Spring, and many more.
Best of both worlds: Flexibility and control

Knative is designed to plug easily into existing build and CI/CD toolchains. By focusing on open-source-first technologies that run anywhere, on any cloud, on any infrastructure supported by Kubernetes, enterprises are free to move their workloads wherever they run best. This offers the flexibility and control customers need to adapt the system to their own unique requirements.
Operator-friendly

Knative is designed to be run as a service by all major cloud providers. Google currently works with industry leaders such as Pivotal, SAP, Red Hat, IBM, and many others to create the building blocks that will best suit the needs of developers. Knative powers real-world workloads and is also compatible with other cutting-edge technologies such as Kubernetes and Istio.
Run your serverless workloads on Kubernetes Engine

You can now run your serverless workloads on Google Kubernetes Engine (GKE) by enabling the serverless add-on. Powered by Knative, the serverless add-on helps developers orchestrate builds, serving, and events with a single click, enabling the benefits of an idiomatic developer experience with the flexibility and control of GKE.

______________________________
https://www.itprotoday.com/containers/rancher-labs-k3s-shrinks-kubernetes-edge

Rancher Labs' K3s Shrinks Kubernetes for the Edge
For running containers at the edge, Rancher Labs has created K3s, a Kubernetes distribution that weighs-in at 40MB and needs only 512MB RAM to run.
_____________________________
https://www.datacenterknowledge.com/open-source/aws-google-microsoft-red-hats-new-registry-act-clearing-house-kubernetes-operators
AWS, Google, Microsoft, Red Hat's New Registry to Act as Clearing House for Kubernetes Operators
Operators make life easier for Kubernetes users, but they're so popular that finding good ones is not easy. Operatorhub.io is an attempt to fix that.
_____________________________________
https://github.com/gluster/gluster-kubernetes
gluster-kubernetes is a project to provide Kubernetes administrators a 
mechanism to easily deploy GlusterFS as a native storage service onto an 
existing Kubernetes cluster. Here, GlusterFS is managed and orchestrated like 
any other app in Kubernetes. This is a convenient way to unlock the power of 
dynamically provisioned, persistent GlusterFS volumes in Kubernetes.
________________________________
https://www.infoq.com/news/2019/03/airbnb-kubernetes-workflow

________________________________
Kubernetes top questions by votes in ServerFault:
https://serverfault.com/questions/tagged/kubernetes?sort=votes&pageSize=15

Kubernetes top questions by votes in DevOps.stackexchange.com:
https://devops.stackexchange.com/questions/tagged/kubernetes?sort=votes&pageSize=15
_______________________________
https://www.infoq.com/news/2019/03/rancher-submariner-multicluster
_________________________
https://www.infoq.com/news/2019/03/redhat-release-quarkus
_________________________
proper shutdown k8s cluster
https://serverfault.com/questions/893886/proper-shutdown-of-a-kubernetes-cluster
_________________________
The K8s Bible for Beginners and developers:
https://docs.google.com/document/d/1O-BwDTuE4qI0ASE7iFp6qFpTj8uIVrl9F0HUrC4u_GQ/edit
__________________
https://opensource.com/article/19/3/getting-started-jaeger
_____________________
https://www.infoq.com/news/2019/04/kubernetes-pci-dss-compliance
_____________________
C&P from JBCNConf 2019:
Zero Downtime Migrations in Istio era
(talk)

You joined the DevOps movement and want to release software even faster and safer. You started reading about Advanced deployment techniques like Blue-Green Deployment, Canary Releases or Dark Shadow Technique. But how do you implement them without disrupting your users in production? With Zero Downtime! This is easy with your code, but what about ephemeral and persistent states? Most of the examples out there does not tackle this scenario (which is the most common in real systems). Come to this session and you’ll learn in a practical way how you can achieve zero downtime deployments applying advanced deployment techniques for maintaining the ephemeral and persistent state with Istio
Alex Soto
Java Champion, Engineer @ Red Hat. Speaker, CoAuthor of Testing Java Microservices book, Member of JSR374 and Java advocate

Alex is a Software Engineer at Red Hat in Developers group. He is a passionate about Java world, software automation and he believes in the opensource software model. Alex is the creator of NoSQLUnit project, member of JSR374 (Java API for JSON Processing) Expert Group, the co-author of Testing Java Microservices book for Manning and contributor of several open source projects. A Java Champion since 2017 and international speaker, he has talked about new testing techniques for microservices and continuous delivery in the 21st century.
_____________________
-->
</html>
