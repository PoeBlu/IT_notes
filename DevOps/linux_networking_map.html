<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Linux Networking Map<!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<table style='width:100%'{>
<tbody>
<tr {>
  <th colspan=3 header_delimit {   >topic1</th>
</tr }>
</body>
<!--
4.2. operating system tuning
NODE JS ARCHITECTURE I 4. Software solution
4096 bytes per socket.
TCP RECYCLE ( REUSE TIMEWAIT STATE)
echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle (0 default value)
root@ubuntu:~# cat /etc/security/limits.conf
...
ubuntu soft nofile 1000000
ubuntu hard nofile 1000000
ubuntu soft nproc 200000
ubuntu hard nproc 200000
root@ubuntu:~# cat /etc/sysctl.conf
...
fs.file-max = 6815744
net.core.rmem_max = 25165824
# Maximum TCP Send Window
net.core.wmem_max = 25165824
# others
net.ipv4.tcp_rmem = 4096 16384 25165824
net.ipv4.tcp_wmem = 4096 16384 25165824
net.ipv4.tcp_syncookies = 1
# this gives the kernel more memory for tcp which you need with many (100k+) open socket connections
# 786432 = 3GB
net.ipv4.tcp_mem = 786432 1048576 26777216
net.ipv4.tcp_max_tw_buckets = 360000
net.core.netdev_max_backlog = 2500
vm.min_free_kbytes = 65536
vm.swappiness = 0
net.ipv4.ip_local_port_range = 1024 65535
net.core.somaxconn = 65535
kernel.shmmax=37396480

sysctl -p
sysctl -p /etc/stsctl.conf

ulimit -n 20000000 (20k sockets open)
cat /proc/sys/fs/nr_open (1041576=> 20000000)
root@ubuntu:~# cat /etc/security/limits.conf (mongodb)
?
Limit Soft Limit Hard Limit Units
Max cpu time unlimited unlimited seconds
Max file size unlimited unlimited bytes
Max data size unlimited unlimited bytes
Max stack size 8388608 unlimited bytes
Max core file size 0 unlimited bytes
Max resident set unlimited unlimited bytes
Max processes 1000000 1000000
processes
Max open files 1000000 1000000 files
Max locked memory 65536 65536 bytes
Max address space unlimited unlimited bytes
Max file locks unlimited unlimited locks
Max pending signals 643901 643901 signals
Max msgqueue size 819200 819200 bytes
Max nice priority 0 0
Max realtime priority 0 0
Max realtime timeout unlimited unlimited us
_____________________________
http://www.eweek.com/enterprise-apps/linux-3.13-improves-networking-memory-performance.html
_____________________________
nftables (Linux 3.13+ new packet filtering technology)
   Iptables             nftables 
 typically used for  more robust and
 security, access    easier to use than
 and firewall        iptables while 
  configuration.     offering similar
                     functionality  
                     backward-compatible
                     with iptables rules


Denise Dumas,Platform Engineering @ Red Hat,
"""iptables has always been difficult for customers to use successfully
and we have high hopes that nftables will provide a much more user-friendly experience."""
_________________________________
Networking also gets a boost in Linux 3.13 with a pair of innovations,  including the High-Availability Seamless Redundancy (HSR) standard that  is now supported in Linux, enabling a new approach for failover.
""It [HSR] requires a special network topology where all nodes are connected in a ring (each node having two physical network interfaces),""
 Linux developer Arvid Brodin wrote in his code commit message. ""It is suited for applications that demand high availability and very short reaction time.""

In addition to HSR, Linux 3.13 benefits from the TCP Fast Open specification, which is intended to accelerate the ability of a system 
to open up multiple Transmission Control Protocol (TCP) connections. The technology first landed in the Linux 3.7 kernel  at the end of 2012 and is now enabled by default in the Linux 3.13 release.

""Applications have started to use Fast Open (e.g., Chrome browser has such an optional flag) and the feature has gone through several 
generations of kernels since 3.7 with many real network tests,"" Linux kernel developer Yuchung Cheng wrote in his code commit message. 
""It's time to enable this flag by default for applications to test more conveniently and extensively.""
See more at: http://www.eweek.com/enterprise-apps/linux-3.13-improves-networking-memory-performance.html#sthash.WVlKASt4.dpuf
________________________________
http://lartc.org/ (LInux Advanced Routing and Traffic Control)
________________________________
http://www.linuxjournal.com/content/dnsmasq-pint-sized-super-d%C3%A6mon
DNSMasq: the way it works is simplicity at its finest. First, let's look at its features:
Extremely small memory and CPU footprint: I knew this was the case, because it's the program that runs on Linux-based consumer routers where
memory and CPU are at a premium.

DNS server: DNSMasq approaches DNS in a different way from the traditional BIND dæmon. It doesn't offer the complexity of domain
transfers, master/slave relationships and so on. It does offer extremely simple and highly configurable options that are, in my opinion, far
more useful in a small- to medium-size network. It even does reverse DNS (PTR records) automatically! (More on those details later.)

DHCP server: where the DNS portion of DNSMasq lacks in certain advanced features, the DHCP services offered actually are extremely robust. 
Most routers running firmware like DD-WRT don't offer a Web interface to the advanced features DNSMasq provides, but it rivals and even
surpasses some of the standalone DHCP servers.

TFTP server: working in perfect tandem with the advanced features of DHCP, DNSMasq even offers a built-in TFTP server for things like booting
thin clients or sending configuration files.

A single configuration file: it's possible to use multiple configuration files, and I even recommend it for clarity's sake. In the end, however,
DNSMasq requires you to edit only a single configuration file to manage all of its powerful services. That configuration file also is very well
commented, which makes using it much nicer.

________________________________

High Availability {{{
Sofware.admin.HA  Setting up a high availability nfs with drdb and heartbeat  http://www.howtoforge.com/high_availability_nfs_drbd_heartbeat
    Virtual Router Redundancy Protocol  http://fr.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol
    DRDB: Networked RAID 1  http://www.drbd.org/
    "The GlusterFS project, a petabyte-scale, networked elastic filesystem.

Gluster Geo-replication GlusterFS Geo-replication provides a continuous, asynchronous, and incremental replication service from one site to another over Local Area Networks (LANs), Wide Area Networks (WANs) and across the Internet. "   http://blog.gluster.com/2011/06/new-release-glusterfs-3-2-1/
}}}  

________________________________
BPF  : Berkeley Packet Filters.
eBPF : Extended Berkeley Packet Filters.
cBPF : Clasic   Berkeley Packet Filters.

http://www.man7.org/linux/man-pages/man2/bpf.2.html
"""  For both cBPF and eBPF programs, the kernel statically
   analyzes the programs before loading them, in order to ensure that
   they cannot harm the running system."""

Related:
   Cilium 1.0.0-rc4 Released:
   Transparently Secure Container Network Connectivity Utilising Linux BPF
   https://www.infoq.com/news/2018/03/cilium-linux-bpf

   Microservices applications tend to be highly dynamic, and this presents both a challenge and an opportunity in terms of securing connectivity between microservices. Modern approaches to overcoming this issue have coalesced around the CNCF-hosted <a href="https://github.com/containernetworking/cni">Container Network Interface (CNI)</a> and the increasingly popular "<a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/">service mesh</a>" technologies, such as <a href="https://www.infoq.com/news/2017/05/istio">Istio</a> and <a href="https://www.infoq.com/news/2018/01/conduit-service-mesh">Conduit</a>. According to the <a href="http://cilium.readthedocs.io/en/latest/intro/">Cilium documentation</a>, traditional Linux network security approaches (such as <a href="https://en.wikipedia.org/wiki/Iptables">iptables</a>) filter on IP address and TCP/UDP ports. However, the highly volatile life cycle of containers and IP addresses cause these approaches to struggle to scale alongside the application&nbsp;as the large number of load balancing tables and access control lists&nbsp;must be updated&nbsp;continually.</p>

<p>Cilium attempts to address the issue with scaling by utilising a (relatively) new technology called <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Berkeley Packet Filter (BPF)</a>. BPF is a <a href="https://github.com/cilium/cilium#user-content-what-is-ebpf-and-xdp">Linux kernel bytecode interpreter</a> that was originally introduced to filter network packets, as seen in <a href="https://www.tcpdump.org/tcpdump_man.html">tcpdump</a> and socket filters. It has been extended with additional data structures such as hash tables and arrays as well as additional actions to support packet mangling, forwarding, encapsulation, etc. An in-kernel verifier ensures that BPF programs are safe to run and a JIT compiler converts the bytecode to CPU architecture specific instructions for native execution efficiency. For readers keen to explore BPF in further detail, performance Guru <a href="http://www.brendangregg.com/">Brendan Gregg</a> has written and talked extensively about "<a href="http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html">Linux BPF Superpowers</a>".</p>

________________________________
socat
________________________________
  Utilising Linux BPF:
<pre xxxsmall zoom { >
https://www.infoq.com/news/2018/03/cilium-linux-bpf?utm_medium=SpecialNL_EditorialContent&utm_cam
Cilium is open source software for transparently securing the network 
connectivity between application services deployed using Linux container 
management platforms like Docker and Kubernetes. Cilium 1.0.0-rc4 has recently 
been released, which includes: the Cloud Native Computing Foundation 
(CNCF)-hosted Envoy configured as the default HTTP/gRPC proxy; the addition of 
a simple health overview for connectivity and other errors; and an improved 
scalable kvstore interaction layer.

Microservices applications tend to be highly dynamic, and this presents both a 
challenge and an opportunity in terms of securing connectivity between 
microservices. Modern approaches to overcoming this issue have coalesced around
the CNCF-hosted Container Network Interface (CNI) and the increasingly popular 
"service mesh" technologies, such as Istio and Conduit. According to the Cilium
documentation, traditional Linux network security approaches (such as iptables)
filter on IP address and TCP/UDP ports. However, the highly volatile life cycle
of containers and IP addresses cause these approaches to struggle to scale 
alongside the application as the large number of load balancing tables and 
access control lists must be updated continually.

Cilium attempts to address the issue with scaling by utilising a (relatively) 
new technology called Berkeley Packet Filter (BPF). BPF is a Linux kernel 
bytecode interpreter that was originally introduced to filter network packets, 
as seen in tcpdump and socket filters. It has been extended with additional 
data structures such as hash tables and arrays as well as additional actions to
support packet mangling, forwarding, encapsulation, etc. An in-kernel verifier 
ensures that BPF programs are safe to run and a JIT compiler converts the 
bytecode to CPU architecture specific instructions for native execution 
efficiency. For readers keen to explore BPF in further detail, performance Guru
Brendan Gregg has written and talked extensively about "Linux BPF Superpowers".
</pre }>

________________________________
Wireshark 2.6 add support for gRPC, ...
https://news.softpedia.com/news/wireshark-world-s-most-popular-network-protocol-analyzer-gets-major-release-520851.shtml
________________
  Linux Networking examples and tutorials:
     https://github.com/knorrie/network-examples
________________
  Understanding how the OS uses the modern NIC:

  https://www.joyent.com/blog/virtualizing-nics
______________
  Working with Network Configurations from the Command Line:
  https://www.linux.com/learn/working-network-configurations-command-line

______________
  https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#general-advice-on-monitoring-and-tuning-the-linux-networking-stack
  https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#general-advice-on-monitoring-and-tuning-the-linux-networking-stack 
_____________________________
http://www.securitybydefault.com/2013/11/1010-herramientas-de-monitorizacion-de.html

"
Con interfaz web:

vnstati: es la herramienta de vnstat para generar archivos png que poder visualizar vía web. Muy muy sencilla. Como pega, no es dinámica.
collectd: realmente versátil y potente. Permite medir muchos otros parámetros  además de la red con distintos plugins. Funciona en modo 
cliente/servidor, por lo que puede monitorizar redes de sistemas.
munin: conceptualmente similar al anterior, permite, mediante plugins,  monitorizar varios servicios. También funciona en modo cliente/servidor.
cacti: archiconocido y muy usado para adquirir datos vía snmp de sistemas remotos. Permite diseñar y crear las gráficas usando su propio interfaz 
web.

bandwidthd: pese a que cumple sus funciones de pintar gráficas de consumo de ancho de banda, no permite configurar demasiadas opciones.

ntopng: versión ""ng"" del clásico ntop. Personalmente no me gusta la forma de presentar los datos.

mrtg: otro clásico, permite pintar gráficas obteniendo datos vía snmp. 

orca: pinta gráficas estilo mrtg. Al igual que mrtg, son versiones no adaptadas a estos tiempos modernos.
bwbar: genera una única barra muy sencilla, incluso más que vnstati, con los datos de entrada y salida.

Graphite: realmente no es para dibujar gráficas de tráfico, pero permite dibujar gráficas de cualquier tipo de una forma realmente sencilla y bonita. Requiere que se le pasen los datos mediante algún script, por ejemplo, usando alguna herramienta de las vistas en la sección anterior. 
w
___________________________
https://utcc.utoronto.ca/~cks/space/blog/linux/ReplacingNetstatNotBad
here's real reasons for Linux to replace ifconfig, netstat, et al
May 25, 2018

One of the ongoing system administration controversies in Linux is that there is an ongoing effort to obsolete the old, cross-Unix standard network administration and diagnosis commands of ifconfig, netstat and the like and replace them with fresh new Linux specific things like ss and the ip suite. Old sysadmins are generally grumpy about this; they consider it yet another sign of Linux's 'not invented here' attitude that sees Linux breaking from well-established Unix norms to go its own way. Although I'm an old sysadmin myself, I don't have this reaction. Instead, I think that it might be both sensible and honest for Linux to go off in this direction. There are two reasons for this, one ostensible and one subtle.
_______________
https://opensource.com/article/18/10/iptables-tips-and-tricks:
16 iptables tips and tricks for sysadmins
Iptables provides powerful capabilities to control traffic coming in and out of your system.

Modern Linux kernels come with a packet-filtering framework named Netfilter.

Netfilter enables to:
- allow, drop, and modify traffic coming in and going out of a system.

Userspace CLI:
- iptables: create firewall by adding rules to form policies.

AVOID LOCKING YOURSELF OUT:
You want to avoid locking yourself—and potentially everybody else—out 
while modifying iptables policies.

Tip #1: backup current iptables policy/config with:

 #~ /sbin/iptables-save > /root/iptables-OK-`date +%F`
 
 Restore it with:
     
 #~ /sbin/iptables-restore < /root/iptables-works-2018-09-11

Tip #4: Put specific rules at the top of the policy and generic rules at the bottom.


  #~ iptables -A INPUT -p tcp --dport 22 \       ← specific rule. Put at top.
       –s 10.0.0.0/8 –d 192.168.100.101 -j DROP
  #~ iptables -A INPUT -p tcp --dport 22 -j DROP ← Generic  rule. Put at bottom.


  (The more criteria/specific, the less chance to locking yourself out)

Tip #5: Whitelist your IP address at top
        (very effective method to not lock yourself out) 

   #~ iptables -I INPUT -s <your IP> -j ACCEPT ← top/first rule
                ^
               -I: inserts as first rule
               -A: appends at the end
..........
FIREWALL POLICIES TIPS:
Tip #1: Set the default policy as DROP.

*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

Tip #2: Allow users the minimum amount of services needed to get their work done.

The iptables rules need to allow the workstation to get an IP address, netmask, and other important information via DHCP (-p udp --dport 67:68 --sport 67:68). For remote management, the rules need to allow inbound SSH (--dport 22), outbound mail (--dport 25), DNS (--dport 53), outbound ping (-p icmp), Network Time Protocol (--dport 123 --sport 123), and outbound HTTP (--dport 80) and HTTPS (--dport 443).

# Set a default policy of DROP
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

# Accept any related or established connections
-I INPUT  1 -m state --state RELATED,ESTABLISHED -j ACCEPT
-I OUTPUT 1 -m state --state RELATED,ESTABLISHED -j ACCEPT

# Allow all traffic on the loopback interface
-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

# Allow outbound DHCP request
-A OUTPUT –o eth0 -p udp --dport 67:68 --sport 67:68 -j ACCEPT

# Allow inbound SSH
-A INPUT -i eth0 -p tcp -m tcp --dport 22 -m state --state NEW  -j ACCEPT

# Allow outbound email
-A OUTPUT -i eth0 -p tcp -m tcp --dport 25 -m state --state NEW  -j ACCEPT

# Outbound DNS lookups
-A OUTPUT -o eth0 -p udp -m udp --dport 53 -j ACCEPT

# Outbound PING requests
-A OUTPUT –o eth0 -p icmp -j ACCEPT

# Outbound Network Time Protocol (NTP) requests
-A OUTPUT –o eth0 -p udp --dport 123 --sport 123 -j ACCEPT

# Outbound HTTP
-A OUTPUT -o eth0 -p tcp -m tcp --dport 80 -m state --state NEW -j ACCEPT
-A OUTPUT -o eth0 -p tcp -m tcp --dport 443 -m state --state NEW -j ACCEPT

COMMIT

Restrict an IP address range

Scenario: The CEO of your company thinks the employees are spending too much time on Facebook and not getting any work done. The CEO tells the CIO to do something about the employees wasting time on Facebook. The CIO tells the CISO to do something about employees wasting time on Facebook. Eventually, you are told the employees are wasting too much time on Facebook, and you have to do something about it. You decide to block all access to Facebook. First, find out Facebook's IP address by using the host and whois commands.

host -t a www.facebook.com
www.facebook.com is an alias for star.c10r.facebook.com.
star.c10r.facebook.com has address 31.13.65.17
whois 31.13.65.17 | grep inetnum
inetnum:        31.13.64.0 - 31.13.127.255

Then convert that range to CIDR notation by using the CIDR to IPv4 Conversion page. You get 31.13.64.0/18. To prevent outgoing access to www.facebook.com, enter:

iptables -A OUTPUT -p tcp -i eth0 –o eth1 –d 31.13.64.0/18 -j DROP

Regulate by time

Scenario: The backlash from the company's employees over denying access to Facebook access causes the CEO to relent a little (that and his administrative assistant's reminding him that she keeps HIS Facebook page up-to-date). The CEO decides to allow access to Facebook.com only at lunchtime (12PM to 1PM). Assuming the default policy is DROP, use iptables' time features to open up access.

iptables –A OUTPUT -p tcp -m multiport --dport http,https -i eth0 -o eth1 -m time --timestart 12:00 --timestart 12:00 –timestop 13:00 –d
31.13.64.0/18  -j ACCEPT

This command sets the policy to allow (-j ACCEPT) http and https (-m multiport --dport http,https) between noon (--timestart 12:00) and 13PM (--timestop 13:00) to Facebook.com (–d 31.13.64.0/18).
Regulate by time—Take 2

Scenario: During planned downtime for system maintenance, you need to deny all TCP and UDP traffic between the hours of 2AM and 3AM so maintenance tasks won't be disrupted by incoming traffic. This will take two iptables rules:

iptables -A INPUT -p tcp -m time --timestart 02:00 --timestop 03:00 -j DROP
iptables -A INPUT -p udp -m time --timestart 02:00 --timestop 03:00 -j DROP

With these rules, TCP and UDP traffic (-p tcp and -p udp ) are denied (-j DROP) between the hours of 2AM (--timestart 02:00) and 3AM (--timestop 03:00) on input (-A INPUT).
Limit connections with iptables

Scenario: Your internet-connected web servers are under attack by bad actors from around the world attempting to DoS (Denial of Service) them. To mitigate these attacks, you restrict the number of connections a single IP address can have to your web server:

iptables –A INPUT –p tcp –syn -m multiport -–dport http,https –m connlimit -–connlimit-above 20 –j REJECT -–reject-with-tcp-reset

Let's look at what this rule does. If a host makes more than 20 (-–connlimit-above 20) new connections (–p tcp –syn) in a minute to the web servers (-–dport http,https), reject the new connection (–j REJECT) and tell the connecting host you are rejecting the connection (-–reject-with-tcp-reset).

_______________


-->

</html>
