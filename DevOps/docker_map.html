<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Docker (beta)</title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>

<body>

<table>
<tr>
<td>
<pre xxxsmall zoom>
<span xsmall>External Links</span>
- @[https://docs.docker.com/]
- @[https://github.com/jdeiviz/docker-training] D.Peman@github
- @[https://github.com/jpetazzo/container.training] container.training@Github
- @[http://container.training/]
</pre>
<pre xxxsmall zoom>
<span xsmall>$ docker help</span>
Usage:	docker COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default "/root/.docker")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default "/root/.docker/ca.pem")
      --tlscert string     Path to TLS certificate file (default "/root/.docker/cert.pem")
      --tlskey string      Path to TLS key file (default "/root/.docker/key.pem")
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:       | Commands:
            Manage ...     |   attach      Attach local STDIN/OUT/ERR streams to a running container
config      Docker configs |   build       Build an image from a Dockerfile
container   containers     |   commit      Create a new image from a container's changes
image       images         |   cp          Copy files/folders between a container and the local filesystem
network     networks       |   create      Create a new container
node        Swarm nodes    |   diff        Inspect changes to files or directories on a container's filesystem
plugin      plugins        |   events      Get real time events from the server
secret      Docker secrets |   exec        Run a command in a running container
service     services       |   export      Export a container's filesystem as a tar archive
swarm       Swarm          |   history     Show the history of an image
system      Docker         |   images      List images
trust       trust on       |   import      Import the contents from a tarball to create a filesystem image
            Docker images  |   info        Display system-wide information
volume      volumes        |   inspect     Return low-level information on Docker objects
                           |   kill        Kill one or more running containers
                           |   load        Load an image from a tar archive or STDIN
                           |   login       Log in to a Docker registry
                           |   logout      Log out from a Docker registry
                           |   logs        Fetch the logs of a container
                           |   pause       Pause all processes within one or more containers
                           |   port        List port mappings or a specific mapping for the container
                           |   ps          List containers
                           |   pull        Pull an image or a repository from a registry
                           |   push        Push an image or a repository to a registry
                           |   rename      Rename a container
                           |   restart     Restart one or more containers
                           |   rm          Remove one or more containers
                           |   rmi         Remove one or more images
                           |   run         Run a command in a new container
                           |   save        Save one or more images to a tar archive (streamed to STDOUT by default)
                           |   search      Search the Docker Hub for images
                           |   start       Start one or more stopped containers
                           |   stats       Display a live stream of container(s) resource usage statistics
                           |   stop        Stop one or more running containers
                           |   tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
                           |   top         Display the running processes of a container
                           |   unpause     Unpause all processes within one or more containers
                           |   update      Update configuration of one or more containers
                           |   version     Show the Docker version information
                           |   wait        Block until one or more containers stop, then print their exit codes
</pre>
</td>
<td title>
    Docker<br/>
    Install and<br/>
    setup
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Proxy settings</span>
To configure Docker to work with an HTTP or HTTPS proxy server, follow 
instructions for your OS:
Windows - <a href="https://docs.docker.com/docker-for-windows/#proxies">Get Started with Docker for Windows</a>
macOS   - <a href="https://docs.docker.com/docker-for-mac/">Get Started with Docker for Mac</a>
Linux   - <a href="https://docs.docker.com/engine/admin/systemd/#httphttps-proxy">Control&amp;config. Docker with Systemd</a>
</pre>

<pre xxxsmall zoom>
<span xsmall>docker global info</span>
<span xsmall>system setup</span>
<span xsmall>running/paused/stopped cont.</span>
$ sudo docker info
Containers: 23
 Running: 10
 Paused: 0
 Stopped: 1
Images: 36
Server Version: 17.03.2-ce
*Storage Driver: devicemapper*
 Pool Name: docker-8:0-128954-pool
 Pool Blocksize: 65.54 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: ext4
 Data file: /dev/loop0
 Metadata file: /dev/loop1
*Data Space Used: 3.014 GB*
*Data Space Total: 107.4 GB*
*Data Space Available: 16.11 GB*
*Metadata Space Used: 4.289 MB*
*Metadata Space Total: 2.147 GB*
*Metadata Space Available: 2.143 GB*
*Thin Pool Minimum Free Space: 10.74 GB*
 Udev Sync Supported: true
 Deferred Removal Enabled: false
 Deferred Deletion Enabled: false
 Deferred Deleted Device Count: 0
*Data loop file: /var/lib/docker/devicemapper/devicemapper/data*
*Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata*
 Library Version: 1.02.137 (2016-11-30) 
*Logging Driver: json-file*
*Cgroup Driver: cgroupfs*
Plugins: 
 Volume: local
 Network: bridge host macvlan null overlay
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 4ab9917febca54791c5f071a9d1f404867857fcc
runc version: 54296cf40ad8143b62dbcaa1d90e520a2136ddfe
init version: 949e6fa
*Security Options:*
* seccomp*
*  Profile: default*
Kernel Version: 4.17.17-x86_64-linode116
Operating System: Debian GNU/Linux 9 (stretch)
OSType: linux
Architecture: x86_64
CPUs: 2
Total Memory: 3.838 GiB
Name: 24x7
ID: ZGYA:L4MN:CDCP:DANS:IEHQ:XYLD:C5KG:SUL4:3XLQ:ZO6M:3RSY:V6VB
*Docker Root Dir: /var/lib/docker*
*Debug Mode (client): false*
*Debug Mode (server): false*
*Registry: https://index.docker.io/v1/*
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
</pre>

<pre xxxsmall zoom>
<span xsmall>/var/run/docker.sock</span>
@[https://medium.com/better-programming/about-var-run-docker-sock-3bfd276e12fd]
- Unix socket the Docker daemon listens on by default,
  used to communicate with the daemon from within a container.
- Can be mounted on containers to allow them to control Docker:
$ docker run*-v /var/run/docker.sock:/var/run/docker.sock*  ....

USSAGE EXAMPLE:

# STEP 1. Create new container
$ curl -XPOST*--unix-socket /var/run/docker.sock* \
  -d '{"Image":"nginx"}' \
  -H 'Content-Type: application/json' \
  http://localhost/containers/create
Returns something similar to:
→ {"Id":"fcb65c6147efb862d5ea3a2ef20e793c52f0fafa3eb04e4292cb4784c5777d65","Warnings":null}

# STEP 2. Use /containers/<ID>/start to start the newly created container.
$ curl -XPOST*--unix-socket /var/run/docker.sock* \
  http://localhost/containers/fcb6...7d65/start

# STEP 3: Verify it's running:
$ docker container ls
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
fcb65c6147ef nginx “nginx -g ‘daemon …” 5 minutes ago Up 5 seconds 80/tcp, 443/tcp ecstatic_kirch
...

*Streaming events from the Docker daemon*

- Docker API also exposes the*/events endpoint*

$ curl*--unix-socket /var/run/docker.sock* http://localhost/events 
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
  command hangs on, waiting for new events from the daemon. 
  Each new event will then be streamed from the daemon.
</pre>



</td>
</tr>
</table>

<table>
<tr>
<td title>
    Docker<br/>
    components
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Docker Networks</span>
Create new network and use it in containers:
  $ docker *network create* o*redisNetwork*
  $ docker run --rm --name redis-server --network o*redisNetwork* -d redis 
  $ docker run --rm --network o*redisNetwork* -it redis redis-cli -h redis-server -p 6379

List networks:
  $ docker network ls

Disconect and connect a container to the network:
  $ docker disconnect o*redisNetwork* redis-server 
  $ docker connect --alias db o*redisNetwork* redis-server
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Volumes</span>
  
REUSE VOLUME FROM CONTAINER:
  STEP 0: Create new container with volume
    host-mach $ docker run -it o*--name alpha* *-v "hostPath":/var/log* ubuntu bash
    container $ date &gt; /var/log/now
     
  STEP 1: Create new container using volume from previous container:
    host-mach $ docker run --volumes-from o*alpha* ubuntu 
    container $ cat /var/log/now 

CREAR VOLUME FOR REUSE IN DIFFERENT CONTAINERS

  STEP 0: Create Volume
  host-mach $ docker volume create --name=o*websiteVolume*
  STEP 1: Use volume in new container
  host-mach $ docker run -d -p 8888:80 \
              -v o*websiteVolume*:/usr/share/nginx/html
              -v logs:/var/log/nginx nginx 
  host-mach $ docker run 
              -v o*websiteVolume*:/website
              -w /website \
              -it alpine vi index.html

Ex.: Update redis version without loosing data:
  host-mach $ docker network create dbNetwork
  host-mach $ docker run -d --network dbNetwork \
              --network-alias redis \
              --name redis28 redis:2.8
  host-mach $ docker run -it --network dbNetwork \
              alpine telnet redis 6379
              → SET counter 42 
              → INFO server
              → SAVE
              → QUIT
  host-mach $ docker stop redis28
  host-mach $ docker run -d --network dbNetwork \
              --network-alias redis \
              --name redis30 \
              --volumes-from redis28 \
              redis:3.0
  host-mach $ docker run -it --network dbNetwork \
              alpine telnet redis 6379
              → GET counter
              → INFO server
              → QUIT
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>docker-compose</span>
version: "3"
services:
  web:
    build: .         # ← use Dockerfile to build image
    ports:
      - "8000:8000"
  redis:
    image: redis     # ← use DockerHub image
    volumes:
      - "redis-data:/data"

volumes:
  redis-data:
</pre>
</td>
<td>
<pre xxxsmall zoom>
<a TODO xsmall href="https://docs.docker.com/registry/#what-it-is">Registry</a>
(server store for images)
</pre>
</td>

<td title>
  Managing<br/>
  Containers
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Boot-up/run container:</span>
$ docker run \                             $ docker run \
  --rm  \        ←------ Remove ---------→   --rm  \       
  --name clock  \        on exit             --name clock  \
 *-d*\             ← Daemon    interactive →*-ti*\ 
                     mode      mode                       
  jdeiviz/clock                              jdeiviz/clock


<span xsmall>Show container logs:</span>
$ docker logs docker 
$ logs --tail 3
$ docker logs --tail 1 --follow

<span xsmall>Stop container:</span>
$ docker stop # Espera 10s docker kill

<span xsmall>Prune stopped containers:</span>

$ docker container prune

<span xsmall>container help:</span>
$ docker container
</pre>
<pre xxxsmall zoom>
<span xsmall>ENTRYPOINT</span>
<span xsmall>vs</span>
<span xsmall>COMMAND</span>
Extracted from:
- @[https://docs.docker.com/engine/reference/run/#entrypoint-default-command-to-execute-at-runtime]
The ENTRYPOINT of an image is similar to a COMMAND because it specifies what
executable to run when the container starts, 
*but it is (purposely) more difficult to override*.

- The ENTRYPOINT gives a container its default nature or behavior, so that when 
you set an ENTRYPOINT you can run the container as if it were that binary,
complete with default options, and you can pass in more options via the COMMAND.
But, sometimes an operator may want to run something else inside the container,
so you can override the default ENTRYPOINT at runtime by using a string to specify the 
new ENTRYPOINT. 

*Override Entrypoint @ docker-run passing extra parameters
$ docker run -it --entrypoint /bin/bash ${DOCKER_IMAGE} -c ls -l
                 └───────┬────────────┘                 └───┬───┘
                  overrides the entrypoint             extra params.
                                                      (exec 'ls -l' script)

</pre>

</td>


<td title>
    Monitoring<br/>
    running<br/>
    containers<br>
</td>

<td>
<pre xxxsmall zoom>
<span xsmall>Monitoring (Basic)</span>
List containers instances:
   $ docker ps     # only running
   $ docker ps -a  # also finished, but not yet removed (docker rm ...)
   $ docker ps -lq # TODO:

"top" containers showing Net IO read/writes, Disk read/writes:
   $ docker stats
   | CONTAINER ID   NAME                    CPU %   MEM USAGE / LIMIT     MEM %   NET I/O          BLOCK I/O      PIDS
   | c420875107a1   postgres_trinity_cache  0.00%   11.66MiB / 6.796GiB   0.17%   22.5MB / 19.7MB  309MB / 257kB  16
   | fdf2396e5c72   stupefied_haibt         0.10%   21.94MiB / 6.796GiB   0.32%   356MB / 693MB    144MB / 394MB  39

   $ docker top 'containerID'
   | UID       PID     PPID    C  STIME  TTY   TIME     CMD
   | systemd+  26779   121423  0  06:11  ?     00:00:00 postgres: ddbbName cache 172.17.0.1(35678) idle
   | ...
   | systemd+  121423  121407  0  Jul06  pts/0 00:00:44 postgres
   | systemd+  121465  121423  0  Jul06  ?     00:00:01 postgres: checkpointer process
   | systemd+  121466  121423  0  Jul06  ?     00:00:26 postgres: writer process
   | systemd+  121467  121423  0  Jul06  ?     00:00:25 postgres: wal writer process
   | systemd+  121468  121423  0  Jul06  ?     00:00:27 postgres: autovacuum launcher process
   | systemd+  121469  121423  0  Jul06  ?     00:00:57 postgres: stats collector process

</pre>
<pre xxxsmall zoom>
<span xsmall TODO>SysDig</span>
Container-focused Linux troubleshooting and monitoring tool.

Once Sysdig is installed as a process (or container) on the server,
it sees every process, every network action, and every file action
on the host. You can use Sysdig "live" or view any amount of historical 
data via a system capture file.

Example: take a look at the total CPU usage of each running container:
   $ sudo sysdig -c topcontainers\_cpu
   | CPU% container.name 
   | ---------------------------------------------------- 
   | 80.10% postgres
   | 0.14% httpd
   | ...
   | 

Example: Capture historical data:
   $ sudo sysdig -w historical.scap

Example: "Zoom into a client":
   $ sudo sysdig -pc -c topprocs\_cpu container. name=client
   | CPU% Process container.name
   | ----------------------------------------------
   | 02.69% bash client
   | 31.04%curl client
   | 0.74% sleep client
</pre>
<pre TODO xxxsmall zoom>
<span xsmall> cAdvisor</span>
<span xsmall>+Prometheus</span>
<span xsmall>+Grafana</span>
@[https://dzone.com/refcardz/intro-to-docker-monitoring?chapter=6]
</pre>
</td>
<td colsep>
</td>
</tr>
</table>
<br/>
<table>
<tr>
<td title>
    Managing<br/>
    Images
</td>
<td>
<pre xxxsmall zoom>
  <span xsmall>Managing images</span>
(List all image related commands with: $ docker image)

List local ("downloaded/instaled") images:
  $ docker images

Search remote images @ Docker Hub: | Download image from Docker Hub: | Upload image to Docker Hub:
  $ docker search redis            |   $ docker pull debian:jessie   |   $ docker login
                                                                     |   $ docker push /clock:1.0

Remove (local) image:     
  $ docker rmi /clock:1.0 
  $ docker image prune    # Remove *all* non used images
</pre>

<pre xxxsmall zoom>
<span xsmall>Build image</span>
$ docker build \
   --build-arg http_proxy=http://...:8080 \
   --build-arg https_proxy=https://..:8080 \
   -t figlet .

$ cat ./Dockerfile
FROM ubuntu

RUN apt-get update
# Instalar figlet

ENTRYPOINT ["figlet", "-f", "script"]
</pre>


<pre xxxsmall zoom>
  <span xsmall>Image tags</span>
adding a tag to the image essentially adds an alias 
The tags consists of: 
    'registry_server'/'user_name'/'image_name':'tag'
    ^^^^^^^^^^^^^^^^^
    default one if not
    indicated

Tag image:                              
  $ docker tag jdeiviz/clock /clock:1.0 
</pre>
<pre xxxsmall zoom>
<span xsmall>Show image</span>
<span xsmall>change history</span>
   $ docker history /clock:1.0
</pre>
<pre xxxsmall zoom>
<span xsmall>Commit image</span>
<span xsmall>modifications</span>
(Discouraged most of the time, modify Dockerbuild instead)
host-mach $ docker run -it ubuntu bash     # Boot up existing image
container # apt-get install ...            # Apply changes to running instance
host-mach $ docker diff $(docker ps -lq)   # Show changes done in running container
host-mach $ docker commit $(docker ps -lq) # Commit/Confirm changes
host-mach $ docker tag figlet              # Tage new image 
host-mach $ docker run -it figlet          # Boot new image instance
</pre>
</td>
<td title>
    Advanced<br/>
    Image<br/>
    creation<br>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>ONBUILD</span>
<span xsmall>(base Dockerfile</span>
<span xsmall> for devel)</span>
  
Modify base image adding "ONBUILD" in places that are executed just during build
in the image extending base image: 
| Dockerfile.base                | Dockerfile
| FROM node:7.10-alpine          | FROM node-base
|                                | 
| RUN mkdir /src                 | EXPOSE 8000
| WORKDIR /src
| 
| ONBUILD ARG NODE_ENV
| ONBUILD ENV NODE_ENV $NODE_ENV
| 
| COPY package.json /src
| 
| RUN npm install
| 
| COPY . /src
| 
| CMD [ "npm", "start" ]

  $ docker build -t node-base -f Dockerfile.base . # STEP 1: Compile base image
  $ docker build -t node -f Dockerfile .           # STEP 2: Compile image
  $ docker run -p 8000:8000 -d node
</pre>
</td>
<td>
<pre xxxsmall zoom>
<span xsmall>Multi-Stage </span>
- Multi-Stage allows for final "clean" images that will
  contain just the application binaries, with no building
  or compilation intermediate tools needed during the build.
  This allow for much lighter final images.
                   ┌───────────────────────────────┼────────────────────────────────────────────────┐
                   │ "STANDARD" BUILD              │ multi─stage BUILD                              │
┌──────────────────┼───────────────────────────────┼────────────────────────────────────────────────┤
│Dockerfile        │ Dockerfile                    │ Dockerfile.ms                                  │
│                  │ FROM golang:alpine            │ FROM *golang:alpine* AS o*build─env*           │
│                  │ WORKDIR /app                  │ ADD . /src                                     │
│                  │ ADD . /app                    │ RUN cd /src ; go build ─o app                  │
│                  │ RUN cd /app ; go build ─o app │                                                │
│                  │ ENTRYPOINT ./app              │ FROM*alpine*                                   │
│                  │                               │ WORKDIR /app                                   │
│                  │                               │ COPY ──from=o*build─env* /src/app /app/        │
│                  │                               │ ENTRYPOINT ./app                               │
├──────────────────┼───────────────────────────────┼────────────────────────────────────────────────┤
│ Compile image    │ $ docker build . ─t hello─go  │ $ docker build . ─f Dockerfile.ms ─t hello─goms│
├──────────────────┼───────────────────────────────┼────────────────────────────────────────────────┤
│ Exec container   │ $ docker run hello─go         │ $ docker run hello─goms                        │
├──────────────────┼───────────────────────────────┼────────────────────────────────────────────────┤
│ Check image size │ $ docker images               │ $ docker images                                │
└──────────────────┴───────────────────────────────┴────────────────────────────────────────────────┘
</pre>
<pre xxxsmall zoom>
  <a xsmall href="https://github.com/GoogleContainerTools/distroless">Distroless</a>
- "Distroless" images contain only your application and its runtime dependencies.
(not package managers, shells,...)
Notice: In kubernetes we can also use init containers with non-light images
        containing all set of tools (sed, grep,...) for pre-setup, avoiding
        any need to include in the final image. 

Stable:                      experimental (2019-06)
gcr.io/distroless/static     gcr.io/distroless/python2.7
gcr.io/distroless/base       gcr.io/distroless/python3
gcr.io/distroless/java       gcr.io/distroless/nodejs
gcr.io/distroless/cc         gcr.io/distroless/java/jetty
                             gcr.io/distroless/dotnet

Ex java Multi-stage Dockerfile:
@[https://github.com/GoogleContainerTools/distroless/blob/master/examples/java/Dockerfile]
 *FROM*openjdk:11-jdk-slim  ASo*build-env*
  ADD . /app/examples
  WORKDIR /app
  RUN javac examples/*.java
  RUN jar cfe main.jar examples.HelloJava examples/*.class 
  
  FROM gcr.io/distroless/java:11
  COPY --from=o*build-env* /app /app
  WORKDIR /app
  CMD ["main.jar"]
</pre>
</td>


<td>
<pre xxxsmall zoom>
<span xsmall>alpine how-to</span>
Next image (golang) is just*6Mbytes*in size:
@[https://hub.docker.com/r/ethereum/solc/dockerfile]
Dockerfile:
    01	FROM alpine
    02	MAINTAINER chriseth <chris@ethereum.org>
    03	  
    04	RUN \
    05	  apk --no-cache --update add build-base cmake boost-dev git                                                && \
    06	  sed -i -E -e 's/include &lt;sys\/poll.h>/include &lt;poll.h>/' /usr/include/boost/asio/detail/socket_types.hpp  && \
    07	  git clone --depth 1 --recursive -b release https://github.com/ethereum/solidity                           && \
    08	  cd /solidity && cmake -DCMAKE_BUILD_TYPE=Release -DTESTS=0 -DSTATIC_LINKING=1                             && \
    09	  cd /solidity && make solc && install -s  solc/solc /usr/bin                                               && \
    10	  cd / && rm -rf solidity                                                                                   && \
    11	  apk del sed build-base git make cmake gcc g++ musl-dev curl-dev boost-dev                                 && \
    12	  rm -rf /var/cache/apk/*

Notes:
  - line 07: *--depth 1*: faster cloning (just last commit)
  - line 07: the cloned repo contains next *.dockerignore*:
    01 # out-of-tree builds usually go here. This helps improving performance of uploading
    02 # the build context to the docker image build server
    03*/build*
    04 
    05 # in-tree builds
    06*/deps*
</pre>
</td>

</tr>
</table>
</body>

<!--
TODO_Start:
https://kerneltalks.com/virtualization/8-basic-docker-container-management-commands/
_______________________
Docker Remote API SDK:
https://docs.docker.com/develop/sdk/
__________________
https://www.linux-toys.com/archives/1554
________________________
https://coreos.com/clair/docs/latest/
Clair is an open source project for the static analysis of vulnerabilities in appc and docker containers.

Vulnerability data is continuously imported from a known set of sources and correlated with the indexed contents of container images in order to produce lists of vulnerabilities that threaten a container. When vulnerability data changes upstream, the previous state and new state of the vulnerability along with the images they affect can be sent via webhook to a configured endpoint. All major components can be customized programmatically at compile-time without forking the project.
______________________
https://www.infoq.com/news/2015/02/under-hood-containers
___________________
https://stackoverflow.com/questions/19897743/exposing-a-port-on-a-live-docker-container
_________________________
https://www.eweek.com/cloud/red-hat-advances-container-technology-with-podman-1.0
______________________
https://blog.couchbase.com/monitoring-docker-containers-docker-stats-cadvisor-universal-control-plane/
Monitoring Docker Containers – docker stats, cAdvisor, Universal Control Plane
_______________________________
https://jvns.ca/blog/2016/12/22/container-networking/ !!!
____________________________
https://docs.docker.com/storage/storagedriver/
____________________________
https://www.infoq.com/news/2019/01/docker-windows-server-2019
_______________________________
<td>
  Troubleshooting
<pre xxxsmall zoom>
- /var/lib/docker/devicemapper/devicemapper/data consumes too much space
$ sudo du -sch /var/lib/docker/devicemapper/devicemapper/data
14G     /var/lib/docker/devicemapper/devicemapper/data
<a href="https://meta.discourse.org/t/why-is-docker-devicemapper-taking-so-much-hard-drive-space/34378">[REF@StackOverflow]</a>

</pre>

</td>
____________________________________
<td>
  <a href="https://docs.docker.com/config/containers/live-restore/">Live Restore</a>
<pre xxxsmall zoom>
Keep containers alive during daemon downtime
</pre>

</td>
____________________________________
Docker + Device Mapper + LVM + ...
https://docs.docker.com/storage/storagedriver/device-mapper-driver/
___________________________
https://github.com/opencontainers/runc

CLI tool for spawning and running containers according to the OCI specification https://www.opencontainers.org/
______________________
https://www.opencontainers.org/
___________________________________
https://opensource.com/article/19/3/tips-tricks-rootless-buildah
How rootless Buildah works: Building containers in unprivileged environments
    Buildah is a tool and library for building Open Container Initiative (OCI) container images.
    In previous articles, including How does rootless Podman work?, I talked 
    about Podman, a tool that enables users to manage pods, containers, and container images.
    Buildah is a tool and library for building Open Container Initiative (OCI) 
    container images that is complementary to Podman. (Both projects are 
    maintained by the containers organization, of which I'm a member.) In this 
    article, I will talk about rootless Buildah, including the differences between it and Podman.
_________________________________
https://lwn.net/Articles/788282/
____________________________________
https://opensource.com/business/15/3/docker-security-tuning
______________________
https://www.eweek.com/enterprise-apps/docker-enterprise-3.0-advances-container-development
__________________
https://medium.com/better-programming/about-var-run-docker-sock-3bfd276e12fd

___________________
- Portainer, an open-source management interface used to manage a Docker host or a Swarm cluster.
-->

</html>
