<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>gRPC Summary (v1.0)</title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body onLoad='onPageLoaded()'>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- {{{ START }}} -->
<table style='width:100%'{>
<tbody>
<tr {>
  <td col1 >
  PROTOC + gRPC INSTALLATION STEPS<br/>
  <ol> 
  <li> STEP 1: ProtoC installation: Unpack <code>protoc-3.x...x86_64.zip</code>
<pre xxxsmall zoom { >
from  https://github.com/google/protobuf/releases to /opt/protoc
$ sudo ln -s \
  /opt/protoc/include/google/protobuf \
  /usr/include/google/protobuf
$ sudo ln -s /opt/protoc/bin/protoc \
  /usr/bin/protoc
</pre } >
   </li>
   <li>Install Node/Python/Go/... tools: <a href="http://www.grpc.io/blog/installation">REF</a>
<pre xxxsmall zoom{ >
Language |Platform|Command
---------+--------+------------------------------------
Node.js  |All     |npm install -g grpc
         |        |(installs the grpc_node_plugin @
         |        |/usr/(local/)lib/node_modules
         |        |/grpc-tools/bin
---------+--------+------------------------------------
Python   |All     |pip install grpcio
---------+--------+------------------------------------
Ruby     |All     |gem install grpc
---------+--------+------------------------------------
PHP      |All     |pecl install grpc-beta
---------+--------+------------------------------------
Go       |All     |go get google.golang.org/grpc
---------+--------+------------------------------------
Objective|Mac     |Runtime source fetched automatically
-C        |        |from Github by Cocoapods
---------+--------+------------------------------------
C#       |Windows |Install gRPC NuGet package from your
         |        |IDE(V.Studio, Monodevelop, ...)
---------+--------+------------------------------------
Java     |All     |Use our Maven and Gradle plugins 
         |        |that provide gRPC with statically 
         |        |linked boringssl
---------+--------+------------------------------------
C++      |All     |Currently requires manual 
         |        |build and install
</pre } >
  </li>
  </td>  
  <td col2 >
    <span xbig>Compiling</span><br/>
    NodeJS: 
<pre xxxsmall zoom { >
(COMMENTED SHELL EXAMPLE TO GENERATE JS PROTOBUF & gRPC SERVICE:)
#!/bin/sh
set -e # script option. Abort on first error.

PROTOC=/opt/protoc_v3/bin/protoc # <- PATH to protoc compiler executable
OUT_DIR="./src/lib/protobuf"

if [ ! -d ${OUT_DIR} ]; then mkdir -p ${OUT_DIR} ; fi

# protoc fails if relative path is provided. (2017-01)
GRPC_NODE_PLUGIN=/usr/local/lib/node_modules/grpc-tools/bin/grpc_node_plugin

${PROTOC} \
 --proto_path=../project_proto_definition/   # <- Path to search *proto for
 --js_out=import_style=commonjs,\
                          binary:${OUT_DIR} \# <- JS protobuf output path
\
 --grpc_out=${OUT_DIR} \                     # <- gRPC(services) output path
 --plugin=protoc-gen-grpc=\                    # <- gRPC service related
          ${GRPC_NODE_PLUGIN} \ 
 file1.proto
</pre } >
  <hr/>
  JAVA: <a href="https://github.com/grpc/grpc-java/blob/master/README.md">REF</a><br/>
  Gradle protobuf conf:
<pre xxxsmall zoom { >
apply plugin: 'java'
apply plugin: 'com.google.protobuf'

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }

}
</pre } >
  Java Gradle+grpc conf:
<pre xxxsmall zoom { >
compile 'io.grpc:grpc-netty:1.0.1'        non-Android
compile 'io.grpc:grpc-protobuf:1.0.1'
compile 'io.grpc:grpc-stub:1.0.1'

compile 'io.grpc:grpc-okhttp:1.0.1'       Android:
compile 'io.grpc:grpc-protobuf-lite:1.0.1'
compile 'io.grpc:grpc-stub:1.0.1'
         
...
protobuf {
  protoc { artifact = "com.google.protobuf:protoc:3.1.0" }
  plugins {
    grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.0.1' }
  }
  generateProtoTasks { all()*.plugins { grpc {} } }
}
</pre } >
  </td>  
  <td col3 >
  <b>gRPC PROTOBUF EXCEPTION HANDLING</b><br/>
  <p xsmall zoom>
  C&P FROM: http://stackoverflow.com/questions/38810657/exception-handling-in-grpc<br/>
    Q: I have a server written in Java and client written in PHP.
   How can client catch exception from server if anything goes wrong?
   I can't find anything about exception handling in gRPC documentation.
   <br/>
   <br/>
    A: For handled exceptions, call responseObserver.onError(). If you pass in a
    StatusRuntimeException or StatusException (generally created via
    status.asRuntimeException()) the status code and description will be
    communicated to the client.<br/>
    <br/>
     Unhandled exceptions within a callback will cancel the RPC and will continue
    propagating the exception (generally leading in an UncaughtExceptionHandler being
    called for the executor).
  </p>
  </pre } >
  </td>  
</tr }>
</table>

<table>
<tr {>
  <td col1 colspan=2>
  JAVA SERVICE/SERVER PROTO IMPLEMENTATION SUMMARY<br/>
  gRPC defs:
<pre xxxsmall zoom { >
service RouteGuide {
  rpc GetFeature(Point) returns (Feature) {}
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}
</pre } >

  <code>RouteGuideServer.java</code>
<pre xxxsmall zoom { >
public class RouteGuideServer 
  ... initialization code ...

   private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase
       ...
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
@Override
public void getFeature(
    Point request, StreamObserver<Feature> responseObserver) {
  // Single onNext iteration
  responseObserver.onNext(_checkFeature(request));
  responseObserver.onCompleted(); /* <- ends inmediatelly */
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
@Override
public void listFeatures(
     Rectangle request, 
     StreamObserver<Feature> responseObserver) {
 for (Feature feature : features) {
      ...  responseObserver.onNext(feature); }
 /* ^ one onNext for each feature found
  * (streaming response) */ 
 responseObserver.onCompleted();
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
@Override
public StreamObserver<Point> recordRoute(
    final StreamObserver<RouteSummary> responseObserver) {
  return new StreamObserver<Point>() {
    @Override
    public void onNext(Point point) { ... }

    @Override
    public void onError(Throwable t) { 
        logger.log(Level.WARNING, "recordRoute cancelled"); 
    }

    @Override
    public void onCompleted() {
      long seconds = 
          NANOSECONDS.toSeconds(System.nanoTime() - startTime);
      responseObserver.onNext(RouteSummary.newBuilder()
          .setPointCount(pointCount)
          .setFeatureCount(featureCount).setDistance(distance)
          .setElapsedTime((int) seconds).build());
      responseObserver.onCompleted(); // End stream (Single res.)
    }
  };
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
@Override
public StreamObserver<RouteNote> routeChat(
    final StreamObserver<RouteNote> responseObserver) {
  return new StreamObserver<RouteNote>() {
    @Override public void onNext(RouteNote note) {
      for (RouteNote prevNote : notes.toArray(new RouteNote[0])) {
        responseObserver.onNext(prevNote);
      }
      ...
    }

    @Override
    public void onError(Throwable t) { 
        logger.log(Level.WARNING, "routeChat cancelled"); 
    }

    // Do not complete until received onCompleted for peer
    @Override public void onCompleted() {
       responseObserver.onCompleted(); 
    }
  };
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
  CLIENT PROTO IMPLEMENTATION SUMMARY<br/>
  <a href="https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/route_guide_server.js">REF: static_codegen/route_guide/route_guide_server.js</a><br/>
  Initialization code:
<pre xxxsmall zoom { >
function getServer() {                            | if (require.main === module) {                  
  var server = new grpc.Server();                 |   var routeServer = getServer();                
  server.addService(services.RouteGuideService, { |   routeServer.bind('0.0.0.0:50051',             
    getFeature: getFeature,                       |       grpc.ServerCredentials.createInsecure()); 
    listFeatures: listFeatures,                   |   ...                                           
    recordRoute: recordRoute,                     |   routeServer.start();                          
    routeChat: routeChat                          | });                                             
  });                                             | exports.getServer = getServer;                  
  return server;                                  |
}
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
feature = blockingStub.getFeature(Point.newBuilder().....build());
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
Rectangle request = Rectangle.newBuilder()....build();
Iterator&lt;Feature> features = blockingStub.listFeatures(request);
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
public void recordRoute(List&lt;Feature> features, int numPoints)
     throws InterruptedException
  // NOTE: java.util.concurrent.CountDownLatch details removed

  // STEP 1. SETUP RESPONSE OBSERVER
  StreamObserver&lt;RouteSummary> responseObserver = 
      new StreamObserver&lt;RouteSummary>() {
    @Override
        public void onNext(RouteSummary summary) {
            info... summary.get*()); 
        }
    @Override
        public void onError/*RPC failed*/(Throwable t) {
            log ... Status.fromThrowable(t););
        }
    @Override
        public void onCompleted(){ 
            finishLatch.countDown(); 
        }
  };

  // STEP 2. SETUP REQUEST OBSERVER
  StreamObserver&lt;Point> requestObserver = 
      asyncStub.recordRoute(responseObserver);
--------------------------------------------------------
  try {
    for (int i = 0; i &lt; numPoints; ++i) {
      // push point to req.stream
      requestObserver.onNext(point);
      if (finishLatch.getCount() == 0 ) {
        /* RPC completed|failed before end of
         * request stream 
         * Sending further requests won't error,
         * but they will just be thrown away.
         */
        // 
        return; 
      }
    }
  } catch (RuntimeException e) {
      requestObserver.onError(e) /* Cancel RPC */; 
      throw e; 
  }
  requestObserver.onCompleted(); // Mark the end of requests

  // Receiving happens asynchronously
  finishLatch.await(1, /*java.util.concurrent.*/TimeUnit.MINUTES);
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
public void routeChat() throws InterruptedException {
  // **********************************
  // rpc RouteChat(stream RouteNote)
  //     returns (stream RouteNote) {}
  // **********************************

  // STEP 1. SETUP RESPONSE OBSERVER
  final CountDownLatch finishLatch = new CountDownLatch(1);
  StreamObserver&lt;RouteNote> requestObserver =
      asyncStub.routeChat(new StreamObserver&lt;RouteNote>() {
        @Override 
        public void onNext(RouteNote note) {
            info"Got message ... "; }
        @Override 
        public void onError(Throwable t) {
            warn ... Status.fromThrowable(t);}
        @Override 
        public void onCompleted() {
            finishLatch.countDown(); }
      });

// ----------------------------------------------------------
  // STEP 2: SETUP REQUEST OBSERVER
                          try {
  RouteNote[] requests = {newNote(...), newNote .. };
  for (RouteNote request : requests) {
    requestObserver.onNext(request); // &lt;- Sen Message
  }
                          } catch (RuntimeException e) {
  requestObserver.onError/*Cancel RPC*/(e); throw e;
  requestObserver.onCompleted(); // Mark the end of requests
  // Receiving happens asynchronously
  finishLatch.await(1, TimeUnit.MINUTES);
}
</pre } >
      </td>
    </tr>
    </table>
  </td>
</tr }>
</table>

<table>
<tr {>
  <td col1 colspan=2 >
    NODE.JS SERVER PROTO IMPLEMENTATION SUMMARY:<br/>
    <a href="https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/">REF</a>
    SERVER INITIALIZATION
<pre xxxsmall zoom { >
var routeServer = new grpc.Server();
routeServer.addService(services.RouteGuideService, {
  getFeature: getFeature,
  listFeatures: listFeatures,
  recordRoute: recordRoute,
   routeChat: routeChat
});
routeServer.bind('0.0.0.0:50051',
                 grpc.ServerCredentials.createInsecure());
... "any other initialization"...
routeServer.start();
</pre } >
    <table style="min-width:auto;max-width:auto;">
    <tr>
      <th style="min-width:auto;max-width:auto;">&nbsp;</th>
      <th style="min-width:auto;max-width:auto;">SINGLE RESPONSE</th>
      <th style="min-width:auto;max-width:auto;">STREAM RESPONSE</th>
    </tr>

    <tr>
      <th style="min-width:auto;max-width:auto;">SINGLE<br/>REQUEST</th>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function getFeature/* single request/response */
  (call, callback /*Response callback*/) {
  callback(null, feature ); // <- write response
}
</pre } >
      </td>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function listFeatures/* single request/stream response */
  (call/* call.request == Rectangle (lo, hi) */) {
  _.each(feature_list, function(feature) {
    if ("feature OK") {
      call.write(feature); // <-- write to response stream
    }
  });
  call.end(); // <-- end stream
}
</pre } >
      </td>
    </tr>
    <tr>
      <th style="min-width:auto;max-width:auto;">STREAM<br/>REQUEST</th>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function recordRoute /*stream request, single response*/
  (call /* <- stream */, callback) {
  call.on('data', function(point) { ... });
  call.on('end', function() {
    var summary = new messages.RouteSummary().set...;
    callback(null, summary);
  });
}
</pre } >
      </td>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function routeChat /* stream request, stream response */
  (call /* <- stream. NOTE: no callback*/) {
  call.on('data', function(note) {
    _.each(internal_data, function(note) {
      call.write(note); // <- write to response stream
    });
  });
  call.on('end', function() { call.end(); });
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
  <span>NODE.JS CLIENT PROTO IMPLEMENTATION SUMMARY:</span><br/>
  INITIALIZATION
<pre xxxsmall zoom { >
messages = require('...._pb');
services = require('...._grpc_pb');
grpc = require('grpc');

client = new services.RouteGuideClient(
    'localhost:50051',
    grpc.credentials.createInsecure());
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
function featureCallback(error, feature) {
  if (error) { .... ;  return; }
  var latitude = feature.getLocation()....
  ...
  next();
}
client.getFeature(point1, featureCallback);

</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
function runListFeatures(callback) {
  var call = client.listFeatures(rect);
  call.on('data', function(feature) {
      /* do whatever with feature object */
  });
  call.on('end', callback);
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
// STEP 1. Create a call.write(able) object
var call = client.recordRoute(
  function(error, stats /*<- server response*/) {
    if (error) { ...;  return; }
    /* Do whatever with stats response */
  }
);
// STEP 2. Write to stream
for ("location in ddbb") {
   call.write(location);
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
function runRouteChat(callback) {
  // STEP 1. create call.write(able) object with onData notifier
  var call = client.routeChat(); 
  call.on('data', function(note /*response from stream*/) {
      // STEP 2. callback for stream response object received
      // do whatever with note response
  });
  // STEP 3. Setup onEnd
  call.on('end', callback);

  // STEP 4. Write to request stream
  for ("note in note_ddbb") {
    var noteMsg = new messages.RouteNote().setXXX..;
    call.write(noteMsg);
  }
  call.end();
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
</tr }>
</body>
<!--
https://blog.gopheracademy.com/advent-2017/go-grpc-beyond-basics/
____________________________
See also Rsocket, that authors claim to be better than gRPC:
    https://github.com/rsocket/rsocket/blob/master/Motivations.md

-->

</html>
