<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>changeme title</title>
<!--
 Q:Note what the attribute { and } do:
 A:Those attributes are ignored by the browser but are helpful to fold/unfold text in some
   editors (Vim, Emacs,...)
-->
<!--
ROW TEMPLATE
<tr {>
  <td col1 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col2 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
  <td col3 >
     <ul>
       <li> </li>
       <li> </li>
       <li> </li>
     </ul>
  </td>  
</tr }>
-->

<head>
<script>
var zoomDivDOM
function onZoomDivDoubleClick() { zoomDivDOM.innerHTML = ''; }
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 
function onTDDoubleClick()      { zoomDivDOM.innerHTML = 
     "('Esc' to close) Toggle "+
     "<span style='color:blue;' onClick=\"zoomDivFW  = !zoomDivFW ; zoomDivDOM.style.maxWidth  = zoomDivFW  ? '98%' : '30%'\">[Width]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivFH  = !zoomDivFH ; zoomDivDOM.style.maxHeight = zoomDivFH  ? '98%' : '30%'\">[Height]</span> " 
   + " Toggle " 
   + "<span style='color:blue;' onClick=\"zoomDivLft = !zoomDivLft; zoomDivDOM.style.left      = zoomDivLft ? '1%'  : '69%'\">[Horz]</span> " 
   + "<span style='color:blue;' onClick=\"zoomDivTop = !zoomDivTop; zoomDivDOM.style.top       = zoomDivTop ? '1%'  : '69%'\">[Vert]</span> " 
   + " <br/> " 
   + this.innerHTML; 
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  zoomDivDOM.addEventListener('dblclick',onZoomDivDoubleClick, false)
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; onZoomDivDoubleClick(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',onTDDoubleClick, false)
  }
  setTimeout(onZoomDivDoubleClick, 3000);
  removeToLeftMarginInPre();
}
</script>
<style>
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#FFFFFF; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
* xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xbig  ]  { font-size:1.3rem; }
ul { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

#zoomDiv [xxsmall]  , #zoomDiv * [xxsmall] , #zoomDiv * * [xxsmall] , #zoomDiv * * * [xxsmall] { font-size:1em; }
#zoomDiv [xsmall]   , #zoomDiv * [xsmall]  , #zoomDiv * * [xsmall]  , #zoomDiv * * * [xsmall]  { font-size:1em; }
#zoomDiv [small]    , #zoomDiv * [small]   , #zoomDiv * * [small]   , #zoomDiv * * * [small]   { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   position:fixed; top:1%; left:1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.1em;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td[col1] ,th[col1] {background-color:#FFFFFF; min-width:34%; max-width:34%; font-size: 1rem;}
td[col2] ,th[col2] {background-color:#FAFAFA; min-width:33%; max-width:33%; }
td[col3] ,th[col3] {background-color:#FFFFFF; min-width:33%; max-width:33%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

</style>
</head>
<body onLoad='onPageLoaded()'>
<div id='zoomDiv'>Hint: double-click on cell to zoom!!</div>

<table style='width:100%'{>
<tbody>
<tr {>
  <td col1 >
    <span xbig>PROTOC + gRPC INSTALLATION STEPS</span>
    <ol>
      <li>ProtoC installation: Unpack <code>protoc-3.x...x86_64.zip</code>
<pre { >
from  https://github.com/google/protobuf/releases to /opt/protoc
$ sudo ln -s \
  /opt/protoc/include/google/protobuf \
  /usr/include/google/protobuf
$ sudo ln -s /opt/protoc/bin/protoc \
  /usr/bin/protoc
</pre } >
      </li>
      <li>Install grpc-tools: REF: http://www.grpc.io/blog/installation.<br/>
<pre { >
Language   |Platform           |Command
-----------+-------------------+------------------------------------
Node.js    |Linux, Mac, Windows|npm install -g grpc
           |                   |(installs the grpc_node_plugin @
           |                   |/usr/(local/)lib/node_modules
           |                   |/grpc-tools/bin
-----------+-------------------+------------------------------------
Python     |Linux, Mac, Windows|pip install grpcio
-----------+-------------------+------------------------------------
Ruby       |Linux, Mac, Windows|gem install grpc
-----------+-------------------+------------------------------------
PHP        |Linux, Mac, Windows|pecl install grpc-beta
-----------+-------------------+------------------------------------
Go         |Linux, Mac, Windows|go get google.golang.org/grpc
-----------+-------------------+------------------------------------
Objective-C|Mac                |Runtime source fetched automatically
           |                   |from Github by Cocoapods
-----------+-------------------+------------------------------------
C#         |Windows            |Install gRPC NuGet package from your
           |                   |IDE(V.Studio, Monodevelop, ...)
-----------+-------------------+------------------------------------
Java       |Linux, Mac, Windows|Use our Maven and Gradle plugins 
           |                   |that provide gRPC with statically 
           |                   |linked boringssl
-----------+-------------------+------------------------------------
C++        |Linux, Mac, Windows|Currently requires manual 
           |                   |build and install
</pre } >
      </li>
    </ol>
  </td>  
  <td col2 >
    <span xbig>Compiling</span><br/>
    NodeJS: COMMENTED SHELL EXAMPLE TO GENERATE JS PROTOBUF & gRPC SERVICE:
<pre { >

#!/bin/sh
set -e # script option. Abort on first error.

PROTOC=/opt/protoc_v3/bin/protoc # <- PATH to protoc compiler executable
OUT_DIR="./src/lib/protobuf"

if [ ! -d ${OUT_DIR} ]; then mkdir -p ${OUT_DIR} ; fi

# protoc fails if relative path is provided. (2017-01)
GRPC_NODE_PLUGIN=/usr/local/lib/node_modules/grpc-tools/bin/grpc_node_plugin

${PROTOC} \
       --proto_path=../project_proto_definition/            # <- Path to search *proto for
       --js_out=import_style=commonjs,binary:${OUT_DIR} \   # <- JS protobuf output path
       \
       --grpc_out=${OUT_DIR} \                              # <- gRPC (services) output path
       --plugin=protoc-gen-grpc=${GRPC_NODE_PLUGIN} \       # <- gRPC service related
       file1.proto
</pre } >
    JAVA: REF: https://github.com/grpc/grpc-java/blob/master/README.md 
<pre { >
Java Gradle protobuf conf:

apply plugin: 'java'
apply plugin: 'com.google.protobuf'

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }

}
</pre } >

<pre { >
Java Gradle+grpc conf:

non-Android

    compile 'io.grpc:grpc-netty:1.0.1'
    compile 'io.grpc:grpc-protobuf:1.0.1'
    compile 'io.grpc:grpc-stub:1.0.1'

Android:
    compile 'io.grpc:grpc-okhttp:1.0.1'
    compile 'io.grpc:grpc-protobuf-lite:1.0.1'
    compile 'io.grpc:grpc-stub:1.0.1'
</pre } >
<pre { >
protobuf {
  protoc {
    artifact = "com.google.protobuf:protoc:3.1.0"
  }
  plugins {
    grpc {
      artifact = 'io.grpc:protoc-gen-grpc-java:1.0.1'
    }
  }
  generateProtoTasks {
    all()*.plugins {
      grpc {}
    }
  }
}
</pre } >
  </td>  
  <td col3 >
    <span xbig>gPRC PROTOBUF EXCEPTION HANDLING<span><br/>
    C&P FROM: http://stackoverflow.com/questions/38810657/exception-handling-in-grpc<br/>
    <p>
      Q: I have a server written in Java and client written in PHP.
     How can client catch exception from server if anything goes wrong?
     I can't find anything about exception handling in gRPC documentation.
    </p>
    
    <p>
      A: For handled exceptions, call responseObserver.onError(). If you pass in a
      StatusRuntimeException or StatusException (generally created via
      status.asRuntimeException()) the status code and description will be
      communicated to the client.<br/>
      <br/>
       Unhandled exceptions within a callback will cancel the RPC and will continue
      propagating the exception (generally leading in an UncaughtExceptionHandler being
      called for the executor).
    </p>
    </pre } >

  </td>  
</tr }>
<tr {>
  <td col1 colspan=2>
    <span xbig>JAVA SERVICE/SERVER PROTO IMPLEMENTATION SUMMARY<span>
<pre { >
service RouteGuide {
  rpc GetFeature(Point) returns (Feature) {}
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}
</pre } >

<pre { >
public class RouteGuideServer 
  ... initialization code ...

   private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase
       ...
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE REQUEST</th>
      <td>
<pre { >
@Override
public void getFeature(Point request, StreamObserver<Feature> responseObserver) {
  responseObserver.onNext(_checkFeature(request)); /* Single onNext iteration. */
  responseObserver.onCompleted(); /* <- ends inmediatelly */
}
</pre } >
      </td>
      <td>
<pre { >
// Single Request / Stream Response
@Override
public void listFeatures(Rectangle request, StreamObserver<Feature> responseObserver) {
 for (Feature feature : features) { ...  responseObserver.onNext(feature); }
 /* ^ one onNext for each feature found (streaming response) */ 
 responseObserver.onCompleted();
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM REQUEST</th>
      <td>
<pre { >
@Override
public StreamObserver<Point> recordRoute(final StreamObserver<RouteSummary> responseObserver) {
  return new StreamObserver<Point>() {
    @Override
    public void onNext(Point point) { ... }

    @Override
    public void onError(Throwable t) { logger.log(Level.WARNING, "recordRoute cancelled"); }

    @Override
    public void onCompleted() {
      long seconds = NANOSECONDS.toSeconds(System.nanoTime() - startTime);
      responseObserver.onNext(RouteSummary.newBuilder().setPointCount(pointCount)
          .setFeatureCount(featureCount).setDistance(distance)
          .setElapsedTime((int) seconds).build());
      responseObserver.onCompleted(); // <- End stream (Single response)
    }
  };
}
</pre } >
      </td>
      <td>
<pre { >
@Override
public StreamObserver<RouteNote> routeChat(final StreamObserver<RouteNote> responseObserver) {
  return new StreamObserver<RouteNote>() {
    @Override public void onNext(RouteNote note) {
      for (RouteNote prevNote : notes.toArray(new RouteNote[0])) {
        responseObserver.onNext(prevNote);
      }
      ...
    }
                                                                                               
    @Override
    public void onError(Throwable t) { logger.log(Level.WARNING, "routeChat cancelled"); }
                                                                                               
    // Do not complete until received onCompleted for peer
    @Override public void onCompleted() { responseObserver.onCompleted(); }
  };
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
    <span xbig>CLIENT PROTO IMPLEMENTATION SUMMARY<span>
    REF: <a href="https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/route_guide_server.js">static_codegen/route_guide/route_guide_server.js</a><br/>
    
   |Initialization code:
<pre { >
function getServer() {                            | if (require.main === module) {                  
  var server = new grpc.Server();                 |   var routeServer = getServer();                
  server.addService(services.RouteGuideService, { |   routeServer.bind('0.0.0.0:50051',             
    getFeature: getFeature,                       |       grpc.ServerCredentials.createInsecure()); 
    listFeatures: listFeatures,                   |   ...                                           
    recordRoute: recordRoute,                     |   routeServer.start();                          
    routeChat: routeChat                          | });                                             
  });                                             | exports.getServer = getServer;                  
  return server;                                  |                                                 
}                                                 |                                                 
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE REQUEST</th>
      <td>
<pre { >
feature = blockingStub.getFeature(Point.newBuilder().....build());
</pre } >
      </td>
      <td>
<pre { >
Rectangle request = Rectangle.newBuilder()....build();
Iterator&lt;Feature> features = blockingStub.listFeatures(request);
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM REQUEST</th>
      <td>
<pre { >
public void recordRoute(List&lt;Feature> features, int numPoints) throws InterruptedException
  // NOTE: java.util.concurrent.CountDownLatch details removed

  // STEP 1. SETUP RESPONSE OBSERVER
  StreamObserver&lt;RouteSummary> responseObserver = new StreamObserver&lt;RouteSummary>() {
    @Override public void onNext(RouteSummary summary) { info... summary.get*()); }
    @Override public void onError/*RPC failed*/(Throwable t){log ... Status.fromThrowable(t););}
    @Override public void onCompleted(){ finishLatch.countDown(); }
  };

  // STEP 2. SETUP REQUEST OBSERVER
  StreamObserver&lt;Point> requestObserver = asyncStub.recordRoute(responseObserver);
------------------------------------------------------------------------------------------------
  try {
    for (int i = 0; i &lt; numPoints; ++i) {
      requestObserver.onNext(point); // -- push new point to request stream
      if (finishLatch.getCount() == 0 /* RPC completed|failed before end of request stream */) {
        return; // Sending further requests won't error, but they will just be thrown away.
      }
    }
  } catch (RuntimeException e) { requestObserver.onError(e) /* Cancel RPC */; throw e; }
  requestObserver.onCompleted(); // Mark the end of requests

  // Receiving happens asynchronously
  finishLatch.await(1, /*java.util.concurrent.*/TimeUnit.MINUTES);
}
</pre } >
      </td>
      <td>
<pre { >
public void routeChat() throws InterruptedException {
  // *************************************************************
  // rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
  // *************************************************************
    |   final CountDownLatch finishLatch = new CountDownLatch(1);
  StreamObserver&lt;RouteNote> requestObserver =
      asyncStub.routeChat(new StreamObserver&lt;RouteNote>() {
        @Override public void onNext(RouteNote note) { info"Got message ... "; }
        @Override public void onError(Throwable t) { warn ... Status.fromThrowable(t);}
        @Override public void onCompleted() { finishLatch.countDown(); }
      });
                                                                                        
----------------------------------------------------------------------
                                          try {
  RouteNote[] requests = {newNote(...), newNote .. };
  for (RouteNote request : requests) {
    requestObserver.onNext(request); // &lt;- Sen Message
  }
                                          } catch (RuntimeException e) {
  requestObserver.onError/*Cancel RPC*/(e); throw e;
  requestObserver.onCompleted(); // Mark the end of requests
  finishLatch.await(1, TimeUnit.MINUTES); // Receiving happens asynchronously
}
</pre } >
      </td>
    </tr>
    </table>
  </td>
</tr }>
<tr {>
  <td col1 colspan=2 >
    <span xbig>NODE.JS SERVER PROTO IMPLEMENTATION SUMMARY:<span>
    REF: https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/
<pre { >
SERVER INITIALIZATION
var routeServer = new grpc.Server();
routeServer.addService(services.RouteGuideService, {
  getFeature: getFeature, listFeatures: listFeatures, recordRoute: recordRoute, routeChat: routeChat
});
routeServer.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());
... "any other initialization"...
routeServer.start();
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE REQUEST</th>
      <td>
<pre { >
function getFeature/* single request/response */
  (call, callback /*Response callback*/) {
  callback(null, feature ); // <- write response
}
</pre } >
      </td>
      <td>
<pre { >
function listFeatures/* single request/stream response */
  (call/* call.request == Rectangle (lo, hi) */) {
  _.each(feature_list, function(feature) {
    if ("feature OK") {
      call.write(feature); // <-- write to response stream
    }
  });
  call.end(); // <-- end stream
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM REQUEST</th>
      <td>
<pre { >
function recordRoute /*stream request, single response*/
  (call /* <- stream */, callback) {
  call.on('data', function(point) { ... });
  call.on('end', function() {
    var summary = new messages.RouteSummary().set...;
    callback(null, summary);
  });
}
</pre } >
      </td>
      <td>
<pre { >
function routeChat /* stream request, stream response */
  (call /* <- stream. NOTE: no callback*/) {
  call.on('data', function(note) {
    _.each(internal_data, function(note) {
      call.write(note); // <- write to response stream
    });
  });
  call.on('end', function() { call.end(); });
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
    <span xbig>NODE.JS CLIENT PROTO IMPLEMENTATION SUMMARY:<span>
<pre { >
INITIALIZATION:
messages = require('...._pb');
services = require('...._grpc_pb');
grpc = require('grpc');

client = new services.RouteGuideClient(
    'localhost:50051',
    grpc.credentials.createInsecure());
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE REQUEST</th>
      <td>
<pre { >
function featureCallback(error, feature) {
  if (error) { .... ;  return; }
  var latitude = feature.getLocation()....
  ...
  next();
}
client.getFeature(point1, featureCallback);

</pre } >
      </td>
      <td>
<pre { >
function runListFeatures(callback) {
  var call = client.listFeatures(rect);
  call.on('data', function(feature) {
      /* do whatever with feature object */
  });
  call.on('end', callback);
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM REQUEST</th>
      <td>
<pre { >
// STEP 1. Create a call.write(able) object
var call = client.recordRoute(
  function(error, stats /*<- server response*/) {
    if (error) { ...;  return; }
    /* Do whatever with stats response */
  }
);
// STEP 2. Write to stream
for ("location in ddbb") {
   call.write(location);
}
</pre } >
      </td>
      <td>
<pre { >
function runRouteChat(callback) {
  // STEP 1. create call.write(able) object with onData notifier
  var call = client.routeChat(); 
  call.on('data', function(note /*response from stream*/) {
      // STEP 2. callback for stream response object received
      // do whatever with note response
  });
  // STEP 3. Setup onEnd
  call.on('end', callback);

  // STEP 4. Write to request stream
  for ("note in note_ddbb") {
    var noteMsg = new messages.RouteNote().setXXX..;
    call.write(noteMsg);
  }
  call.end();
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
</tr }>
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 

-->

</html>
