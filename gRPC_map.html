<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>gRPC Summary (v1.0)</title>
<!-- mapview_v1 {{{ -->
<script>
var zoomDivDOM
function doCloseZoom() {
  zoomDivDOM.innerHTML = ''; 
  zoomDivDOM.style.display="none";
}
var zoomDivFW = true; // FW Full Width
var zoomDivFH = true; // FW Full Height 
var zoomDivTop = true; 
var zoomDivLft = true; 

var zoom=0.1
var idxXXXsmallRule=-1;
var idxXXsmallRule =-1;
var idxXsmallRule  =-1;
function onZoomOut(){
  zoom=zoom - 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function onZoomIn(){
  zoom=zoom + 0.05
  document.styleSheets[0]['cssRules'][idxXXXsmallRule].style['font-size']=zoom+'rem';
}
function doOpenZoom(e)      { 
  zoomDivDOM.innerHTML = 
     "<span style='font-size:1.0rem; color:blue;'>('Esc' to close)<br/></span>" 
   + this.outerHTML; 
  zoomDivDOM.style.display="block";
  e.stopPropagation();
}

function removeToLeftMarginInPre() {
  // TODO:(0) Not working
  // nodeList = document.querySelectorAll('pre')
  // for (idx in nodeList) { 
  //   var node = nodeList[idx]
  //   var html = node.innerHTML
  //   var pattern = html.match(/^\s*[|]/)
  //   var regEx = new RegExp(pattern, "")
  //   console.log(html)
  //   node.innerHTML = html.replace(regEx,''))
  //    
  // }
}


function onPageLoaded() {
  zoomDivDOM = document.getElementById('zoomDiv')
  document.addEventListener('keyup',function(e) { if (e.code !== "Escape") return; doCloseZoom(); })
  // Change default a.target to blank. Ussually this is bad practice 
  // but this is the exception to the rule
  var nodeList = document.querySelectorAll('a')
  for (idx in nodeList) { 
      if (!nodeList[idx].href) { continue; }
      if (nodeList[idx].href && !nodeList[idx].href.startsWith("http")) continue;
      nodeList[idx].target='_blank'; 
  }
  nodeList = document.querySelectorAll('td')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }
  nodeList = document.querySelectorAll('*[zoom]')
  for (idx in nodeList) { 
     if (!!! nodeList[idx].addEventListener) continue;
     nodeList[idx].addEventListener('dblclick',doOpenZoom, false)
  }

  removeToLeftMarginInPre();

  for (idx=0; idx<document.styleSheets[0]['cssRules'].length; idx++){
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxxsmall]") {
          idxXXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xxsmall]") {
          idxXXsmallRule=idx;
      }
      if( document.styleSheets[0]['cssRules'][idx].selectorText == "[xsmall]"  ) {
          idxXsmallRule=idx;
      }
  }
  // Simulate initial dblclick to show help
  var event = new MouseEvent('dblclick', { 'view': window, 'bubbles': true, 'cancelable': true });
  document.getElementById('initialMessage').dispatchEvent(event);
}
</script>
<style { >
*[blue]         { color:blue !important;  }
*[orange]         { color:orange !important; }
*[green]         { color:green !important;  }
*[brown]         { color:brown !important;  }
b { color: #0A9}
*[mono]         { font-family: monospace; white-space: pre; }
pre { background-color:#EEEEEE; outline:1px dotted grey; margin: 0; }
*[cite]         { font-style: italic; }
*[TODO]         { color:red; font-weight: bold; }
*[TODO]:before  { content: "TODO:"; }
*[xxxsmall]{ font-size:0.1rem; }
img[xxxsmall]{ max-width:10rem; }
*[xxsmall] { font-size:0.3rem; }
*[xsmall]  { font-size:0.7rem; }
*[small]   { font-size:0.9rem; }
*[xxbig]  { font-size:1.7em; font-weight: bold; color:#007733;}
*[xbig]  { font-size:1.5em; }
*[hidden]  { display:none; }
ul,ol { margin-left: 1.0em; padding-left: 0rem; }
#zoomDiv [xxxsmall] , #zoomDiv * [xxxsmall], #zoomDiv * * [xxxsmall], #zoomDiv * * * [xxxsmall]{ font-size:1em; } 
#zoomDiv img[xxxsmall] , #zoomDiv * img[xxxsmall], #zoomDiv * * img[xxxsmall], #zoomDiv * * * img[xxxsmall]{ max-width:100%; } 

/* REF: https://stackoverflow.com/questions/4910077/select-all-child-elements-recursively-in-css */
#zoomDiv * [small], #zoomDiv * [xsmall], #zoomDiv * [xxsmall] { font-size:1em; }
#zoomDiv *[small], #zoomDiv *[xsmall], #zoomDiv *[xxsmall] { font-size:1em; }
#zoomDiv * td { font-size:1em; }

body      { font-family:sans-serif; font-size:16px; padding: 0; margin: 0; }
#zoomDiv  { 
   display:none;
   position:fixed; top:0.1%; left:0.1%; width:auto; height:auto;
   max-height: 98%; max-width: 98%; overflow: auto;
   background-color:#FFFFFF; color:#000; border-radius: 0.5rem; border: 4px solid black; font-size: 2rem;
   box-shadow: 5px 5px 30px black;
   padding: 0.5rem;
}

a            { text-decoration:none; font-family:monospace; padding:0.0;}
a[href^="#"]:before /* mark internal anchor */ {  content: ">"; }
a[href^="#"]:after  /* mark internal anchor */ {  content: "<"; }
a:visited { color:blue; }
td { 
   font-size: 0.8rem;
   vertical-align: top;
   outline: 1px solid grey; 
}
td,th               {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col0] ,th[col1]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col2] ,th[col2]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col3] ,th[col3]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col4] ,th[col4]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col5] ,th[col5]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col6] ,th[col6]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col7] ,th[col7]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col8] ,th[col8]  {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col9] ,th[col9]  {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col10],th[col10] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
td[col11],th[col11] {background-color:#FFFFFF; min-width:8.25%; max-width:8.25%; }
td[col12],th[col12] {background-color:#FAFAFA; min-width:8.25%; max-width:8.25%; }
tr[header_delimit] > *{background-color:#000000; color:#FFFFFF; font-size:2em; color: white; }
tr[header_delimit] > td > a{color:inherit; text-decoration: underline; }
div[subtable1] { max-width: 95%; overflow: auto; padding:0; margin: 0;}

table { width:100% border:0; margin: 0;}
</style }>
</head>
<body onLoad='onPageLoaded()'>
<b id='initialMessage' orange>Hint double-click on elements to zoom!!</b>
<div id='zoomDiv'></div>
<div style="position:fixed; right:0.3%; bottom:0; width:auto;">
<b style="font-size:1.5rem" orange><a onclick="onZoomOut()">[-A]</a></b>
<b style="font-size:1.5rem"       >                                 </b>
<b style="font-size:2.0rem" orange><a onclick="onZoomIn ()">[A+]</a></b>
</div>
<!-- mapview_v1 }}} -->
<table style='width:100%'{>
<tbody>
<tr {>
  <td col1 >
  PROTOC + gRPC INSTALLATION STEPS<br/>
  <ol> 
  <li> STEP 1: ProtoC installation: Unpack <code>protoc-3.x...x86_64.zip</code>
<pre xxxsmall zoom { >
from  https://github.com/google/protobuf/releases to /opt/protoc
$ sudo ln -s \
  /opt/protoc/include/google/protobuf \
  /usr/include/google/protobuf
$ sudo ln -s /opt/protoc/bin/protoc \
  /usr/bin/protoc
</pre } >
   </li>
   <li>Install Node/Python/Go/... tools: <a href="http://www.grpc.io/blog/installation">REF</a>
<pre xxxsmall zoom{ >
Language |Platform|Command
---------+--------+------------------------------------
Node.js  |All     |npm install -g grpc
         |        |(installs the grpc_node_plugin @
         |        |/usr/(local/)lib/node_modules
         |        |/grpc-tools/bin
---------+--------+------------------------------------
Python   |All     |pip install grpcio
---------+--------+------------------------------------
Ruby     |All     |gem install grpc
---------+--------+------------------------------------
PHP      |All     |pecl install grpc-beta
---------+--------+------------------------------------
Go       |All     |go get google.golang.org/grpc
---------+--------+------------------------------------
Objective|Mac     |Runtime source fetched automatically
-C        |        |from Github by Cocoapods
---------+--------+------------------------------------
C#       |Windows |Install gRPC NuGet package from your
         |        |IDE(V.Studio, Monodevelop, ...)
---------+--------+------------------------------------
Java     |All     |Use our Maven and Gradle plugins 
         |        |that provide gRPC with statically 
         |        |linked boringssl
---------+--------+------------------------------------
C++      |All     |Currently requires manual 
         |        |build and install
</pre } >
  </li>
  </td>  
  <td col2 >
    <span xbig>Compiling</span><br/>
    NodeJS: 
<pre xxxsmall zoom { >
(COMMENTED SHELL EXAMPLE TO GENERATE JS PROTOBUF & gRPC SERVICE:)
#!/bin/sh
set -e # script option. Abort on first error.

PROTOC=/opt/protoc_v3/bin/protoc # <- PATH to protoc compiler executable
OUT_DIR="./src/lib/protobuf"

if [ ! -d ${OUT_DIR} ]; then mkdir -p ${OUT_DIR} ; fi

# protoc fails if relative path is provided. (2017-01)
GRPC_NODE_PLUGIN=/usr/local/lib/node_modules/grpc-tools/bin/grpc_node_plugin

${PROTOC} \
 --proto_path=../project_proto_definition/   # <- Path to search *proto for
 --js_out=import_style=commonjs,\
                          binary:${OUT_DIR} \# <- JS protobuf output path
\
 --grpc_out=${OUT_DIR} \                     # <- gRPC(services) output path
 --plugin=protoc-gen-grpc=\                    # <- gRPC service related
          ${GRPC_NODE_PLUGIN} \ 
 file1.proto
</pre } >
  <hr/>
  JAVA: <a href="https://github.com/grpc/grpc-java/blob/master/README.md">REF</a><br/>
  Gradle protobuf conf:
<pre xxxsmall zoom { >
apply plugin: 'java'
apply plugin: 'com.google.protobuf'

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }

}
</pre } >
  Java Gradle+grpc conf:
<pre xxxsmall zoom { >
compile 'io.grpc:grpc-netty:1.0.1'        non-Android
compile 'io.grpc:grpc-protobuf:1.0.1'
compile 'io.grpc:grpc-stub:1.0.1'

compile 'io.grpc:grpc-okhttp:1.0.1'       Android:
compile 'io.grpc:grpc-protobuf-lite:1.0.1'
compile 'io.grpc:grpc-stub:1.0.1'
         
...
protobuf {
  protoc { artifact = "com.google.protobuf:protoc:3.1.0" }
  plugins {
    grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.0.1' }
  }
  generateProtoTasks { all()*.plugins { grpc {} } }
}
</pre } >
  </td>  
  <td col3 >
  <b>gRPC PROTOBUF EXCEPTION HANDLING</b><br/>
  <p xsmall zoom>
  C&P FROM: http://stackoverflow.com/questions/38810657/exception-handling-in-grpc<br/>
    Q: I have a server written in Java and client written in PHP.
   How can client catch exception from server if anything goes wrong?
   I can't find anything about exception handling in gRPC documentation.
   <br/>
   <br/>
    A: For handled exceptions, call responseObserver.onError(). If you pass in a
    StatusRuntimeException or StatusException (generally created via
    status.asRuntimeException()) the status code and description will be
    communicated to the client.<br/>
    <br/>
     Unhandled exceptions within a callback will cancel the RPC and will continue
    propagating the exception (generally leading in an UncaughtExceptionHandler being
    called for the executor).
  </p>
  </pre } >
  </td>  
</tr }>
</table>

<table>
<tr {>
  <td col1 colspan=2>
  JAVA SERVICE/SERVER PROTO IMPLEMENTATION SUMMARY<br/>
  gRPC defs:
<pre xxxsmall zoom { >
service RouteGuide {
  rpc GetFeature(Point) returns (Feature) {}
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}
</pre } >

  <code>RouteGuideServer.java</code>
<pre xxxsmall zoom { >
public class RouteGuideServer 
  ... initialization code ...

   private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase
       ...
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
@Override
public void getFeature(
    Point request, StreamObserver<Feature> responseObserver) {
  // Single onNext iteration
  responseObserver.onNext(_checkFeature(request));
  responseObserver.onCompleted(); /* <- ends inmediatelly */
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
@Override
public void listFeatures(
     Rectangle request, 
     StreamObserver<Feature> responseObserver) {
 for (Feature feature : features) {
      ...  responseObserver.onNext(feature); }
 /* ^ one onNext for each feature found
  * (streaming response) */ 
 responseObserver.onCompleted();
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
@Override
public StreamObserver<Point> recordRoute(
    final StreamObserver<RouteSummary> responseObserver) {
  return new StreamObserver<Point>() {
    @Override
    public void onNext(Point point) { ... }

    @Override
    public void onError(Throwable t) { 
        logger.log(Level.WARNING, "recordRoute cancelled"); 
    }

    @Override
    public void onCompleted() {
      long seconds = 
          NANOSECONDS.toSeconds(System.nanoTime() - startTime);
      responseObserver.onNext(RouteSummary.newBuilder()
          .setPointCount(pointCount)
          .setFeatureCount(featureCount).setDistance(distance)
          .setElapsedTime((int) seconds).build());
      responseObserver.onCompleted(); // End stream (Single res.)
    }
  };
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
@Override
public StreamObserver<RouteNote> routeChat(
    final StreamObserver<RouteNote> responseObserver) {
  return new StreamObserver<RouteNote>() {
    @Override public void onNext(RouteNote note) {
      for (RouteNote prevNote : notes.toArray(new RouteNote[0])) {
        responseObserver.onNext(prevNote);
      }
      ...
    }

    @Override
    public void onError(Throwable t) { 
        logger.log(Level.WARNING, "routeChat cancelled"); 
    }

    // Do not complete until received onCompleted for peer
    @Override public void onCompleted() {
       responseObserver.onCompleted(); 
    }
  };
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
  CLIENT PROTO IMPLEMENTATION SUMMARY<br/>
  <a href="https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/route_guide_server.js">REF: static_codegen/route_guide/route_guide_server.js</a><br/>
  Initialization code:
<pre xxxsmall zoom { >
function getServer() {                            | if (require.main === module) {                  
  var server = new grpc.Server();                 |   var routeServer = getServer();                
  server.addService(services.RouteGuideService, { |   routeServer.bind('0.0.0.0:50051',             
    getFeature: getFeature,                       |       grpc.ServerCredentials.createInsecure()); 
    listFeatures: listFeatures,                   |   ...                                           
    recordRoute: recordRoute,                     |   routeServer.start();                          
    routeChat: routeChat                          | });                                             
  });                                             | exports.getServer = getServer;                  
  return server;                                  |
}
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
feature = blockingStub.getFeature(Point.newBuilder().....build());
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
Rectangle request = Rectangle.newBuilder()....build();
Iterator&lt;Feature> features = blockingStub.listFeatures(request);
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
public void recordRoute(List&lt;Feature> features, int numPoints)
     throws InterruptedException
  // NOTE: java.util.concurrent.CountDownLatch details removed

  // STEP 1. SETUP RESPONSE OBSERVER
  StreamObserver&lt;RouteSummary> responseObserver = 
      new StreamObserver&lt;RouteSummary>() {
    @Override
        public void onNext(RouteSummary summary) {
            info... summary.get*()); 
        }
    @Override
        public void onError/*RPC failed*/(Throwable t) {
            log ... Status.fromThrowable(t););
        }
    @Override
        public void onCompleted(){ 
            finishLatch.countDown(); 
        }
  };

  // STEP 2. SETUP REQUEST OBSERVER
  StreamObserver&lt;Point> requestObserver = 
      asyncStub.recordRoute(responseObserver);
--------------------------------------------------------
  try {
    for (int i = 0; i &lt; numPoints; ++i) {
      // push point to req.stream
      requestObserver.onNext(point);
      if (finishLatch.getCount() == 0 ) {
        /* RPC completed|failed before end of
         * request stream 
         * Sending further requests won't error,
         * but they will just be thrown away.
         */
        // 
        return; 
      }
    }
  } catch (RuntimeException e) {
      requestObserver.onError(e) /* Cancel RPC */; 
      throw e; 
  }
  requestObserver.onCompleted(); // Mark the end of requests

  // Receiving happens asynchronously
  finishLatch.await(1, /*java.util.concurrent.*/TimeUnit.MINUTES);
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
public void routeChat() throws InterruptedException {
  // **********************************
  // rpc RouteChat(stream RouteNote)
  //     returns (stream RouteNote) {}
  // **********************************

  // STEP 1. SETUP RESPONSE OBSERVER
  final CountDownLatch finishLatch = new CountDownLatch(1);
  StreamObserver&lt;RouteNote> requestObserver =
      asyncStub.routeChat(new StreamObserver&lt;RouteNote>() {
        @Override 
        public void onNext(RouteNote note) {
            info"Got message ... "; }
        @Override 
        public void onError(Throwable t) {
            warn ... Status.fromThrowable(t);}
        @Override 
        public void onCompleted() {
            finishLatch.countDown(); }
      });

// ----------------------------------------------------------
  // STEP 2: SETUP REQUEST OBSERVER
                          try {
  RouteNote[] requests = {newNote(...), newNote .. };
  for (RouteNote request : requests) {
    requestObserver.onNext(request); // &lt;- Sen Message
  }
                          } catch (RuntimeException e) {
  requestObserver.onError/*Cancel RPC*/(e); throw e;
  requestObserver.onCompleted(); // Mark the end of requests
  // Receiving happens asynchronously
  finishLatch.await(1, TimeUnit.MINUTES);
}
</pre } >
      </td>
    </tr>
    </table>
  </td>
</tr }>
</table>

<table>
<tr {>
  <td col1 colspan=2 >
    NODE.JS SERVER PROTO IMPLEMENTATION SUMMARY:<br/>
    <a href="https://github.com/grpc/grpc/blob/master/examples/node/static_codegen/route_guide/">REF</a>
    SERVER INITIALIZATION
<pre xxxsmall zoom { >
var routeServer = new grpc.Server();
routeServer.addService(services.RouteGuideService, {
  getFeature: getFeature,
  listFeatures: listFeatures,
  recordRoute: recordRoute,
   routeChat: routeChat
});
routeServer.bind('0.0.0.0:50051',
                 grpc.ServerCredentials.createInsecure());
... "any other initialization"...
routeServer.start();
</pre } >
    <table style="min-width:auto;max-width:auto;">
    <tr>
      <th style="min-width:auto;max-width:auto;">&nbsp;</th>
      <th style="min-width:auto;max-width:auto;">SINGLE RESPONSE</th>
      <th style="min-width:auto;max-width:auto;">STREAM RESPONSE</th>
    </tr>

    <tr>
      <th style="min-width:auto;max-width:auto;">SINGLE<br/>REQUEST</th>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function getFeature/* single request/response */
  (call, callback /*Response callback*/) {
  callback(null, feature ); // <- write response
}
</pre } >
      </td>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function listFeatures/* single request/stream response */
  (call/* call.request == Rectangle (lo, hi) */) {
  _.each(feature_list, function(feature) {
    if ("feature OK") {
      call.write(feature); // <-- write to response stream
    }
  });
  call.end(); // <-- end stream
}
</pre } >
      </td>
    </tr>
    <tr>
      <th style="min-width:auto;max-width:auto;">STREAM<br/>REQUEST</th>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function recordRoute /*stream request, single response*/
  (call /* <- stream */, callback) {
  call.on('data', function(point) { ... });
  call.on('end', function() {
    var summary = new messages.RouteSummary().set...;
    callback(null, summary);
  });
}
</pre } >
      </td>
      <td style="min-width:auto;max-width:auto;">
<pre xxxsmall zoom { >
function routeChat /* stream request, stream response */
  (call /* <- stream. NOTE: no callback*/) {
  call.on('data', function(note) {
    _.each(internal_data, function(note) {
      call.write(note); // <- write to response stream
    });
  });
  call.on('end', function() { call.end(); });
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
  <td col2 >
  <span>NODE.JS CLIENT PROTO IMPLEMENTATION SUMMARY:</span><br/>
  INITIALIZATION
<pre xxxsmall zoom { >
messages = require('...._pb');
services = require('...._grpc_pb');
grpc = require('grpc');

client = new services.RouteGuideClient(
    'localhost:50051',
    grpc.credentials.createInsecure());
</pre } >
    <table>
    <tr>
      <th>&nbsp;</th>
      <th>SINGLE RESPONSE</th>
      <th>STREAM RESPONSE</th>
    </tr>

    <tr>
      <th>SINGLE<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
function featureCallback(error, feature) {
  if (error) { .... ;  return; }
  var latitude = feature.getLocation()....
  ...
  next();
}
client.getFeature(point1, featureCallback);

</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
function runListFeatures(callback) {
  var call = client.listFeatures(rect);
  call.on('data', function(feature) {
      /* do whatever with feature object */
  });
  call.on('end', callback);
}
</pre } >
      </td>
    </tr>
    <tr>
      <th>STREAM<br/>REQUEST</th>
      <td>
<pre xxxsmall zoom { >
// STEP 1. Create a call.write(able) object
var call = client.recordRoute(
  function(error, stats /*<- server response*/) {
    if (error) { ...;  return; }
    /* Do whatever with stats response */
  }
);
// STEP 2. Write to stream
for ("location in ddbb") {
   call.write(location);
}
</pre } >
      </td>
      <td>
<pre xxxsmall zoom { >
function runRouteChat(callback) {
  // STEP 1. create call.write(able) object with onData notifier
  var call = client.routeChat(); 
  call.on('data', function(note /*response from stream*/) {
      // STEP 2. callback for stream response object received
      // do whatever with note response
  });
  // STEP 3. Setup onEnd
  call.on('end', callback);

  // STEP 4. Write to request stream
  for ("note in note_ddbb") {
    var noteMsg = new messages.RouteNote().setXXX..;
    call.write(noteMsg);
  }
  call.end();
}
</pre } >
      </td>
    </tr>
    </table>
  </td>  
</tr }>
</body>
<!--
REF: http://www.alanflavell.org.uk/unicode/unidata25.html
─  ┐  ┠   ┰    ╀   ═   ╠   ╰     ┌─────┬─────┐
                                 │     │     │
━  ┑  ┡   ┱    ╁   ║   ╡   ╱     │     │     │
                                 ├─────┼─────┤
│  ┒  ┢   ┲    ╂   ╒   ╢   ╲     │     │     │
                                 │     │     │
┃  ┓  ┣   ┳    ╃   ╓   ╣   ╳     └─────┴─────┘
                                 ← ↑
┄  └  ┤   ┴    ╄   ╔   ╤   ╴     → ↓

┅  ┕  ┥   ┵    ╅   ╕   ╥   ╵     ┌─────────┐
                                 │         │
┆  ┖  ┦   ┶    ╆   ╖   ╦   ╶     │         │
                                 │         │
┇  ┗  ┧   ┷    ╇   ╗   ╧   ╷     │         │
                                 └─────────┘
┈  ┘  ┨   ┸    ╈   ╘   ╨   ╸ 

┉  ┙  ┩   ┹    ╉   ╙   ╩   ╹ 

┊  ┚  ┪   ┺    ╊   ╚   ╪   ╺ 

┋  ┛  ┫   ┻    ╋   ╛   ╫   ╻ 

┌  ├  ┬   ┼    ╌   ╜   ╬   ╼ 

┍  ┝  ┭   ┽    ╍   ╝   ╭   ╽ 

┎  ┞  ┮   ┾    ╎   ╞   ╮   ╾ 

┏  ┟  ┯   ┿    ╏   ╟   ╯   ╿ 

-->

</html>
