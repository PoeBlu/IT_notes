<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>C SHARP <!-- draft --></title>
<head>
<script src="../map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="../map_v1.css" />
</head>


<body>
<table>
<tr>
<td TODO>
  External Links:
  <ul xxxsmall zoom>
  <li><a href="http://www.ecma-international.org/publications/standards/Ecma-334.htm">ECMA-334 C# Lang. Spec</a></li>
  <li><a href="http://docs.go-mono.com/?link=root:/classlib">Mono BaseClass Library</a></li>
  </ul>
</td>
<td>
  syntax Summary
<pre xxxsmall zoom>
<b>DATA TYPES</b>                                    <b>TYPE CONVERSION METHODS</b>
bool     : Boolean value                     ToBoolean  ToDecimal ToInt64   ToType    
byte     :   8-bit unsigned integer          ToByte     ToDouble  ToSbyte   ToUInt16  
char     :  16-bit Unicode character         ToChar     ToInt16   ToSingle  ToUInt32  
double   :  64-bit double-prec. float.point  ToDateTime ToInt32   ToString  ToUInt64  
float    :  32-bit single-prec. float.point 
int      :  32-bit signed integer            <b>ARRAYS</b>
long     :  64-bit signed integer            int[] array = new int[] {1, 2, 3}
object   : Base type for all other types     int[] array = {1, 2, 3}
sbyte    :   8-bit signed integer            var array = new int[] {1, 2, 3}
short    :  16-bit signed integer            int[] array = new int[3]
string   : String value                      
uint     :  32-bit unsigned integer          <b>NAMING CONVENTIONS</b>
ulong    :  64-bit unsigned integer          Class            MyClass 
ushort   :  16-bit unsigned integer          Method           MyMethod 
decimal  : 128-bit precise decimal values    Local variable   myLocalVariable
           (28-29 sign digits)               Private variable _myPrivateVariable 
                                             Constant         MyConstant 

<b>STATEMENTS</b>
|if (true) {...}      |switch (var) {    |Loops:                              |try {...} 
|else if (true) {...} |  case 1 : break; |for (int i =1; i &lt; 5; i++) {...} |catch (Exception e) {...} 
|else {...}           |  default: break; |foreach (int item in array) {...}   |catch {...} 
                      |}                 |while (true) {...}                  |finally {...}
                                          |do {...} while (true);

| Class Definition         | Class Inheritance             | Constructor                   | Finalizer:
| public class Dog {...}   |  public class Dog: Pet {...}  | public Dog () {...}           | ~Dog () {...}
                                                           | public Dog (string var) {...} | modifiers|params not allowed
| Static Class
| public static class Dog {...}


<b>ACCESS MODIFIERS</b>
public      Accessible by any other code in the same assembly or another assembly that references it
private     Only accessible by code in the same class or struct
protected   Only accessible by code in the same class or struct, or in a derived class
internal    Accessible by any code in the same assembly, but not from another assembly
protected   Accessible by any code in the same assembly, or by any derived class in another assembly
  internal

<b>OTHER MODIFIERS</b>
abstract    Indicates that a class is intended only to be a base class of other classes
async       modified method|lambda|anonymous method is async
const       Specifies that the value of the field or the local variable cannot be modified
event       Declares an event
extern      Indicates that the method is implemented externally
new         Explicitly hides a member inherited from a base class
override    Provides a new implementation of a virtual member inherited from a base class
partial     Defines partial classes, structs and methods throughout the same assembly
readonly    Declares a field that can only be assigned values as part of the declaration
            or in a constructor in the same class
sealed      Specifies that a class cannot be inherited
static      Declares a member that belongs to the type itself instead of to a specific object
unsafe      Declares an unsafe context
virtual     Declares a method or an accessor whose implementation can be changed
            by an overriding member in a derived class
volatile    Indicates that a field can be modified in the program by something such
            as the operating system, the hardware, or a concurrently executing thread

<b>OTHER OPERATORS</b>
sizeof()    Returns the size of a data type
typeof()    Returns the type of a class
&amp;       Returns the address of a variable
*           Pointer to a variable
is          Determines whether an object is of a specific type
as          Cast without raising an exception if the cast fails

</pre>
</td>
<td>
  Collections
<pre xxxsmall zoom>
  COLLECTION CLASSES
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
  |            UNTYPED                               |          GENERIC (C# 2.0+):                        |     CONCURRENT                     |
  | Everything is an object                          |          typed collections as declared             | Thread-safe, force deterministic   |
  |                                                  |          at runtime                                | access by concurrent threads       |
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
  | ArrayList  : Ordered collection of objects.      | List<T>                 : Typed list of items.     | BlockingCollection<T>              |
  |              Size can increase. NOT decrease     |                                                    |                                    |
  |                                                  | SortedList<TKey, Value> : Type List implementing   |                                    |
  |                                                  |                           IComparable              |                                    |
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
  | HashTable  : key/value collection                | Dictionary<TKey, TValue>: Typed HastTable.         | ConcurrentDictionary<TKey, TValue> |
  |                                                  |                                                    |                                    |
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
  | Queue      : First-In-First-Out list             | Queue<T>                : Typed Queue              | ConcurrentQueue<T>                 |
  |                                                  |                                                    |                                    |
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
  | Stack      :  Last-In-First-Out list             | Stack<T>                : Typed Stack              | ConcurrentStack<T>                 |
  |                                                  |                                                    |                                    |
  +--------------------------------------------------+----------------------------------------------------+------------------------------------+
</pre>
<td>
  App. Configuration
<pre xxxsmall zoom>
- configuration in .NET applications takes place in an XML .config file.
-  This XML formatted file has a <configuration> node, and a whole slew
   of project specific nodes within. Getting a reference to the
   configuration requires a call to OpenExeConfiguration.

   Ex.:
      System.Configuration.Configuration config =
          ConfigurationManager.OpenExeConfiguration();
   
      // Now getting a reference is "straightforward".
      var sectionName = “Whatever!”;
      System.Configuration.AppSettingsSection section =
       (System.Configuration.AppSettingsSection) config.GetSection(sectionName);

- Config file sections(config-groups):
  SECTION         DESCRIPTION
 +-----------------------------------------------------------------+
 |Startup         Describes the .NET version to use                |
 +-----------------------------------------------------------------+
 |Runtime         Lists the .NET elements to bind to the executable|
 +-----------------------------------------------------------------+
 |Network         Describes proxy and other network settings       |
 +-----------------------------------------------------------------+
 |Cryptography    values referencing crypto resources              |
 +-----------------------------------------------------------------+
 |Configuration   The most used section. (custom sections)         |
 +-----------------------------------------------------------------+
 |Trace/Debug     Settings for tracing+logging                     |
 +-----------------------------------------------------------------+
 |appsettings     things like DDBB connection strings              |
 +-----------------------------------------------------------------+
 |websettings     ASP.NET specific details                         |
 +-----------------------------------------------------------------+
</pre>
</td>
<td>
 Async Programming
<pre xxxsmall zoom>
- async : used to declare an asynchronous function, which returns a Task.
          - All async methods must contain at least one "await" expression:
          - await tells C# to take referred code and run it in a separate
            thread than the user thread.

Next table breaks down the asynchronous parts of the language.
  STATEMENT          DESCRIPTION
 +---------------------------------------------------------------------+
 |async              funct. modifier (interpreted at compile time)     |
 |---------------------------------------------------------------------|
 |await              Operator suspending execution of the containing   |
 |                   method/thread until the awaited task completes.   |
 |---------------------------------------------------------------------|
 |Task               Represents an asynchronous operation.             |
 |---------------------------------------------------------------------|
 |Task<TResult>      Represents an asynchronous operation return value.|
 |---------------------------------------------------------------------|
 |Task.ContinueWith  A continuation that is started after the operation|
 |                   in the Task is completed.                         |
 +---------------------------------------------------------------------+
</td>
<td>
  <a href="https://www.mono-project.com/docs/tools+libraries/tools/">Mono tools</a>
<pre xxxsmall zoom>
Main tools
https://www.mono-project.com/
<a href="https://www.mono-project.com/docs/advanced/runtime/"               >mono</a>:
- runtime and Just In Time compiler (JIT)
<a href="https://www.mono-project.com/docs/about-mono/languages/csharp/"    >mcs</a> :
- C# compiler
<a href="https://www.mono-project.com/docs/advanced/assemblies-and-the-gac/">gacutil :
- install versioned assemblies into
  the system Global Assembly Cache (GAC)
  to become part of the assemblies that
  are available for all apps at runtime.
<a href="https://www.mono-project.com/docs/web/aspnet/"                     >xsp</a> :
- Stand alone ASP.NET web services and
  web application server
<a href=""                                                          >mono-config</a> :
- Stand alone ASP.NET web services and
  Mono runtime file format configuration

<a href="/docs/tools+libraries/tools/mkbundle"                         >mkbundle</a> :
- Create and cross-compile self-contained executables with no external dependencies.

- Check <a href="https://www.mono-project.com/docs/tools+libraries/tools/">link</a> for
  other tools.
</pre>

</td>
<td>
  <a href="https://docs.microsoft.com/en-us/nuget/what-is-nuget">[NuGet pck mng]</a>
  <a href="https://nuget.org">[Nuget.org]</a>
<pre xxxsmall zoom>
- tools handling how packages for .NET are created/hosted/consumed
- NuGet (.nupkg) package = ZIP file containing:
- compiled code (DLLs)
- files related to that code
- manifest (version,...)
- refer to the package in code with using <namespace> where <namespace>
   is specific to the package you're using. 

NuGet supports private hosts + public nuget.org
                               ^^^^^^^^^^^^^^^^
                               100,000+ packages

creator ->(push .nupkg) -> HOST -> (pop .nupkg) -> Consumer


- To maximize a package's compatibility, developers target <b>.NET Standard</b>
  which all .NET and .NET Core projects can consume.

NuGet tools

Tool            Platforms   Applicable Scenarios    Description
nuget.exe CLI   All         Creation, Consumption   Provides all NuGet capabilities, with some commands 
                                                    applying specifically to package creators, some applying 
                                                    only to consumers, and others applying to both. For 
                                                    example, package creators use the nuget pack command to 
                                                    create a package from various assemblies and related files
                                                    , package consumers use nuget install to include packages 
                                                    in a project folder, and everyone uses nuget config to 
                                                    set NuGet configuration variables. As a platform-agnostic 
                                                    tool, the NuGet CLI does not interact with Visual Studio 
                                                    projects.
dotnet CLI      All         Creation, Consumption   Provides certain NuGet CLI capabilities directly within 
                                                    the .NET Core tool chain. As with the NuGet CLI, the 
                                                    dotnet CLI does not interact with Visual Studio 
                                                    projects.
Package Manager VS Win... 
UI/Console                
Manage NuGet UI VS Mac ...
MSBuild         Windows     Creation, Consumption   ...


<b>dependencies Management</b>
- Uses a tree "graph"
- Transitive dependencies
- package Coordinates:
    - package identifier
    - version number

- A NuGet <b orange>reference list</b> is created on 
  package installation and can be used
   to restore packages elsewhere

<b>Build systems like Azure DevOps </b> provide "NuGet restore" steps
 to restore using just the reference list 
- when cloning a repository <b>nuget restore -NuGet CLI-</b>
  (dotnet restore -dotnet CLI-) is enough to obtain all
  necessary packages.

<b orange>reference list</b> is maintained in one of two 
    package management formats:
- <b orange>packages.config:</b> (NuGet 1.0+) XML file with flat 
  list of all dependencies in project. (legacy)
  Installed or restored packages are stored in a packages folder.
- <b orange>&lt;PackageReference&gt; (@project file)</b> (NuGet 4.0+
  and all .NET Core projects):
  keeps a list of project's top-level dependencies
  obj/project.assets.json is dynamically generated to manage the
  overall dependency graph of the packages that a project uses along
  with all down-level dependencies.

TIP: Various nuget.exe CLI commands, like nuget install, do not automatically
    add the package to the reference list. The list is updated when
    installing a package with the Visual Studio Package Manager (UI or Console), 
    and with dotnet.exe CLI.

<b>NuGet package cache</b>   : Boots performance, avoids re-downloading 
<b>global packages folder</b>: shortcut (re)installation (shared by different
                               projects).
- NuGet maintains also all the specifications related to how 
  packages are structured (including localization and debug symbols)
  and how they are referenced (including <b>version ranges</b> and
  pre-release versions.)

</pre>

  dotnet CLI
<pre xxxsmall zoom>
$ mkdir project01 && cd project01
$ dotnet new console # ← Create a project
$ dotnet run         # ← run to check 
$ dotnet add package 
  \ Newtonsoft.Json  #  ← install Newtonsoft.json pkg 

$ check in .csproj that the reference has been added.
    &lt;ItemGroup&gt;
    &lt;PackageReference Include="Newtonsoft.Json" Version="12.0.1" /&gt;
    &lt;/ItemGroup&gt;

Using Newtonsoft.Json API:
$ vim Program.cs 
+ using Newtonsoft.Json;
  public class Account
  {
      public string Name { get; set; }
      public string Email { get; set; }
      public DateTime DOB { get; set; }
  }

  static void Main(string[] args)
  {
      Account account = new Account
      {
          Name = "John Doe",
          Email = "john@nuget.org",
          DOB = new DateTime(1980, 2, 20, 0, 0, 0, DateTimeKind.Utc),
      };
  
+     string json = JsonConvert.SerializeObject(account, Formatting.Indented);
      Console.WriteLine(json);
  }

$ dotnet run         # ← run to check 
→ {
→   "Name": "John Doe",
→   "Email": "john@nuget.org",
→   "DOB": "1980-02-20T00:00:00Z"
→ }

<b>Create and publish a package</>
PRE-SETUP:
- Register for a free account on nuget.org
- Acquire your API key
  Select your user name on nuget.org
  -> select API Key
     -> Select Create 
        -> provide key name  
           -> select Select Scopes
              -> Push:
                 Under API Key, enter * for Glob pattern
                 -> select Create
                    -> Copy and Save in a secure location because
                       you cannot copy the key again later on,
                       only regenerate it.

$ mkdir AppLogger && cd AppLogger
$ dotnet new classlib  # ← create a new class library project
                           By default uses current dir name as project name

$ "vim" .csproj:
    &lt;PropertyGroup>
  + &lt;PackageId>AppLogger&lt;/PackageId>
  + &lt;Version>1.0.0&lt;/Version>
  + &lt;Authors>your_name&lt;/Authors>
  + &lt;Company>your_company&lt;/Company>
    ...
    &lt;/PropertyGroup>

Add .nuspec manifest pkg metadata describes contents and dependencies
    ^^^^^^^ 
    generated from NuGet
    metadata properties in
    .csproj

NOTE: For packages built for public consumption, pay special
    attention to the PackageTags property, as tags help others
    find your package and understand what it does.

$ dotnet pack # ← build projects and creates Nuget *.nupkg file
→ ...
→ Successfully created package '...\Debug\AppLogger.1.0.0.nupkg'

$ dotnet nuget push       \
  AppLogger.1.0.0.nupkg   \
  -k ${KEY}               |
  -s https://api.nuget.org/v3/index.json
→ info : Pushing AppLogger.1.0.0.nupkg to 'https://www.nuget.org/api/v2/package'...
→ info :   PUT https://www.nuget.org/api/v2/package/
→ info :   Created https://www.nuget.org/api/v2/package/ 12620ms
→ info : Your package was pushed.
   
Manage published packages
nuget.org -> select profile -> select Manage Packages
-> check published pkgs.
</pre>

</td>
</tr>
</table>

</body>
<!--
TODO_START: {
________________
https://www.mono-project.com/docs/about-mono/languages/csharp/
________________

https://www.mono-project.com/docs/advanced/runtime/
________________
https://www.mono-project.com/docs/advanced/embedding/scripting/
________________
https://www.mono-project.com/docs/advanced/embedding/

________________
https://www.infoq.com/news/2019/01/Collection-Net-Core-3
________________
https://www.infoq.com/news/2019/01/IAsyncDisposable-IAsyncEnume

https://github.com/dotnet/csharplang/blob/master/proposals/async-streams.md
________________
https://www.infoq.com/news/2019/02/csharp-defer
_____________________________

<a href="https://access.redhat.com/errata/RHBA-2019:0355?sc_cid=701600000006NHXAA2"> RHBA-2019:0355 Red Hat Bug Fix Advisory:</a>
 .NET Core on Red Hat Enterprise Linux Container Image Updates

Summary:
.NET Core has been updated in all container images for the new security release. The new versions are as such:
1.0.14       , 1.1.11
2.1.8 Runtime, 2.2.2 Runtime
2.1.504 SDK  , 2.2.104 SDK
See also: https://dotnet.microsoft.com/download

}
-->

</html>
